const E3 = "modulepreload",
    S3 = function(t) {
        return "/" + t
    },
    Nw = {},
    nh = function(e, n, r) {
        if (!n || n.length === 0) return e();
        const i = document.getElementsByTagName("link");
        return Promise.all(n.map(s => {
            if (s = S3(s), s in Nw) return;
            Nw[s] = !0;
            const o = s.endsWith(".css"),
                a = o ? '[rel="stylesheet"]' : "";
            if (!!r)
                for (let u = i.length - 1; u >= 0; u--) {
                    const d = i[u];
                    if (d.href === s && (!o || d.rel === "stylesheet")) return
                } else if (document.querySelector(`link[href="${s}"]${a}`)) return;
            const c = document.createElement("link");
            if (c.rel = o ? "stylesheet" : E3, o || (c.as = "script", c.crossOrigin = ""), c.href = s, document.head.appendChild(c), o) return new Promise((u, d) => {
                c.addEventListener("load", u), c.addEventListener("error", () => d(new Error(`Unable to preload CSS for ${s}`)))
            })
        })).then(() => e()).catch(s => {
            const o = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (o.payload = s, window.dispatchEvent(o), !o.defaultPrevented) throw s
        })
    };

function T3(t, e) {
    const n = Object.create(null),
        r = t.split(",");
    for (let i = 0; i < r.length; i++) n[r[i]] = !0;
    return e ? i => !!n[i.toLowerCase()] : i => !!n[i]
}
const Hu = Object.assign,
    C3 = Object.prototype.hasOwnProperty,
    Kh = (t, e) => C3.call(t, e),
    Fi = Array.isArray,
    Mc = t => oA(t) === "[object Map]",
    u_ = t => typeof t == "function",
    P3 = t => typeof t == "string",
    d_ = t => typeof t == "symbol",
    zu = t => t !== null && typeof t == "object",
    A3 = Object.prototype.toString,
    oA = t => A3.call(t),
    aA = t => oA(t).slice(8, -1),
    f_ = t => P3(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t,
    O3 = t => {
        const e = Object.create(null);
        return n => e[n] || (e[n] = t(n))
    },
    I3 = O3(t => t.charAt(0).toUpperCase() + t.slice(1)),
    h_ = (t, e) => !Object.is(t, e),
    M3 = (t, e, n) => {
        Object.defineProperty(t, e, {
            configurable: !0,
            enumerable: !1,
            value: n
        })
    };

function rh(t, ...e) {
    console.warn(`[Vue warn] ${t}`, ...e)
}
let Vn;
class p_ {
    constructor(e = !1) {
        this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Vn, !e && Vn && (this.index = (Vn.scopes || (Vn.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    run(e) {
        if (this._active) {
            const n = Vn;
            try {
                return Vn = this, e()
            } finally {
                Vn = n
            }
        } else rh("cannot run an inactive effect scope.")
    }
    on() {
        Vn = this
    }
    off() {
        Vn = this.parent
    }
    stop(e) {
        if (this._active) {
            let n, r;
            for (n = 0, r = this.effects.length; n < r; n++) this.effects[n].stop();
            for (n = 0, r = this.cleanups.length; n < r; n++) this.cleanups[n]();
            if (this.scopes)
                for (n = 0, r = this.scopes.length; n < r; n++) this.scopes[n].stop(!0);
            if (!this.detached && this.parent && !e) {
                const i = this.parent.scopes.pop();
                i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index)
            }
            this.parent = void 0, this._active = !1
        }
    }
}

function ju(t) {
    return new p_(t)
}

function lA(t, e = Vn) {
    e && e.active && e.effects.push(t)
}

function Vu() {
    return Vn
}

function m_(t) {
    Vn ? Vn.cleanups.push(t) : rh("onScopeDispose() is called when there is no active effect scope to be associated with.")
}
const g_ = t => {
        const e = new Set(t);
        return e.w = 0, e.n = 0, e
    },
    cA = t => (t.w & Gs) > 0,
    uA = t => (t.n & Gs) > 0,
    R3 = ({
        deps: t
    }) => {
        if (t.length)
            for (let e = 0; e < t.length; e++) t[e].w |= Gs
    },
    k3 = t => {
        const {
            deps: e
        } = t;
        if (e.length) {
            let n = 0;
            for (let r = 0; r < e.length; r++) {
                const i = e[r];
                cA(i) && !uA(i) ? i.delete(t) : e[n++] = i, i.w &= ~Gs, i.n &= ~Gs
            }
            e.length = n
        }
    },
    ih = new WeakMap;
let Ec = 0,
    Gs = 1;
const Uy = 30;
let _n;
const Fo = Symbol("iterate"),
    Gy = Symbol("Map key iterate");
class Wu {
    constructor(e, n = null, r) {
        this.fn = e, this.scheduler = n, this.active = !0, this.deps = [], this.parent = void 0, lA(this, r)
    }
    run() {
        if (!this.active) return this.fn();
        let e = _n,
            n = Rs;
        for (; e;) {
            if (e === this) return;
            e = e.parent
        }
        try {
            return this.parent = _n, _n = this, Rs = !0, Gs = 1 << ++Ec, Ec <= Uy ? R3(this) : Uw(this), this.fn()
        } finally {
            Ec <= Uy && k3(this), Gs = 1 << --Ec, _n = this.parent, Rs = n, this.parent = void 0, this.deferStop && this.stop()
        }
    }
    stop() {
        _n === this ? this.deferStop = !0 : this.active && (Uw(this), this.onStop && this.onStop(), this.active = !1)
    }
}

function Uw(t) {
    const {
        deps: e
    } = t;
    if (e.length) {
        for (let n = 0; n < e.length; n++) e[n].delete(t);
        e.length = 0
    }
}

function B3(t, e) {
    t.effect && (t = t.effect.fn);
    const n = new Wu(t);
    e && (Hu(n, e), e.scope && lA(n, e.scope)), (!e || !e.lazy) && n.run();
    const r = n.run.bind(n);
    return r.effect = n, r
}

function D3(t) {
    t.effect.stop()
}
let Rs = !0;
const dA = [];

function fa() {
    dA.push(Rs), Rs = !1
}

function ha() {
    const t = dA.pop();
    Rs = t === void 0 ? !0 : t
}

function pn(t, e, n) {
    if (Rs && _n) {
        let r = ih.get(t);
        r || ih.set(t, r = new Map);
        let i = r.get(n);
        i || r.set(n, i = g_()), fA(i, {
            effect: _n,
            target: t,
            type: e,
            key: n
        })
    }
}

function fA(t, e) {
    let n = !1;
    Ec <= Uy ? uA(t) || (t.n |= Gs, n = !cA(t)) : n = !t.has(_n), n && (t.add(_n), _n.deps.push(t), _n.onTrack && _n.onTrack(Hu({
        effect: _n
    }, e)))
}

function ai(t, e, n, r, i, s) {
    const o = ih.get(t);
    if (!o) return;
    let a = [];
    if (e === "clear") a = [...o.values()];
    else if (n === "length" && Fi(t)) {
        const c = Number(r);
        o.forEach((u, d) => {
            (d === "length" || d >= c) && a.push(u)
        })
    } else switch (n !== void 0 && a.push(o.get(n)), e) {
        case "add":
            Fi(t) ? f_(n) && a.push(o.get("length")) : (a.push(o.get(Fo)), Mc(t) && a.push(o.get(Gy)));
            break;
        case "delete":
            Fi(t) || (a.push(o.get(Fo)), Mc(t) && a.push(o.get(Gy)));
            break;
        case "set":
            Mc(t) && a.push(o.get(Fo));
            break
    }
    const l = {
        target: t,
        type: e,
        key: n,
        newValue: r,
        oldValue: i,
        oldTarget: s
    };
    if (a.length === 1) a[0] && Hy(a[0], l);
    else {
        const c = [];
        for (const u of a) u && c.push(...u);
        Hy(g_(c), l)
    }
}

function Hy(t, e) {
    const n = Fi(t) ? t : [...t];
    for (const r of n) r.computed && Gw(r, e);
    for (const r of n) r.computed || Gw(r, e)
}

function Gw(t, e) {
    (t !== _n || t.allowRecurse) && (t.onTrigger && t.onTrigger(Hu({
        effect: t
    }, e)), t.scheduler ? t.scheduler() : t.run())
}

function $3(t, e) {
    var n;
    return (n = ih.get(t)) == null ? void 0 : n.get(e)
}
const F3 = T3("__proto__,__v_isRef,__isVue"),
    hA = new Set(Object.getOwnPropertyNames(Symbol).filter(t => t !== "arguments" && t !== "caller").map(t => Symbol[t]).filter(d_)),
    L3 = Jh(),
    N3 = Jh(!1, !0),
    U3 = Jh(!0),
    G3 = Jh(!0, !0),
    Hw = H3();

function H3() {
    const t = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(e => {
        t[e] = function(...n) {
            const r = Me(this);
            for (let s = 0, o = this.length; s < o; s++) pn(r, "get", s + "");
            const i = r[e](...n);
            return i === -1 || i === !1 ? r[e](...n.map(Me)) : i
        }
    }), ["push", "pop", "shift", "unshift", "splice"].forEach(e => {
        t[e] = function(...n) {
            fa();
            const r = Me(this)[e].apply(this, n);
            return ha(), r
        }
    }), t
}

function z3(t) {
    const e = Me(this);
    return pn(e, "has", t), e.hasOwnProperty(t)
}

function Jh(t = !1, e = !1) {
    return function(r, i, s) {
        if (i === "__v_isReactive") return !t;
        if (i === "__v_isReadonly") return t;
        if (i === "__v_isShallow") return e;
        if (i === "__v_raw" && s === (t ? e ? xA : bA : e ? _A : vA).get(r)) return r;
        const o = Fi(r);
        if (!t) {
            if (o && Kh(Hw, i)) return Reflect.get(Hw, i, s);
            if (i === "hasOwnProperty") return z3
        }
        const a = Reflect.get(r, i, s);
        return (d_(i) ? hA.has(i) : F3(i)) || (t || pn(r, "get", i), e) ? a : et(a) ? o && f_(i) ? a : a.value : zu(a) ? t ? pa(a) : ft(a) : a
    }
}
const j3 = pA(),
    V3 = pA(!0);

function pA(t = !1) {
    return function(n, r, i, s) {
        let o = n[r];
        if (Yi(o) && et(o) && !et(i)) return !1;
        if (!t && (!su(i) && !Yi(i) && (o = Me(o), i = Me(i)), !Fi(n) && et(o) && !et(i))) return o.value = i, !0;
        const a = Fi(n) && f_(r) ? Number(r) < n.length : Kh(n, r),
            l = Reflect.set(n, r, i, s);
        return n === Me(s) && (a ? h_(i, o) && ai(n, "set", r, i, o) : ai(n, "add", r, i)), l
    }
}

function W3(t, e) {
    const n = Kh(t, e),
        r = t[e],
        i = Reflect.deleteProperty(t, e);
    return i && n && ai(t, "delete", e, void 0, r), i
}

function Y3(t, e) {
    const n = Reflect.has(t, e);
    return (!d_(e) || !hA.has(e)) && pn(t, "has", e), n
}

function X3(t) {
    return pn(t, "iterate", Fi(t) ? "length" : Fo), Reflect.ownKeys(t)
}
const mA = {
        get: L3,
        set: j3,
        deleteProperty: W3,
        has: Y3,
        ownKeys: X3
    },
    gA = {
        get: U3,
        set(t, e) {
            return rh(`Set operation on key "${String(e)}" failed: target is readonly.`, t), !0
        },
        deleteProperty(t, e) {
            return rh(`Delete operation on key "${String(e)}" failed: target is readonly.`, t), !0
        }
    },
    q3 = Hu({}, mA, {
        get: N3,
        set: V3
    }),
    K3 = Hu({}, gA, {
        get: G3
    }),
    y_ = t => t,
    Zh = t => Reflect.getPrototypeOf(t);

function Pd(t, e, n = !1, r = !1) {
    t = t.__v_raw;
    const i = Me(t),
        s = Me(e);
    n || (e !== s && pn(i, "get", e), pn(i, "get", s));
    const {
        has: o
    } = Zh(i), a = r ? y_ : n ? v_ : au;
    if (o.call(i, e)) return a(t.get(e));
    if (o.call(i, s)) return a(t.get(s));
    t !== i && t.get(e)
}

function Ad(t, e = !1) {
    const n = this.__v_raw,
        r = Me(n),
        i = Me(t);
    return e || (t !== i && pn(r, "has", t), pn(r, "has", i)), t === i ? n.has(t) : n.has(t) || n.has(i)
}

function Od(t, e = !1) {
    return t = t.__v_raw, !e && pn(Me(t), "iterate", Fo), Reflect.get(t, "size", t)
}

function zw(t) {
    t = Me(t);
    const e = Me(this);
    return Zh(e).has.call(e, t) || (e.add(t), ai(e, "add", t, t)), this
}

function jw(t, e) {
    e = Me(e);
    const n = Me(this),
        {
            has: r,
            get: i
        } = Zh(n);
    let s = r.call(n, t);
    s ? yA(n, r, t) : (t = Me(t), s = r.call(n, t));
    const o = i.call(n, t);
    return n.set(t, e), s ? h_(e, o) && ai(n, "set", t, e, o) : ai(n, "add", t, e), this
}

function Vw(t) {
    const e = Me(this),
        {
            has: n,
            get: r
        } = Zh(e);
    let i = n.call(e, t);
    i ? yA(e, n, t) : (t = Me(t), i = n.call(e, t));
    const s = r ? r.call(e, t) : void 0,
        o = e.delete(t);
    return i && ai(e, "delete", t, void 0, s), o
}

function Ww() {
    const t = Me(this),
        e = t.size !== 0,
        n = Mc(t) ? new Map(t) : new Set(t),
        r = t.clear();
    return e && ai(t, "clear", void 0, void 0, n), r
}

function Id(t, e) {
    return function(r, i) {
        const s = this,
            o = s.__v_raw,
            a = Me(o),
            l = e ? y_ : t ? v_ : au;
        return !t && pn(a, "iterate", Fo), o.forEach((c, u) => r.call(i, l(c), l(u), s))
    }
}

function Md(t, e, n) {
    return function(...r) {
        const i = this.__v_raw,
            s = Me(i),
            o = Mc(s),
            a = t === "entries" || t === Symbol.iterator && o,
            l = t === "keys" && o,
            c = i[t](...r),
            u = n ? y_ : e ? v_ : au;
        return !e && pn(s, "iterate", l ? Gy : Fo), {
            next() {
                const {
                    value: d,
                    done: f
                } = c.next();
                return f ? {
                    value: d,
                    done: f
                } : {
                    value: a ? [u(d[0]), u(d[1])] : u(d),
                    done: f
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}

function ls(t) {
    return function(...e) {
        {
            const n = e[0] ? `on key "${e[0]}" ` : "";
            console.warn(`${I3(t)} operation ${n}failed: target is readonly.`, Me(this))
        }
        return t === "delete" ? !1 : this
    }
}

function J3() {
    const t = {
            get(s) {
                return Pd(this, s)
            },
            get size() {
                return Od(this)
            },
            has: Ad,
            add: zw,
            set: jw,
            delete: Vw,
            clear: Ww,
            forEach: Id(!1, !1)
        },
        e = {
            get(s) {
                return Pd(this, s, !1, !0)
            },
            get size() {
                return Od(this)
            },
            has: Ad,
            add: zw,
            set: jw,
            delete: Vw,
            clear: Ww,
            forEach: Id(!1, !0)
        },
        n = {
            get(s) {
                return Pd(this, s, !0)
            },
            get size() {
                return Od(this, !0)
            },
            has(s) {
                return Ad.call(this, s, !0)
            },
            add: ls("add"),
            set: ls("set"),
            delete: ls("delete"),
            clear: ls("clear"),
            forEach: Id(!0, !1)
        },
        r = {
            get(s) {
                return Pd(this, s, !0, !0)
            },
            get size() {
                return Od(this, !0)
            },
            has(s) {
                return Ad.call(this, s, !0)
            },
            add: ls("add"),
            set: ls("set"),
            delete: ls("delete"),
            clear: ls("clear"),
            forEach: Id(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(s => {
        t[s] = Md(s, !1, !1), n[s] = Md(s, !0, !1), e[s] = Md(s, !1, !0), r[s] = Md(s, !0, !0)
    }), [t, n, e, r]
}
const [Z3, Q3, eN, tN] = J3();

function Qh(t, e) {
    const n = e ? t ? tN : eN : t ? Q3 : Z3;
    return (r, i, s) => i === "__v_isReactive" ? !t : i === "__v_isReadonly" ? t : i === "__v_raw" ? r : Reflect.get(Kh(n, i) && i in r ? n : r, i, s)
}
const nN = {
        get: Qh(!1, !1)
    },
    rN = {
        get: Qh(!1, !0)
    },
    iN = {
        get: Qh(!0, !1)
    },
    sN = {
        get: Qh(!0, !0)
    };

function yA(t, e, n) {
    const r = Me(n);
    if (r !== n && e.call(t, r)) {
        const i = aA(t);
        console.warn(`Reactive ${i} contains both the raw and reactive versions of the same object${i==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)
    }
}
const vA = new WeakMap,
    _A = new WeakMap,
    bA = new WeakMap,
    xA = new WeakMap;

function oN(t) {
    switch (t) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}

function aN(t) {
    return t.__v_skip || !Object.isExtensible(t) ? 0 : oN(aA(t))
}

function ft(t) {
    return Yi(t) ? t : ep(t, !1, mA, nN, vA)
}

function wA(t) {
    return ep(t, !1, q3, rN, _A)
}

function pa(t) {
    return ep(t, !0, gA, iN, bA)
}

function Ka(t) {
    return ep(t, !0, K3, sN, xA)
}

function ep(t, e, n, r, i) {
    if (!zu(t)) return console.warn(`value cannot be made reactive: ${String(t)}`), t;
    if (t.__v_raw && !(e && t.__v_isReactive)) return t;
    const s = i.get(t);
    if (s) return s;
    const o = aN(t);
    if (o === 0) return t;
    const a = new Proxy(t, o === 2 ? r : n);
    return i.set(t, a), a
}

function Rr(t) {
    return Yi(t) ? Rr(t.__v_raw) : !!(t && t.__v_isReactive)
}

function Yi(t) {
    return !!(t && t.__v_isReadonly)
}

function su(t) {
    return !!(t && t.__v_isShallow)
}

function ou(t) {
    return Rr(t) || Yi(t)
}

function Me(t) {
    const e = t && t.__v_raw;
    return e ? Me(e) : t
}

function ni(t) {
    return M3(t, "__v_skip", !0), t
}
const au = t => zu(t) ? ft(t) : t,
    v_ = t => zu(t) ? pa(t) : t;

function __(t) {
    Rs && _n && (t = Me(t), fA(t.dep || (t.dep = g_()), {
        target: t,
        type: "get",
        key: "value"
    }))
}

function tp(t, e) {
    t = Me(t);
    const n = t.dep;
    n && Hy(n, {
        target: t,
        type: "set",
        key: "value",
        newValue: e
    })
}

function et(t) {
    return !!(t && t.__v_isRef === !0)
}

function q(t) {
    return EA(t, !1)
}

function np(t) {
    return EA(t, !0)
}

function EA(t, e) {
    return et(t) ? t : new lN(t, e)
}
class lN {
    constructor(e, n) {
        this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? e : Me(e), this._value = n ? e : au(e)
    }
    get value() {
        return __(this), this._value
    }
    set value(e) {
        const n = this.__v_isShallow || su(e) || Yi(e);
        e = n ? e : Me(e), h_(e, this._rawValue) && (this._rawValue = e, this._value = n ? e : au(e), tp(this, e))
    }
}

function cN(t) {
    tp(t, t.value)
}

function En(t) {
    return et(t) ? t.value : t
}

function uN(t) {
    return u_(t) ? t() : En(t)
}
const dN = {
    get: (t, e, n) => En(Reflect.get(t, e, n)),
    set: (t, e, n, r) => {
        const i = t[e];
        return et(i) && !et(n) ? (i.value = n, !0) : Reflect.set(t, e, n, r)
    }
};

function b_(t) {
    return Rr(t) ? t : new Proxy(t, dN)
}
class fN {
    constructor(e) {
        this.dep = void 0, this.__v_isRef = !0;
        const {
            get: n,
            set: r
        } = e(() => __(this), () => tp(this));
        this._get = n, this._set = r
    }
    get value() {
        return this._get()
    }
    set value(e) {
        this._set(e)
    }
}

function SA(t) {
    return new fN(t)
}

function zy(t) {
    ou(t) || console.warn("toRefs() expects a reactive object but received a plain one.");
    const e = Fi(t) ? new Array(t.length) : {};
    for (const n in t) e[n] = TA(t, n);
    return e
}
class hN {
    constructor(e, n, r) {
        this._object = e, this._key = n, this._defaultValue = r, this.__v_isRef = !0
    }
    get value() {
        const e = this._object[this._key];
        return e === void 0 ? this._defaultValue : e
    }
    set value(e) {
        this._object[this._key] = e
    }
    get dep() {
        return $3(Me(this._object), this._key)
    }
}
class pN {
    constructor(e) {
        this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0
    }
    get value() {
        return this._getter()
    }
}

function Rc(t, e, n) {
    return et(t) ? t : u_(t) ? new pN(t) : zu(t) && arguments.length > 1 ? TA(t, e, n) : q(t)
}

function TA(t, e, n) {
    const r = t[e];
    return et(r) ? r : new hN(t, e, n)
}
class mN {
    constructor(e, n, r, i) {
        this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new Wu(e, () => {
            this._dirty || (this._dirty = !0, tp(this))
        }), this.effect.computed = this, this.effect.active = this._cacheable = !i, this.__v_isReadonly = r
    }
    get value() {
        const e = Me(this);
        return __(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value
    }
    set value(e) {
        this._setter(e)
    }
}

function gN(t, e, n = !1) {
    let r, i;
    const s = u_(t);
    s ? (r = t, i = () => {
        console.warn("Write operation failed: computed value is readonly")
    }) : (r = t.get, i = t.set);
    const o = new mN(r, i, s || !i, n);
    return e && !n && (o.effect.onTrack = e.onTrack, o.effect.onTrigger = e.onTrigger), o
}

function Yu(t, e) {
    const n = Object.create(null),
        r = t.split(",");
    for (let i = 0; i < r.length; i++) n[r[i]] = !0;
    return e ? i => !!n[i.toLowerCase()] : i => !!n[i]
}
const ot = Object.freeze({}),
    tl = Object.freeze([]),
    Dn = () => {},
    CA = () => !1,
    yN = /^on[^a-z]/,
    Xu = t => yN.test(t),
    jy = t => t.startsWith("onUpdate:"),
    St = Object.assign,
    x_ = (t, e) => {
        const n = t.indexOf(e);
        n > -1 && t.splice(n, 1)
    },
    vN = Object.prototype.hasOwnProperty,
    Je = (t, e) => vN.call(t, e),
    De = Array.isArray,
    PA = t => qu(t) === "[object Map]",
    AA = t => qu(t) === "[object Set]",
    _N = t => qu(t) === "[object RegExp]",
    Be = t => typeof t == "function",
    Rt = t => typeof t == "string",
    ct = t => t !== null && typeof t == "object",
    rp = t => ct(t) && Be(t.then) && Be(t.catch),
    OA = Object.prototype.toString,
    qu = t => OA.call(t),
    bN = t => qu(t).slice(8, -1),
    IA = t => qu(t) === "[object Object]",
    kc = Yu(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    xN = Yu("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"),
    ip = t => {
        const e = Object.create(null);
        return n => e[n] || (e[n] = t(n))
    },
    wN = /-(\w)/g,
    Dr = ip(t => t.replace(wN, (e, n) => n ? n.toUpperCase() : "")),
    EN = /\B([A-Z])/g,
    dl = ip(t => t.replace(EN, "-$1").toLowerCase()),
    fl = ip(t => t.charAt(0).toUpperCase() + t.slice(1)),
    Ii = ip(t => t ? `on${fl(t)}` : ""),
    Vy = (t, e) => !Object.is(t, e),
    Eo = (t, e) => {
        for (let n = 0; n < t.length; n++) t[n](e)
    },
    Wy = (t, e, n) => {
        Object.defineProperty(t, e, {
            configurable: !0,
            enumerable: !1,
            value: n
        })
    },
    SN = t => {
        const e = parseFloat(t);
        return isNaN(e) ? t : e
    },
    TN = t => {
        const e = Rt(t) ? Number(t) : NaN;
        return isNaN(e) ? t : e
    };
let Yw;
const sh = () => Yw || (Yw = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}),
    CN = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console",
    PN = Yu(CN);

function Ku(t) {
    if (De(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const r = t[n],
                i = Rt(r) ? MN(r) : Ku(r);
            if (i)
                for (const s in i) e[s] = i[s]
        }
        return e
    } else {
        if (Rt(t)) return t;
        if (ct(t)) return t
    }
}
const AN = /;(?![^(]*\))/g,
    ON = /:([^]+)/,
    IN = /\/\*[^]*?\*\//g;

function MN(t) {
    const e = {};
    return t.replace(IN, "").split(AN).forEach(n => {
        if (n) {
            const r = n.split(ON);
            r.length > 1 && (e[r[0].trim()] = r[1].trim())
        }
    }), e
}

function Ju(t) {
    let e = "";
    if (Rt(t)) e = t;
    else if (De(t))
        for (let n = 0; n < t.length; n++) {
            const r = Ju(t[n]);
            r && (e += r + " ")
        } else if (ct(t))
            for (const n in t) t[n] && (e += n + " ");
    return e.trim()
}

function RN(t) {
    if (!t) return null;
    let {
        class: e,
        style: n
    } = t;
    return e && !Rt(e) && (t.class = Ju(e)), n && (t.style = Ku(n)), t
}
const kN = t => Rt(t) ? t : t == null ? "" : De(t) || ct(t) && (t.toString === OA || !Be(t.toString)) ? JSON.stringify(t, MA, 2) : String(t),
    MA = (t, e) => e && e.__v_isRef ? MA(t, e.value) : PA(e) ? {
        [`Map(${e.size})`]: [...e.entries()].reduce((n, [r, i]) => (n[`${r} =>`] = i, n), {})
    } : AA(e) ? {
        [`Set(${e.size})`]: [...e.values()]
    } : ct(e) && !De(e) && !IA(e) ? String(e) : e,
    Lo = [];

function Bc(t) {
    Lo.push(t)
}

function Dc() {
    Lo.pop()
}

function re(t, ...e) {
    fa();
    const n = Lo.length ? Lo[Lo.length - 1].component : null,
        r = n && n.appContext.config.warnHandler,
        i = BN();
    if (r) ii(r, n, 11, [t + e.join(""), n && n.proxy, i.map(({
        vnode: s
    }) => `at <${gp(n,s.type)}>`).join(`
`), i]);
    else {
        const s = [`[Vue warn]: ${t}`, ...e];
        i.length && s.push(`
`, ...DN(i)), console.warn(...s)
    }
    ha()
}

function BN() {
    let t = Lo[Lo.length - 1];
    if (!t) return [];
    const e = [];
    for (; t;) {
        const n = e[0];
        n && n.vnode === t ? n.recurseCount++ : e.push({
            vnode: t,
            recurseCount: 0
        });
        const r = t.component && t.component.parent;
        t = r && r.vnode
    }
    return e
}

function DN(t) {
    const e = [];
    return t.forEach((n, r) => {
        e.push(...r === 0 ? [] : [`
`], ...$N(n))
    }), e
}

function $N({
    vnode: t,
    recurseCount: e
}) {
    const n = e > 0 ? `... (${e} recursive calls)` : "",
        r = t.component ? t.component.parent == null : !1,
        i = ` at <${gp(t.component,t.type,r)}`,
        s = ">" + n;
    return t.props ? [i, ...FN(t.props), s] : [i + s]
}

function FN(t) {
    const e = [],
        n = Object.keys(t);
    return n.slice(0, 3).forEach(r => {
        e.push(...RA(r, t[r]))
    }), n.length > 3 && e.push(" ..."), e
}

function RA(t, e, n) {
    return Rt(e) ? (e = JSON.stringify(e), n ? e : [`${t}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? n ? e : [`${t}=${e}`] : et(e) ? (e = RA(t, Me(e.value), !0), n ? e : [`${t}=Ref<`, e, ">"]) : Be(e) ? [`${t}=fn${e.name?`<${e.name}>`:""}`] : (e = Me(e), n ? e : [`${t}=`, e])
}

function w_(t, e) {
    t !== void 0 && (typeof t != "number" ? re(`${e} is not a valid number - got ${JSON.stringify(t)}.`) : isNaN(t) && re(`${e} is NaN - the duration expression might be incorrect.`))
}
const E_ = {
    sp: "serverPrefetch hook",
    bc: "beforeCreate hook",
    c: "created hook",
    bm: "beforeMount hook",
    m: "mounted hook",
    bu: "beforeUpdate hook",
    u: "updated",
    bum: "beforeUnmount hook",
    um: "unmounted hook",
    a: "activated hook",
    da: "deactivated hook",
    ec: "errorCaptured hook",
    rtc: "renderTracked hook",
    rtg: "renderTriggered hook",
    0: "setup function",
    1: "render function",
    2: "watcher getter",
    3: "watcher callback",
    4: "watcher cleanup function",
    5: "native event handler",
    6: "component event handler",
    7: "vnode hook",
    8: "directive hook",
    9: "transition hook",
    10: "app errorHandler",
    11: "app warnHandler",
    12: "ref function",
    13: "async component loader",
    14: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};

function ii(t, e, n, r) {
    let i;
    try {
        i = r ? t(...r) : t()
    } catch (s) {
        ma(s, e, n)
    }
    return i
}

function qn(t, e, n, r) {
    if (Be(t)) {
        const s = ii(t, e, n, r);
        return s && rp(s) && s.catch(o => {
            ma(o, e, n)
        }), s
    }
    const i = [];
    for (let s = 0; s < t.length; s++) i.push(qn(t[s], e, n, r));
    return i
}

function ma(t, e, n, r = !0) {
    const i = e ? e.vnode : null;
    if (e) {
        let s = e.parent;
        const o = e.proxy,
            a = E_[n];
        for (; s;) {
            const c = s.ec;
            if (c) {
                for (let u = 0; u < c.length; u++)
                    if (c[u](t, o, a) === !1) return
            }
            s = s.parent
        }
        const l = e.appContext.config.errorHandler;
        if (l) {
            ii(l, null, 10, [t, o, a]);
            return
        }
    }
    LN(t, n, i, r)
}

function LN(t, e, n, r = !0) {
    {
        const i = E_[e];
        if (n && Bc(n), re(`Unhandled error${i?` during execution of ${i}`:""}`), n && Dc(), r) throw t;
        console.error(t)
    }
}
let lu = !1,
    Yy = !1;
const cn = [];
let Qr = 0;
const nl = [];
let Xr = null,
    ys = 0;
const kA = Promise.resolve();
let S_ = null;
const NN = 100;

function Ue(t) {
    const e = S_ || kA;
    return t ? e.then(this ? t.bind(this) : t) : e
}

function UN(t) {
    let e = Qr + 1,
        n = cn.length;
    for (; e < n;) {
        const r = e + n >>> 1;
        cu(cn[r]) < t ? e = r + 1 : n = r
    }
    return e
}

function Zu(t) {
    (!cn.length || !cn.includes(t, lu && t.allowRecurse ? Qr + 1 : Qr)) && (t.id == null ? cn.push(t) : cn.splice(UN(t.id), 0, t), BA())
}

function BA() {
    !lu && !Yy && (Yy = !0, S_ = kA.then(DA))
}

function GN(t) {
    const e = cn.indexOf(t);
    e > Qr && cn.splice(e, 1)
}

function sp(t) {
    De(t) ? nl.push(...t) : (!Xr || !Xr.includes(t, t.allowRecurse ? ys + 1 : ys)) && nl.push(t), BA()
}

function Xw(t, e = lu ? Qr + 1 : 0) {
    for (t = t || new Map; e < cn.length; e++) {
        const n = cn[e];
        if (n && n.pre) {
            if (T_(t, n)) continue;
            cn.splice(e, 1), e--, n()
        }
    }
}

function oh(t) {
    if (nl.length) {
        const e = [...new Set(nl)];
        if (nl.length = 0, Xr) {
            Xr.push(...e);
            return
        }
        for (Xr = e, t = t || new Map, Xr.sort((n, r) => cu(n) - cu(r)), ys = 0; ys < Xr.length; ys++) T_(t, Xr[ys]) || Xr[ys]();
        Xr = null, ys = 0
    }
}
const cu = t => t.id == null ? 1 / 0 : t.id,
    HN = (t, e) => {
        const n = cu(t) - cu(e);
        if (n === 0) {
            if (t.pre && !e.pre) return -1;
            if (e.pre && !t.pre) return 1
        }
        return n
    };

function DA(t) {
    Yy = !1, lu = !0, t = t || new Map, cn.sort(HN);
    const e = n => T_(t, n);
    try {
        for (Qr = 0; Qr < cn.length; Qr++) {
            const n = cn[Qr];
            if (n && n.active !== !1) {
                if (e(n)) continue;
                ii(n, null, 14)
            }
        }
    } finally {
        Qr = 0, cn.length = 0, oh(t), lu = !1, S_ = null, (cn.length || nl.length) && DA(t)
    }
}

function T_(t, e) {
    if (!t.has(e)) t.set(e, 1);
    else {
        const n = t.get(e);
        if (n > NN) {
            const r = e.ownerInstance,
                i = r && pu(r.type);
            return re(`Maximum recursive updates exceeded${i?` in component <${i}>`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`), !0
        } else t.set(e, n + 1)
    }
}
let ks = !1;
const Wa = new Set;
sh().__VUE_HMR_RUNTIME__ = {
    createRecord: wm($A),
    rerender: wm(VN),
    reload: wm(WN)
};
const Yo = new Map;

function zN(t) {
    const e = t.type.__hmrId;
    let n = Yo.get(e);
    n || ($A(e, t.type), n = Yo.get(e)), n.instances.add(t)
}

function jN(t) {
    Yo.get(t.type.__hmrId).instances.delete(t)
}

function $A(t, e) {
    return Yo.has(t) ? !1 : (Yo.set(t, {
        initialDef: $c(e),
        instances: new Set
    }), !0)
}

function $c(t) {
    return CO(t) ? t.__vccOpts : t
}

function VN(t, e) {
    const n = Yo.get(t);
    n && (n.initialDef.render = e, [...n.instances].forEach(r => {
        e && (r.render = e, $c(r.type).render = e), r.renderCache = [], ks = !0, r.update(), ks = !1
    }))
}

function WN(t, e) {
    const n = Yo.get(t);
    if (!n) return;
    e = $c(e), qw(n.initialDef, e);
    const r = [...n.instances];
    for (const i of r) {
        const s = $c(i.type);
        Wa.has(s) || (s !== n.initialDef && qw(s, e), Wa.add(s)), i.appContext.propsCache.delete(i.type), i.appContext.emitsCache.delete(i.type), i.appContext.optionsCache.delete(i.type), i.ceReload ? (Wa.add(s), i.ceReload(e.styles), Wa.delete(s)) : i.parent ? Zu(i.parent.update) : i.appContext.reload ? i.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn("[HMR] Root or manually mounted instance modified. Full reload required.")
    }
    sp(() => {
        for (const i of r) Wa.delete($c(i.type))
    })
}

function qw(t, e) {
    St(t, e);
    for (const n in t) n !== "__file" && !(n in e) && delete t[n]
}

function wm(t) {
    return (e, n) => {
        try {
            return t(e, n)
        } catch (r) {
            console.error(r), console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")
        }
    }
}
let Cr, Sc = [],
    Xy = !1;

function Qu(t, ...e) {
    Cr ? Cr.emit(t, ...e) : Xy || Sc.push({
        event: t,
        args: e
    })
}

function C_(t, e) {
    var n, r;
    Cr = t, Cr ? (Cr.enabled = !0, Sc.forEach(({
        event: i,
        args: s
    }) => Cr.emit(i, ...s)), Sc = []) : typeof window < "u" && window.HTMLElement && !((r = (n = window.navigator) == null ? void 0 : n.userAgent) != null && r.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(s => {
        C_(s, e)
    }), setTimeout(() => {
        Cr || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Xy = !0, Sc = [])
    }, 3e3)) : (Xy = !0, Sc = [])
}

function YN(t, e) {
    Qu("app:init", t, e, {
        Fragment: mt,
        Text: li,
        Comment: It,
        Static: Bs
    })
}

function XN(t) {
    Qu("app:unmount", t)
}
const qy = P_("component:added"),
    FA = P_("component:updated"),
    qN = P_("component:removed"),
    KN = t => {
        Cr && typeof Cr.cleanupBuffer == "function" && !Cr.cleanupBuffer(t) && qN(t)
    };

function P_(t) {
    return e => {
        Qu(t, e.appContext.app, e.uid, e.parent ? e.parent.uid : void 0, e)
    }
}
const JN = LA("perf:start"),
    ZN = LA("perf:end");

function LA(t) {
    return (e, n, r) => {
        Qu(t, e.appContext.app, e.uid, e, n, r)
    }
}

function QN(t, e, n) {
    Qu("component:emit", t.appContext.app, t, e, n)
}

function e4(t, e, ...n) {
    if (t.isUnmounted) return;
    const r = t.vnode.props || ot; {
        const {
            emitsOptions: u,
            propsOptions: [d]
        } = t;
        if (u)
            if (!(e in u))(!d || !(Ii(e) in d)) && re(`Component emitted event "${e}" but it is neither declared in the emits option nor as an "${Ii(e)}" prop.`);
            else {
                const f = u[e];
                Be(f) && (f(...n) || re(`Invalid event arguments: event validation failed for event "${e}".`))
            }
    }
    let i = n;
    const s = e.startsWith("update:"),
        o = s && e.slice(7);
    if (o && o in r) {
        const u = `${o==="modelValue"?"model":o}Modifiers`,
            {
                number: d,
                trim: f
            } = r[u] || ot;
        f && (i = n.map(h => Rt(h) ? h.trim() : h)), d && (i = n.map(SN))
    }
    QN(t, e, i); {
        const u = e.toLowerCase();
        u !== e && r[Ii(u)] && re(`Event "${u}" is emitted in component ${gp(t,t.type)} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${dl(e)}" instead of "${e}".`)
    }
    let a, l = r[a = Ii(e)] || r[a = Ii(Dr(e))];
    !l && s && (l = r[a = Ii(dl(e))]), l && qn(l, t, 6, i);
    const c = r[a + "Once"];
    if (c) {
        if (!t.emitted) t.emitted = {};
        else if (t.emitted[a]) return;
        t.emitted[a] = !0, qn(c, t, 6, i)
    }
}

function NA(t, e, n = !1) {
    const r = e.emitsCache,
        i = r.get(t);
    if (i !== void 0) return i;
    const s = t.emits;
    let o = {},
        a = !1;
    if (!Be(t)) {
        const l = c => {
            const u = NA(c, e, !0);
            u && (a = !0, St(o, u))
        };
        !n && e.mixins.length && e.mixins.forEach(l), t.extends && l(t.extends), t.mixins && t.mixins.forEach(l)
    }
    return !s && !a ? (ct(t) && r.set(t, null), null) : (De(s) ? s.forEach(l => o[l] = null) : St(o, s), ct(t) && r.set(t, o), o)
}

function op(t, e) {
    return !t || !Xu(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Je(t, e[0].toLowerCase() + e.slice(1)) || Je(t, dl(e)) || Je(t, e))
}
let $t = null,
    ap = null;

function uu(t) {
    const e = $t;
    return $t = t, ap = t && t.type.__scopeId || null, e
}

function t4(t) {
    ap = t
}

function n4() {
    ap = null
}
const r4 = t => A_;

function A_(t, e = $t, n) {
    if (!e || t._n) return t;
    const r = (...i) => {
        r._d && rv(-1);
        const s = uu(e);
        let o;
        try {
            o = t(...i)
        } finally {
            uu(s), r._d && rv(1)
        }
        return FA(e), o
    };
    return r._n = !0, r._c = !0, r._d = !0, r
}
let Ky = !1;

function ah() {
    Ky = !0
}

function Mf(t) {
    const {
        type: e,
        vnode: n,
        proxy: r,
        withProxy: i,
        props: s,
        propsOptions: [o],
        slots: a,
        attrs: l,
        emit: c,
        render: u,
        renderCache: d,
        data: f,
        setupState: h,
        ctx: p,
        inheritAttrs: b
    } = t;
    let y, m;
    const g = uu(t);
    Ky = !1;
    try {
        if (n.shapeFlag & 4) {
            const x = i || r;
            y = kn(u.call(x, x, d, s, h, f, p)), m = l
        } else {
            const x = e;
            l === s && ah(), y = kn(x.length > 1 ? x(s, {
                get attrs() {
                    return ah(), l
                },
                slots: a,
                emit: c
            }) : x(s, null)), m = e.props ? l : s4(l)
        }
    } catch (x) {
        Lc.length = 0, ma(x, t, 1), y = I(It)
    }
    let v = y,
        _;
    if (y.patchFlag > 0 && y.patchFlag & 2048 && ([v, _] = i4(y)), m && b !== !1) {
        const x = Object.keys(m),
            {
                shapeFlag: w
            } = v;
        if (x.length) {
            if (w & 7) o && x.some(jy) && (m = o4(m, o)), v = _r(v, m);
            else if (!Ky && v.type !== It) {
                const E = Object.keys(l),
                    C = [],
                    A = [];
                for (let T = 0, S = E.length; T < S; T++) {
                    const P = E[T];
                    Xu(P) ? jy(P) || C.push(P[2].toLowerCase() + P.slice(3)) : A.push(P)
                }
                A.length && re(`Extraneous non-props attributes (${A.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`), C.length && re(`Extraneous non-emits event listeners (${C.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`)
            }
        }
    }
    return n.dirs && (Kw(v) || re("Runtime directive used on component with non-element root node. The directives will not function as intended."), v = _r(v), v.dirs = v.dirs ? v.dirs.concat(n.dirs) : n.dirs), n.transition && (Kw(v) || re("Component inside <Transition> renders non-element root node that cannot be animated."), v.transition = n.transition), _ ? _(v) : y = v, uu(g), y
}
const i4 = t => {
    const e = t.children,
        n = t.dynamicChildren,
        r = O_(e);
    if (!r) return [t, void 0];
    const i = e.indexOf(r),
        s = n ? n.indexOf(r) : -1,
        o = a => {
            e[i] = a, n && (s > -1 ? n[s] = a : a.patchFlag > 0 && (t.dynamicChildren = [...n, a]))
        };
    return [kn(r), o]
};

function O_(t) {
    let e;
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        if (ci(r)) {
            if (r.type !== It || r.children === "v-if") {
                if (e) return;
                e = r
            }
        } else return
    }
    return e
}
const s4 = t => {
        let e;
        for (const n in t)(n === "class" || n === "style" || Xu(n)) && ((e || (e = {}))[n] = t[n]);
        return e
    },
    o4 = (t, e) => {
        const n = {};
        for (const r in t)(!jy(r) || !(r.slice(9) in e)) && (n[r] = t[r]);
        return n
    },
    Kw = t => t.shapeFlag & 7 || t.type === It;

function a4(t, e, n) {
    const {
        props: r,
        children: i,
        component: s
    } = t, {
        props: o,
        children: a,
        patchFlag: l
    } = e, c = s.emitsOptions;
    if ((i || a) && ks || e.dirs || e.transition) return !0;
    if (n && l >= 0) {
        if (l & 1024) return !0;
        if (l & 16) return r ? Jw(r, o, c) : !!o;
        if (l & 8) {
            const u = e.dynamicProps;
            for (let d = 0; d < u.length; d++) {
                const f = u[d];
                if (o[f] !== r[f] && !op(c, f)) return !0
            }
        }
    } else return (i || a) && (!a || !a.$stable) ? !0 : r === o ? !1 : r ? o ? Jw(r, o, c) : !0 : !!o;
    return !1
}

function Jw(t, e, n) {
    const r = Object.keys(e);
    if (r.length !== Object.keys(t).length) return !0;
    for (let i = 0; i < r.length; i++) {
        const s = r[i];
        if (e[s] !== t[s] && !op(n, s)) return !0
    }
    return !1
}

function I_({
    vnode: t,
    parent: e
}, n) {
    for (; e && e.subTree === t;)(t = e.vnode).el = n, e = e.parent
}
const UA = t => t.__isSuspense,
    l4 = {
        name: "Suspense",
        __isSuspense: !0,
        process(t, e, n, r, i, s, o, a, l, c) {
            t == null ? u4(e, n, r, i, s, o, a, l, c) : d4(t, e, n, r, i, o, a, l, c)
        },
        hydrate: f4,
        create: M_,
        normalize: h4
    },
    c4 = l4;

function du(t, e) {
    const n = t.props && t.props[e];
    Be(n) && n()
}

function u4(t, e, n, r, i, s, o, a, l) {
    const {
        p: c,
        o: {
            createElement: u
        }
    } = l, d = u("div"), f = t.suspense = M_(t, i, r, e, d, n, s, o, a, l);
    c(null, f.pendingBranch = t.ssContent, d, null, r, f, s, o), f.deps > 0 ? (du(t, "onPending"), du(t, "onFallback"), c(null, t.ssFallback, e, n, r, null, s, o), rl(f, t.ssFallback)) : f.resolve(!1, !0)
}

function d4(t, e, n, r, i, s, o, a, {
    p: l,
    um: c,
    o: {
        createElement: u
    }
}) {
    const d = e.suspense = t.suspense;
    d.vnode = e, e.el = t.el;
    const f = e.ssContent,
        h = e.ssFallback,
        {
            activeBranch: p,
            pendingBranch: b,
            isInFallback: y,
            isHydrating: m
        } = d;
    if (b) d.pendingBranch = f, Pr(f, b) ? (l(b, f, d.hiddenContainer, null, i, d, s, o, a), d.deps <= 0 ? d.resolve() : y && (l(p, h, n, r, i, null, s, o, a), rl(d, h))) : (d.pendingId++, m ? (d.isHydrating = !1, d.activeBranch = b) : c(b, i, d), d.deps = 0, d.effects.length = 0, d.hiddenContainer = u("div"), y ? (l(null, f, d.hiddenContainer, null, i, d, s, o, a), d.deps <= 0 ? d.resolve() : (l(p, h, n, r, i, null, s, o, a), rl(d, h))) : p && Pr(f, p) ? (l(p, f, n, r, i, d, s, o, a), d.resolve(!0)) : (l(null, f, d.hiddenContainer, null, i, d, s, o, a), d.deps <= 0 && d.resolve()));
    else if (p && Pr(f, p)) l(p, f, n, r, i, d, s, o, a), rl(d, f);
    else if (du(e, "onPending"), d.pendingBranch = f, d.pendingId++, l(null, f, d.hiddenContainer, null, i, d, s, o, a), d.deps <= 0) d.resolve();
    else {
        const {
            timeout: g,
            pendingId: v
        } = d;
        g > 0 ? setTimeout(() => {
            d.pendingId === v && d.fallback(h)
        }, g) : g === 0 && d.fallback(h)
    }
}
let Zw = !1;

function M_(t, e, n, r, i, s, o, a, l, c, u = !1) {
    Zw || (Zw = !0, console[console.info ? "info" : "log"]("<Suspense> is an experimental feature and its API will likely change."));
    const {
        p: d,
        m: f,
        um: h,
        n: p,
        o: {
            parentNode: b,
            remove: y
        }
    } = c;
    let m;
    const g = p4(t);
    g && e != null && e.pendingBranch && (m = e.pendingId, e.deps++);
    const v = t.props ? TN(t.props.timeout) : void 0;
    w_(v, "Suspense timeout");
    const _ = {
        vnode: t,
        parent: e,
        parentComponent: n,
        isSVG: o,
        container: r,
        hiddenContainer: i,
        anchor: s,
        deps: 0,
        pendingId: 0,
        timeout: typeof v == "number" ? v : -1,
        activeBranch: null,
        pendingBranch: null,
        isInFallback: !0,
        isHydrating: u,
        isUnmounted: !1,
        effects: [],
        resolve(x = !1, w = !1) {
            {
                if (!x && !_.pendingBranch) throw new Error("suspense.resolve() is called without a pending branch.");
                if (_.isUnmounted) throw new Error("suspense.resolve() is called on an already unmounted suspense boundary.")
            }
            const {
                vnode: E,
                activeBranch: C,
                pendingBranch: A,
                pendingId: T,
                effects: S,
                parentComponent: P,
                container: R
            } = _;
            if (_.isHydrating) _.isHydrating = !1;
            else if (!x) {
                const B = C && A.transition && A.transition.mode === "out-in";
                B && (C.transition.afterLeave = () => {
                    T === _.pendingId && f(A, R, N, 0)
                });
                let {
                    anchor: N
                } = _;
                C && (N = p(C), h(C, P, _, !0)), B || f(A, R, N, 0)
            }
            rl(_, A), _.pendingBranch = null, _.isInFallback = !1;
            let D = _.parent,
                H = !1;
            for (; D;) {
                if (D.pendingBranch) {
                    D.effects.push(...S), H = !0;
                    break
                }
                D = D.parent
            }
            H || sp(S), _.effects = [], g && e && e.pendingBranch && m === e.pendingId && (e.deps--, e.deps === 0 && !w && e.resolve()), du(E, "onResolve")
        },
        fallback(x) {
            if (!_.pendingBranch) return;
            const {
                vnode: w,
                activeBranch: E,
                parentComponent: C,
                container: A,
                isSVG: T
            } = _;
            du(w, "onFallback");
            const S = p(E),
                P = () => {
                    _.isInFallback && (d(null, x, A, S, C, null, T, a, l), rl(_, x))
                },
                R = x.transition && x.transition.mode === "out-in";
            R && (E.transition.afterLeave = P), _.isInFallback = !0, h(E, C, null, !0), R || P()
        },
        move(x, w, E) {
            _.activeBranch && f(_.activeBranch, x, w, E), _.container = x
        },
        next() {
            return _.activeBranch && p(_.activeBranch)
        },
        registerDep(x, w) {
            const E = !!_.pendingBranch;
            E && _.deps++;
            const C = x.vnode.el;
            x.asyncDep.catch(A => {
                ma(A, x, 0)
            }).then(A => {
                if (x.isUnmounted || _.isUnmounted || _.pendingId !== x.suspenseId) return;
                x.asyncResolved = !0;
                const {
                    vnode: T
                } = x;
                Bc(T), ov(x, A, !1), C && (T.el = C);
                const S = !C && x.subTree.el;
                w(x, T, b(C || x.subTree.el), C ? null : p(x.subTree), _, o, l), S && y(S), I_(x, T.el), Dc(), E && --_.deps === 0 && _.resolve()
            })
        },
        unmount(x, w) {
            _.isUnmounted = !0, _.activeBranch && h(_.activeBranch, n, x, w), _.pendingBranch && h(_.pendingBranch, n, x, w)
        }
    };
    return _
}

function f4(t, e, n, r, i, s, o, a, l) {
    const c = e.suspense = M_(e, r, n, t.parentNode, document.createElement("div"), null, i, s, o, a, !0),
        u = l(t, c.pendingBranch = e.ssContent, n, c, s, o);
    return c.deps === 0 && c.resolve(!1, !0), u
}

function h4(t) {
    const {
        shapeFlag: e,
        children: n
    } = t, r = e & 32;
    t.ssContent = Qw(r ? n.default : n), t.ssFallback = r ? Qw(n.fallback) : I(It)
}

function Qw(t) {
    let e;
    if (Be(t)) {
        const n = qo && t._c;
        n && (t._d = !1, fp()), t = t(), n && (t._d = !0, e = $n, gO())
    }
    if (De(t)) {
        const n = O_(t);
        n || re("<Suspense> slots expect a single root node."), t = n
    }
    return t = kn(t), e && !t.dynamicChildren && (t.dynamicChildren = e.filter(n => n !== t)), t
}

function GA(t, e) {
    e && e.pendingBranch ? De(t) ? e.effects.push(...t) : e.effects.push(t) : sp(t)
}

function rl(t, e) {
    t.activeBranch = e;
    const {
        vnode: n,
        parentComponent: r
    } = t, i = n.el = e.el;
    r && r.subTree === n && (r.vnode.el = i, I_(r, i))
}

function p4(t) {
    var e;
    return ((e = t.props) == null ? void 0 : e.suspensible) != null && t.props.suspensible !== !1
}

function Ul(t, e) {
    return ed(t, null, e)
}

function HA(t, e) {
    return ed(t, null, St({}, e, {
        flush: "post"
    }))
}

function m4(t, e) {
    return ed(t, null, St({}, e, {
        flush: "sync"
    }))
}
const Rd = {};

function he(t, e, n) {
    return Be(e) || re("`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."), ed(t, e, n)
}

function ed(t, e, {
    immediate: n,
    deep: r,
    flush: i,
    onTrack: s,
    onTrigger: o
} = ot) {
    var a;
    e || (n !== void 0 && re('watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'), r !== void 0 && re('watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'));
    const l = x => {
            re("Invalid watch source: ", x, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.")
        },
        c = Vu() === ((a = Dt) == null ? void 0 : a.scope) ? Dt : null;
    let u, d = !1,
        f = !1;
    if (et(t) ? (u = () => t.value, d = su(t)) : Rr(t) ? (u = () => t, r = !0) : De(t) ? (f = !0, d = t.some(x => Rr(x) || su(x)), u = () => t.map(x => {
            if (et(x)) return x.value;
            if (Rr(x)) return Po(x);
            if (Be(x)) return ii(x, c, 2);
            l(x)
        })) : Be(t) ? e ? u = () => ii(t, c, 2) : u = () => {
            if (!(c && c.isUnmounted)) return h && h(), qn(t, c, 3, [p])
        } : (u = Dn, l(t)), e && r) {
        const x = u;
        u = () => Po(x())
    }
    let h, p = x => {
            h = v.onStop = () => {
                ii(x, c, 4)
            }
        },
        b;
    if (pl)
        if (p = Dn, e ? n && qn(e, c, 3, [u(), f ? [] : void 0, p]) : u(), i === "sync") {
            const x = AO();
            b = x.__watcherHandles || (x.__watcherHandles = [])
        } else return Dn;
    let y = f ? new Array(t.length).fill(Rd) : Rd;
    const m = () => {
        if (v.active)
            if (e) {
                const x = v.run();
                (r || d || (f ? x.some((w, E) => Vy(w, y[E])) : Vy(x, y))) && (h && h(), qn(e, c, 3, [x, y === Rd ? void 0 : f && y[0] === Rd ? [] : y, p]), y = x)
            } else v.run()
    };
    m.allowRecurse = !!e;
    let g;
    i === "sync" ? g = m : i === "post" ? g = () => en(m, c && c.suspense) : (m.pre = !0, c && (m.id = c.uid), g = () => Zu(m));
    const v = new Wu(u, g);
    v.onTrack = s, v.onTrigger = o, e ? n ? m() : y = v.run() : i === "post" ? en(v.run.bind(v), c && c.suspense) : v.run();
    const _ = () => {
        v.stop(), c && c.scope && x_(c.scope.effects, v)
    };
    return b && b.push(_), _
}

function g4(t, e, n) {
    const r = this.proxy,
        i = Rt(t) ? t.includes(".") ? zA(r, t) : () => r[t] : t.bind(r, r);
    let s;
    Be(e) ? s = e : (s = e.handler, n = e);
    const o = Dt;
    Hs(this);
    const a = ed(i, s.bind(r), n);
    return o ? Hs(o) : Ds(), a
}

function zA(t, e) {
    const n = e.split(".");
    return () => {
        let r = t;
        for (let i = 0; i < n.length && r; i++) r = r[n[i]];
        return r
    }
}

function Po(t, e) {
    if (!ct(t) || t.__v_skip || (e = e || new Set, e.has(t))) return t;
    if (e.add(t), et(t)) Po(t.value, e);
    else if (De(t))
        for (let n = 0; n < t.length; n++) Po(t[n], e);
    else if (AA(t) || PA(t)) t.forEach(n => {
        Po(n, e)
    });
    else if (IA(t))
        for (const n in t) Po(t[n], e);
    return t
}

function jA(t) {
    xN(t) && re("Do not use built-in directive ids as custom directive id: " + t)
}

function mr(t, e) {
    const n = $t;
    if (n === null) return re("withDirectives can only be used inside render functions."), t;
    const r = mp(n) || n.proxy,
        i = t.dirs || (t.dirs = []);
    for (let s = 0; s < e.length; s++) {
        let [o, a, l, c = ot] = e[s];
        o && (Be(o) && (o = {
            mounted: o,
            updated: o
        }), o.deep && Po(a), i.push({
            dir: o,
            instance: r,
            value: a,
            oldValue: void 0,
            arg: l,
            modifiers: c
        }))
    }
    return t
}

function Kr(t, e, n, r) {
    const i = t.dirs,
        s = e && e.dirs;
    for (let o = 0; o < i.length; o++) {
        const a = i[o];
        s && (a.oldValue = s[o].value);
        let l = a.dir[r];
        l && (fa(), qn(l, n, 8, [t.el, a, t, e]), ha())
    }
}

function R_() {
    const t = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return _t(() => {
        t.isMounted = !0
    }), nr(() => {
        t.isUnmounting = !0
    }), t
}
const or = [Function, Array],
    k_ = {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: or,
        onEnter: or,
        onAfterEnter: or,
        onEnterCancelled: or,
        onBeforeLeave: or,
        onLeave: or,
        onAfterLeave: or,
        onLeaveCancelled: or,
        onBeforeAppear: or,
        onAppear: or,
        onAfterAppear: or,
        onAppearCancelled: or
    },
    y4 = {
        name: "BaseTransition",
        props: k_,
        setup(t, {
            slots: e
        }) {
            const n = rt(),
                r = R_();
            let i;
            return () => {
                const s = e.default && lp(e.default(), !0);
                if (!s || !s.length) return;
                let o = s[0];
                if (s.length > 1) {
                    let b = !1;
                    for (const y of s)
                        if (y.type !== It) {
                            if (b) {
                                re("<transition> can only be used on a single element or component. Use <transition-group> for lists.");
                                break
                            }
                            o = y, b = !0
                        }
                }
                const a = Me(t),
                    {
                        mode: l
                    } = a;
                if (l && l !== "in-out" && l !== "out-in" && l !== "default" && re(`invalid <transition> mode: ${l}`), r.isLeaving) return Em(o);
                const c = eE(o);
                if (!c) return Em(o);
                const u = hl(c, a, r, n);
                Xo(c, u);
                const d = n.subTree,
                    f = d && eE(d);
                let h = !1;
                const {
                    getTransitionKey: p
                } = c.type;
                if (p) {
                    const b = p();
                    i === void 0 ? i = b : b !== i && (i = b, h = !0)
                }
                if (f && f.type !== It && (!Pr(c, f) || h)) {
                    const b = hl(f, a, r, n);
                    if (Xo(f, b), l === "out-in") return r.isLeaving = !0, b.afterLeave = () => {
                        r.isLeaving = !1, n.update.active !== !1 && n.update()
                    }, Em(o);
                    l === "in-out" && c.type !== It && (b.delayLeave = (y, m, g) => {
                        const v = WA(r, f);
                        v[String(f.key)] = f, y._leaveCb = () => {
                            m(), y._leaveCb = void 0, delete u.delayedLeave
                        }, u.delayedLeave = g
                    })
                }
                return o
            }
        }
    },
    VA = y4;

function WA(t, e) {
    const {
        leavingVNodes: n
    } = t;
    let r = n.get(e.type);
    return r || (r = Object.create(null), n.set(e.type, r)), r
}

function hl(t, e, n, r) {
    const {
        appear: i,
        mode: s,
        persisted: o = !1,
        onBeforeEnter: a,
        onEnter: l,
        onAfterEnter: c,
        onEnterCancelled: u,
        onBeforeLeave: d,
        onLeave: f,
        onAfterLeave: h,
        onLeaveCancelled: p,
        onBeforeAppear: b,
        onAppear: y,
        onAfterAppear: m,
        onAppearCancelled: g
    } = e, v = String(t.key), _ = WA(n, t), x = (C, A) => {
        C && qn(C, r, 9, A)
    }, w = (C, A) => {
        const T = A[1];
        x(C, A), De(C) ? C.every(S => S.length <= 1) && T() : C.length <= 1 && T()
    }, E = {
        mode: s,
        persisted: o,
        beforeEnter(C) {
            let A = a;
            if (!n.isMounted)
                if (i) A = b || a;
                else return;
            C._leaveCb && C._leaveCb(!0);
            const T = _[v];
            T && Pr(t, T) && T.el._leaveCb && T.el._leaveCb(), x(A, [C])
        },
        enter(C) {
            let A = l,
                T = c,
                S = u;
            if (!n.isMounted)
                if (i) A = y || l, T = m || c, S = g || u;
                else return;
            let P = !1;
            const R = C._enterCb = D => {
                P || (P = !0, D ? x(S, [C]) : x(T, [C]), E.delayedLeave && E.delayedLeave(), C._enterCb = void 0)
            };
            A ? w(A, [C, R]) : R()
        },
        leave(C, A) {
            const T = String(t.key);
            if (C._enterCb && C._enterCb(!0), n.isUnmounting) return A();
            x(d, [C]);
            let S = !1;
            const P = C._leaveCb = R => {
                S || (S = !0, A(), R ? x(p, [C]) : x(h, [C]), C._leaveCb = void 0, _[T] === t && delete _[T])
            };
            _[T] = t, f ? w(f, [C, P]) : P()
        },
        clone(C) {
            return hl(C, e, n, r)
        }
    };
    return E
}

function Em(t) {
    if (Gl(t)) return t = _r(t), t.children = null, t
}

function eE(t) {
    return Gl(t) ? t.children ? t.children[0] : void 0 : t
}

function Xo(t, e) {
    t.shapeFlag & 6 && t.component ? Xo(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e
}

function lp(t, e = !1, n) {
    let r = [],
        i = 0;
    for (let s = 0; s < t.length; s++) {
        let o = t[s];
        const a = n == null ? o.key : String(n) + String(o.key != null ? o.key : s);
        o.type === mt ? (o.patchFlag & 128 && i++, r = r.concat(lp(o.children, e, a))) : (e || o.type !== It) && r.push(a != null ? _r(o, {
            key: a
        }) : o)
    }
    if (i > 1)
        for (let s = 0; s < r.length; s++) r[s].patchFlag = -2;
    return r
}

function ve(t, e) {
    return Be(t) ? (() => St({
        name: t.name
    }, e, {
        setup: t
    }))() : t
}
const No = t => !!t.type.__asyncLoader;

function v4(t) {
    Be(t) && (t = {
        loader: t
    });
    const {
        loader: e,
        loadingComponent: n,
        errorComponent: r,
        delay: i = 200,
        timeout: s,
        suspensible: o = !0,
        onError: a
    } = t;
    let l = null,
        c, u = 0;
    const d = () => (u++, l = null, f()),
        f = () => {
            let h;
            return l || (h = l = e().catch(p => {
                if (p = p instanceof Error ? p : new Error(String(p)), a) return new Promise((b, y) => {
                    a(p, () => b(d()), () => y(p), u + 1)
                });
                throw p
            }).then(p => {
                if (h !== l && l) return l;
                if (p || re("Async component loader resolved to undefined. If you are using retry(), make sure to return its return value."), p && (p.__esModule || p[Symbol.toStringTag] === "Module") && (p = p.default), p && !ct(p) && !Be(p)) throw new Error(`Invalid async component load result: ${p}`);
                return c = p, p
            }))
        };
    return ve({
        name: "AsyncComponentWrapper",
        __asyncLoader: f,
        get __asyncResolved() {
            return c
        },
        setup() {
            const h = Dt;
            if (c) return () => Sm(c, h);
            const p = g => {
                l = null, ma(g, h, 13, !r)
            };
            if (o && h.suspense || pl) return f().then(g => () => Sm(g, h)).catch(g => (p(g), () => r ? I(r, {
                error: g
            }) : null));
            const b = q(!1),
                y = q(),
                m = q(!!i);
            return i && setTimeout(() => {
                m.value = !1
            }, i), s != null && setTimeout(() => {
                if (!b.value && !y.value) {
                    const g = new Error(`Async component timed out after ${s}ms.`);
                    p(g), y.value = g
                }
            }, s), f().then(() => {
                b.value = !0, h.parent && Gl(h.parent.vnode) && Zu(h.parent.update)
            }).catch(g => {
                p(g), y.value = g
            }), () => {
                if (b.value && c) return Sm(c, h);
                if (y.value && r) return I(r, {
                    error: y.value
                });
                if (n && !m.value) return I(n)
            }
        }
    })
}

function Sm(t, e) {
    const {
        ref: n,
        props: r,
        children: i,
        ce: s
    } = e.vnode, o = I(t, r, i);
    return o.ref = n, o.ce = s, delete e.vnode.ce, o
}
const Gl = t => t.type.__isKeepAlive,
    _4 = {
        name: "KeepAlive",
        __isKeepAlive: !0,
        props: {
            include: [String, RegExp, Array],
            exclude: [String, RegExp, Array],
            max: [String, Number]
        },
        setup(t, {
            slots: e
        }) {
            const n = rt(),
                r = n.ctx;
            if (!r.renderer) return () => {
                const g = e.default && e.default();
                return g && g.length === 1 ? g[0] : g
            };
            const i = new Map,
                s = new Set;
            let o = null;
            n.__v_cache = i;
            const a = n.suspense,
                {
                    renderer: {
                        p: l,
                        m: c,
                        um: u,
                        o: {
                            createElement: d
                        }
                    }
                } = r,
                f = d("div");
            r.activate = (g, v, _, x, w) => {
                const E = g.component;
                c(g, v, _, 0, a), l(E.vnode, g, v, _, E, a, x, g.slotScopeIds, w), en(() => {
                    E.isDeactivated = !1, E.a && Eo(E.a);
                    const C = g.props && g.props.onVnodeMounted;
                    C && In(C, E.parent, g)
                }, a), qy(E)
            }, r.deactivate = g => {
                const v = g.component;
                c(g, f, null, 1, a), en(() => {
                    v.da && Eo(v.da);
                    const _ = g.props && g.props.onVnodeUnmounted;
                    _ && In(_, v.parent, g), v.isDeactivated = !0
                }, a), qy(v)
            };

            function h(g) {
                Tm(g), u(g, n, a, !0)
            }

            function p(g) {
                i.forEach((v, _) => {
                    const x = pu(v.type);
                    x && (!g || !g(x)) && b(_)
                })
            }

            function b(g) {
                const v = i.get(g);
                !o || !Pr(v, o) ? h(v) : o && Tm(o), i.delete(g), s.delete(g)
            }
            he(() => [t.include, t.exclude], ([g, v]) => {
                g && p(_ => Tc(g, _)), v && p(_ => !Tc(v, _))
            }, {
                flush: "post",
                deep: !0
            });
            let y = null;
            const m = () => {
                y != null && i.set(y, Cm(n.subTree))
            };
            return _t(m), ga(m), nr(() => {
                i.forEach(g => {
                    const {
                        subTree: v,
                        suspense: _
                    } = n, x = Cm(v);
                    if (g.type === x.type && g.key === x.key) {
                        Tm(x);
                        const w = x.component.da;
                        w && en(w, _);
                        return
                    }
                    h(g)
                })
            }), () => {
                if (y = null, !e.default) return null;
                const g = e.default(),
                    v = g[0];
                if (g.length > 1) return re("KeepAlive should contain exactly one component child."), o = null, g;
                if (!ci(v) || !(v.shapeFlag & 4) && !(v.shapeFlag & 128)) return o = null, v;
                let _ = Cm(v);
                const x = _.type,
                    w = pu(No(_) ? _.type.__asyncResolved || {} : x),
                    {
                        include: E,
                        exclude: C,
                        max: A
                    } = t;
                if (E && (!w || !Tc(E, w)) || C && w && Tc(C, w)) return o = _, v;
                const T = _.key == null ? x : _.key,
                    S = i.get(T);
                return _.el && (_ = _r(_), v.shapeFlag & 128 && (v.ssContent = _)), y = T, S ? (_.el = S.el, _.component = S.component, _.transition && Xo(_, _.transition), _.shapeFlag |= 512, s.delete(T), s.add(T)) : (s.add(T), A && s.size > parseInt(A, 10) && b(s.values().next().value)), _.shapeFlag |= 256, o = _, UA(v.type) ? v : _
            }
        }
    },
    b4 = _4;

function Tc(t, e) {
    return De(t) ? t.some(n => Tc(n, e)) : Rt(t) ? t.split(",").includes(e) : _N(t) ? t.test(e) : !1
}

function ns(t, e) {
    YA(t, "a", e)
}

function hi(t, e) {
    YA(t, "da", e)
}

function YA(t, e, n = Dt) {
    const r = t.__wdc || (t.__wdc = () => {
        let i = n;
        for (; i;) {
            if (i.isDeactivated) return;
            i = i.parent
        }
        return t()
    });
    if (cp(e, r, n), n) {
        let i = n.parent;
        for (; i && i.parent;) Gl(i.parent.vnode) && x4(r, e, n, i), i = i.parent
    }
}

function x4(t, e, n, r) {
    const i = cp(e, t, r, !0);
    is(() => {
        x_(r[e], i)
    }, n)
}

function Tm(t) {
    t.shapeFlag &= -257, t.shapeFlag &= -513
}

function Cm(t) {
    return t.shapeFlag & 128 ? t.ssContent : t
}

function cp(t, e, n = Dt, r = !1) {
    if (n) {
        const i = n[t] || (n[t] = []),
            s = e.__weh || (e.__weh = (...o) => {
                if (n.isUnmounted) return;
                fa(), Hs(n);
                const a = qn(e, n, t, o);
                return Ds(), ha(), a
            });
        return r ? i.unshift(s) : i.push(s), s
    } else {
        const i = Ii(E_[t].replace(/ hook$/, ""));
        re(`${i} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`)
    }
}
const rs = t => (e, n = Dt) => (!pl || t === "sp") && cp(t, (...r) => e(...r), n),
    XA = rs("bm"),
    _t = rs("m"),
    up = rs("bu"),
    ga = rs("u"),
    nr = rs("bum"),
    is = rs("um"),
    qA = rs("sp"),
    KA = rs("rtg"),
    JA = rs("rtc");

function ZA(t, e = Dt) {
    cp("ec", t, e)
}
const lh = "components",
    w4 = "directives";

function E4(t, e) {
    return B_(lh, t, !0, e) || t
}
const QA = Symbol.for("v-ndc");

function S4(t) {
    return Rt(t) ? B_(lh, t, !1) || t : t || QA
}

function eO(t) {
    return B_(w4, t)
}

function B_(t, e, n = !0, r = !1) {
    const i = $t || Dt;
    if (i) {
        const s = i.type;
        if (t === lh) {
            const a = pu(s, !1);
            if (a && (a === e || a === Dr(e) || a === fl(Dr(e)))) return s
        }
        const o = tE(i[t] || s[t], e) || tE(i.appContext[t], e);
        if (!o && r) return s;
        if (n && !o) {
            const a = t === lh ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
            re(`Failed to resolve ${t.slice(0,-1)}: ${e}${a}`)
        }
        return o
    } else re(`resolve${fl(t.slice(0,-1))} can only be used in render() or setup().`)
}

function tE(t, e) {
    return t && (t[e] || t[Dr(e)] || t[fl(Dr(e))])
}

function T4(t, e, n, r) {
    let i;
    const s = n && n[r];
    if (De(t) || Rt(t)) {
        i = new Array(t.length);
        for (let o = 0, a = t.length; o < a; o++) i[o] = e(t[o], o, void 0, s && s[o])
    } else if (typeof t == "number") {
        Number.isInteger(t) || re(`The v-for range expect an integer value but got ${t}.`), i = new Array(t);
        for (let o = 0; o < t; o++) i[o] = e(o + 1, o, void 0, s && s[o])
    } else if (ct(t))
        if (t[Symbol.iterator]) i = Array.from(t, (o, a) => e(o, a, void 0, s && s[a]));
        else {
            const o = Object.keys(t);
            i = new Array(o.length);
            for (let a = 0, l = o.length; a < l; a++) {
                const c = o[a];
                i[a] = e(t[c], c, a, s && s[a])
            }
        }
    else i = [];
    return n && (n[r] = i), i
}

function C4(t, e) {
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        if (De(r))
            for (let i = 0; i < r.length; i++) t[r[i].name] = r[i].fn;
        else r && (t[r.name] = r.key ? (...i) => {
            const s = r.fn(...i);
            return s && (s.key = r.key), s
        } : r.fn)
    }
    return t
}

function P4(t, e, n = {}, r, i) {
    if ($t.isCE || $t.parent && No($t.parent) && $t.parent.isCE) return e !== "default" && (n.name = e), I("slot", n, r && r());
    let s = t[e];
    s && s.length > 1 && (re("SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."), s = () => []), s && s._c && (s._d = !1), fp();
    const o = s && tO(s(n)),
        a = L_(mt, {
            key: n.key || o && o.key || `_${e}`
        }, o || (r ? r() : []), o && t._ === 1 ? 64 : -2);
    return !i && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), s && s._c && (s._d = !0), a
}

function tO(t) {
    return t.some(e => ci(e) ? !(e.type === It || e.type === mt && !tO(e.children)) : !0) ? t : null
}

function A4(t, e) {
    const n = {};
    if (!ct(t)) return re("v-on with no argument expects an object value."), n;
    for (const r in t) n[e && /[A-Z]/.test(r) ? `on:${r}` : Ii(r)] = t[r];
    return n
}
const Jy = t => t ? wO(t) ? mp(t) || t.proxy : Jy(t.parent) : null,
    Uo = St(Object.create(null), {
        $: t => t,
        $el: t => t.vnode.el,
        $data: t => t.data,
        $props: t => Ka(t.props),
        $attrs: t => Ka(t.attrs),
        $slots: t => Ka(t.slots),
        $refs: t => Ka(t.refs),
        $parent: t => Jy(t.parent),
        $root: t => Jy(t.root),
        $emit: t => t.emit,
        $options: t => $_(t),
        $forceUpdate: t => t.f || (t.f = () => Zu(t.update)),
        $nextTick: t => t.n || (t.n = Ue.bind(t.proxy)),
        $watch: t => g4.bind(t)
    }),
    D_ = t => t === "_" || t === "$",
    Pm = (t, e) => t !== ot && !t.__isScriptSetup && Je(t, e),
    Fc = {
        get({
            _: t
        }, e) {
            const {
                ctx: n,
                setupState: r,
                data: i,
                props: s,
                accessCache: o,
                type: a,
                appContext: l
            } = t;
            if (e === "__isVue") return !0;
            let c;
            if (e[0] !== "$") {
                const h = o[e];
                if (h !== void 0) switch (h) {
                    case 1:
                        return r[e];
                    case 2:
                        return i[e];
                    case 4:
                        return n[e];
                    case 3:
                        return s[e]
                } else {
                    if (Pm(r, e)) return o[e] = 1, r[e];
                    if (i !== ot && Je(i, e)) return o[e] = 2, i[e];
                    if ((c = t.propsOptions[0]) && Je(c, e)) return o[e] = 3, s[e];
                    if (n !== ot && Je(n, e)) return o[e] = 4, n[e];
                    Zy && (o[e] = 0)
                }
            }
            const u = Uo[e];
            let d, f;
            if (u) return e === "$attrs" ? (pn(t, "get", e), ah()) : e === "$slots" && pn(t, "get", e), u(t);
            if ((d = a.__cssModules) && (d = d[e])) return d;
            if (n !== ot && Je(n, e)) return o[e] = 4, n[e];
            if (f = l.config.globalProperties, Je(f, e)) return f[e];
            $t && (!Rt(e) || e.indexOf("__v") !== 0) && (i !== ot && D_(e[0]) && Je(i, e) ? re(`Property ${JSON.stringify(e)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`) : t === $t && re(`Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`))
        },
        set({
            _: t
        }, e, n) {
            const {
                data: r,
                setupState: i,
                ctx: s
            } = t;
            return Pm(i, e) ? (i[e] = n, !0) : i.__isScriptSetup && Je(i, e) ? (re(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : r !== ot && Je(r, e) ? (r[e] = n, !0) : Je(t.props, e) ? (re(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in t ? (re(`Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`), !1) : (e in t.appContext.config.globalProperties ? Object.defineProperty(s, e, {
                enumerable: !0,
                configurable: !0,
                value: n
            }) : s[e] = n, !0)
        },
        has({
            _: {
                data: t,
                setupState: e,
                accessCache: n,
                ctx: r,
                appContext: i,
                propsOptions: s
            }
        }, o) {
            let a;
            return !!n[o] || t !== ot && Je(t, o) || Pm(e, o) || (a = s[0]) && Je(a, o) || Je(r, o) || Je(Uo, o) || Je(i.config.globalProperties, o)
        },
        defineProperty(t, e, n) {
            return n.get != null ? t._.accessCache[e] = 0 : Je(n, "value") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n)
        }
    };
Fc.ownKeys = t => (re("Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."), Reflect.ownKeys(t));
const O4 = St({}, Fc, {
    get(t, e) {
        if (e !== Symbol.unscopables) return Fc.get(t, e, t)
    },
    has(t, e) {
        const n = e[0] !== "_" && !PN(e);
        return !n && Fc.has(t, e) && re(`Property ${JSON.stringify(e)} should not start with _ which is a reserved prefix for Vue internals.`), n
    }
});

function I4(t) {
    const e = {};
    return Object.defineProperty(e, "_", {
        configurable: !0,
        enumerable: !1,
        get: () => t
    }), Object.keys(Uo).forEach(n => {
        Object.defineProperty(e, n, {
            configurable: !0,
            enumerable: !1,
            get: () => Uo[n](t),
            set: Dn
        })
    }), e
}

function M4(t) {
    const {
        ctx: e,
        propsOptions: [n]
    } = t;
    n && Object.keys(n).forEach(r => {
        Object.defineProperty(e, r, {
            enumerable: !0,
            configurable: !0,
            get: () => t.props[r],
            set: Dn
        })
    })
}

function R4(t) {
    const {
        ctx: e,
        setupState: n
    } = t;
    Object.keys(Me(n)).forEach(r => {
        if (!n.__isScriptSetup) {
            if (D_(r[0])) {
                re(`setup() return property ${JSON.stringify(r)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
                return
            }
            Object.defineProperty(e, r, {
                enumerable: !0,
                configurable: !0,
                get: () => n[r],
                set: Dn
            })
        }
    })
}
const ya = t => re(`${t}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`);

function k4() {
    return ya("defineProps"), null
}

function B4() {
    return ya("defineEmits"), null
}

function D4(t) {
    ya("defineExpose")
}

function $4(t) {
    ya("defineOptions")
}

function F4() {
    return ya("defineSlots"), null
}

function L4() {
    ya("defineModel")
}

function N4(t, e) {
    return ya("withDefaults"), null
}

function U4() {
    return nO().slots
}

function G4() {
    return nO().attrs
}

function H4(t, e, n) {
    const r = rt();
    if (!r) return re("useModel() called without active instance."), q();
    if (!r.propsOptions[0][e]) return re(`useModel() called with prop "${e}" which is not declared.`), q();
    if (n && n.local) {
        const i = q(t[e]);
        return he(() => t[e], s => i.value = s), he(i, s => {
            s !== t[e] && r.emit(`update:${e}`, s)
        }), i
    } else return {
        __v_isRef: !0,
        get value() {
            return t[e]
        },
        set value(i) {
            r.emit(`update:${e}`, i)
        }
    }
}

function nO() {
    const t = rt();
    return t || re("useContext() called without active instance."), t.setupContext || (t.setupContext = TO(t))
}

function fu(t) {
    return De(t) ? t.reduce((e, n) => (e[n] = null, e), {}) : t
}

function z4(t, e) {
    const n = fu(t);
    for (const r in e) {
        if (r.startsWith("__skip")) continue;
        let i = n[r];
        i ? De(i) || Be(i) ? i = n[r] = {
            type: i,
            default: e[r]
        } : i.default = e[r] : i === null ? i = n[r] = {
            default: e[r]
        } : re(`props default key "${r}" has no corresponding declaration.`), i && e[`__skip_${r}`] && (i.skipFactory = !0)
    }
    return n
}

function j4(t, e) {
    return !t || !e ? t || e : De(t) && De(e) ? t.concat(e) : St({}, fu(t), fu(e))
}

function V4(t, e) {
    const n = {};
    for (const r in t) e.includes(r) || Object.defineProperty(n, r, {
        enumerable: !0,
        get: () => t[r]
    });
    return n
}

function W4(t) {
    const e = rt();
    e || re("withAsyncContext called without active current instance. This is likely a bug.");
    let n = t();
    return Ds(), rp(n) && (n = n.catch(r => {
        throw Hs(e), r
    })), [n, () => Hs(e)]
}

function Y4() {
    const t = Object.create(null);
    return (e, n) => {
        t[n] ? re(`${e} property "${n}" is already defined in ${t[n]}.`) : t[n] = e
    }
}
let Zy = !0;

function X4(t) {
    const e = $_(t),
        n = t.proxy,
        r = t.ctx;
    Zy = !1, e.beforeCreate && nE(e.beforeCreate, t, "bc");
    const {
        data: i,
        computed: s,
        methods: o,
        watch: a,
        provide: l,
        inject: c,
        created: u,
        beforeMount: d,
        mounted: f,
        beforeUpdate: h,
        updated: p,
        activated: b,
        deactivated: y,
        beforeDestroy: m,
        beforeUnmount: g,
        destroyed: v,
        unmounted: _,
        render: x,
        renderTracked: w,
        renderTriggered: E,
        errorCaptured: C,
        serverPrefetch: A,
        expose: T,
        inheritAttrs: S,
        components: P,
        directives: R,
        filters: D
    } = e, H = Y4(); {
        const [N] = t.propsOptions;
        if (N)
            for (const V in N) H("Props", V)
    }
    if (c && q4(c, r, H), o)
        for (const N in o) {
            const V = o[N];
            Be(V) ? (Object.defineProperty(r, N, {
                value: V.bind(n),
                configurable: !0,
                enumerable: !0,
                writable: !0
            }), H("Methods", N)) : re(`Method "${N}" has type "${typeof V}" in the component definition. Did you reference the function correctly?`)
        }
    if (i) {
        Be(i) || re("The data option must be a function. Plain object usage is no longer supported.");
        const N = i.call(n, n);
        if (rp(N) && re("data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."), !ct(N)) re("data() should return an object.");
        else {
            t.data = ft(N);
            for (const V in N) H("Data", V), D_(V[0]) || Object.defineProperty(r, V, {
                configurable: !0,
                enumerable: !0,
                get: () => N[V],
                set: Dn
            })
        }
    }
    if (Zy = !0, s)
        for (const N in s) {
            const V = s[N],
                Y = Be(V) ? V.bind(n, n) : Be(V.get) ? V.get.bind(n, n) : Dn;
            Y === Dn && re(`Computed property "${N}" has no getter.`);
            const le = !Be(V) && Be(V.set) ? V.set.bind(n) : () => {
                    re(`Write operation failed: computed property "${N}" is readonly.`)
                },
                ae = te({
                    get: Y,
                    set: le
                });
            Object.defineProperty(r, N, {
                enumerable: !0,
                configurable: !0,
                get: () => ae.value,
                set: W => ae.value = W
            }), H("Computed", N)
        }
    if (a)
        for (const N in a) rO(a[N], r, n, N);
    if (l) {
        const N = Be(l) ? l.call(n) : l;
        Reflect.ownKeys(N).forEach(V => {
            gr(V, N[V])
        })
    }
    u && nE(u, t, "c");

    function B(N, V) {
        De(V) ? V.forEach(Y => N(Y.bind(n))) : V && N(V.bind(n))
    }
    if (B(XA, d), B(_t, f), B(up, h), B(ga, p), B(ns, b), B(hi, y), B(ZA, C), B(JA, w), B(KA, E), B(nr, g), B(is, _), B(qA, A), De(T))
        if (T.length) {
            const N = t.exposed || (t.exposed = {});
            T.forEach(V => {
                Object.defineProperty(N, V, {
                    get: () => n[V],
                    set: Y => n[V] = Y
                })
            })
        } else t.exposed || (t.exposed = {});
    x && t.render === Dn && (t.render = x), S != null && (t.inheritAttrs = S), P && (t.components = P), R && (t.directives = R)
}

function q4(t, e, n = Dn) {
    De(t) && (t = Qy(t));
    for (const r in t) {
        const i = t[r];
        let s;
        ct(i) ? "default" in i ? s = Nt(i.from || r, i.default, !0) : s = Nt(i.from || r) : s = Nt(i), et(s) ? Object.defineProperty(e, r, {
            enumerable: !0,
            configurable: !0,
            get: () => s.value,
            set: o => s.value = o
        }) : e[r] = s, n("Inject", r)
    }
}

function nE(t, e, n) {
    qn(De(t) ? t.map(r => r.bind(e.proxy)) : t.bind(e.proxy), e, n)
}

function rO(t, e, n, r) {
    const i = r.includes(".") ? zA(n, r) : () => n[r];
    if (Rt(t)) {
        const s = e[t];
        Be(s) ? he(i, s) : re(`Invalid watch handler specified by key "${t}"`, s)
    } else if (Be(t)) he(i, t.bind(n));
    else if (ct(t))
        if (De(t)) t.forEach(s => rO(s, e, n, r));
        else {
            const s = Be(t.handler) ? t.handler.bind(n) : e[t.handler];
            Be(s) ? he(i, s, t) : re(`Invalid watch handler specified by key "${t.handler}"`, s)
        }
    else re(`Invalid watch option: "${r}"`, t)
}

function $_(t) {
    const e = t.type,
        {
            mixins: n,
            extends: r
        } = e,
        {
            mixins: i,
            optionsCache: s,
            config: {
                optionMergeStrategies: o
            }
        } = t.appContext,
        a = s.get(e);
    let l;
    return a ? l = a : !i.length && !n && !r ? l = e : (l = {}, i.length && i.forEach(c => ch(l, c, o, !0)), ch(l, e, o)), ct(e) && s.set(e, l), l
}

function ch(t, e, n, r = !1) {
    const {
        mixins: i,
        extends: s
    } = e;
    s && ch(t, s, n, !0), i && i.forEach(o => ch(t, o, n, !0));
    for (const o in e)
        if (r && o === "expose") re('"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.');
        else {
            const a = K4[o] || n && n[o];
            t[o] = a ? a(t[o], e[o]) : e[o]
        }
    return t
}
const K4 = {
    data: rE,
    props: iE,
    emits: iE,
    methods: Cc,
    computed: Cc,
    beforeCreate: gn,
    created: gn,
    beforeMount: gn,
    mounted: gn,
    beforeUpdate: gn,
    updated: gn,
    beforeDestroy: gn,
    beforeUnmount: gn,
    destroyed: gn,
    unmounted: gn,
    activated: gn,
    deactivated: gn,
    errorCaptured: gn,
    serverPrefetch: gn,
    components: Cc,
    directives: Cc,
    watch: Z4,
    provide: rE,
    inject: J4
};

function rE(t, e) {
    return e ? t ? function() {
        return St(Be(t) ? t.call(this, this) : t, Be(e) ? e.call(this, this) : e)
    } : e : t
}

function J4(t, e) {
    return Cc(Qy(t), Qy(e))
}

function Qy(t) {
    if (De(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++) e[t[n]] = t[n];
        return e
    }
    return t
}

function gn(t, e) {
    return t ? [...new Set([].concat(t, e))] : e
}

function Cc(t, e) {
    return t ? St(Object.create(null), t, e) : e
}

function iE(t, e) {
    return t ? De(t) && De(e) ? [...new Set([...t, ...e])] : St(Object.create(null), fu(t), fu(e ? ? {})) : e
}

function Z4(t, e) {
    if (!t) return e;
    if (!e) return t;
    const n = St(Object.create(null), t);
    for (const r in e) n[r] = gn(t[r], e[r]);
    return n
}

function iO() {
    return {
        app: null,
        config: {
            isNativeTag: CA,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let Q4 = 0;

function eU(t, e) {
    return function(r, i = null) {
        Be(r) || (r = St({}, r)), i != null && !ct(i) && (re("root props passed to app.mount() must be an object."), i = null);
        const s = iO();
        Object.defineProperty(s.config, "unwrapInjectedRef", {
            get() {
                return !0
            },
            set() {
                re("app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API.")
            }
        });
        const o = new Set;
        let a = !1;
        const l = s.app = {
            _uid: Q4++,
            _component: r,
            _props: i,
            _container: null,
            _context: s,
            _instance: null,
            version: lv,
            get config() {
                return s.config
            },
            set config(c) {
                re("app.config cannot be replaced. Modify individual options instead.")
            },
            use(c, ...u) {
                return o.has(c) ? re("Plugin has already been applied to target app.") : c && Be(c.install) ? (o.add(c), c.install(l, ...u)) : Be(c) ? (o.add(c), c(l, ...u)) : re('A plugin must either be a function or an object with an "install" function.'), l
            },
            mixin(c) {
                return s.mixins.includes(c) ? re("Mixin has already been applied to target app" + (c.name ? `: ${c.name}` : "")) : s.mixins.push(c), l
            },
            component(c, u) {
                return sv(c, s.config), u ? (s.components[c] && re(`Component "${c}" has already been registered in target app.`), s.components[c] = u, l) : s.components[c]
            },
            directive(c, u) {
                return jA(c), u ? (s.directives[c] && re(`Directive "${c}" has already been registered in target app.`), s.directives[c] = u, l) : s.directives[c]
            },
            mount(c, u, d) {
                if (a) re("App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`");
                else {
                    c.__vue_app__ && re("There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.");
                    const f = I(r, i);
                    return f.appContext = s, s.reload = () => {
                        t(_r(f), c, d)
                    }, u && e ? e(f, c) : t(f, c, d), a = !0, l._container = c, c.__vue_app__ = l, l._instance = f.component, YN(l, lv), mp(f.component) || f.component.proxy
                }
            },
            unmount() {
                a ? (t(null, l._container), l._instance = null, XN(l), delete l._container.__vue_app__) : re("Cannot unmount an app that is not mounted.")
            },
            provide(c, u) {
                return c in s.provides && re(`App already provides property with key "${String(c)}". It will be overwritten with the new value.`), s.provides[c] = u, l
            },
            runWithContext(c) {
                hu = l;
                try {
                    return c()
                } finally {
                    hu = null
                }
            }
        };
        return l
    }
}
let hu = null;

function gr(t, e) {
    if (!Dt) re("provide() can only be used inside setup().");
    else {
        let n = Dt.provides;
        const r = Dt.parent && Dt.parent.provides;
        r === n && (n = Dt.provides = Object.create(r)), n[t] = e
    }
}

function Nt(t, e, n = !1) {
    const r = Dt || $t;
    if (r || hu) {
        const i = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : hu._context.provides;
        if (i && t in i) return i[t];
        if (arguments.length > 1) return n && Be(e) ? e.call(r && r.proxy) : e;
        re(`injection "${String(t)}" not found.`)
    } else re("inject() can only be used inside setup() or functional components.")
}

function sO() {
    return !!(Dt || $t || hu)
}

function tU(t, e, n, r = !1) {
    const i = {},
        s = {};
    Wy(s, hp, 1), t.propsDefaults = Object.create(null), oO(t, e, i, s);
    for (const o in t.propsOptions[0]) o in i || (i[o] = void 0);
    lO(e || {}, i, t), n ? t.props = r ? i : wA(i) : t.type.props ? t.props = i : t.props = s, t.attrs = s
}

function nU(t) {
    for (; t;) {
        if (t.type.__hmrId) return !0;
        t = t.parent
    }
}

function rU(t, e, n, r) {
    const {
        props: i,
        attrs: s,
        vnode: {
            patchFlag: o
        }
    } = t, a = Me(i), [l] = t.propsOptions;
    let c = !1;
    if (!nU(t) && (r || o > 0) && !(o & 16)) {
        if (o & 8) {
            const u = t.vnode.dynamicProps;
            for (let d = 0; d < u.length; d++) {
                let f = u[d];
                if (op(t.emitsOptions, f)) continue;
                const h = e[f];
                if (l)
                    if (Je(s, f)) h !== s[f] && (s[f] = h, c = !0);
                    else {
                        const p = Dr(f);
                        i[p] = ev(l, a, p, h, t, !1)
                    }
                else h !== s[f] && (s[f] = h, c = !0)
            }
        }
    } else {
        oO(t, e, i, s) && (c = !0);
        let u;
        for (const d in a)(!e || !Je(e, d) && ((u = dl(d)) === d || !Je(e, u))) && (l ? n && (n[d] !== void 0 || n[u] !== void 0) && (i[d] = ev(l, a, d, void 0, t, !0)) : delete i[d]);
        if (s !== a)
            for (const d in s)(!e || !Je(e, d)) && (delete s[d], c = !0)
    }
    c && ai(t, "set", "$attrs"), lO(e || {}, i, t)
}

function oO(t, e, n, r) {
    const [i, s] = t.propsOptions;
    let o = !1,
        a;
    if (e)
        for (let l in e) {
            if (kc(l)) continue;
            const c = e[l];
            let u;
            i && Je(i, u = Dr(l)) ? !s || !s.includes(u) ? n[u] = c : (a || (a = {}))[u] = c : op(t.emitsOptions, l) || (!(l in r) || c !== r[l]) && (r[l] = c, o = !0)
        }
    if (s) {
        const l = Me(n),
            c = a || ot;
        for (let u = 0; u < s.length; u++) {
            const d = s[u];
            n[d] = ev(i, l, d, c[d], t, !Je(c, d))
        }
    }
    return o
}

function ev(t, e, n, r, i, s) {
    const o = t[n];
    if (o != null) {
        const a = Je(o, "default");
        if (a && r === void 0) {
            const l = o.default;
            if (o.type !== Function && !o.skipFactory && Be(l)) {
                const {
                    propsDefaults: c
                } = i;
                n in c ? r = c[n] : (Hs(i), r = c[n] = l.call(null, e), Ds())
            } else r = l
        }
        o[0] && (s && !a ? r = !1 : o[1] && (r === "" || r === dl(n)) && (r = !0))
    }
    return r
}

function aO(t, e, n = !1) {
    const r = e.propsCache,
        i = r.get(t);
    if (i) return i;
    const s = t.props,
        o = {},
        a = [];
    let l = !1;
    if (!Be(t)) {
        const u = d => {
            l = !0;
            const [f, h] = aO(d, e, !0);
            St(o, f), h && a.push(...h)
        };
        !n && e.mixins.length && e.mixins.forEach(u), t.extends && u(t.extends), t.mixins && t.mixins.forEach(u)
    }
    if (!s && !l) return ct(t) && r.set(t, tl), tl;
    if (De(s))
        for (let u = 0; u < s.length; u++) {
            Rt(s[u]) || re("props must be strings when using array syntax.", s[u]);
            const d = Dr(s[u]);
            sE(d) && (o[d] = ot)
        } else if (s) {
            ct(s) || re("invalid props options", s);
            for (const u in s) {
                const d = Dr(u);
                if (sE(d)) {
                    const f = s[u],
                        h = o[d] = De(f) || Be(f) ? {
                            type: f
                        } : St({}, f);
                    if (h) {
                        const p = aE(Boolean, h.type),
                            b = aE(String, h.type);
                        h[0] = p > -1, h[1] = b < 0 || p < b, (p > -1 || Je(h, "default")) && a.push(d)
                    }
                }
            }
        }
    const c = [o, a];
    return ct(t) && r.set(t, c), c
}

function sE(t) {
    return t[0] !== "$" ? !0 : (re(`Invalid prop name: "${t}" is a reserved property.`), !1)
}

function tv(t) {
    const e = t && t.toString().match(/^\s*(function|class) (\w+)/);
    return e ? e[2] : t === null ? "null" : ""
}

function oE(t, e) {
    return tv(t) === tv(e)
}

function aE(t, e) {
    return De(e) ? e.findIndex(n => oE(n, t)) : Be(e) && oE(e, t) ? 0 : -1
}

function lO(t, e, n) {
    const r = Me(e),
        i = n.propsOptions[0];
    for (const s in i) {
        let o = i[s];
        o != null && iU(s, r[s], o, !Je(t, s) && !Je(t, dl(s)))
    }
}

function iU(t, e, n, r) {
    const {
        type: i,
        required: s,
        validator: o,
        skipCheck: a
    } = n;
    if (s && r) {
        re('Missing required prop: "' + t + '"');
        return
    }
    if (!(e == null && !s)) {
        if (i != null && i !== !0 && !a) {
            let l = !1;
            const c = De(i) ? i : [i],
                u = [];
            for (let d = 0; d < c.length && !l; d++) {
                const {
                    valid: f,
                    expectedType: h
                } = oU(e, c[d]);
                u.push(h || ""), l = f
            }
            if (!l) {
                re(aU(t, e, u));
                return
            }
        }
        o && !o(e) && re('Invalid prop: custom validator check failed for prop "' + t + '".')
    }
}
const sU = Yu("String,Number,Boolean,Function,Symbol,BigInt");

function oU(t, e) {
    let n;
    const r = tv(e);
    if (sU(r)) {
        const i = typeof t;
        n = i === r.toLowerCase(), !n && i === "object" && (n = t instanceof e)
    } else r === "Object" ? n = ct(t) : r === "Array" ? n = De(t) : r === "null" ? n = t === null : n = t instanceof e;
    return {
        valid: n,
        expectedType: r
    }
}

function aU(t, e, n) {
    let r = `Invalid prop: type check failed for prop "${t}". Expected ${n.map(fl).join(" | ")}`;
    const i = n[0],
        s = bN(e),
        o = lE(e, i),
        a = lE(e, s);
    return n.length === 1 && cE(i) && !lU(i, s) && (r += ` with value ${o}`), r += `, got ${s} `, cE(s) && (r += `with value ${a}.`), r
}

function lE(t, e) {
    return e === "String" ? `"${t}"` : e === "Number" ? `${Number(t)}` : `${t}`
}

function cE(t) {
    return ["string", "number", "boolean"].some(n => t.toLowerCase() === n)
}

function lU(...t) {
    return t.some(e => e.toLowerCase() === "boolean")
}
const cO = t => t[0] === "_" || t === "$stable",
    F_ = t => De(t) ? t.map(kn) : [kn(t)],
    cU = (t, e, n) => {
        if (e._n) return e;
        const r = A_((...i) => (Dt && re(`Slot "${t}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`), F_(e(...i))), n);
        return r._c = !1, r
    },
    uO = (t, e, n) => {
        const r = t._ctx;
        for (const i in t) {
            if (cO(i)) continue;
            const s = t[i];
            if (Be(s)) e[i] = cU(i, s, r);
            else if (s != null) {
                re(`Non-function value encountered for slot "${i}". Prefer function slots for better performance.`);
                const o = F_(s);
                e[i] = () => o
            }
        }
    },
    dO = (t, e) => {
        Gl(t.vnode) || re("Non-function value encountered for default slot. Prefer function slots for better performance.");
        const n = F_(e);
        t.slots.default = () => n
    },
    uU = (t, e) => {
        if (t.vnode.shapeFlag & 32) {
            const n = e._;
            n ? (t.slots = Me(e), Wy(e, "_", n)) : uO(e, t.slots = {})
        } else t.slots = {}, e && dO(t, e);
        Wy(t.slots, hp, 1)
    },
    dU = (t, e, n) => {
        const {
            vnode: r,
            slots: i
        } = t;
        let s = !0,
            o = ot;
        if (r.shapeFlag & 32) {
            const a = e._;
            a ? ks ? (St(i, e), ai(t, "set", "$slots")) : n && a === 1 ? s = !1 : (St(i, e), !n && a === 1 && delete i._) : (s = !e.$stable, uO(e, i)), o = e
        } else e && (dO(t, e), o = {
            default: 1
        });
        if (s)
            for (const a in i) !cO(a) && !(a in o) && delete i[a]
    };

function uh(t, e, n, r, i = !1) {
    if (De(t)) {
        t.forEach((f, h) => uh(f, e && (De(e) ? e[h] : e), n, r, i));
        return
    }
    if (No(r) && !i) return;
    const s = r.shapeFlag & 4 ? mp(r.component) || r.component.proxy : r.el,
        o = i ? null : s,
        {
            i: a,
            r: l
        } = t;
    if (!a) {
        re("Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.");
        return
    }
    const c = e && e.r,
        u = a.refs === ot ? a.refs = {} : a.refs,
        d = a.setupState;
    if (c != null && c !== l && (Rt(c) ? (u[c] = null, Je(d, c) && (d[c] = null)) : et(c) && (c.value = null)), Be(l)) ii(l, a, 12, [o, u]);
    else {
        const f = Rt(l),
            h = et(l);
        if (f || h) {
            const p = () => {
                if (t.f) {
                    const b = f ? Je(d, l) ? d[l] : u[l] : l.value;
                    i ? De(b) && x_(b, s) : De(b) ? b.includes(s) || b.push(s) : f ? (u[l] = [s], Je(d, l) && (d[l] = u[l])) : (l.value = [s], t.k && (u[t.k] = l.value))
                } else f ? (u[l] = o, Je(d, l) && (d[l] = o)) : h ? (l.value = o, t.k && (u[t.k] = o)) : re("Invalid template ref type:", l, `(${typeof l})`)
            };
            o ? (p.id = -1, en(p, n)) : p()
        } else re("Invalid template ref type:", l, `(${typeof l})`)
    }
}
let cs = !1;
const kd = t => /svg/.test(t.namespaceURI) && t.tagName !== "foreignObject",
    ec = t => t.nodeType === 8;

function fU(t) {
    const {
        mt: e,
        p: n,
        o: {
            patchProp: r,
            createText: i,
            nextSibling: s,
            parentNode: o,
            remove: a,
            insert: l,
            createComment: c
        }
    } = t, u = (m, g) => {
        if (!g.hasChildNodes()) {
            re("Attempting to hydrate existing markup but container is empty. Performing full mount instead."), n(null, m, g), oh(), g._vnode = m;
            return
        }
        cs = !1, d(g.firstChild, m, null, null, null), oh(), g._vnode = m, cs && console.error("Hydration completed but contains mismatches.")
    }, d = (m, g, v, _, x, w = !1) => {
        const E = ec(m) && m.data === "[",
            C = () => b(m, g, v, _, x, E),
            {
                type: A,
                ref: T,
                shapeFlag: S,
                patchFlag: P
            } = g;
        let R = m.nodeType;
        g.el = m, P === -2 && (w = !1, g.dynamicChildren = null);
        let D = null;
        switch (A) {
            case li:
                R !== 3 ? g.children === "" ? (l(g.el = i(""), o(m), m), D = m) : D = C() : (m.data !== g.children && (cs = !0, re(`Hydration text mismatch:
- Client: ${JSON.stringify(m.data)}
- Server: ${JSON.stringify(g.children)}`), m.data = g.children), D = s(m));
                break;
            case It:
                R !== 8 || E ? D = C() : D = s(m);
                break;
            case Bs:
                if (E && (m = s(m), R = m.nodeType), R === 1 || R === 3) {
                    D = m;
                    const H = !g.children.length;
                    for (let B = 0; B < g.staticCount; B++) H && (g.children += D.nodeType === 1 ? D.outerHTML : D.data), B === g.staticCount - 1 && (g.anchor = D), D = s(D);
                    return E ? s(D) : D
                } else C();
                break;
            case mt:
                E ? D = p(m, g, v, _, x, w) : D = C();
                break;
            default:
                if (S & 1) R !== 1 || g.type.toLowerCase() !== m.tagName.toLowerCase() ? D = C() : D = f(m, g, v, _, x, w);
                else if (S & 6) {
                    g.slotScopeIds = x;
                    const H = o(m);
                    if (e(g, H, null, v, _, kd(H), w), D = E ? y(m) : s(m), D && ec(D) && D.data === "teleport end" && (D = s(D)), No(g)) {
                        let B;
                        E ? (B = I(mt), B.anchor = D ? D.previousSibling : H.lastChild) : B = m.nodeType === 3 ? pp("") : I("div"), B.el = m, g.component.subTree = B
                    }
                } else S & 64 ? R !== 8 ? D = C() : D = g.type.hydrate(m, g, v, _, x, w, t, h) : S & 128 ? D = g.type.hydrate(m, g, v, _, kd(o(m)), x, w, t, d) : re("Invalid HostVNode type:", A, `(${typeof A})`)
        }
        return T != null && uh(T, null, _, g), D
    }, f = (m, g, v, _, x, w) => {
        w = w || !!g.dynamicChildren;
        const {
            type: E,
            props: C,
            patchFlag: A,
            shapeFlag: T,
            dirs: S
        } = g, P = E === "input" && S || E === "option"; {
            if (S && Kr(g, null, v, "created"), C)
                if (P || !w || A & 48)
                    for (const D in C)(P && D.endsWith("value") || Xu(D) && !kc(D)) && r(m, D, null, C[D], !1, void 0, v);
                else C.onClick && r(m, "onClick", null, C.onClick, !1, void 0, v);
            let R;
            if ((R = C && C.onVnodeBeforeMount) && In(R, v, g), S && Kr(g, null, v, "beforeMount"), ((R = C && C.onVnodeMounted) || S) && GA(() => {
                    R && In(R, v, g), S && Kr(g, null, v, "mounted")
                }, _), T & 16 && !(C && (C.innerHTML || C.textContent))) {
                let D = h(m.firstChild, g, m, v, _, x, w),
                    H = !1;
                for (; D;) {
                    cs = !0, H || (re(`Hydration children mismatch in <${g.type}>: server rendered element contains more child nodes than client vdom.`), H = !0);
                    const B = D;
                    D = D.nextSibling, a(B)
                }
            } else T & 8 && m.textContent !== g.children && (cs = !0, re(`Hydration text content mismatch in <${g.type}>:
- Client: ${m.textContent}
- Server: ${g.children}`), m.textContent = g.children)
        }
        return m.nextSibling
    }, h = (m, g, v, _, x, w, E) => {
        E = E || !!g.dynamicChildren;
        const C = g.children,
            A = C.length;
        let T = !1;
        for (let S = 0; S < A; S++) {
            const P = E ? C[S] : C[S] = kn(C[S]);
            if (m) m = d(m, P, _, x, w, E);
            else {
                if (P.type === li && !P.children) continue;
                cs = !0, T || (re(`Hydration children mismatch in <${v.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`), T = !0), n(null, P, v, null, _, x, kd(v), w)
            }
        }
        return m
    }, p = (m, g, v, _, x, w) => {
        const {
            slotScopeIds: E
        } = g;
        E && (x = x ? x.concat(E) : E);
        const C = o(m),
            A = h(s(m), g, C, v, _, x, w);
        return A && ec(A) && A.data === "]" ? s(g.anchor = A) : (cs = !0, l(g.anchor = c("]"), C, A), A)
    }, b = (m, g, v, _, x, w) => {
        if (cs = !0, re(`Hydration node mismatch:
- Client vnode:`, g.type, `
- Server rendered DOM:`, m, m.nodeType === 3 ? "(text)" : ec(m) && m.data === "[" ? "(start of fragment)" : ""), g.el = null, w) {
            const A = y(m);
            for (;;) {
                const T = s(m);
                if (T && T !== A) a(T);
                else break
            }
        }
        const E = s(m),
            C = o(m);
        return a(m), n(null, g, C, E, v, _, kd(C), x), E
    }, y = m => {
        let g = 0;
        for (; m;)
            if (m = s(m), m && ec(m) && (m.data === "[" && g++, m.data === "]")) {
                if (g === 0) return s(m);
                g--
            }
        return m
    };
    return [u, d]
}
let tc, bs;

function Si(t, e) {
    t.appContext.config.performance && dh() && bs.mark(`vue-${e}-${t.uid}`), JN(t, e, dh() ? bs.now() : Date.now())
}

function Ti(t, e) {
    if (t.appContext.config.performance && dh()) {
        const n = `vue-${e}-${t.uid}`,
            r = n + ":end";
        bs.mark(r), bs.measure(`<${gp(t,t.type)}> ${e}`, n, r), bs.clearMarks(n), bs.clearMarks(r)
    }
    ZN(t, e, dh() ? bs.now() : Date.now())
}

function dh() {
    return tc !== void 0 || (typeof window < "u" && window.performance ? (tc = !0, bs = window.performance) : tc = !1), tc
}

function hU() {
    const t = [];
    if (t.length) {
        const e = t.length > 1;
        console.warn(`Feature flag${e?"s":""} ${t.join(", ")} ${e?"are":"is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`)
    }
}
const en = GA;

function fO(t) {
    return pO(t)
}

function hO(t) {
    return pO(t, fU)
}

function pO(t, e) {
    hU();
    const n = sh();
    n.__VUE__ = !0, C_(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);
    const {
        insert: r,
        remove: i,
        patchProp: s,
        createElement: o,
        createText: a,
        createComment: l,
        setText: c,
        setElementText: u,
        parentNode: d,
        nextSibling: f,
        setScopeId: h = Dn,
        insertStaticContent: p
    } = t, b = (O, L, j, ie = null, oe = null, M = null, k = !1, U = null, J = ks ? !1 : !!L.dynamicChildren) => {
        if (O === L) return;
        O && !Pr(O, L) && (ie = Z(O), ne(O, oe, M, !0), O = null), L.patchFlag === -2 && (J = !1, L.dynamicChildren = null);
        const {
            type: se,
            ref: pe,
            shapeFlag: ue
        } = L;
        switch (se) {
            case li:
                y(O, L, j, ie);
                break;
            case It:
                m(O, L, j, ie);
                break;
            case Bs:
                O == null ? g(L, j, ie, k) : v(O, L, j, k);
                break;
            case mt:
                R(O, L, j, ie, oe, M, k, U, J);
                break;
            default:
                ue & 1 ? w(O, L, j, ie, oe, M, k, U, J) : ue & 6 ? D(O, L, j, ie, oe, M, k, U, J) : ue & 64 || ue & 128 ? se.process(O, L, j, ie, oe, M, k, U, J, ce) : re("Invalid VNode type:", se, `(${typeof se})`)
        }
        pe != null && oe && uh(pe, O && O.ref, M, L || O, !L)
    }, y = (O, L, j, ie) => {
        if (O == null) r(L.el = a(L.children), j, ie);
        else {
            const oe = L.el = O.el;
            L.children !== O.children && c(oe, L.children)
        }
    }, m = (O, L, j, ie) => {
        O == null ? r(L.el = l(L.children || ""), j, ie) : L.el = O.el
    }, g = (O, L, j, ie) => {
        [O.el, O.anchor] = p(O.children, L, j, ie, O.el, O.anchor)
    }, v = (O, L, j, ie) => {
        if (L.children !== O.children) {
            const oe = f(O.anchor);
            x(O), [L.el, L.anchor] = p(L.children, j, oe, ie)
        } else L.el = O.el, L.anchor = O.anchor
    }, _ = ({
        el: O,
        anchor: L
    }, j, ie) => {
        let oe;
        for (; O && O !== L;) oe = f(O), r(O, j, ie), O = oe;
        r(L, j, ie)
    }, x = ({
        el: O,
        anchor: L
    }) => {
        let j;
        for (; O && O !== L;) j = f(O), i(O), O = j;
        i(L)
    }, w = (O, L, j, ie, oe, M, k, U, J) => {
        k = k || L.type === "svg", O == null ? E(L, j, ie, oe, M, k, U, J) : T(O, L, oe, M, k, U, J)
    }, E = (O, L, j, ie, oe, M, k, U) => {
        let J, se;
        const {
            type: pe,
            props: ue,
            shapeFlag: z,
            transition: ee,
            dirs: xe
        } = O;
        if (J = O.el = o(O.type, M, ue && ue.is, ue), z & 8 ? u(J, O.children) : z & 16 && A(O.children, J, null, ie, oe, M && pe !== "foreignObject", k, U), xe && Kr(O, null, ie, "created"), C(J, O, O.scopeId, k, ie), ue) {
            for (const Ve in ue) Ve !== "value" && !kc(Ve) && s(J, Ve, null, ue[Ve], M, O.children, ie, oe, F);
            "value" in ue && s(J, "value", null, ue.value), (se = ue.onVnodeBeforeMount) && In(se, ie, O)
        }
        Object.defineProperty(J, "__vnode", {
            value: O,
            enumerable: !1
        }), Object.defineProperty(J, "__vueParentComponent", {
            value: ie,
            enumerable: !1
        }), xe && Kr(O, null, ie, "beforeMount");
        const ke = (!oe || oe && !oe.pendingBranch) && ee && !ee.persisted;
        ke && ee.beforeEnter(J), r(J, L, j), ((se = ue && ue.onVnodeMounted) || ke || xe) && en(() => {
            se && In(se, ie, O), ke && ee.enter(J), xe && Kr(O, null, ie, "mounted")
        }, oe)
    }, C = (O, L, j, ie, oe) => {
        if (j && h(O, j), ie)
            for (let M = 0; M < ie.length; M++) h(O, ie[M]);
        if (oe) {
            let M = oe.subTree;
            if (M.patchFlag > 0 && M.patchFlag & 2048 && (M = O_(M.children) || M), L === M) {
                const k = oe.vnode;
                C(O, k, k.scopeId, k.slotScopeIds, oe.parent)
            }
        }
    }, A = (O, L, j, ie, oe, M, k, U, J = 0) => {
        for (let se = J; se < O.length; se++) {
            const pe = O[se] = U ? vs(O[se]) : kn(O[se]);
            b(null, pe, L, j, ie, oe, M, k, U)
        }
    }, T = (O, L, j, ie, oe, M, k) => {
        const U = L.el = O.el;
        let {
            patchFlag: J,
            dynamicChildren: se,
            dirs: pe
        } = L;
        J |= O.patchFlag & 16;
        const ue = O.props || ot,
            z = L.props || ot;
        let ee;
        j && lo(j, !1), (ee = z.onVnodeBeforeUpdate) && In(ee, j, L, O), pe && Kr(L, O, j, "beforeUpdate"), j && lo(j, !0), ks && (J = 0, k = !1, se = null);
        const xe = oe && L.type !== "foreignObject";
        if (se ? (S(O.dynamicChildren, se, U, j, ie, xe, M), fh(O, L)) : k || Y(O, L, U, null, j, ie, xe, M, !1), J > 0) {
            if (J & 16) P(U, L, ue, z, j, ie, oe);
            else if (J & 2 && ue.class !== z.class && s(U, "class", null, z.class, oe), J & 4 && s(U, "style", ue.style, z.style, oe), J & 8) {
                const ke = L.dynamicProps;
                for (let Ve = 0; Ve < ke.length; Ve++) {
                    const ht = ke[Ve],
                        Yt = ue[ht],
                        On = z[ht];
                    (On !== Yt || ht === "value") && s(U, ht, Yt, On, oe, O.children, j, ie, F)
                }
            }
            J & 1 && O.children !== L.children && u(U, L.children)
        } else !k && se == null && P(U, L, ue, z, j, ie, oe);
        ((ee = z.onVnodeUpdated) || pe) && en(() => {
            ee && In(ee, j, L, O), pe && Kr(L, O, j, "updated")
        }, ie)
    }, S = (O, L, j, ie, oe, M, k) => {
        for (let U = 0; U < L.length; U++) {
            const J = O[U],
                se = L[U],
                pe = J.el && (J.type === mt || !Pr(J, se) || J.shapeFlag & 70) ? d(J.el) : j;
            b(J, se, pe, null, ie, oe, M, k, !0)
        }
    }, P = (O, L, j, ie, oe, M, k) => {
        if (j !== ie) {
            if (j !== ot)
                for (const U in j) !kc(U) && !(U in ie) && s(O, U, j[U], null, k, L.children, oe, M, F);
            for (const U in ie) {
                if (kc(U)) continue;
                const J = ie[U],
                    se = j[U];
                J !== se && U !== "value" && s(O, U, se, J, k, L.children, oe, M, F)
            }
            "value" in ie && s(O, "value", j.value, ie.value)
        }
    }, R = (O, L, j, ie, oe, M, k, U, J) => {
        const se = L.el = O ? O.el : a(""),
            pe = L.anchor = O ? O.anchor : a("");
        let {
            patchFlag: ue,
            dynamicChildren: z,
            slotScopeIds: ee
        } = L;
        (ks || ue & 2048) && (ue = 0, J = !1, z = null), ee && (U = U ? U.concat(ee) : ee), O == null ? (r(se, j, ie), r(pe, j, ie), A(L.children, j, pe, oe, M, k, U, J)) : ue > 0 && ue & 64 && z && O.dynamicChildren ? (S(O.dynamicChildren, z, j, oe, M, k, U), fh(O, L)) : Y(O, L, j, pe, oe, M, k, U, J)
    }, D = (O, L, j, ie, oe, M, k, U, J) => {
        L.slotScopeIds = U, O == null ? L.shapeFlag & 512 ? oe.ctx.activate(L, j, ie, k, J) : H(L, j, ie, oe, M, k, J) : B(O, L, J)
    }, H = (O, L, j, ie, oe, M, k) => {
        const U = O.component = xO(O, ie, oe);
        if (U.type.__hmrId && zN(U), Bc(O), Si(U, "mount"), Gl(O) && (U.ctx.renderer = ce), Si(U, "init"), EO(U), Ti(U, "init"), U.asyncDep) {
            if (oe && oe.registerDep(U, N), !O.el) {
                const J = U.subTree = I(It);
                m(null, J, L, j)
            }
            return
        }
        N(U, O, L, j, oe, M, k), Dc(), Ti(U, "mount")
    }, B = (O, L, j) => {
        const ie = L.component = O.component;
        if (a4(O, L, j))
            if (ie.asyncDep && !ie.asyncResolved) {
                Bc(L), V(ie, L, j), Dc();
                return
            } else ie.next = L, GN(ie.update), ie.update();
        else L.el = O.el, ie.vnode = L
    }, N = (O, L, j, ie, oe, M, k) => {
        const U = () => {
                if (O.isMounted) {
                    let {
                        next: pe,
                        bu: ue,
                        u: z,
                        parent: ee,
                        vnode: xe
                    } = O, ke = pe, Ve;
                    Bc(pe || O.vnode), lo(O, !1), pe ? (pe.el = xe.el, V(O, pe, k)) : pe = xe, ue && Eo(ue), (Ve = pe.props && pe.props.onVnodeBeforeUpdate) && In(Ve, ee, pe, xe), lo(O, !0), Si(O, "render");
                    const ht = Mf(O);
                    Ti(O, "render");
                    const Yt = O.subTree;
                    O.subTree = ht, Si(O, "patch"), b(Yt, ht, d(Yt.el), Z(Yt), O, oe, M), Ti(O, "patch"), pe.el = ht.el, ke === null && I_(O, ht.el), z && en(z, oe), (Ve = pe.props && pe.props.onVnodeUpdated) && en(() => In(Ve, ee, pe, xe), oe), FA(O), Dc()
                } else {
                    let pe;
                    const {
                        el: ue,
                        props: z
                    } = L, {
                        bm: ee,
                        m: xe,
                        parent: ke
                    } = O, Ve = No(L);
                    if (lo(O, !1), ee && Eo(ee), !Ve && (pe = z && z.onVnodeBeforeMount) && In(pe, ke, L), lo(O, !0), ue && ge) {
                        const ht = () => {
                            Si(O, "render"), O.subTree = Mf(O), Ti(O, "render"), Si(O, "hydrate"), ge(ue, O.subTree, O, oe, null), Ti(O, "hydrate")
                        };
                        Ve ? L.type.__asyncLoader().then(() => !O.isUnmounted && ht()) : ht()
                    } else {
                        Si(O, "render");
                        const ht = O.subTree = Mf(O);
                        Ti(O, "render"), Si(O, "patch"), b(null, ht, j, ie, O, oe, M), Ti(O, "patch"), L.el = ht.el
                    }
                    if (xe && en(xe, oe), !Ve && (pe = z && z.onVnodeMounted)) {
                        const ht = L;
                        en(() => In(pe, ke, ht), oe)
                    }(L.shapeFlag & 256 || ke && No(ke.vnode) && ke.vnode.shapeFlag & 256) && O.a && en(O.a, oe), O.isMounted = !0, qy(O), L = j = ie = null
                }
            },
            J = O.effect = new Wu(U, () => Zu(se), O.scope),
            se = O.update = () => J.run();
        se.id = O.uid, lo(O, !0), J.onTrack = O.rtc ? pe => Eo(O.rtc, pe) : void 0, J.onTrigger = O.rtg ? pe => Eo(O.rtg, pe) : void 0, se.ownerInstance = O, se()
    }, V = (O, L, j) => {
        L.component = O;
        const ie = O.vnode.props;
        O.vnode = L, O.next = null, rU(O, L.props, ie, j), dU(O, L.children, j), fa(), Xw(), ha()
    }, Y = (O, L, j, ie, oe, M, k, U, J = !1) => {
        const se = O && O.children,
            pe = O ? O.shapeFlag : 0,
            ue = L.children,
            {
                patchFlag: z,
                shapeFlag: ee
            } = L;
        if (z > 0) {
            if (z & 128) {
                ae(se, ue, j, ie, oe, M, k, U, J);
                return
            } else if (z & 256) {
                le(se, ue, j, ie, oe, M, k, U, J);
                return
            }
        }
        ee & 8 ? (pe & 16 && F(se, oe, M), ue !== se && u(j, ue)) : pe & 16 ? ee & 16 ? ae(se, ue, j, ie, oe, M, k, U, J) : F(se, oe, M, !0) : (pe & 8 && u(j, ""), ee & 16 && A(ue, j, ie, oe, M, k, U, J))
    }, le = (O, L, j, ie, oe, M, k, U, J) => {
        O = O || tl, L = L || tl;
        const se = O.length,
            pe = L.length,
            ue = Math.min(se, pe);
        let z;
        for (z = 0; z < ue; z++) {
            const ee = L[z] = J ? vs(L[z]) : kn(L[z]);
            b(O[z], ee, j, null, oe, M, k, U, J)
        }
        se > pe ? F(O, oe, M, !0, !1, ue) : A(L, j, ie, oe, M, k, U, J, ue)
    }, ae = (O, L, j, ie, oe, M, k, U, J) => {
        let se = 0;
        const pe = L.length;
        let ue = O.length - 1,
            z = pe - 1;
        for (; se <= ue && se <= z;) {
            const ee = O[se],
                xe = L[se] = J ? vs(L[se]) : kn(L[se]);
            if (Pr(ee, xe)) b(ee, xe, j, null, oe, M, k, U, J);
            else break;
            se++
        }
        for (; se <= ue && se <= z;) {
            const ee = O[ue],
                xe = L[z] = J ? vs(L[z]) : kn(L[z]);
            if (Pr(ee, xe)) b(ee, xe, j, null, oe, M, k, U, J);
            else break;
            ue--, z--
        }
        if (se > ue) {
            if (se <= z) {
                const ee = z + 1,
                    xe = ee < pe ? L[ee].el : ie;
                for (; se <= z;) b(null, L[se] = J ? vs(L[se]) : kn(L[se]), j, xe, oe, M, k, U, J), se++
            }
        } else if (se > z)
            for (; se <= ue;) ne(O[se], oe, M, !0), se++;
        else {
            const ee = se,
                xe = se,
                ke = new Map;
            for (se = xe; se <= z; se++) {
                const mn = L[se] = J ? vs(L[se]) : kn(L[se]);
                mn.key != null && (ke.has(mn.key) && re("Duplicate keys found during update:", JSON.stringify(mn.key), "Make sure keys are unique."), ke.set(mn.key, se))
            }
            let Ve, ht = 0;
            const Yt = z - xe + 1;
            let On = !1,
                Cd = 0;
            const as = new Array(Yt);
            for (se = 0; se < Yt; se++) as[se] = 0;
            for (se = ee; se <= ue; se++) {
                const mn = O[se];
                if (ht >= Yt) {
                    ne(mn, oe, M, !0);
                    continue
                }
                let Gr;
                if (mn.key != null) Gr = ke.get(mn.key);
                else
                    for (Ve = xe; Ve <= z; Ve++)
                        if (as[Ve - xe] === 0 && Pr(mn, L[Ve])) {
                            Gr = Ve;
                            break
                        }
                Gr === void 0 ? ne(mn, oe, M, !0) : (as[Gr - xe] = se + 1, Gr >= Cd ? Cd = Gr : On = !0, b(mn, L[Gr], j, null, oe, M, k, U, J), ht++)
            }
            const Fw = On ? pU(as) : tl;
            for (Ve = Fw.length - 1, se = Yt - 1; se >= 0; se--) {
                const mn = xe + se,
                    Gr = L[mn],
                    Lw = mn + 1 < pe ? L[mn + 1].el : ie;
                as[se] === 0 ? b(null, Gr, j, Lw, oe, M, k, U, J) : On && (Ve < 0 || se !== Fw[Ve] ? W(Gr, j, Lw, 2) : Ve--)
            }
        }
    }, W = (O, L, j, ie, oe = null) => {
        const {
            el: M,
            type: k,
            transition: U,
            children: J,
            shapeFlag: se
        } = O;
        if (se & 6) {
            W(O.component.subTree, L, j, ie);
            return
        }
        if (se & 128) {
            O.suspense.move(L, j, ie);
            return
        }
        if (se & 64) {
            k.move(O, L, j, ce);
            return
        }
        if (k === mt) {
            r(M, L, j);
            for (let ue = 0; ue < J.length; ue++) W(J[ue], L, j, ie);
            r(O.anchor, L, j);
            return
        }
        if (k === Bs) {
            _(O, L, j);
            return
        }
        if (ie !== 2 && se & 1 && U)
            if (ie === 0) U.beforeEnter(M), r(M, L, j), en(() => U.enter(M), oe);
            else {
                const {
                    leave: ue,
                    delayLeave: z,
                    afterLeave: ee
                } = U, xe = () => r(M, L, j), ke = () => {
                    ue(M, () => {
                        xe(), ee && ee()
                    })
                };
                z ? z(M, xe, ke) : ke()
            }
        else r(M, L, j)
    }, ne = (O, L, j, ie = !1, oe = !1) => {
        const {
            type: M,
            props: k,
            ref: U,
            children: J,
            dynamicChildren: se,
            shapeFlag: pe,
            patchFlag: ue,
            dirs: z
        } = O;
        if (U != null && uh(U, null, j, O, !0), pe & 256) {
            L.ctx.deactivate(O);
            return
        }
        const ee = pe & 1 && z,
            xe = !No(O);
        let ke;
        if (xe && (ke = k && k.onVnodeBeforeUnmount) && In(ke, L, O), pe & 6) X(O.component, j, ie);
        else {
            if (pe & 128) {
                O.suspense.unmount(j, ie);
                return
            }
            ee && Kr(O, null, L, "beforeUnmount"), pe & 64 ? O.type.remove(O, L, j, oe, ce, ie) : se && (M !== mt || ue > 0 && ue & 64) ? F(se, L, j, !1, !0) : (M === mt && ue & 384 || !oe && pe & 16) && F(J, L, j), ie && fe(O)
        }(xe && (ke = k && k.onVnodeUnmounted) || ee) && en(() => {
            ke && In(ke, L, O), ee && Kr(O, null, L, "unmounted")
        }, j)
    }, fe = O => {
        const {
            type: L,
            el: j,
            anchor: ie,
            transition: oe
        } = O;
        if (L === mt) {
            O.patchFlag > 0 && O.patchFlag & 2048 && oe && !oe.persisted ? O.children.forEach(k => {
                k.type === It ? i(k.el) : fe(k)
            }) : $(j, ie);
            return
        }
        if (L === Bs) {
            x(O);
            return
        }
        const M = () => {
            i(j), oe && !oe.persisted && oe.afterLeave && oe.afterLeave()
        };
        if (O.shapeFlag & 1 && oe && !oe.persisted) {
            const {
                leave: k,
                delayLeave: U
            } = oe, J = () => k(j, M);
            U ? U(O.el, M, J) : J()
        } else M()
    }, $ = (O, L) => {
        let j;
        for (; O !== L;) j = f(O), i(O), O = j;
        i(L)
    }, X = (O, L, j) => {
        O.type.__hmrId && jN(O);
        const {
            bum: ie,
            scope: oe,
            update: M,
            subTree: k,
            um: U
        } = O;
        ie && Eo(ie), oe.stop(), M && (M.active = !1, ne(k, O, L, j)), U && en(U, L), en(() => {
            O.isUnmounted = !0
        }, L), L && L.pendingBranch && !L.isUnmounted && O.asyncDep && !O.asyncResolved && O.suspenseId === L.pendingId && (L.deps--, L.deps === 0 && L.resolve()), KN(O)
    }, F = (O, L, j, ie = !1, oe = !1, M = 0) => {
        for (let k = M; k < O.length; k++) ne(O[k], L, j, ie, oe)
    }, Z = O => O.shapeFlag & 6 ? Z(O.component.subTree) : O.shapeFlag & 128 ? O.suspense.next() : f(O.anchor || O.el), K = (O, L, j) => {
        O == null ? L._vnode && ne(L._vnode, null, null, !0) : b(L._vnode || null, O, L, null, null, null, j), Xw(), oh(), L._vnode = O
    }, ce = {
        p: b,
        um: ne,
        m: W,
        r: fe,
        mt: H,
        mc: A,
        pc: Y,
        pbc: S,
        n: Z,
        o: t
    };
    let de, ge;
    return e && ([de, ge] = e(ce)), {
        render: K,
        hydrate: de,
        createApp: eU(K, de)
    }
}

function lo({
    effect: t,
    update: e
}, n) {
    t.allowRecurse = e.allowRecurse = n
}

function fh(t, e, n = !1) {
    const r = t.children,
        i = e.children;
    if (De(r) && De(i))
        for (let s = 0; s < r.length; s++) {
            const o = r[s];
            let a = i[s];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = i[s] = vs(i[s]), a.el = o.el), n || fh(o, a)), a.type === li && (a.el = o.el), a.type === It && !a.el && (a.el = o.el)
        }
}

function pU(t) {
    const e = t.slice(),
        n = [0];
    let r, i, s, o, a;
    const l = t.length;
    for (r = 0; r < l; r++) {
        const c = t[r];
        if (c !== 0) {
            if (i = n[n.length - 1], t[i] < c) {
                e[r] = i, n.push(r);
                continue
            }
            for (s = 0, o = n.length - 1; s < o;) a = s + o >> 1, t[n[a]] < c ? s = a + 1 : o = a;
            c < t[n[s]] && (s > 0 && (e[r] = n[s - 1]), n[s] = r)
        }
    }
    for (s = n.length, o = n[s - 1]; s-- > 0;) n[s] = o, o = e[o];
    return n
}
const mU = t => t.__isTeleport,
    il = t => t && (t.disabled || t.disabled === ""),
    uE = t => typeof SVGElement < "u" && t instanceof SVGElement,
    nv = (t, e) => {
        const n = t && t.to;
        if (Rt(n))
            if (e) {
                const r = e(n);
                return r || re(`Failed to locate Teleport target with selector "${n}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`), r
            } else return re("Current renderer does not support string target for Teleports. (missing querySelector renderer option)"), null;
        else return !n && !il(t) && re(`Invalid Teleport target: ${n}`), n
    },
    gU = {
        __isTeleport: !0,
        process(t, e, n, r, i, s, o, a, l, c) {
            const {
                mc: u,
                pc: d,
                pbc: f,
                o: {
                    insert: h,
                    querySelector: p,
                    createText: b,
                    createComment: y
                }
            } = c, m = il(e.props);
            let {
                shapeFlag: g,
                children: v,
                dynamicChildren: _
            } = e;
            if (ks && (l = !1, _ = null), t == null) {
                const x = e.el = y("teleport start"),
                    w = e.anchor = y("teleport end");
                h(x, n, r), h(w, n, r);
                const E = e.target = nv(e.props, p),
                    C = e.targetAnchor = b("");
                E ? (h(C, E), o = o || uE(E)) : m || re("Invalid Teleport target on mount:", E, `(${typeof E})`);
                const A = (T, S) => {
                    g & 16 && u(v, T, S, i, s, o, a, l)
                };
                m ? A(n, w) : E && A(E, C)
            } else {
                e.el = t.el;
                const x = e.anchor = t.anchor,
                    w = e.target = t.target,
                    E = e.targetAnchor = t.targetAnchor,
                    C = il(t.props),
                    A = C ? n : w,
                    T = C ? x : E;
                if (o = o || uE(w), _ ? (f(t.dynamicChildren, _, A, i, s, o, a), fh(t, e, !0)) : l || d(t, e, A, T, i, s, o, a, !1), m) C || Bd(e, n, x, c, 1);
                else if ((e.props && e.props.to) !== (t.props && t.props.to)) {
                    const S = e.target = nv(e.props, p);
                    S ? Bd(e, S, null, c, 0) : re("Invalid Teleport target on update:", w, `(${typeof w})`)
                } else C && Bd(e, w, E, c, 1)
            }
            mO(e)
        },
        remove(t, e, n, r, {
            um: i,
            o: {
                remove: s
            }
        }, o) {
            const {
                shapeFlag: a,
                children: l,
                anchor: c,
                targetAnchor: u,
                target: d,
                props: f
            } = t;
            if (d && s(u), (o || !il(f)) && (s(c), a & 16))
                for (let h = 0; h < l.length; h++) {
                    const p = l[h];
                    i(p, e, n, !0, !!p.dynamicChildren)
                }
        },
        move: Bd,
        hydrate: yU
    };

function Bd(t, e, n, {
    o: {
        insert: r
    },
    m: i
}, s = 2) {
    s === 0 && r(t.targetAnchor, e, n);
    const {
        el: o,
        anchor: a,
        shapeFlag: l,
        children: c,
        props: u
    } = t, d = s === 2;
    if (d && r(o, e, n), (!d || il(u)) && l & 16)
        for (let f = 0; f < c.length; f++) i(c[f], e, n, 2);
    d && r(a, e, n)
}

function yU(t, e, n, r, i, s, {
    o: {
        nextSibling: o,
        parentNode: a,
        querySelector: l
    }
}, c) {
    const u = e.target = nv(e.props, l);
    if (u) {
        const d = u._lpa || u.firstChild;
        if (e.shapeFlag & 16)
            if (il(e.props)) e.anchor = c(o(t), e, a(t), n, r, i, s), e.targetAnchor = d;
            else {
                e.anchor = o(t);
                let f = d;
                for (; f;)
                    if (f = o(f), f && f.nodeType === 8 && f.data === "teleport anchor") {
                        e.targetAnchor = f, u._lpa = e.targetAnchor && o(e.targetAnchor);
                        break
                    }
                c(d, e, u, n, r, i, s)
            }
        mO(e)
    }
    return e.anchor && o(e.anchor)
}
const dp = gU;

function mO(t) {
    const e = t.ctx;
    if (e && e.ut) {
        let n = t.children[0].el;
        for (; n !== t.targetAnchor;) n.nodeType === 1 && n.setAttribute("data-v-owner", e.uid), n = n.nextSibling;
        e.ut()
    }
}
const mt = Symbol.for("v-fgt"),
    li = Symbol.for("v-txt"),
    It = Symbol.for("v-cmt"),
    Bs = Symbol.for("v-stc"),
    Lc = [];
let $n = null;

function fp(t = !1) {
    Lc.push($n = t ? null : [])
}

function gO() {
    Lc.pop(), $n = Lc[Lc.length - 1] || null
}
let qo = 1;

function rv(t) {
    qo += t
}

function yO(t) {
    return t.dynamicChildren = qo > 0 ? $n || tl : null, gO(), qo > 0 && $n && $n.push(t), t
}

function vU(t, e, n, r, i, s) {
    return yO(N_(t, e, n, r, i, s, !0))
}

function L_(t, e, n, r, i) {
    return yO(I(t, e, n, r, i, !0))
}

function ci(t) {
    return t ? t.__v_isVNode === !0 : !1
}

function Pr(t, e) {
    return e.shapeFlag & 6 && Wa.has(e.type) ? (t.shapeFlag &= -257, e.shapeFlag &= -513, !1) : t.type === e.type && t.key === e.key
}
let iv;

function _U(t) {
    iv = t
}
const bU = (...t) => xU(...iv ? iv(t, $t) : t),
    hp = "__vInternal",
    vO = ({
        key: t
    }) => t ? ? null,
    Rf = ({
        ref: t,
        ref_key: e,
        ref_for: n
    }) => (typeof t == "number" && (t = "" + t), t != null ? Rt(t) || et(t) || Be(t) ? {
        i: $t,
        r: t,
        k: e,
        f: !!n
    } : t : null);

function N_(t, e = null, n = null, r = 0, i = null, s = t === mt ? 0 : 1, o = !1, a = !1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t,
        props: e,
        key: e && vO(e),
        ref: e && Rf(e),
        scopeId: ap,
        slotScopeIds: null,
        children: n,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: s,
        patchFlag: r,
        dynamicProps: i,
        dynamicChildren: null,
        appContext: null,
        ctx: $t
    };
    return a ? (U_(l, n), s & 128 && t.normalize(l)) : n && (l.shapeFlag |= Rt(n) ? 8 : 16), l.key !== l.key && re("VNode created with invalid key (NaN). VNode type:", l.type), qo > 0 && !o && $n && (l.patchFlag > 0 || s & 6) && l.patchFlag !== 32 && $n.push(l), l
}
const I = bU;

function xU(t, e = null, n = null, r = 0, i = null, s = !1) {
    if ((!t || t === QA) && (t || re(`Invalid vnode type when creating vnode: ${t}.`), t = It), ci(t)) {
        const a = _r(t, e, !0);
        return n && U_(a, n), qo > 0 && !s && $n && (a.shapeFlag & 6 ? $n[$n.indexOf(t)] = a : $n.push(a)), a.patchFlag |= -2, a
    }
    if (CO(t) && (t = t.__vccOpts), e) {
        e = _O(e);
        let {
            class: a,
            style: l
        } = e;
        a && !Rt(a) && (e.class = Ju(a)), ct(l) && (ou(l) && !De(l) && (l = St({}, l)), e.style = Ku(l))
    }
    const o = Rt(t) ? 1 : UA(t) ? 128 : mU(t) ? 64 : ct(t) ? 4 : Be(t) ? 2 : 0;
    return o & 4 && ou(t) && (t = Me(t), re("Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.", `
Component that was made reactive: `, t)), N_(t, e, n, r, i, o, s, !0)
}

function _O(t) {
    return t ? ou(t) || hp in t ? St({}, t) : t : null
}

function _r(t, e, n = !1) {
    const {
        props: r,
        ref: i,
        patchFlag: s,
        children: o
    } = t, a = e ? Ke(r || {}, e) : r;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: t.type,
        props: a,
        key: a && vO(a),
        ref: e && e.ref ? n && i ? De(i) ? i.concat(Rf(e)) : [i, Rf(e)] : Rf(e) : i,
        scopeId: t.scopeId,
        slotScopeIds: t.slotScopeIds,
        children: s === -1 && De(o) ? o.map(bO) : o,
        target: t.target,
        targetAnchor: t.targetAnchor,
        staticCount: t.staticCount,
        shapeFlag: t.shapeFlag,
        patchFlag: e && t.type !== mt ? s === -1 ? 16 : s | 16 : s,
        dynamicProps: t.dynamicProps,
        dynamicChildren: t.dynamicChildren,
        appContext: t.appContext,
        dirs: t.dirs,
        transition: t.transition,
        component: t.component,
        suspense: t.suspense,
        ssContent: t.ssContent && _r(t.ssContent),
        ssFallback: t.ssFallback && _r(t.ssFallback),
        el: t.el,
        anchor: t.anchor,
        ctx: t.ctx,
        ce: t.ce
    }
}

function bO(t) {
    const e = _r(t);
    return De(t.children) && (e.children = t.children.map(bO)), e
}

function pp(t = " ", e = 0) {
    return I(li, null, t, e)
}

function wU(t, e) {
    const n = I(Bs, null, t);
    return n.staticCount = e, n
}

function EU(t = "", e = !1) {
    return e ? (fp(), L_(It, null, t)) : I(It, null, t)
}

function kn(t) {
    return t == null || typeof t == "boolean" ? I(It) : De(t) ? I(mt, null, t.slice()) : typeof t == "object" ? vs(t) : I(li, null, String(t))
}

function vs(t) {
    return t.el === null && t.patchFlag !== -1 || t.memo ? t : _r(t)
}

function U_(t, e) {
    let n = 0;
    const {
        shapeFlag: r
    } = t;
    if (e == null) e = null;
    else if (De(e)) n = 16;
    else if (typeof e == "object")
        if (r & 65) {
            const i = e.default;
            i && (i._c && (i._d = !1), U_(t, i()), i._c && (i._d = !0));
            return
        } else {
            n = 32;
            const i = e._;
            !i && !(hp in e) ? e._ctx = $t : i === 3 && $t && ($t.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024))
        }
    else Be(e) ? (e = {
        default: e,
        _ctx: $t
    }, n = 32) : (e = String(e), r & 64 ? (n = 16, e = [pp(e)]) : n = 8);
    t.children = e, t.shapeFlag |= n
}

function Ke(...t) {
    const e = {};
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        for (const i in r)
            if (i === "class") e.class !== r.class && (e.class = Ju([e.class, r.class]));
            else if (i === "style") e.style = Ku([e.style, r.style]);
        else if (Xu(i)) {
            const s = e[i],
                o = r[i];
            o && s !== o && !(De(s) && s.includes(o)) && (e[i] = s ? [].concat(s, o) : o)
        } else i !== "" && (e[i] = r[i])
    }
    return e
}

function In(t, e, n, r = null) {
    qn(t, e, 7, [n, r])
}
const SU = iO();
let TU = 0;

function xO(t, e, n) {
    const r = t.type,
        i = (e ? e.appContext : t.appContext) || SU,
        s = {
            uid: TU++,
            vnode: t,
            type: r,
            parent: e,
            appContext: i,
            root: null,
            next: null,
            subTree: null,
            effect: null,
            update: null,
            scope: new p_(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: e ? e.provides : Object.create(i.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: aO(r, i),
            emitsOptions: NA(r, i),
            emit: null,
            emitted: null,
            propsDefaults: ot,
            inheritAttrs: r.inheritAttrs,
            ctx: ot,
            data: ot,
            props: ot,
            attrs: ot,
            slots: ot,
            refs: ot,
            setupState: ot,
            setupContext: null,
            attrsProxy: null,
            slotsProxy: null,
            suspense: n,
            suspenseId: n ? n.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return s.ctx = I4(s), s.root = e ? e.root : s, s.emit = e4.bind(null, s), t.ce && t.ce(s), s
}
let Dt = null;
const rt = () => Dt || $t;
let G_, Ta, dE = "__VUE_INSTANCE_SETTERS__";
(Ta = sh()[dE]) || (Ta = sh()[dE] = []), Ta.push(t => Dt = t), G_ = t => {
    Ta.length > 1 ? Ta.forEach(e => e(t)) : Ta[0](t)
};
const Hs = t => {
        G_(t), t.scope.on()
    },
    Ds = () => {
        Dt && Dt.scope.off(), G_(null)
    },
    CU = Yu("slot,component");

function sv(t, e) {
    const n = e.isNativeTag || CA;
    (CU(t) || n(t)) && re("Do not use built-in or reserved HTML elements as component id: " + t)
}

function wO(t) {
    return t.vnode.shapeFlag & 4
}
let pl = !1;

function EO(t, e = !1) {
    pl = e;
    const {
        props: n,
        children: r
    } = t.vnode, i = wO(t);
    tU(t, n, i, e), uU(t, r);
    const s = i ? PU(t, e) : void 0;
    return pl = !1, s
}

function PU(t, e) {
    var n;
    const r = t.type; {
        if (r.name && sv(r.name, t.appContext.config), r.components) {
            const s = Object.keys(r.components);
            for (let o = 0; o < s.length; o++) sv(s[o], t.appContext.config)
        }
        if (r.directives) {
            const s = Object.keys(r.directives);
            for (let o = 0; o < s.length; o++) jA(s[o])
        }
        r.compilerOptions && H_() && re('"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.')
    }
    t.accessCache = Object.create(null), t.proxy = ni(new Proxy(t.ctx, Fc)), M4(t);
    const {
        setup: i
    } = r;
    if (i) {
        const s = t.setupContext = i.length > 1 ? TO(t) : null;
        Hs(t), fa();
        const o = ii(i, t, 0, [Ka(t.props), s]);
        if (ha(), Ds(), rp(o)) {
            if (o.then(Ds, Ds), e) return o.then(a => {
                ov(t, a, e)
            }).catch(a => {
                ma(a, t, 0)
            });
            if (t.asyncDep = o, !t.suspense) {
                const a = (n = r.name) != null ? n : "Anonymous";
                re(`Component <${a}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`)
            }
        } else ov(t, o, e)
    } else SO(t, e)
}

function ov(t, e, n) {
    Be(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : ct(e) ? (ci(e) && re("setup() should not return VNodes directly - return a render function instead."), t.devtoolsRawSetupState = e, t.setupState = b_(e), R4(t)) : e !== void 0 && re(`setup() should return an object. Received: ${e===null?"null":typeof e}`), SO(t, n)
}
let Nc, av;

function AU(t) {
    Nc = t, av = e => {
        e.render._rc && (e.withProxy = new Proxy(e.ctx, O4))
    }
}
const H_ = () => !Nc;

function SO(t, e, n) {
    const r = t.type;
    if (!t.render) {
        if (!e && Nc && !r.render) {
            const i = r.template || $_(t).template;
            if (i) {
                Si(t, "compile");
                const {
                    isCustomElement: s,
                    compilerOptions: o
                } = t.appContext.config, {
                    delimiters: a,
                    compilerOptions: l
                } = r, c = St(St({
                    isCustomElement: s,
                    delimiters: a
                }, o), l);
                r.render = Nc(i, c), Ti(t, "compile")
            }
        }
        t.render = r.render || Dn, av && av(t)
    }
    Hs(t), fa(), X4(t), ha(), Ds(), !r.render && t.render === Dn && !e && (!Nc && r.template ? re('Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".') : re("Component is missing template or render function."))
}

function OU(t) {
    return t.attrsProxy || (t.attrsProxy = new Proxy(t.attrs, {
        get(e, n) {
            return ah(), pn(t, "get", "$attrs"), e[n]
        },
        set() {
            return re("setupContext.attrs is readonly."), !1
        },
        deleteProperty() {
            return re("setupContext.attrs is readonly."), !1
        }
    }))
}

function IU(t) {
    return t.slotsProxy || (t.slotsProxy = new Proxy(t.slots, {
        get(e, n) {
            return pn(t, "get", "$slots"), e[n]
        }
    }))
}

function TO(t) {
    return Object.freeze({
        get attrs() {
            return OU(t)
        },
        get slots() {
            return IU(t)
        },
        get emit() {
            return (n, ...r) => t.emit(n, ...r)
        },
        expose: n => {
            if (t.exposed && re("expose() should be called only once per setup()."), n != null) {
                let r = typeof n;
                r === "object" && (De(n) ? r = "array" : et(n) && (r = "ref")), r !== "object" && re(`expose() should be passed a plain object, received ${r}.`)
            }
            t.exposed = n || {}
        }
    })
}

function mp(t) {
    if (t.exposed) return t.exposeProxy || (t.exposeProxy = new Proxy(b_(ni(t.exposed)), {
        get(e, n) {
            if (n in e) return e[n];
            if (n in Uo) return Uo[n](t)
        },
        has(e, n) {
            return n in e || n in Uo
        }
    }))
}
const MU = /(?:^|[-_])(\w)/g,
    RU = t => t.replace(MU, e => e.toUpperCase()).replace(/[-_]/g, "");

function pu(t, e = !0) {
    return Be(t) ? t.displayName || t.name : t.name || e && t.__name
}

function gp(t, e, n = !1) {
    let r = pu(e);
    if (!r && e.__file) {
        const i = e.__file.match(/([^/\\]+)\.\w+$/);
        i && (r = i[1])
    }
    if (!r && t && t.parent) {
        const i = s => {
            for (const o in s)
                if (s[o] === e) return o
        };
        r = i(t.components || t.parent.type.components) || i(t.appContext.components)
    }
    return r ? RU(r) : n ? "App" : "Anonymous"
}

function CO(t) {
    return Be(t) && "__vccOpts" in t
}
const te = (t, e) => gN(t, e, pl);

function Jt(t, e, n) {
    const r = arguments.length;
    return r === 2 ? ct(e) && !De(e) ? ci(e) ? I(t, null, [e]) : I(t, e) : I(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && ci(n) && (n = [n]), I(t, e, n))
}
const PO = Symbol.for("v-scx"),
    AO = () => {
        {
            const t = Nt(PO);
            return t || re("Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."), t
        }
    };

function Am(t) {
    return !!(t && t.__v_isShallow)
}

function OO() {
    if (typeof window > "u") return;
    const t = {
            style: "color:#3ba776"
        },
        e = {
            style: "color:#0b1bc9"
        },
        n = {
            style: "color:#b62e24"
        },
        r = {
            style: "color:#9d288c"
        },
        i = {
            header(d) {
                return ct(d) ? d.__isVue ? ["div", t, "VueInstance"] : et(d) ? ["div", {},
                    ["span", t, u(d)], "<", a(d.value), ">"
                ] : Rr(d) ? ["div", {},
                    ["span", t, Am(d) ? "ShallowReactive" : "Reactive"], "<", a(d), `>${Yi(d)?" (readonly)":""}`
                ] : Yi(d) ? ["div", {},
                    ["span", t, Am(d) ? "ShallowReadonly" : "Readonly"], "<", a(d), ">"
                ] : null : null
            },
            hasBody(d) {
                return d && d.__isVue
            },
            body(d) {
                if (d && d.__isVue) return ["div", {}, ...s(d.$)]
            }
        };

    function s(d) {
        const f = [];
        d.type.props && d.props && f.push(o("props", Me(d.props))), d.setupState !== ot && f.push(o("setup", d.setupState)), d.data !== ot && f.push(o("data", Me(d.data)));
        const h = l(d, "computed");
        h && f.push(o("computed", h));
        const p = l(d, "inject");
        return p && f.push(o("injected", p)), f.push(["div", {},
            ["span", {
                style: r.style + ";opacity:0.66"
            }, "$ (internal): "],
            ["object", {
                object: d
            }]
        ]), f
    }

    function o(d, f) {
        return f = St({}, f), Object.keys(f).length ? ["div", {
                style: "line-height:1.25em;margin-bottom:0.6em"
            },
            ["div", {
                style: "color:#476582"
            }, d],
            ["div", {
                style: "padding-left:1.25em"
            }, ...Object.keys(f).map(h => ["div", {},
                ["span", r, h + ": "], a(f[h], !1)
            ])]
        ] : ["span", {}]
    }

    function a(d, f = !0) {
        return typeof d == "number" ? ["span", e, d] : typeof d == "string" ? ["span", n, JSON.stringify(d)] : typeof d == "boolean" ? ["span", r, d] : ct(d) ? ["object", {
            object: f ? Me(d) : d
        }] : ["span", n, String(d)]
    }

    function l(d, f) {
        const h = d.type;
        if (Be(h)) return;
        const p = {};
        for (const b in d.ctx) c(h, b, f) && (p[b] = d.ctx[b]);
        return p
    }

    function c(d, f, h) {
        const p = d[h];
        if (De(p) && p.includes(f) || ct(p) && f in p || d.extends && c(d.extends, f, h) || d.mixins && d.mixins.some(b => c(b, f, h))) return !0
    }

    function u(d) {
        return Am(d) ? "ShallowRef" : d.effect ? "ComputedRef" : "Ref"
    }
    window.devtoolsFormatters ? window.devtoolsFormatters.push(i) : window.devtoolsFormatters = [i]
}

function kU(t, e, n, r) {
    const i = n[r];
    if (i && IO(i, t)) return i;
    const s = e();
    return s.memo = t.slice(), n[r] = s
}

function IO(t, e) {
    const n = t.memo;
    if (n.length != e.length) return !1;
    for (let r = 0; r < n.length; r++)
        if (Vy(n[r], e[r])) return !1;
    return qo > 0 && $n && $n.push(t), !0
}
const lv = "3.3.4",
    BU = {
        createComponentInstance: xO,
        setupComponent: EO,
        renderComponentRoot: Mf,
        setCurrentRenderingInstance: uu,
        isVNode: ci,
        normalizeVNode: kn
    },
    DU = BU,
    $U = null,
    FU = null;

function z_(t, e) {
    const n = Object.create(null),
        r = t.split(",");
    for (let i = 0; i < r.length; i++) n[r[i]] = !0;
    return e ? i => !!n[i.toLowerCase()] : i => !!n[i]
}
const Om = Object.freeze({}),
    LU = /^on[^a-z]/,
    NU = t => LU.test(t),
    UU = t => t.startsWith("onUpdate:"),
    td = Object.assign,
    Un = Array.isArray,
    nd = t => RO(t) === "[object Set]",
    fE = t => RO(t) === "[object Date]",
    MO = t => typeof t == "function",
    mu = t => typeof t == "string",
    hE = t => typeof t == "symbol",
    cv = t => t !== null && typeof t == "object",
    GU = Object.prototype.toString,
    RO = t => GU.call(t),
    j_ = t => {
        const e = Object.create(null);
        return n => e[n] || (e[n] = t(n))
    },
    HU = /-(\w)/g,
    Im = j_(t => t.replace(HU, (e, n) => n ? n.toUpperCase() : "")),
    zU = /\B([A-Z])/g,
    xs = j_(t => t.replace(zU, "-$1").toLowerCase()),
    jU = j_(t => t.charAt(0).toUpperCase() + t.slice(1)),
    VU = (t, e) => {
        for (let n = 0; n < t.length; n++) t[n](e)
    },
    uv = t => {
        const e = parseFloat(t);
        return isNaN(e) ? t : e
    },
    dv = t => {
        const e = mu(t) ? Number(t) : NaN;
        return isNaN(e) ? t : e
    },
    WU = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot",
    YU = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view",
    XU = z_(WU),
    qU = z_(YU),
    KU = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    JU = z_(KU);

function kO(t) {
    return !!t || t === ""
}

function ZU(t, e) {
    if (t.length !== e.length) return !1;
    let n = !0;
    for (let r = 0; n && r < t.length; r++) n = zs(t[r], e[r]);
    return n
}

function zs(t, e) {
    if (t === e) return !0;
    let n = fE(t),
        r = fE(e);
    if (n || r) return n && r ? t.getTime() === e.getTime() : !1;
    if (n = hE(t), r = hE(e), n || r) return t === e;
    if (n = Un(t), r = Un(e), n || r) return n && r ? ZU(t, e) : !1;
    if (n = cv(t), r = cv(e), n || r) {
        if (!n || !r) return !1;
        const i = Object.keys(t).length,
            s = Object.keys(e).length;
        if (i !== s) return !1;
        for (const o in t) {
            const a = t.hasOwnProperty(o),
                l = e.hasOwnProperty(o);
            if (a && !l || !a && l || !zs(t[o], e[o])) return !1
        }
    }
    return String(t) === String(e)
}

function yp(t, e) {
    return t.findIndex(n => zs(n, e))
}
const QU = "http://www.w3.org/2000/svg",
    So = typeof document < "u" ? document : null,
    pE = So && So.createElement("template"),
    eG = {
        insert: (t, e, n) => {
            e.insertBefore(t, n || null)
        },
        remove: t => {
            const e = t.parentNode;
            e && e.removeChild(t)
        },
        createElement: (t, e, n, r) => {
            const i = e ? So.createElementNS(QU, t) : So.createElement(t, n ? {
                is: n
            } : void 0);
            return t === "select" && r && r.multiple != null && i.setAttribute("multiple", r.multiple), i
        },
        createText: t => So.createTextNode(t),
        createComment: t => So.createComment(t),
        setText: (t, e) => {
            t.nodeValue = e
        },
        setElementText: (t, e) => {
            t.textContent = e
        },
        parentNode: t => t.parentNode,
        nextSibling: t => t.nextSibling,
        querySelector: t => So.querySelector(t),
        setScopeId(t, e) {
            t.setAttribute(e, "")
        },
        insertStaticContent(t, e, n, r, i, s) {
            const o = n ? n.previousSibling : e.lastChild;
            if (i && (i === s || i.nextSibling))
                for (; e.insertBefore(i.cloneNode(!0), n), !(i === s || !(i = i.nextSibling)););
            else {
                pE.innerHTML = r ? `<svg>${t}</svg>` : t;
                const a = pE.content;
                if (r) {
                    const l = a.firstChild;
                    for (; l.firstChild;) a.appendChild(l.firstChild);
                    a.removeChild(l)
                }
                e.insertBefore(a, n)
            }
            return [o ? o.nextSibling : e.firstChild, n ? n.previousSibling : e.lastChild]
        }
    };

function tG(t, e, n) {
    const r = t._vtc;
    r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? t.removeAttribute("class") : n ? t.setAttribute("class", e) : t.className = e
}

function nG(t, e, n) {
    const r = t.style,
        i = mu(n);
    if (n && !i) {
        if (e && !mu(e))
            for (const s in e) n[s] == null && fv(r, s, "");
        for (const s in n) fv(r, s, n[s])
    } else {
        const s = r.display;
        i ? e !== n && (r.cssText = n) : e && t.removeAttribute("style"), "_vod" in t && (r.display = s)
    }
}
const rG = /[^\\];\s*$/,
    mE = /\s*!important$/;

function fv(t, e, n) {
    if (Un(n)) n.forEach(r => fv(t, e, r));
    else if (n == null && (n = ""), rG.test(n) && re(`Unexpected semicolon at the end of '${e}' style value: '${n}'`), e.startsWith("--")) t.setProperty(e, n);
    else {
        const r = iG(t, e);
        mE.test(n) ? t.setProperty(xs(r), n.replace(mE, ""), "important") : t[r] = n
    }
}
const gE = ["Webkit", "Moz", "ms"],
    Mm = {};

function iG(t, e) {
    const n = Mm[e];
    if (n) return n;
    let r = Dr(e);
    if (r !== "filter" && r in t) return Mm[e] = r;
    r = jU(r);
    for (let i = 0; i < gE.length; i++) {
        const s = gE[i] + r;
        if (s in t) return Mm[e] = s
    }
    return e
}
const yE = "http://www.w3.org/1999/xlink";

function sG(t, e, n, r, i) {
    if (r && e.startsWith("xlink:")) n == null ? t.removeAttributeNS(yE, e.slice(6, e.length)) : t.setAttributeNS(yE, e, n);
    else {
        const s = JU(e);
        n == null || s && !kO(n) ? t.removeAttribute(e) : t.setAttribute(e, s ? "" : n)
    }
}

function oG(t, e, n, r, i, s, o) {
    if (e === "innerHTML" || e === "textContent") {
        r && o(r, i, s), t[e] = n ? ? "";
        return
    }
    const a = t.tagName;
    if (e === "value" && a !== "PROGRESS" && !a.includes("-")) {
        t._value = n;
        const c = a === "OPTION" ? t.getAttribute("value") : t.value,
            u = n ? ? "";
        c !== u && (t.value = u), n == null && t.removeAttribute(e);
        return
    }
    let l = !1;
    if (n === "" || n == null) {
        const c = typeof t[e];
        c === "boolean" ? n = kO(n) : n == null && c === "string" ? (n = "", l = !0) : c === "number" && (n = 0, l = !0)
    }
    try {
        t[e] = n
    } catch (c) {
        l || re(`Failed setting prop "${e}" on <${a.toLowerCase()}>: value ${n} is invalid.`, c)
    }
    l && t.removeAttribute(e)
}

function ki(t, e, n, r) {
    t.addEventListener(e, n, r)
}

function aG(t, e, n, r) {
    t.removeEventListener(e, n, r)
}

function lG(t, e, n, r, i = null) {
    const s = t._vei || (t._vei = {}),
        o = s[e];
    if (r && o) o.value = r;
    else {
        const [a, l] = cG(e);
        if (r) {
            const c = s[e] = fG(r, i);
            ki(t, a, c, l)
        } else o && (aG(t, a, o, l), s[e] = void 0)
    }
}
const vE = /(?:Once|Passive|Capture)$/;

function cG(t) {
    let e;
    if (vE.test(t)) {
        e = {};
        let r;
        for (; r = t.match(vE);) t = t.slice(0, t.length - r[0].length), e[r[0].toLowerCase()] = !0
    }
    return [t[2] === ":" ? t.slice(3) : xs(t.slice(2)), e]
}
let Rm = 0;
const uG = Promise.resolve(),
    dG = () => Rm || (uG.then(() => Rm = 0), Rm = Date.now());

function fG(t, e) {
    const n = r => {
        if (!r._vts) r._vts = Date.now();
        else if (r._vts <= n.attached) return;
        qn(hG(r, n.value), e, 5, [r])
    };
    return n.value = t, n.attached = dG(), n
}

function hG(t, e) {
    if (Un(e)) {
        const n = t.stopImmediatePropagation;
        return t.stopImmediatePropagation = () => {
            n.call(t), t._stopped = !0
        }, e.map(r => i => !i._stopped && r && r(i))
    } else return e
}
const _E = /^on[a-z]/,
    pG = (t, e, n, r, i = !1, s, o, a, l) => {
        e === "class" ? tG(t, r, i) : e === "style" ? nG(t, n, r) : NU(e) ? UU(e) || lG(t, e, n, r, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : mG(t, e, r, i)) ? oG(t, e, r, s, o, a, l) : (e === "true-value" ? t._trueValue = r : e === "false-value" && (t._falseValue = r), sG(t, e, r, i))
    };

function mG(t, e, n, r) {
    return r ? !!(e === "innerHTML" || e === "textContent" || e in t && _E.test(e) && MO(n)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && t.tagName === "INPUT" || e === "type" && t.tagName === "TEXTAREA" || _E.test(e) && mu(n) ? !1 : e in t
}

function BO(t, e) {
    const n = ve(t);
    class r extends vp {
        constructor(s) {
            super(n, s, e)
        }
    }
    return r.def = n, r
}
const gG = t => BO(t, KO),
    yG = typeof HTMLElement < "u" ? HTMLElement : class {};
class vp extends yG {
    constructor(e, n = {}, r) {
        super(), this._def = e, this._props = n, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this.shadowRoot && r ? r(this._createVNode(), this.shadowRoot) : (this.shadowRoot && re("Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`."), this.attachShadow({
            mode: "open"
        }), this._def.__asyncLoader || this._resolveProps(this._def))
    }
    connectedCallback() {
        this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef())
    }
    disconnectedCallback() {
        this._connected = !1, Ue(() => {
            this._connected || (mv(null, this.shadowRoot), this._instance = null)
        })
    }
    _resolveDef() {
        this._resolved = !0;
        for (let r = 0; r < this.attributes.length; r++) this._setAttr(this.attributes[r].name);
        new MutationObserver(r => {
            for (const i of r) this._setAttr(i.attributeName)
        }).observe(this, {
            attributes: !0
        });
        const e = (r, i = !1) => {
                const {
                    props: s,
                    styles: o
                } = r;
                let a;
                if (s && !Un(s))
                    for (const l in s) {
                        const c = s[l];
                        (c === Number || c && c.type === Number) && (l in this._props && (this._props[l] = dv(this._props[l])), (a || (a = Object.create(null)))[Im(l)] = !0)
                    }
                this._numberProps = a, i && this._resolveProps(r), this._applyStyles(o), this._update()
            },
            n = this._def.__asyncLoader;
        n ? n().then(r => e(r, !0)) : e(this._def)
    }
    _resolveProps(e) {
        const {
            props: n
        } = e, r = Un(n) ? n : Object.keys(n || {});
        for (const i of Object.keys(this)) i[0] !== "_" && r.includes(i) && this._setProp(i, this[i], !0, !1);
        for (const i of r.map(Im)) Object.defineProperty(this, i, {
            get() {
                return this._getProp(i)
            },
            set(s) {
                this._setProp(i, s)
            }
        })
    }
    _setAttr(e) {
        let n = this.getAttribute(e);
        const r = Im(e);
        this._numberProps && this._numberProps[r] && (n = dv(n)), this._setProp(r, n, !1)
    }
    _getProp(e) {
        return this._props[e]
    }
    _setProp(e, n, r = !0, i = !0) {
        n !== this._props[e] && (this._props[e] = n, i && this._instance && this._update(), r && (n === !0 ? this.setAttribute(xs(e), "") : typeof n == "string" || typeof n == "number" ? this.setAttribute(xs(e), n + "") : n || this.removeAttribute(xs(e))))
    }
    _update() {
        mv(this._createVNode(), this.shadowRoot)
    }
    _createVNode() {
        const e = I(this._def, td({}, this._props));
        return this._instance || (e.ce = n => {
            this._instance = n, n.isCE = !0, n.ceReload = s => {
                this._styles && (this._styles.forEach(o => this.shadowRoot.removeChild(o)), this._styles.length = 0), this._applyStyles(s), this._instance = null, this._update()
            };
            const r = (s, o) => {
                this.dispatchEvent(new CustomEvent(s, {
                    detail: o
                }))
            };
            n.emit = (s, ...o) => {
                r(s, o), xs(s) !== s && r(xs(s), o)
            };
            let i = this;
            for (; i = i && (i.parentNode || i.host);)
                if (i instanceof vp) {
                    n.parent = i._instance, n.provides = i._instance.provides;
                    break
                }
        }), e
    }
    _applyStyles(e) {
        e && e.forEach(n => {
            const r = document.createElement("style");
            r.textContent = n, this.shadowRoot.appendChild(r), (this._styles || (this._styles = [])).push(r)
        })
    }
}

function vG(t = "$style") {
    {
        const e = rt();
        if (!e) return re("useCssModule must be called inside setup()"), Om;
        const n = e.type.__cssModules;
        if (!n) return re("Current instance does not have CSS modules injected."), Om;
        const r = n[t];
        return r || (re(`Current instance does not have CSS module named "${t}".`), Om)
    }
}

function _G(t) {
    const e = rt();
    if (!e) {
        re("useCssVars is called without current active component instance.");
        return
    }
    const n = e.ut = (i = t(e.proxy)) => {
            Array.from(document.querySelectorAll(`[data-v-owner="${e.uid}"]`)).forEach(s => pv(s, i))
        },
        r = () => {
            const i = t(e.proxy);
            hv(e.subTree, i), n(i)
        };
    HA(r), _t(() => {
        const i = new MutationObserver(r);
        i.observe(e.subTree.el.parentNode, {
            childList: !0
        }), is(() => i.disconnect())
    })
}

function hv(t, e) {
    if (t.shapeFlag & 128) {
        const n = t.suspense;
        t = n.activeBranch, n.pendingBranch && !n.isHydrating && n.effects.push(() => {
            hv(n.activeBranch, e)
        })
    }
    for (; t.component;) t = t.component.subTree;
    if (t.shapeFlag & 1 && t.el) pv(t.el, e);
    else if (t.type === mt) t.children.forEach(n => hv(n, e));
    else if (t.type === Bs) {
        let {
            el: n,
            anchor: r
        } = t;
        for (; n && (pv(n, e), n !== r);) n = n.nextSibling
    }
}

function pv(t, e) {
    if (t.nodeType === 1) {
        const n = t.style;
        for (const r in e) n.setProperty(`--${r}`, e[r])
    }
}
const us = "transition",
    nc = "animation",
    rd = (t, {
        slots: e
    }) => Jt(VA, $O(t), e);
rd.displayName = "Transition";
const DO = {
        name: String,
        type: String,
        css: {
            type: Boolean,
            default: !0
        },
        duration: [String, Number, Object],
        enterFromClass: String,
        enterActiveClass: String,
        enterToClass: String,
        appearFromClass: String,
        appearActiveClass: String,
        appearToClass: String,
        leaveFromClass: String,
        leaveActiveClass: String,
        leaveToClass: String
    },
    bG = rd.props = td({}, k_, DO),
    co = (t, e = []) => {
        Un(t) ? t.forEach(n => n(...e)) : t && t(...e)
    },
    bE = t => t ? Un(t) ? t.some(e => e.length > 1) : t.length > 1 : !1;

function $O(t) {
    const e = {};
    for (const P in t) P in DO || (e[P] = t[P]);
    if (t.css === !1) return e;
    const {
        name: n = "v",
        type: r,
        duration: i,
        enterFromClass: s = `${n}-enter-from`,
        enterActiveClass: o = `${n}-enter-active`,
        enterToClass: a = `${n}-enter-to`,
        appearFromClass: l = s,
        appearActiveClass: c = o,
        appearToClass: u = a,
        leaveFromClass: d = `${n}-leave-from`,
        leaveActiveClass: f = `${n}-leave-active`,
        leaveToClass: h = `${n}-leave-to`
    } = t, p = xG(i), b = p && p[0], y = p && p[1], {
        onBeforeEnter: m,
        onEnter: g,
        onEnterCancelled: v,
        onLeave: _,
        onLeaveCancelled: x,
        onBeforeAppear: w = m,
        onAppear: E = g,
        onAppearCancelled: C = v
    } = e, A = (P, R, D) => {
        gs(P, R ? u : a), gs(P, R ? c : o), D && D()
    }, T = (P, R) => {
        P._isLeaving = !1, gs(P, d), gs(P, h), gs(P, f), R && R()
    }, S = P => (R, D) => {
        const H = P ? E : g,
            B = () => A(R, P, D);
        co(H, [R, B]), xE(() => {
            gs(R, P ? l : s), Ci(R, P ? u : a), bE(H) || wE(R, r, b, B)
        })
    };
    return td(e, {
        onBeforeEnter(P) {
            co(m, [P]), Ci(P, s), Ci(P, o)
        },
        onBeforeAppear(P) {
            co(w, [P]), Ci(P, l), Ci(P, c)
        },
        onEnter: S(!1),
        onAppear: S(!0),
        onLeave(P, R) {
            P._isLeaving = !0;
            const D = () => T(P, R);
            Ci(P, d), LO(), Ci(P, f), xE(() => {
                P._isLeaving && (gs(P, d), Ci(P, h), bE(_) || wE(P, r, y, D))
            }), co(_, [P, D])
        },
        onEnterCancelled(P) {
            A(P, !1), co(v, [P])
        },
        onAppearCancelled(P) {
            A(P, !0), co(C, [P])
        },
        onLeaveCancelled(P) {
            T(P), co(x, [P])
        }
    })
}

function xG(t) {
    if (t == null) return null;
    if (cv(t)) return [km(t.enter), km(t.leave)]; {
        const e = km(t);
        return [e, e]
    }
}

function km(t) {
    const e = dv(t);
    return w_(e, "<transition> explicit duration"), e
}

function Ci(t, e) {
    e.split(/\s+/).forEach(n => n && t.classList.add(n)), (t._vtc || (t._vtc = new Set)).add(e)
}

function gs(t, e) {
    e.split(/\s+/).forEach(r => r && t.classList.remove(r));
    const {
        _vtc: n
    } = t;
    n && (n.delete(e), n.size || (t._vtc = void 0))
}

function xE(t) {
    requestAnimationFrame(() => {
        requestAnimationFrame(t)
    })
}
let wG = 0;

function wE(t, e, n, r) {
    const i = t._endId = ++wG,
        s = () => {
            i === t._endId && r()
        };
    if (n) return setTimeout(s, n);
    const {
        type: o,
        timeout: a,
        propCount: l
    } = FO(t, e);
    if (!o) return r();
    const c = o + "end";
    let u = 0;
    const d = () => {
            t.removeEventListener(c, f), s()
        },
        f = h => {
            h.target === t && ++u >= l && d()
        };
    setTimeout(() => {
        u < l && d()
    }, a + 1), t.addEventListener(c, f)
}

function FO(t, e) {
    const n = window.getComputedStyle(t),
        r = p => (n[p] || "").split(", "),
        i = r(`${us}Delay`),
        s = r(`${us}Duration`),
        o = EE(i, s),
        a = r(`${nc}Delay`),
        l = r(`${nc}Duration`),
        c = EE(a, l);
    let u = null,
        d = 0,
        f = 0;
    e === us ? o > 0 && (u = us, d = o, f = s.length) : e === nc ? c > 0 && (u = nc, d = c, f = l.length) : (d = Math.max(o, c), u = d > 0 ? o > c ? us : nc : null, f = u ? u === us ? s.length : l.length : 0);
    const h = u === us && /\b(transform|all)(,|$)/.test(r(`${us}Property`).toString());
    return {
        type: u,
        timeout: d,
        propCount: f,
        hasTransform: h
    }
}

function EE(t, e) {
    for (; t.length < e.length;) t = t.concat(t);
    return Math.max(...e.map((n, r) => SE(n) + SE(t[r])))
}

function SE(t) {
    return Number(t.slice(0, -1).replace(",", ".")) * 1e3
}

function LO() {
    return document.body.offsetHeight
}
const NO = new WeakMap,
    UO = new WeakMap,
    GO = {
        name: "TransitionGroup",
        props: td({}, bG, {
            tag: String,
            moveClass: String
        }),
        setup(t, {
            slots: e
        }) {
            const n = rt(),
                r = R_();
            let i, s;
            return ga(() => {
                if (!i.length) return;
                const o = t.moveClass || `${t.name||"v"}-move`;
                if (!AG(i[0].el, n.vnode.el, o)) return;
                i.forEach(TG), i.forEach(CG);
                const a = i.filter(PG);
                LO(), a.forEach(l => {
                    const c = l.el,
                        u = c.style;
                    Ci(c, o), u.transform = u.webkitTransform = u.transitionDuration = "";
                    const d = c._moveCb = f => {
                        f && f.target !== c || (!f || /transform$/.test(f.propertyName)) && (c.removeEventListener("transitionend", d), c._moveCb = null, gs(c, o))
                    };
                    c.addEventListener("transitionend", d)
                })
            }), () => {
                const o = Me(t),
                    a = $O(o);
                let l = o.tag || mt;
                i = s, s = e.default ? lp(e.default()) : [];
                for (let c = 0; c < s.length; c++) {
                    const u = s[c];
                    u.key != null ? Xo(u, hl(u, a, r, n)) : re("<TransitionGroup> children must be keyed.")
                }
                if (i)
                    for (let c = 0; c < i.length; c++) {
                        const u = i[c];
                        Xo(u, hl(u, a, r, n)), NO.set(u, u.el.getBoundingClientRect())
                    }
                return I(l, null, s)
            }
        }
    },
    EG = t => delete t.mode;
GO.props;
const SG = GO;

function TG(t) {
    const e = t.el;
    e._moveCb && e._moveCb(), e._enterCb && e._enterCb()
}

function CG(t) {
    UO.set(t, t.el.getBoundingClientRect())
}

function PG(t) {
    const e = NO.get(t),
        n = UO.get(t),
        r = e.left - n.left,
        i = e.top - n.top;
    if (r || i) {
        const s = t.el.style;
        return s.transform = s.webkitTransform = `translate(${r}px,${i}px)`, s.transitionDuration = "0s", t
    }
}

function AG(t, e, n) {
    const r = t.cloneNode();
    t._vtc && t._vtc.forEach(o => {
        o.split(/\s+/).forEach(a => a && r.classList.remove(a))
    }), n.split(/\s+/).forEach(o => o && r.classList.add(o)), r.style.display = "none";
    const i = e.nodeType === 1 ? e : e.parentNode;
    i.appendChild(r);
    const {
        hasTransform: s
    } = FO(r);
    return i.removeChild(r), s
}
const js = t => {
    const e = t.props["onUpdate:modelValue"] || !1;
    return Un(e) ? n => VU(e, n) : e
};

function OG(t) {
    t.target.composing = !0
}

function TE(t) {
    const e = t.target;
    e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")))
}
const hh = {
        created(t, {
            modifiers: {
                lazy: e,
                trim: n,
                number: r
            }
        }, i) {
            t._assign = js(i);
            const s = r || i.props && i.props.type === "number";
            ki(t, e ? "change" : "input", o => {
                if (o.target.composing) return;
                let a = t.value;
                n && (a = a.trim()), s && (a = uv(a)), t._assign(a)
            }), n && ki(t, "change", () => {
                t.value = t.value.trim()
            }), e || (ki(t, "compositionstart", OG), ki(t, "compositionend", TE), ki(t, "change", TE))
        },
        mounted(t, {
            value: e
        }) {
            t.value = e ? ? ""
        },
        beforeUpdate(t, {
            value: e,
            modifiers: {
                lazy: n,
                trim: r,
                number: i
            }
        }, s) {
            if (t._assign = js(s), t.composing || document.activeElement === t && t.type !== "range" && (n || r && t.value.trim() === e || (i || t.type === "number") && uv(t.value) === e)) return;
            const o = e ? ? "";
            t.value !== o && (t.value = o)
        }
    },
    V_ = {
        deep: !0,
        created(t, e, n) {
            t._assign = js(n), ki(t, "change", () => {
                const r = t._modelValue,
                    i = ml(t),
                    s = t.checked,
                    o = t._assign;
                if (Un(r)) {
                    const a = yp(r, i),
                        l = a !== -1;
                    if (s && !l) o(r.concat(i));
                    else if (!s && l) {
                        const c = [...r];
                        c.splice(a, 1), o(c)
                    }
                } else if (nd(r)) {
                    const a = new Set(r);
                    s ? a.add(i) : a.delete(i), o(a)
                } else o(zO(t, s))
            })
        },
        mounted: CE,
        beforeUpdate(t, e, n) {
            t._assign = js(n), CE(t, e, n)
        }
    };

function CE(t, {
    value: e,
    oldValue: n
}, r) {
    t._modelValue = e, Un(e) ? t.checked = yp(e, r.props.value) > -1 : nd(e) ? t.checked = e.has(r.props.value) : e !== n && (t.checked = zs(e, zO(t, !0)))
}
const W_ = {
        created(t, {
            value: e
        }, n) {
            t.checked = zs(e, n.props.value), t._assign = js(n), ki(t, "change", () => {
                t._assign(ml(t))
            })
        },
        beforeUpdate(t, {
            value: e,
            oldValue: n
        }, r) {
            t._assign = js(r), e !== n && (t.checked = zs(e, r.props.value))
        }
    },
    HO = {
        deep: !0,
        created(t, {
            value: e,
            modifiers: {
                number: n
            }
        }, r) {
            const i = nd(e);
            ki(t, "change", () => {
                const s = Array.prototype.filter.call(t.options, o => o.selected).map(o => n ? uv(ml(o)) : ml(o));
                t._assign(t.multiple ? i ? new Set(s) : s : s[0])
            }), t._assign = js(r)
        },
        mounted(t, {
            value: e
        }) {
            PE(t, e)
        },
        beforeUpdate(t, e, n) {
            t._assign = js(n)
        },
        updated(t, {
            value: e
        }) {
            PE(t, e)
        }
    };

function PE(t, e) {
    const n = t.multiple;
    if (n && !Un(e) && !nd(e)) {
        re(`<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8,-1)}.`);
        return
    }
    for (let r = 0, i = t.options.length; r < i; r++) {
        const s = t.options[r],
            o = ml(s);
        if (n) Un(e) ? s.selected = yp(e, o) > -1 : s.selected = e.has(o);
        else if (zs(ml(s), e)) {
            t.selectedIndex !== r && (t.selectedIndex = r);
            return
        }
    }!n && t.selectedIndex !== -1 && (t.selectedIndex = -1)
}

function ml(t) {
    return "_value" in t ? t._value : t.value
}

function zO(t, e) {
    const n = e ? "_trueValue" : "_falseValue";
    return n in t ? t[n] : e
}
const jO = {
    created(t, e, n) {
        Dd(t, e, n, null, "created")
    },
    mounted(t, e, n) {
        Dd(t, e, n, null, "mounted")
    },
    beforeUpdate(t, e, n, r) {
        Dd(t, e, n, r, "beforeUpdate")
    },
    updated(t, e, n, r) {
        Dd(t, e, n, r, "updated")
    }
};

function VO(t, e) {
    switch (t) {
        case "SELECT":
            return HO;
        case "TEXTAREA":
            return hh;
        default:
            switch (e) {
                case "checkbox":
                    return V_;
                case "radio":
                    return W_;
                default:
                    return hh
            }
    }
}

function Dd(t, e, n, r, i) {
    const o = VO(t.tagName, n.props && n.props.type)[i];
    o && o(t, e, n, r)
}

function IG() {
    hh.getSSRProps = ({
        value: t
    }) => ({
        value: t
    }), W_.getSSRProps = ({
        value: t
    }, e) => {
        if (e.props && zs(e.props.value, t)) return {
            checked: !0
        }
    }, V_.getSSRProps = ({
        value: t
    }, e) => {
        if (Un(t)) {
            if (e.props && yp(t, e.props.value) > -1) return {
                checked: !0
            }
        } else if (nd(t)) {
            if (e.props && t.has(e.props.value)) return {
                checked: !0
            }
        } else if (t) return {
            checked: !0
        }
    }, jO.getSSRProps = (t, e) => {
        if (typeof e.type != "string") return;
        const n = VO(e.type.toUpperCase(), e.props && e.props.type);
        if (n.getSSRProps) return n.getSSRProps(t, e)
    }
}
const MG = ["ctrl", "shift", "alt", "meta"],
    RG = {
        stop: t => t.stopPropagation(),
        prevent: t => t.preventDefault(),
        self: t => t.target !== t.currentTarget,
        ctrl: t => !t.ctrlKey,
        shift: t => !t.shiftKey,
        alt: t => !t.altKey,
        meta: t => !t.metaKey,
        left: t => "button" in t && t.button !== 0,
        middle: t => "button" in t && t.button !== 1,
        right: t => "button" in t && t.button !== 2,
        exact: (t, e) => MG.some(n => t[`${n}Key`] && !e.includes(n))
    },
    kG = (t, e) => (n, ...r) => {
        for (let i = 0; i < e.length; i++) {
            const s = RG[e[i]];
            if (s && s(n, e)) return
        }
        return t(n, ...r)
    },
    BG = {
        esc: "escape",
        space: " ",
        up: "arrow-up",
        left: "arrow-left",
        right: "arrow-right",
        down: "arrow-down",
        delete: "backspace"
    },
    WO = (t, e) => n => {
        if (!("key" in n)) return;
        const r = xs(n.key);
        if (e.some(i => i === r || BG[i] === r)) return t(n)
    },
    yr = {
        beforeMount(t, {
            value: e
        }, {
            transition: n
        }) {
            t._vod = t.style.display === "none" ? "" : t.style.display, n && e ? n.beforeEnter(t) : rc(t, e)
        },
        mounted(t, {
            value: e
        }, {
            transition: n
        }) {
            n && e && n.enter(t)
        },
        updated(t, {
            value: e,
            oldValue: n
        }, {
            transition: r
        }) {
            !e != !n && (r ? e ? (r.beforeEnter(t), rc(t, !0), r.enter(t)) : r.leave(t, () => {
                rc(t, !1)
            }) : rc(t, e))
        },
        beforeUnmount(t, {
            value: e
        }) {
            rc(t, e)
        }
    };

function rc(t, e) {
    t.style.display = e ? t._vod : "none"
}

function DG() {
    yr.getSSRProps = ({
        value: t
    }) => {
        if (!t) return {
            style: {
                display: "none"
            }
        }
    }
}
const YO = td({
    patchProp: pG
}, eG);
let Uc, AE = !1;

function XO() {
    return Uc || (Uc = fO(YO))
}

function qO() {
    return Uc = AE ? Uc : hO(YO), AE = !0, Uc
}
const mv = (...t) => {
        XO().render(...t)
    },
    KO = (...t) => {
        qO().hydrate(...t)
    },
    JO = (...t) => {
        const e = XO().createApp(...t);
        ZO(e), QO(e);
        const {
            mount: n
        } = e;
        return e.mount = r => {
            const i = eI(r);
            if (!i) return;
            const s = e._component;
            !MO(s) && !s.render && !s.template && (s.template = i.innerHTML), i.innerHTML = "";
            const o = n(i, !1, i instanceof SVGElement);
            return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), o
        }, e
    },
    $G = (...t) => {
        const e = qO().createApp(...t);
        ZO(e), QO(e);
        const {
            mount: n
        } = e;
        return e.mount = r => {
            const i = eI(r);
            if (i) return n(i, !0, i instanceof SVGElement)
        }, e
    };

function ZO(t) {
    Object.defineProperty(t.config, "isNativeTag", {
        value: e => XU(e) || qU(e),
        writable: !1
    })
}

function QO(t) {
    if (H_()) {
        const e = t.config.isCustomElement;
        Object.defineProperty(t.config, "isCustomElement", {
            get() {
                return e
            },
            set() {
                re("The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.")
            }
        });
        const n = t.config.compilerOptions,
            r = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
        Object.defineProperty(t.config, "compilerOptions", {
            get() {
                return re(r), n
            },
            set() {
                re(r)
            }
        })
    }
}

function eI(t) {
    if (mu(t)) {
        const e = document.querySelector(t);
        return e || re(`Failed to mount app: mount target selector "${t}" returned null.`), e
    }
    return window.ShadowRoot && t instanceof window.ShadowRoot && t.mode === "closed" && re('mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'), t
}
let OE = !1;
const FG = () => {
    OE || (OE = !0, IG(), DG())
};

function LG() {
    OO()
}
LG();
const NG = () => {
        re('Runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".')
    },
    UG = Object.freeze(Object.defineProperty({
        __proto__: null,
        BaseTransition: VA,
        BaseTransitionPropsValidators: k_,
        Comment: It,
        EffectScope: p_,
        Fragment: mt,
        KeepAlive: b4,
        ReactiveEffect: Wu,
        Static: Bs,
        Suspense: c4,
        Teleport: dp,
        Text: li,
        Transition: rd,
        TransitionGroup: SG,
        VueElement: vp,
        assertNumber: w_,
        callWithAsyncErrorHandling: qn,
        callWithErrorHandling: ii,
        camelize: Dr,
        capitalize: fl,
        cloneVNode: _r,
        compatUtils: FU,
        compile: NG,
        computed: te,
        createApp: JO,
        createBlock: L_,
        createCommentVNode: EU,
        createElementBlock: vU,
        createElementVNode: N_,
        createHydrationRenderer: hO,
        createPropsRestProxy: V4,
        createRenderer: fO,
        createSSRApp: $G,
        createSlots: C4,
        createStaticVNode: wU,
        createTextVNode: pp,
        createVNode: I,
        customRef: SA,
        defineAsyncComponent: v4,
        defineComponent: ve,
        defineCustomElement: BO,
        defineEmits: B4,
        defineExpose: D4,
        defineModel: L4,
        defineOptions: $4,
        defineProps: k4,
        defineSSRCustomElement: gG,
        defineSlots: F4,
        get devtools() {
            return Cr
        },
        effect: B3,
        effectScope: ju,
        getCurrentInstance: rt,
        getCurrentScope: Vu,
        getTransitionRawChildren: lp,
        guardReactiveProps: _O,
        h: Jt,
        handleError: ma,
        hasInjectionContext: sO,
        hydrate: KO,
        initCustomFormatter: OO,
        initDirectivesForSSR: FG,
        inject: Nt,
        isMemoSame: IO,
        isProxy: ou,
        isReactive: Rr,
        isReadonly: Yi,
        isRef: et,
        isRuntimeOnly: H_,
        isShallow: su,
        isVNode: ci,
        markRaw: ni,
        mergeDefaults: z4,
        mergeModels: j4,
        mergeProps: Ke,
        nextTick: Ue,
        normalizeClass: Ju,
        normalizeProps: RN,
        normalizeStyle: Ku,
        onActivated: ns,
        onBeforeMount: XA,
        onBeforeUnmount: nr,
        onBeforeUpdate: up,
        onDeactivated: hi,
        onErrorCaptured: ZA,
        onMounted: _t,
        onRenderTracked: JA,
        onRenderTriggered: KA,
        onScopeDispose: m_,
        onServerPrefetch: qA,
        onUnmounted: is,
        onUpdated: ga,
        openBlock: fp,
        popScopeId: n4,
        provide: gr,
        proxyRefs: b_,
        pushScopeId: t4,
        queuePostFlushCb: sp,
        reactive: ft,
        readonly: pa,
        ref: q,
        registerRuntimeCompiler: AU,
        render: mv,
        renderList: T4,
        renderSlot: P4,
        resolveComponent: E4,
        resolveDirective: eO,
        resolveDynamicComponent: S4,
        resolveFilter: $U,
        resolveTransitionHooks: hl,
        setBlockTracking: rv,
        setDevtoolsHook: C_,
        setTransitionHooks: Xo,
        shallowReactive: wA,
        shallowReadonly: Ka,
        shallowRef: np,
        ssrContextKey: PO,
        ssrUtils: DU,
        stop: D3,
        toDisplayString: kN,
        toHandlerKey: Ii,
        toHandlers: A4,
        toRaw: Me,
        toRef: Rc,
        toRefs: zy,
        toValue: uN,
        transformVNodeArgs: _U,
        triggerRef: cN,
        unref: En,
        useAttrs: G4,
        useCssModule: vG,
        useCssVars: _G,
        useModel: H4,
        useSSRContext: AO,
        useSlots: U4,
        useTransitionState: R_,
        vModelCheckbox: V_,
        vModelDynamic: jO,
        vModelRadio: W_,
        vModelSelect: HO,
        vModelText: hh,
        vShow: yr,
        version: lv,
        warn: re,
        watch: he,
        watchEffect: Ul,
        watchPostEffect: HA,
        watchSyncEffect: m4,
        withAsyncContext: W4,
        withCtx: A_,
        withDefaults: N4,
        withDirectives: mr,
        withKeys: WO,
        withMemo: kU,
        withModifiers: kG,
        withScopeId: r4
    }, Symbol.toStringTag, {
        value: "Module"
    }));
var GG = !1;

function $d(t, e, n) {
    return Array.isArray(t) ? (t.length = Math.max(t.length, e), t.splice(e, 1, n), n) : (t[e] = n, n)
}

function Bm(t, e) {
    if (Array.isArray(t)) {
        t.splice(e, 1);
        return
    }
    delete t[e]
}

function HG() {
    return tI().__VUE_DEVTOOLS_GLOBAL_HOOK__
}

function tI() {
    return typeof navigator < "u" && typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : {}
}
const zG = typeof Proxy == "function",
    jG = "devtools-plugin:setup",
    VG = "plugin:settings:set";
let Ca, gv;

function WG() {
    var t;
    return Ca !== void 0 || (typeof window < "u" && window.performance ? (Ca = !0, gv = window.performance) : typeof globalThis < "u" && (!((t = globalThis.perf_hooks) === null || t === void 0) && t.performance) ? (Ca = !0, gv = globalThis.perf_hooks.performance) : Ca = !1), Ca
}

function YG() {
    return WG() ? gv.now() : Date.now()
}
class XG {
    constructor(e, n) {
        this.target = null, this.targetQueue = [], this.onQueue = [], this.plugin = e, this.hook = n;
        const r = {};
        if (e.settings)
            for (const o in e.settings) {
                const a = e.settings[o];
                r[o] = a.defaultValue
            }
        const i = `__vue-devtools-plugin-settings__${e.id}`;
        let s = Object.assign({}, r);
        try {
            const o = localStorage.getItem(i),
                a = JSON.parse(o);
            Object.assign(s, a)
        } catch {}
        this.fallbacks = {
            getSettings() {
                return s
            },
            setSettings(o) {
                try {
                    localStorage.setItem(i, JSON.stringify(o))
                } catch {}
                s = o
            },
            now() {
                return YG()
            }
        }, n && n.on(VG, (o, a) => {
            o === this.plugin.id && this.fallbacks.setSettings(a)
        }), this.proxiedOn = new Proxy({}, {
            get: (o, a) => this.target ? this.target.on[a] : (...l) => {
                this.onQueue.push({
                    method: a,
                    args: l
                })
            }
        }), this.proxiedTarget = new Proxy({}, {
            get: (o, a) => this.target ? this.target[a] : a === "on" ? this.proxiedOn : Object.keys(this.fallbacks).includes(a) ? (...l) => (this.targetQueue.push({
                method: a,
                args: l,
                resolve: () => {}
            }), this.fallbacks[a](...l)) : (...l) => new Promise(c => {
                this.targetQueue.push({
                    method: a,
                    args: l,
                    resolve: c
                })
            })
        })
    }
    async setRealTarget(e) {
        this.target = e;
        for (const n of this.onQueue) this.target.on[n.method](...n.args);
        for (const n of this.targetQueue) n.resolve(await this.target[n.method](...n.args))
    }
}

function _p(t, e) {
    const n = t,
        r = tI(),
        i = HG(),
        s = zG && n.enableEarlyProxy;
    if (i && (r.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !s)) i.emit(jG, t, e);
    else {
        const o = s ? new XG(n, i) : null;
        (r.__VUE_DEVTOOLS_PLUGINS__ = r.__VUE_DEVTOOLS_PLUGINS__ || []).push({
            pluginDescriptor: n,
            setupFn: e,
            proxy: o
        }), o && e(o.proxiedTarget)
    }
}
/*!
 * pinia v2.3.1
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let yv;
const gu = t => yv = t,
    nI = Symbol("pinia");

function Ko(t) {
    return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function"
}
var si;
(function(t) {
    t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function"
})(si || (si = {}));
const Go = typeof window < "u",
    IE = (() => typeof window == "object" && window.window === window ? window : typeof self == "object" && self.self === self ? self : typeof global == "object" && global.global === global ? global : typeof globalThis == "object" ? globalThis : {
        HTMLElement: null
    })();

function qG(t, {
    autoBom: e = !1
} = {}) {
    return e && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob([String.fromCharCode(65279), t], {
        type: t.type
    }) : t
}

function Y_(t, e, n) {
    const r = new XMLHttpRequest;
    r.open("GET", t), r.responseType = "blob", r.onload = function() {
        sI(r.response, e, n)
    }, r.onerror = function() {
        console.error("could not download file")
    }, r.send()
}

function rI(t) {
    const e = new XMLHttpRequest;
    e.open("HEAD", t, !1);
    try {
        e.send()
    } catch {}
    return e.status >= 200 && e.status <= 299
}

function kf(t) {
    try {
        t.dispatchEvent(new MouseEvent("click"))
    } catch {
        const n = document.createEvent("MouseEvents");
        n.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), t.dispatchEvent(n)
    }
}
const Bf = typeof navigator == "object" ? navigator : {
        userAgent: ""
    },
    iI = (() => /Macintosh/.test(Bf.userAgent) && /AppleWebKit/.test(Bf.userAgent) && !/Safari/.test(Bf.userAgent))(),
    sI = Go ? typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype && !iI ? KG : "msSaveOrOpenBlob" in Bf ? JG : ZG : () => {};

function KG(t, e = "download", n) {
    const r = document.createElement("a");
    r.download = e, r.rel = "noopener", typeof t == "string" ? (r.href = t, r.origin !== location.origin ? rI(r.href) ? Y_(t, e, n) : (r.target = "_blank", kf(r)) : kf(r)) : (r.href = URL.createObjectURL(t), setTimeout(function() {
        URL.revokeObjectURL(r.href)
    }, 4e4), setTimeout(function() {
        kf(r)
    }, 0))
}

function JG(t, e = "download", n) {
    if (typeof t == "string")
        if (rI(t)) Y_(t, e, n);
        else {
            const r = document.createElement("a");
            r.href = t, r.target = "_blank", setTimeout(function() {
                kf(r)
            })
        }
    else navigator.msSaveOrOpenBlob(qG(t, n), e)
}

function ZG(t, e, n, r) {
    if (r = r || open("", "_blank"), r && (r.document.title = r.document.body.innerText = "downloading..."), typeof t == "string") return Y_(t, e, n);
    const i = t.type === "application/octet-stream",
        s = /constructor/i.test(String(IE.HTMLElement)) || "safari" in IE,
        o = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((o || i && s || iI) && typeof FileReader < "u") {
        const a = new FileReader;
        a.onloadend = function() {
            let l = a.result;
            if (typeof l != "string") throw r = null, new Error("Wrong reader.result type");
            l = o ? l : l.replace(/^data:[^;]*;/, "data:attachment/file;"), r ? r.location.href = l : location.assign(l), r = null
        }, a.readAsDataURL(t)
    } else {
        const a = URL.createObjectURL(t);
        r ? r.location.assign(a) : location.href = a, r = null, setTimeout(function() {
            URL.revokeObjectURL(a)
        }, 4e4)
    }
}

function Kt(t, e) {
    const n = " " + t;
    typeof __VUE_DEVTOOLS_TOAST__ == "function" ? __VUE_DEVTOOLS_TOAST__(n, e) : e === "error" ? console.error(n) : e === "warn" ? console.warn(n) : console.log(n)
}

function X_(t) {
    return "_a" in t && "install" in t
}

function oI() {
    if (!("clipboard" in navigator)) return Kt("Your browser doesn't support the Clipboard API", "error"), !0
}

function aI(t) {
    return t instanceof Error && t.message.toLowerCase().includes("document is not focused") ? (Kt('You need to activate the "Emulate a focused page" setting in the "Rendering" panel of devtools.', "warn"), !0) : !1
}
async function QG(t) {
    if (!oI()) try {
        await navigator.clipboard.writeText(JSON.stringify(t.state.value)), Kt("Global state copied to clipboard.")
    } catch (e) {
        if (aI(e)) return;
        Kt("Failed to serialize the state. Check the console for more details.", "error"), console.error(e)
    }
}
async function e6(t) {
    if (!oI()) try {
        lI(t, JSON.parse(await navigator.clipboard.readText())), Kt("Global state pasted from clipboard.")
    } catch (e) {
        if (aI(e)) return;
        Kt("Failed to deserialize the state from clipboard. Check the console for more details.", "error"), console.error(e)
    }
}
async function t6(t) {
    try {
        sI(new Blob([JSON.stringify(t.state.value)], {
            type: "text/plain;charset=utf-8"
        }), "pinia-state.json")
    } catch (e) {
        Kt("Failed to export the state as JSON. Check the console for more details.", "error"), console.error(e)
    }
}
let vi;

function n6() {
    vi || (vi = document.createElement("input"), vi.type = "file", vi.accept = ".json");

    function t() {
        return new Promise((e, n) => {
            vi.onchange = async () => {
                const r = vi.files;
                if (!r) return e(null);
                const i = r.item(0);
                return e(i ? {
                    text: await i.text(),
                    file: i
                } : null)
            }, vi.oncancel = () => e(null), vi.onerror = n, vi.click()
        })
    }
    return t
}
async function r6(t) {
    try {
        const n = await n6()();
        if (!n) return;
        const {
            text: r,
            file: i
        } = n;
        lI(t, JSON.parse(r)), Kt(`Global state imported from "${i.name}".`)
    } catch (e) {
        Kt("Failed to import the state from JSON. Check the console for more details.", "error"), console.error(e)
    }
}

function lI(t, e) {
    for (const n in e) {
        const r = t.state.value[n];
        r ? Object.assign(r, e[n]) : t.state.value[n] = e[n]
    }
}

function Tr(t) {
    return {
        _custom: {
            display: t
        }
    }
}
const cI = " Pinia (root)",
    Df = "_root";

function i6(t) {
    return X_(t) ? {
        id: Df,
        label: cI
    } : {
        id: t.$id,
        label: t.$id
    }
}

function s6(t) {
    if (X_(t)) {
        const n = Array.from(t._s.keys()),
            r = t._s;
        return {
            state: n.map(s => ({
                editable: !0,
                key: s,
                value: t.state.value[s]
            })),
            getters: n.filter(s => r.get(s)._getters).map(s => {
                const o = r.get(s);
                return {
                    editable: !1,
                    key: s,
                    value: o._getters.reduce((a, l) => (a[l] = o[l], a), {})
                }
            })
        }
    }
    const e = {
        state: Object.keys(t.$state).map(n => ({
            editable: !0,
            key: n,
            value: t.$state[n]
        }))
    };
    return t._getters && t._getters.length && (e.getters = t._getters.map(n => ({
        editable: !1,
        key: n,
        value: t[n]
    }))), t._customProperties.size && (e.customProperties = Array.from(t._customProperties).map(n => ({
        editable: !0,
        key: n,
        value: t[n]
    }))), e
}

function o6(t) {
    return t ? Array.isArray(t) ? t.reduce((e, n) => (e.keys.push(n.key), e.operations.push(n.type), e.oldValue[n.key] = n.oldValue, e.newValue[n.key] = n.newValue, e), {
        oldValue: {},
        keys: [],
        operations: [],
        newValue: {}
    }) : {
        operation: Tr(t.type),
        key: Tr(t.key),
        oldValue: t.oldValue,
        newValue: t.newValue
    } : {}
}

function a6(t) {
    switch (t) {
        case si.direct:
            return "mutation";
        case si.patchFunction:
            return "$patch";
        case si.patchObject:
            return "$patch";
        default:
            return "unknown"
    }
}
let Ja = !0;
const $f = [],
    yo = "pinia:mutations",
    an = "pinia",
    {
        assign: l6
    } = Object,
    ph = t => " " + t;

function c6(t, e) {
    _p({
        id: "dev.esm.pinia",
        label: "Pinia ",
        logo: "https://pinia.vuejs.org/logo.svg",
        packageName: "pinia",
        homepage: "https://pinia.vuejs.org",
        componentStateTypes: $f,
        app: t
    }, n => {
        typeof n.now != "function" && Kt("You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), n.addTimelineLayer({
            id: yo,
            label: "Pinia ",
            color: 15064968
        }), n.addInspector({
            id: an,
            label: "Pinia ",
            icon: "storage",
            treeFilterPlaceholder: "Search stores",
            actions: [{
                icon: "content_copy",
                action: () => {
                    QG(e)
                },
                tooltip: "Serialize and copy the state"
            }, {
                icon: "content_paste",
                action: async () => {
                    await e6(e), n.sendInspectorTree(an), n.sendInspectorState(an)
                },
                tooltip: "Replace the state with the content of your clipboard"
            }, {
                icon: "save",
                action: () => {
                    t6(e)
                },
                tooltip: "Save the state as a JSON file"
            }, {
                icon: "folder_open",
                action: async () => {
                    await r6(e), n.sendInspectorTree(an), n.sendInspectorState(an)
                },
                tooltip: "Import the state from a JSON file"
            }],
            nodeActions: [{
                icon: "restore",
                tooltip: 'Reset the state (with "$reset")',
                action: r => {
                    const i = e._s.get(r);
                    i ? typeof i.$reset != "function" ? Kt(`Cannot reset "${r}" store because it doesn't have a "$reset" method implemented.`, "warn") : (i.$reset(), Kt(`Store "${r}" reset.`)) : Kt(`Cannot reset "${r}" store because it wasn't found.`, "warn")
                }
            }]
        }), n.on.inspectComponent((r, i) => {
            const s = r.componentInstance && r.componentInstance.proxy;
            if (s && s._pStores) {
                const o = r.componentInstance.proxy._pStores;
                Object.values(o).forEach(a => {
                    r.instanceData.state.push({
                        type: ph(a.$id),
                        key: "state",
                        editable: !0,
                        value: a._isOptionsAPI ? {
                            _custom: {
                                value: Me(a.$state),
                                actions: [{
                                    icon: "restore",
                                    tooltip: "Reset the state of this store",
                                    action: () => a.$reset()
                                }]
                            }
                        } : Object.keys(a.$state).reduce((l, c) => (l[c] = a.$state[c], l), {})
                    }), a._getters && a._getters.length && r.instanceData.state.push({
                        type: ph(a.$id),
                        key: "getters",
                        editable: !1,
                        value: a._getters.reduce((l, c) => {
                            try {
                                l[c] = a[c]
                            } catch (u) {
                                l[c] = u
                            }
                            return l
                        }, {})
                    })
                })
            }
        }), n.on.getInspectorTree(r => {
            if (r.app === t && r.inspectorId === an) {
                let i = [e];
                i = i.concat(Array.from(e._s.values())), r.rootNodes = (r.filter ? i.filter(s => "$id" in s ? s.$id.toLowerCase().includes(r.filter.toLowerCase()) : cI.toLowerCase().includes(r.filter.toLowerCase())) : i).map(i6)
            }
        }), globalThis.$pinia = e, n.on.getInspectorState(r => {
            if (r.app === t && r.inspectorId === an) {
                const i = r.nodeId === Df ? e : e._s.get(r.nodeId);
                if (!i) return;
                i && (r.nodeId !== Df && (globalThis.$store = Me(i)), r.state = s6(i))
            }
        }), n.on.editInspectorState((r, i) => {
            if (r.app === t && r.inspectorId === an) {
                const s = r.nodeId === Df ? e : e._s.get(r.nodeId);
                if (!s) return Kt(`store "${r.nodeId}" not found`, "error");
                const {
                    path: o
                } = r;
                X_(s) ? o.unshift("state") : (o.length !== 1 || !s._customProperties.has(o[0]) || o[0] in s.$state) && o.unshift("$state"), Ja = !1, r.set(s, o, r.state.value), Ja = !0
            }
        }), n.on.editComponentState(r => {
            if (r.type.startsWith("")) {
                const i = r.type.replace(/^\s*/, ""),
                    s = e._s.get(i);
                if (!s) return Kt(`store "${i}" not found`, "error");
                const {
                    path: o
                } = r;
                if (o[0] !== "state") return Kt(`Invalid path for store "${i}":
${o}
Only state can be modified.`);
                o[0] = "$state", Ja = !1, r.set(s, o, r.state.value), Ja = !0
            }
        })
    })
}

function u6(t, e) {
    $f.includes(ph(e.$id)) || $f.push(ph(e.$id)), _p({
        id: "dev.esm.pinia",
        label: "Pinia ",
        logo: "https://pinia.vuejs.org/logo.svg",
        packageName: "pinia",
        homepage: "https://pinia.vuejs.org",
        componentStateTypes: $f,
        app: t,
        settings: {
            logStoreChanges: {
                label: "Notify about new/deleted stores",
                type: "boolean",
                defaultValue: !0
            }
        }
    }, n => {
        const r = typeof n.now == "function" ? n.now.bind(n) : Date.now;
        e.$onAction(({
            after: o,
            onError: a,
            name: l,
            args: c
        }) => {
            const u = uI++;
            n.addTimelineEvent({
                layerId: yo,
                event: {
                    time: r(),
                    title: " " + l,
                    subtitle: "start",
                    data: {
                        store: Tr(e.$id),
                        action: Tr(l),
                        args: c
                    },
                    groupId: u
                }
            }), o(d => {
                Ss = void 0, n.addTimelineEvent({
                    layerId: yo,
                    event: {
                        time: r(),
                        title: " " + l,
                        subtitle: "end",
                        data: {
                            store: Tr(e.$id),
                            action: Tr(l),
                            args: c,
                            result: d
                        },
                        groupId: u
                    }
                })
            }), a(d => {
                Ss = void 0, n.addTimelineEvent({
                    layerId: yo,
                    event: {
                        time: r(),
                        logType: "error",
                        title: " " + l,
                        subtitle: "end",
                        data: {
                            store: Tr(e.$id),
                            action: Tr(l),
                            args: c,
                            error: d
                        },
                        groupId: u
                    }
                })
            })
        }, !0), e._customProperties.forEach(o => {
            he(() => En(e[o]), (a, l) => {
                n.notifyComponentUpdate(), n.sendInspectorState(an), Ja && n.addTimelineEvent({
                    layerId: yo,
                    event: {
                        time: r(),
                        title: "Change",
                        subtitle: o,
                        data: {
                            newValue: a,
                            oldValue: l
                        },
                        groupId: Ss
                    }
                })
            }, {
                deep: !0
            })
        }), e.$subscribe(({
            events: o,
            type: a
        }, l) => {
            if (n.notifyComponentUpdate(), n.sendInspectorState(an), !Ja) return;
            const c = {
                time: r(),
                title: a6(a),
                data: l6({
                    store: Tr(e.$id)
                }, o6(o)),
                groupId: Ss
            };
            a === si.patchFunction ? c.subtitle = "" : a === si.patchObject ? c.subtitle = "" : o && !Array.isArray(o) && (c.subtitle = o.type), o && (c.data["rawEvent(s)"] = {
                _custom: {
                    display: "DebuggerEvent",
                    type: "object",
                    tooltip: "raw DebuggerEvent[]",
                    value: o
                }
            }), n.addTimelineEvent({
                layerId: yo,
                event: c
            })
        }, {
            detached: !0,
            flush: "sync"
        });
        const i = e._hotUpdate;
        e._hotUpdate = ni(o => {
            i(o), n.addTimelineEvent({
                layerId: yo,
                event: {
                    time: r(),
                    title: " " + e.$id,
                    subtitle: "HMR update",
                    data: {
                        store: Tr(e.$id),
                        info: Tr("HMR update")
                    }
                }
            }), n.notifyComponentUpdate(), n.sendInspectorTree(an), n.sendInspectorState(an)
        });
        const {
            $dispose: s
        } = e;
        e.$dispose = () => {
            s(), n.notifyComponentUpdate(), n.sendInspectorTree(an), n.sendInspectorState(an), n.getSettings().logStoreChanges && Kt(`Disposed "${e.$id}" store `)
        }, n.notifyComponentUpdate(), n.sendInspectorTree(an), n.sendInspectorState(an), n.getSettings().logStoreChanges && Kt(`"${e.$id}" store installed `)
    })
}
let uI = 0,
    Ss;

function ME(t, e, n) {
    const r = e.reduce((i, s) => (i[s] = Me(t)[s], i), {});
    for (const i in r) t[i] = function() {
        const s = uI,
            o = n ? new Proxy(t, {
                get(...l) {
                    return Ss = s, Reflect.get(...l)
                },
                set(...l) {
                    return Ss = s, Reflect.set(...l)
                }
            }) : t;
        Ss = s;
        const a = r[i].apply(o, arguments);
        return Ss = void 0, a
    }
}

function d6({
    app: t,
    store: e,
    options: n
}) {
    if (!e.$id.startsWith("__hot:")) {
        if (e._isOptionsAPI = !!n.state, !e._p._testing) {
            ME(e, Object.keys(n.actions), e._isOptionsAPI);
            const r = e._hotUpdate;
            Me(e)._hotUpdate = function(i) {
                r.apply(this, arguments), ME(e, Object.keys(i._hmrPayload.actions), !!e._isOptionsAPI)
            }
        }
        u6(t, e)
    }
}

function Fbe() {
    const t = ju(!0),
        e = t.run(() => q({}));
    let n = [],
        r = [];
    const i = ni({
        install(s) {
            gu(i), i._a = s, s.provide(nI, i), s.config.globalProperties.$pinia = i, Go && c6(s, i), r.forEach(o => n.push(o)), r = []
        },
        use(s) {
            return !this._a && !GG ? r.push(s) : n.push(s), this
        },
        _p: n,
        _a: null,
        _e: t,
        _s: new Map,
        state: e
    });
    return Go && typeof Proxy < "u" && i.use(d6), i
}

function dI(t, e) {
    for (const n in e) {
        const r = e[n];
        if (!(n in t)) continue;
        const i = t[n];
        Ko(i) && Ko(r) && !et(r) && !Rr(r) ? t[n] = dI(i, r) : t[n] = r
    }
    return t
}
const f6 = () => {};

function RE(t, e, n, r = f6) {
    t.push(e);
    const i = () => {
        const s = t.indexOf(e);
        s > -1 && (t.splice(s, 1), r())
    };
    return !n && Vu() && m_(i), i
}

function Pa(t, ...e) {
    t.slice().forEach(n => {
        n(...e)
    })
}
const h6 = t => t(),
    kE = Symbol(),
    Dm = Symbol();

function vv(t, e) {
    t instanceof Map && e instanceof Map ? e.forEach((n, r) => t.set(r, n)) : t instanceof Set && e instanceof Set && e.forEach(t.add, t);
    for (const n in e) {
        if (!e.hasOwnProperty(n)) continue;
        const r = e[n],
            i = t[n];
        Ko(i) && Ko(r) && t.hasOwnProperty(n) && !et(r) && !Rr(r) ? t[n] = vv(i, r) : t[n] = r
    }
    return t
}
const p6 = Symbol("pinia:skipHydration");

function m6(t) {
    return !Ko(t) || !t.hasOwnProperty(p6)
}
const {
    assign: ur
} = Object;

function BE(t) {
    return !!(et(t) && t.effect)
}

function DE(t, e, n, r) {
    const {
        state: i,
        actions: s,
        getters: o
    } = e, a = n.state.value[t];
    let l;

    function c() {
        !a && !r && (n.state.value[t] = i ? i() : {});
        const u = zy(r ? q(i ? i() : {}).value : n.state.value[t]);
        return ur(u, s, Object.keys(o || {}).reduce((d, f) => (f in u && console.warn(`[]: A getter cannot have the same name as another state property. Rename one of them. Found with "${f}" in store "${t}".`), d[f] = ni(te(() => {
            gu(n);
            const h = n._s.get(t);
            return o[f].call(h, h)
        })), d), {}))
    }
    return l = _v(t, c, e, n, r, !0), l
}

function _v(t, e, n = {}, r, i, s) {
    let o;
    const a = ur({
        actions: {}
    }, n);
    if (!r._e.active) throw new Error("Pinia destroyed");
    const l = {
        deep: !0
    };
    l.onTrigger = T => {
        c ? h = T : c == !1 && !E._hotUpdating && (Array.isArray(h) ? h.push(T) : console.error(" debuggerEvents should be an array. This is most likely an internal Pinia bug."))
    };
    let c, u, d = [],
        f = [],
        h;
    const p = r.state.value[t];
    !s && !p && !i && (r.state.value[t] = {});
    const b = q({});
    let y;

    function m(T) {
        let S;
        c = u = !1, h = [], typeof T == "function" ? (T(r.state.value[t]), S = {
            type: si.patchFunction,
            storeId: t,
            events: h
        }) : (vv(r.state.value[t], T), S = {
            type: si.patchObject,
            payload: T,
            storeId: t,
            events: h
        });
        const P = y = Symbol();
        Ue().then(() => {
            y === P && (c = !0)
        }), u = !0, Pa(d, S, r.state.value[t])
    }
    const g = s ? function() {
        const {
            state: S
        } = n, P = S ? S() : {};
        this.$patch(R => {
            ur(R, P)
        })
    } : () => {
        throw new Error(`: Store "${t}" is built using the setup syntax and does not implement $reset().`)
    };

    function v() {
        o.stop(), d = [], f = [], r._s.delete(t)
    }
    const _ = (T, S = "") => {
            if (kE in T) return T[Dm] = S, T;
            const P = function() {
                gu(r);
                const R = Array.from(arguments),
                    D = [],
                    H = [];

                function B(Y) {
                    D.push(Y)
                }

                function N(Y) {
                    H.push(Y)
                }
                Pa(f, {
                    args: R,
                    name: P[Dm],
                    store: E,
                    after: B,
                    onError: N
                });
                let V;
                try {
                    V = T.apply(this && this.$id === t ? this : E, R)
                } catch (Y) {
                    throw Pa(H, Y), Y
                }
                return V instanceof Promise ? V.then(Y => (Pa(D, Y), Y)).catch(Y => (Pa(H, Y), Promise.reject(Y))) : (Pa(D, V), V)
            };
            return P[kE] = !0, P[Dm] = S, P
        },
        x = ni({
            actions: {},
            getters: {},
            state: [],
            hotState: b
        }),
        w = {
            _p: r,
            $id: t,
            $onAction: RE.bind(null, f),
            $patch: m,
            $reset: g,
            $subscribe(T, S = {}) {
                const P = RE(d, T, S.detached, () => R()),
                    R = o.run(() => he(() => r.state.value[t], D => {
                        (S.flush === "sync" ? u : c) && T({
                            storeId: t,
                            type: si.direct,
                            events: h
                        }, D)
                    }, ur({}, l, S)));
                return P
            },
            $dispose: v
        },
        E = ft(ur({
            _hmrPayload: x,
            _customProperties: ni(new Set)
        }, w));
    r._s.set(t, E);
    const A = (r._a && r._a.runWithContext || h6)(() => r._e.run(() => (o = ju()).run(() => e({
        action: _
    }))));
    for (const T in A) {
        const S = A[T];
        if (et(S) && !BE(S) || Rr(S)) i ? $d(b.value, T, Rc(A, T)) : s || (p && m6(S) && (et(S) ? S.value = p[T] : vv(S, p[T])), r.state.value[t][T] = S), x.state.push(T);
        else if (typeof S == "function") {
            const P = i ? S : _(S, T);
            A[T] = P, x.actions[T] = S, a.actions[T] = S
        } else BE(S) && (x.getters[T] = s ? n.getters[T] : S, Go && (A._getters || (A._getters = ni([]))).push(T))
    }
    if (ur(E, A), ur(Me(E), A), Object.defineProperty(E, "$state", {
            get: () => i ? b.value : r.state.value[t],
            set: T => {
                if (i) throw new Error("cannot set hotState");
                m(S => {
                    ur(S, T)
                })
            }
        }), E._hotUpdate = ni(T => {
            E._hotUpdating = !0, T._hmrPayload.state.forEach(S => {
                if (S in E.$state) {
                    const P = T.$state[S],
                        R = E.$state[S];
                    typeof P == "object" && Ko(P) && Ko(R) ? dI(P, R) : T.$state[S] = R
                }
                $d(E, S, Rc(T.$state, S))
            }), Object.keys(E.$state).forEach(S => {
                S in T.$state || Bm(E, S)
            }), c = !1, u = !1, r.state.value[t] = Rc(T._hmrPayload, "hotState"), u = !0, Ue().then(() => {
                c = !0
            });
            for (const S in T._hmrPayload.actions) {
                const P = T[S];
                $d(E, S, _(P, S))
            }
            for (const S in T._hmrPayload.getters) {
                const P = T._hmrPayload.getters[S],
                    R = s ? te(() => (gu(r), P.call(E, E))) : P;
                $d(E, S, R)
            }
            Object.keys(E._hmrPayload.getters).forEach(S => {
                S in T._hmrPayload.getters || Bm(E, S)
            }), Object.keys(E._hmrPayload.actions).forEach(S => {
                S in T._hmrPayload.actions || Bm(E, S)
            }), E._hmrPayload = T._hmrPayload, E._getters = T._getters, E._hotUpdating = !1
        }), Go) {
        const T = {
            writable: !0,
            configurable: !0,
            enumerable: !1
        };
        ["_p", "_hmrPayload", "_getters", "_customProperties"].forEach(S => {
            Object.defineProperty(E, S, ur({
                value: E[S]
            }, T))
        })
    }
    return r._p.forEach(T => {
        if (Go) {
            const S = o.run(() => T({
                store: E,
                app: r._a,
                pinia: r,
                options: a
            }));
            Object.keys(S || {}).forEach(P => E._customProperties.add(P)), ur(E, S)
        } else ur(E, o.run(() => T({
            store: E,
            app: r._a,
            pinia: r,
            options: a
        })))
    }), E.$state && typeof E.$state == "object" && typeof E.$state.constructor == "function" && !E.$state.constructor.toString().includes("[native code]") && console.warn(`[]: The "state" must be a plain object. It cannot be
	state: () => new MyClass()
Found in store "${E.$id}".`), p && s && n.hydrate && n.hydrate(E.$state, p), c = !0, u = !0, E
} /*! #__NO_SIDE_EFFECTS__ */
function Lbe(t, e, n) {
    let r, i;
    const s = typeof e == "function";
    if (typeof t == "string") r = t, i = s ? n : e;
    else if (i = t, r = t.id, typeof r != "string") throw new Error('[]: "defineStore()" must be passed a store id as its first argument.');

    function o(a, l) {
        const c = sO();
        if (a = a || (c ? Nt(nI, null) : null), a && gu(a), !yv) throw new Error(`[]: "getActivePinia()" was called but there was no active Pinia. Are you trying to use a store before calling "app.use(pinia)"?
See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.
This will fail in production.`);
        a = yv, a._s.has(r) || (s ? _v(r, e, i, a) : DE(r, i, a), o._pinia = a);
        const u = a._s.get(r);
        if (l) {
            const d = "__hot:" + r,
                f = s ? _v(d, e, i, a, !0) : DE(d, ur({}, i), a, !0);
            l._hotUpdate(f), delete a.state.value[d], a._s.delete(d)
        }
        if (Go) {
            const d = rt();
            if (d && d.proxy && !l) {
                const f = d.proxy,
                    h = "_pStores" in f ? f._pStores : f._pStores = {};
                h[r] = u
            }
        }
        return u
    }
    return o.$id = r, o
}(function(t, e) {
    var n = t.document,
        r = n.documentElement,
        i = n.querySelector('meta[name="viewport"]'),
        s = n.querySelector('meta[name="flexible"]'),
        o = 0,
        a = 0,
        l, c = e.flexible || (e.flexible = {});
    if (i) {
        var u = i.getAttribute("content").match(/initial\-scale=([\d\.]+)/);
        u && (a = parseFloat(u[1]), o = parseInt(1 / a))
    } else if (s) {
        var d = s.getAttribute("content");
        if (d) {
            var f = d.match(/initial\-dpr=([\d\.]+)/),
                h = d.match(/maximum\-dpr=([\d\.]+)/);
            f && (o = parseFloat(f[1]), a = parseFloat((1 / o).toFixed(2))), h && (o = parseFloat(h[1]), a = parseFloat((1 / o).toFixed(2)))
        }
    }
    if (!o && !a) {
        t.navigator.appVersion.match(/android/gi);
        var p = t.navigator.appVersion.match(/iphone/gi),
            b = t.devicePixelRatio;
        p ? b >= 3 && (!o || o >= 3) ? o = 3 : b >= 2 && (!o || o >= 2) ? o = 2 : o = 1 : o = 1, a = 1 / o
    }
    if (r.setAttribute("data-dpr", o), !i)
        if (i = n.createElement("meta"), i.setAttribute("name", "viewport"), i.setAttribute("content", "initial-scale=" + a + ", maximum-scale=" + a + ", minimum-scale=" + a + ", user-scalable=no"), r.firstElementChild) r.firstElementChild.appendChild(i);
        else {
            var y = n.createElement("div");
            y.appendChild(i), n.write(y.innerHTML)
        }
    function m() {
        var g = r.getBoundingClientRect().width;
        g / o > 540 && (g = 540 * o);
        var v = g / 10;
        r.style.fontSize = v + "px", c.rem = t.rem = v
    }
    t.addEventListener("resize", function() {
        clearTimeout(l), l = setTimeout(m, 300)
    }, !1), t.addEventListener("pageshow", function(g) {
        g.persisted && (clearTimeout(l), l = setTimeout(m, 300))
    }, !1), n.readyState === "complete" ? n.body.style.fontSize = 12 * o + "px" : n.addEventListener("DOMContentLoaded", function(g) {
        n.body.style.fontSize = 12 * o + "px"
    }, !1), m(), c.dpr = t.dpr = o, c.refreshRem = m, c.rem2px = function(g) {
        var v = parseFloat(g) * this.rem;
        return typeof g == "string" && g.match(/rem$/) && (v += "px"), v
    }, c.px2rem = function(g) {
        var v = parseFloat(g) / this.rem;
        return typeof g == "string" && g.match(/px$/) && (v += "rem"), v
    }
})(window, window.lib || (window.lib = {}));

function g6(t) {
    return typeof t == "object" && t !== null
}

function $E(t, e) {
    return t = g6(t) ? t : Object.create(null), new Proxy(t, {
        get(n, r, i) {
            return r === "key" ? Reflect.get(n, r, i) : Reflect.get(n, r, i) || Reflect.get(e, r, i)
        }
    })
}

function y6(t, e) {
    return e.reduce((n, r) => n == null ? void 0 : n[r], t)
}

function v6(t, e, n) {
    return e.slice(0, -1).reduce((r, i) => /^(__proto__)$/.test(i) ? {} : r[i] = r[i] || {}, t)[e[e.length - 1]] = n, t
}

function _6(t, e) {
    return e.reduce((n, r) => {
        const i = r.split(".");
        return v6(n, i, y6(t, i))
    }, {})
}

function b6(t, e) {
    return n => {
        var r;
        try {
            const {
                storage: i = localStorage,
                beforeRestore: s = void 0,
                afterRestore: o = void 0,
                serializer: a = {
                    serialize: JSON.stringify,
                    deserialize: JSON.parse
                },
                key: l = e.$id,
                paths: c = null,
                debug: u = !1
            } = n;
            return {
                storage: i,
                beforeRestore: s,
                afterRestore: o,
                serializer: a,
                key: ((r = t.key) != null ? r : d => d)(typeof l == "string" ? l : l(e.$id)),
                paths: c,
                debug: u
            }
        } catch (i) {
            return n.debug && console.error("[pinia-plugin-persistedstate]", i), null
        }
    }
}

function FE(t, {
    storage: e,
    serializer: n,
    key: r,
    debug: i
}) {
    try {
        const s = e == null ? void 0 : e.getItem(r);
        s && t.$patch(n == null ? void 0 : n.deserialize(s))
    } catch (s) {
        i && console.error("[pinia-plugin-persistedstate]", s)
    }
}

function LE(t, {
    storage: e,
    serializer: n,
    key: r,
    paths: i,
    debug: s
}) {
    try {
        const o = Array.isArray(i) ? _6(t, i) : t;
        e.setItem(r, n.serialize(o))
    } catch (o) {
        s && console.error("[pinia-plugin-persistedstate]", o)
    }
}

function x6(t = {}) {
    return e => {
        const {
            auto: n = !1
        } = t, {
            options: {
                persist: r = n
            },
            store: i,
            pinia: s
        } = e;
        if (!r) return;
        if (!(i.$id in s.state.value)) {
            const a = s._s.get(i.$id.replace("__hot:", ""));
            a && Promise.resolve().then(() => a.$persist());
            return
        }
        const o = (Array.isArray(r) ? r.map(a => $E(a, t)) : [$E(r, t)]).map(b6(t, i)).filter(Boolean);
        i.$persist = () => {
            o.forEach(a => {
                LE(i.$state, a)
            })
        }, i.$hydrate = ({
            runHooks: a = !0
        } = {}) => {
            o.forEach(l => {
                const {
                    beforeRestore: c,
                    afterRestore: u
                } = l;
                a && (c == null || c(e)), FE(i, l), a && (u == null || u(e))
            })
        }, o.forEach(a => {
            const {
                beforeRestore: l,
                afterRestore: c
            } = a;
            l == null || l(e), FE(i, a), c == null || c(e), i.$subscribe((u, d) => {
                LE(d, a)
            }, {
                detached: !0
            })
        })
    }
}
var Nbe = x6(),
    Jo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};

function Hl(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}

function q_(t) {
    if (t.__esModule) return t;
    var e = t.default;
    if (typeof e == "function") {
        var n = function r() {
            return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        n.prototype = e.prototype
    } else n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }), Object.keys(t).forEach(function(r) {
        var i = Object.getOwnPropertyDescriptor(t, r);
        Object.defineProperty(n, r, i.get ? i : {
            enumerable: !0,
            get: function() {
                return t[r]
            }
        })
    }), n
}
const sn = q_(UG);
var fI = {
        exports: {}
    },
    K_ = Object.defineProperty,
    w6 = Object.getOwnPropertyDescriptor,
    E6 = Object.getOwnPropertyNames,
    S6 = Object.prototype.hasOwnProperty,
    T6 = (t, e) => {
        for (var n in e) K_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    C6 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of E6(e)) !S6.call(t, i) && i !== n && K_(t, i, {
                get: () => e[i],
                enumerable: !(r = w6(e, i)) || r.enumerable
            });
        return t
    },
    P6 = t => C6(K_({}, "__esModule", {
        value: !0
    }), t),
    hI = {};
T6(hI, {
    extend: () => O6,
    flat: () => U6,
    get: () => $6,
    inBrowser: () => pI,
    isDate: () => R6,
    isDef: () => I6,
    isFunction: () => bv,
    isIOS: () => D6,
    isMobile: () => k6,
    isNumeric: () => B6,
    isObject: () => J_,
    isPromise: () => M6,
    isSameValue: () => L6,
    noop: () => A6,
    pick: () => F6,
    toArray: () => N6
});
var Zs = P6(hI);

function A6() {}
const O6 = Object.assign,
    pI = typeof window < "u",
    J_ = t => t !== null && typeof t == "object",
    I6 = t => t != null,
    bv = t => typeof t == "function",
    M6 = t => J_(t) && bv(t.then) && bv(t.catch),
    R6 = t => Object.prototype.toString.call(t) === "[object Date]" && !Number.isNaN(t.getTime());

function k6(t) {
    return t = t.replace(/[^-|\d]/g, ""), /^((\+86)|(86))?(1)\d{10}$/.test(t) || /^0[0-9-]{10,13}$/.test(t)
}
const B6 = t => typeof t == "number" || /^\d+(\.\d+)?$/.test(t),
    D6 = () => pI ? /ios|iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()) : !1;

function $6(t, e) {
    const n = e.split(".");
    let r = t;
    return n.forEach(i => {
        var s;
        r = J_(r) && (s = r[i]) != null ? s : ""
    }), r
}

function F6(t, e, n) {
    return e.reduce((r, i) => ((!n || t[i] !== void 0) && (r[i] = t[i]), r), {})
}
const L6 = (t, e) => JSON.stringify(t) === JSON.stringify(e),
    N6 = t => Array.isArray(t) ? t : [t],
    U6 = t => t.reduce((e, n) => e.concat(n), []);
var Z_ = Object.defineProperty,
    G6 = Object.getOwnPropertyDescriptor,
    H6 = Object.getOwnPropertyNames,
    z6 = Object.prototype.hasOwnProperty,
    j6 = (t, e) => {
        for (var n in e) Z_(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    V6 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of H6(e)) !z6.call(t, i) && i !== n && Z_(t, i, {
                get: () => e[i],
                enumerable: !(r = G6(e, i)) || r.enumerable
            });
        return t
    },
    W6 = t => V6(Z_({}, "__esModule", {
        value: !0
    }), t),
    mI = {};
j6(mI, {
    makeArrayProp: () => J6,
    makeNumberProp: () => Z6,
    makeNumericProp: () => Q6,
    makeRequiredProp: () => K6,
    makeStringProp: () => e9,
    numericProp: () => gI,
    truthProp: () => q6,
    unknownProp: () => X6
});
var Y6 = W6(mI);
const X6 = null,
    gI = [Number, String],
    q6 = {
        type: Boolean,
        default: !0
    },
    K6 = t => ({
        type: t,
        required: !0
    }),
    J6 = () => ({
        type: Array,
        default: () => []
    }),
    Z6 = t => ({
        type: Number,
        default: t
    }),
    Q6 = t => ({
        type: gI,
        default: t
    }),
    e9 = t => ({
        type: String,
        default: t
    });
var pi = typeof window < "u",
    t9 = !0;

function Sn(t) {
    return pi ? requestAnimationFrame(t) : -1
}

function id(t) {
    pi && cancelAnimationFrame(t)
}

function Ao(t) {
    Sn(() => Sn(t))
}
var n9 = t => t === window,
    NE = (t, e) => ({
        top: 0,
        left: 0,
        right: t,
        bottom: e,
        width: t,
        height: e
    }),
    jt = t => {
        const e = En(t);
        if (n9(e)) {
            const n = e.innerWidth,
                r = e.innerHeight;
            return NE(n, r)
        }
        return e != null && e.getBoundingClientRect ? e.getBoundingClientRect() : NE(0, 0)
    };

function yI(t = !1) {
    const e = q(t);
    return [e, (r = !e.value) => {
        e.value = r
    }]
}

function rr(t) {
    const e = Nt(t, null);
    if (e) {
        const n = rt(),
            {
                link: r,
                unlink: i,
                internalChildren: s
            } = e;
        r(n), is(() => i(n));
        const o = te(() => s.indexOf(n));
        return {
            parent: e,
            index: o
        }
    }
    return {
        parent: null,
        index: q(-1)
    }
}

function vI(t) {
    const e = [],
        n = r => {
            Array.isArray(r) && r.forEach(i => {
                var s;
                ci(i) && (e.push(i), (s = i.component) != null && s.subTree && (e.push(i.component.subTree), n(i.component.subTree.children)), i.children && n(i.children))
            })
        };
    return n(t), e
}
var UE = (t, e) => {
    const n = t.indexOf(e);
    return n === -1 ? t.findIndex(r => e.key !== void 0 && e.key !== null && r.type === e.type && r.key === e.key) : n
};

function _I(t, e, n) {
    const r = vI(t.subTree.children);
    n.sort((s, o) => UE(r, s.vnode) - UE(r, o.vnode));
    const i = n.map(s => s.proxy);
    e.sort((s, o) => {
        const a = i.indexOf(s),
            l = i.indexOf(o);
        return a - l
    })
}

function Lr(t) {
    const e = ft([]),
        n = ft([]),
        r = rt();
    return {
        children: e,
        linkChildren: s => {
            gr(t, Object.assign({
                link: l => {
                    l.proxy && (n.push(l), e.push(l.proxy), _I(r, e, n))
                },
                unlink: l => {
                    const c = n.indexOf(l);
                    e.splice(c, 1), n.splice(c, 1)
                },
                children: e,
                internalChildren: n
            }, s))
        }
    }
}
var xv = 1e3,
    wv = 60 * xv,
    Ev = 60 * wv,
    GE = 24 * Ev;

function r9(t) {
    const e = Math.floor(t / GE),
        n = Math.floor(t % GE / Ev),
        r = Math.floor(t % Ev / wv),
        i = Math.floor(t % wv / xv),
        s = Math.floor(t % xv);
    return {
        total: t,
        days: e,
        hours: n,
        minutes: r,
        seconds: i,
        milliseconds: s
    }
}

function i9(t, e) {
    return Math.floor(t / 1e3) === Math.floor(e / 1e3)
}

function bI(t) {
    let e, n, r, i;
    const s = q(t.time),
        o = te(() => r9(s.value)),
        a = () => {
            r = !1, id(e)
        },
        l = () => Math.max(n - Date.now(), 0),
        c = b => {
            var y, m;
            s.value = b, (y = t.onChange) == null || y.call(t, o.value), b === 0 && (a(), (m = t.onFinish) == null || m.call(t))
        },
        u = () => {
            e = Sn(() => {
                r && (c(l()), s.value > 0 && u())
            })
        },
        d = () => {
            e = Sn(() => {
                if (r) {
                    const b = l();
                    (!i9(b, s.value) || b === 0) && c(b), s.value > 0 && d()
                }
            })
        },
        f = () => {
            pi && (t.millisecond ? u() : d())
        },
        h = () => {
            r || (n = Date.now() + s.value, r = !0, f())
        },
        p = (b = t.time) => {
            a(), s.value = b
        };
    return nr(a), ns(() => {
        i && (r = !0, i = !1, f())
    }), hi(() => {
        r && (a(), i = !0)
    }), {
        start: h,
        pause: a,
        reset: p,
        current: o
    }
}

function zl(t) {
    let e;
    _t(() => {
        t(), Ue(() => {
            e = !0
        })
    }), ns(() => {
        e && t()
    })
}

function An(t, e, n = {}) {
    if (!pi) return;
    const {
        target: r = window,
        passive: i = !1,
        capture: s = !1
    } = n;
    let o = !1,
        a;
    const l = d => {
            if (o) return;
            const f = En(d);
            f && !a && (f.addEventListener(t, e, {
                capture: s,
                passive: i
            }), a = !0)
        },
        c = d => {
            if (o) return;
            const f = En(d);
            f && a && (f.removeEventListener(t, e, s), a = !1)
        };
    is(() => c(r)), hi(() => c(r)), zl(() => l(r));
    let u;
    return et(r) && (u = he(r, (d, f) => {
        c(f), l(d)
    })), () => {
        u == null || u(), c(r), o = !0
    }
}

function xI(t, e, n = {}) {
    if (!pi) return;
    const {
        eventName: r = "click"
    } = n;
    An(r, s => {
        (Array.isArray(t) ? t : [t]).every(l => {
            const c = En(l);
            return c && !c.contains(s.target)
        }) && e(s)
    }, {
        target: document
    })
}
var Fd, $m;

function wI() {
    if (!Fd && (Fd = q(0), $m = q(0), pi)) {
        const t = () => {
            Fd.value = window.innerWidth, $m.value = window.innerHeight
        };
        t(), window.addEventListener("resize", t, {
            passive: !0
        }), window.addEventListener("orientationchange", t, {
            passive: !0
        })
    }
    return {
        width: Fd,
        height: $m
    }
}
var s9 = /scroll|auto|overlay/i,
    EI = pi ? window : void 0;

function o9(t) {
    return t.tagName !== "HTML" && t.tagName !== "BODY" && t.nodeType === 1
}

function Q_(t, e = EI) {
    let n = t;
    for (; n && n !== e && o9(n);) {
        const {
            overflowY: r
        } = window.getComputedStyle(n);
        if (s9.test(r)) return n;
        n = n.parentNode
    }
    return e
}

function sd(t, e = EI) {
    const n = q();
    return _t(() => {
        t.value && (n.value = Q_(t.value, e))
    }), n
}
var Ld;

function SI() {
    if (!Ld && (Ld = q("visible"), pi)) {
        const t = () => {
            Ld.value = document.hidden ? "hidden" : "visible"
        };
        t(), window.addEventListener("visibilitychange", t)
    }
    return Ld
}
var eb = Symbol("van-field");

function va(t) {
    const e = Nt(eb, null);
    e && !e.customValue.value && (e.customValue.value = t, he(t, () => {
        e.resetValidation(), e.validateWithTrigger("onChange")
    }))
}

function a9(t, e) {
    if (pi) {
        const {
            interval: n = 0,
            isLoop: r = !1
        } = e || {};
        let i, s = !1,
            o;
        const a = () => {
                s = !0, cancelAnimationFrame(o)
            },
            l = c => {
                if (!s) {
                    if (i === void 0) i = c;
                    else if (c - i > n && (t(c), i = c, !r)) {
                        a();
                        return
                    }
                    o = requestAnimationFrame(l)
                }
            };
        return o = requestAnimationFrame(l), a
    }
    return () => {}
}
const l9 = Object.freeze(Object.defineProperty({
        __proto__: null,
        CUSTOM_FIELD_INJECTION_KEY: eb,
        cancelRaf: id,
        doubleRaf: Ao,
        flattenVNodes: vI,
        getScrollParent: Q_,
        inBrowser: pi,
        onMountedOrActivated: zl,
        raf: Sn,
        sortChildren: _I,
        supportsPassive: t9,
        useChildren: Lr,
        useClickAway: xI,
        useCountDown: bI,
        useCustomFieldValue: va,
        useEventListener: An,
        usePageVisibility: SI,
        useParent: rr,
        useRaf: a9,
        useRect: jt,
        useScrollParent: sd,
        useToggle: yI,
        useWindowSize: wI
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    bp = q_(l9);
var tb = Object.defineProperty,
    c9 = Object.getOwnPropertyDescriptor,
    u9 = Object.getOwnPropertyNames,
    d9 = Object.prototype.hasOwnProperty,
    f9 = (t, e) => {
        for (var n in e) tb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    h9 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of u9(e)) !d9.call(t, i) && i !== n && tb(t, i, {
                get: () => e[i],
                enumerable: !(r = c9(e, i)) || r.enumerable
            });
        return t
    },
    p9 = t => h9(tb({}, "__esModule", {
        value: !0
    }), t),
    TI = {};
f9(TI, {
    getContainingBlock: () => T9,
    getElementTop: () => y9,
    getRootScrollTop: () => nb,
    getScrollTop: () => AI,
    isHidden: () => x9,
    preventDefault: () => b9,
    resetScroll: () => _9,
    setRootScrollTop: () => OI,
    setScrollTop: () => Sv,
    stopPropagation: () => II,
    windowHeight: () => E9,
    windowWidth: () => w9
});
var CI = p9(TI),
    PI = bp,
    m9 = sn,
    g9 = Zs;

function AI(t) {
    const e = "scrollTop" in t ? t.scrollTop : t.pageYOffset;
    return Math.max(e, 0)
}

function Sv(t, e) {
    "scrollTop" in t ? t.scrollTop = e : t.scrollTo(t.scrollX, e)
}

function nb() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
}

function OI(t) {
    Sv(window, t), Sv(document.body, t)
}

function y9(t, e) {
    if (t === window) return 0;
    const n = e ? AI(e) : nb();
    return (0, PI.useRect)(t).top + n
}
const v9 = (0, g9.isIOS)();

function _9() {
    v9 && OI(nb())
}
const II = t => t.stopPropagation();

function b9(t, e) {
    (typeof t.cancelable != "boolean" || t.cancelable) && t.preventDefault(), e && II(t)
}

function x9(t) {
    const e = (0, m9.unref)(t);
    if (!e) return !1;
    const n = window.getComputedStyle(e),
        r = n.display === "none",
        i = e.offsetParent === null && n.position !== "fixed";
    return r || i
}
const {
    width: w9,
    height: E9
} = (0, PI.useWindowSize)();

function S9(t) {
    const e = window.getComputedStyle(t);
    return e.transform !== "none" || e.perspective !== "none" || ["transform", "perspective", "filter"].some(n => (e.willChange || "").includes(n))
}

function T9(t) {
    let e = t.parentElement;
    for (; e;) {
        if (e && e.tagName !== "HTML" && e.tagName !== "BODY" && S9(e)) return e;
        e = e.parentElement
    }
    return null
}
var rb = Object.defineProperty,
    C9 = Object.getOwnPropertyDescriptor,
    P9 = Object.getOwnPropertyNames,
    A9 = Object.prototype.hasOwnProperty,
    O9 = (t, e) => {
        for (var n in e) rb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    I9 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of P9(e)) !A9.call(t, i) && i !== n && rb(t, i, {
                get: () => e[i],
                enumerable: !(r = C9(e, i)) || r.enumerable
            });
        return t
    },
    M9 = t => I9(rb({}, "__esModule", {
        value: !0
    }), t),
    MI = {};
O9(MI, {
    addNumber: () => W9,
    addUnit: () => Ff,
    camelize: () => G9,
    clamp: () => j9,
    formatNumber: () => V9,
    getSizeStyle: () => k9,
    getZIndexStyle: () => B9,
    kebabCase: () => H9,
    padZero: () => z9,
    unitToPx: () => N9
});
var ib = M9(MI),
    R9 = Zs,
    RI = CI,
    Tv = Zs;

function Ff(t) {
    if ((0, Tv.isDef)(t)) return (0, Tv.isNumeric)(t) ? `${t}px` : String(t)
}

function k9(t) {
    if ((0, Tv.isDef)(t)) {
        if (Array.isArray(t)) return {
            width: Ff(t[0]),
            height: Ff(t[1])
        };
        const e = Ff(t);
        return {
            width: e,
            height: e
        }
    }
}

function B9(t) {
    const e = {};
    return t !== void 0 && (e.zIndex = +t), e
}
let Fm;

function D9() {
    if (!Fm) {
        const t = document.documentElement,
            e = t.style.fontSize || window.getComputedStyle(t).fontSize;
        Fm = parseFloat(e)
    }
    return Fm
}

function $9(t) {
    return t = t.replace(/rem/g, ""), +t * D9()
}

function F9(t) {
    return t = t.replace(/vw/g, ""), +t * RI.windowWidth.value / 100
}

function L9(t) {
    return t = t.replace(/vh/g, ""), +t * RI.windowHeight.value / 100
}

function N9(t) {
    if (typeof t == "number") return t;
    if (R9.inBrowser) {
        if (t.includes("rem")) return $9(t);
        if (t.includes("vw")) return F9(t);
        if (t.includes("vh")) return L9(t)
    }
    return parseFloat(t)
}
const U9 = /-(\w)/g,
    G9 = t => t.replace(U9, (e, n) => n.toUpperCase()),
    H9 = t => t.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");

function z9(t, e = 2) {
    let n = t + "";
    for (; n.length < e;) n = "0" + n;
    return n
}
const j9 = (t, e, n) => Math.min(Math.max(t, e), n);

function HE(t, e, n) {
    const r = t.indexOf(e);
    return r === -1 ? t : e === "-" && r !== 0 ? t.slice(0, r) : t.slice(0, r + 1) + t.slice(r).replace(n, "")
}

function V9(t, e = !0, n = !0) {
    e ? t = HE(t, ".", /\./g) : t = t.split(".")[0], n ? t = HE(t, "-", /-/g) : t = t.replace(/-/, "");
    const r = e ? /[^-0-9.]/g : /[^-0-9]/g;
    return t.replace(r, "")
}

function W9(t, e) {
    return Math.round((t + e) * 1e10) / 1e10
}
var sb = Object.defineProperty,
    Y9 = Object.getOwnPropertyDescriptor,
    X9 = Object.getOwnPropertyNames,
    q9 = Object.prototype.hasOwnProperty,
    K9 = (t, e) => {
        for (var n in e) sb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    J9 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of X9(e)) !q9.call(t, i) && i !== n && sb(t, i, {
                get: () => e[i],
                enumerable: !(r = Y9(e, i)) || r.enumerable
            });
        return t
    },
    Z9 = t => J9(sb({}, "__esModule", {
        value: !0
    }), t),
    kI = {};
K9(kI, {
    deepAssign: () => BI
});
var Q9 = Z9(kI),
    zE = Zs;
const {
    hasOwnProperty: eH
} = Object.prototype;

function tH(t, e, n) {
    const r = e[n];
    (0, zE.isDef)(r) && (!eH.call(t, n) || !(0, zE.isObject)(r) ? t[n] = r : t[n] = BI(Object(t[n]), r))
}

function BI(t, e) {
    return Object.keys(e).forEach(n => {
        tH(t, e, n)
    }), t
}
var ob = Object.defineProperty,
    nH = Object.getOwnPropertyDescriptor,
    rH = Object.getOwnPropertyNames,
    iH = Object.prototype.hasOwnProperty,
    sH = (t, e) => {
        for (var n in e) ob(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    oH = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of rH(e)) !iH.call(t, i) && i !== n && ob(t, i, {
                get: () => e[i],
                enumerable: !(r = nH(e, i)) || r.enumerable
            });
        return t
    },
    aH = t => oH(ob({}, "__esModule", {
        value: !0
    }), t),
    DI = {};
sH(DI, {
    default: () => cH
});
var lH = aH(DI),
    cH = {
        name: "",
        tel: "",
        save: "",
        clear: "",
        cancel: "",
        confirm: "",
        delete: "",
        loading: "...",
        noCoupon: "",
        nameEmpty: "",
        addContact: "",
        telInvalid: "",
        vanCalendar: {
            end: "",
            start: "",
            title: "",
            weekdays: ["", "", "", "", "", "", ""],
            monthTitle: (t, e) => `${t}${e}`,
            rangePrompt: t => ` ${t} `
        },
        vanCascader: {
            select: ""
        },
        vanPagination: {
            prev: "",
            next: ""
        },
        vanPullRefresh: {
            pulling: "...",
            loosing: "..."
        },
        vanSubmitBar: {
            label: ":"
        },
        vanCoupon: {
            unlimited: "",
            discount: t => `${t}`,
            condition: t => `${t}`
        },
        vanCouponCell: {
            title: "",
            count: t => `${t}`
        },
        vanCouponList: {
            exchange: "",
            close: "",
            enable: "",
            disabled: "",
            placeholder: ""
        },
        vanAddressEdit: {
            area: "",
            areaEmpty: "",
            addressEmpty: "",
            addressDetail: "",
            defaultAddress: ""
        },
        vanAddressList: {
            add: ""
        }
    },
    uH = Object.create,
    xp = Object.defineProperty,
    dH = Object.getOwnPropertyDescriptor,
    fH = Object.getOwnPropertyNames,
    hH = Object.getPrototypeOf,
    pH = Object.prototype.hasOwnProperty,
    mH = (t, e) => {
        for (var n in e) xp(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    $I = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of fH(e)) !pH.call(t, i) && i !== n && xp(t, i, {
                get: () => e[i],
                enumerable: !(r = dH(e, i)) || r.enumerable
            });
        return t
    },
    gH = (t, e, n) => (n = t != null ? uH(hH(t)) : {}, $I(e || !t || !t.__esModule ? xp(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    yH = t => $I(xp({}, "__esModule", {
        value: !0
    }), t),
    FI = {};
mH(FI, {
    Locale: () => NI,
    default: () => wH,
    useCurrentLang: () => xH
});
var vH = yH(FI),
    LI = sn,
    _H = Q9,
    bH = gH(lH);
const Cv = (0, LI.ref)("zh-CN"),
    jE = (0, LI.reactive)({
        "zh-CN": bH.default
    }),
    NI = {
        messages() {
            return jE[Cv.value]
        },
        use(t, e) {
            Cv.value = t, this.add({
                [t]: e
            })
        },
        add(t = {}) {
            (0, _H.deepAssign)(jE, t)
        }
    },
    xH = () => Cv;
var wH = NI,
    EH = Object.create,
    wp = Object.defineProperty,
    SH = Object.getOwnPropertyDescriptor,
    TH = Object.getOwnPropertyNames,
    CH = Object.getPrototypeOf,
    PH = Object.prototype.hasOwnProperty,
    AH = (t, e) => {
        for (var n in e) wp(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    UI = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of TH(e)) !PH.call(t, i) && i !== n && wp(t, i, {
                get: () => e[i],
                enumerable: !(r = SH(e, i)) || r.enumerable
            });
        return t
    },
    OH = (t, e, n) => (n = t != null ? EH(CH(t)) : {}, UI(e || !t || !t.__esModule ? wp(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    IH = t => UI(wp({}, "__esModule", {
        value: !0
    }), t),
    GI = {};
AH(GI, {
    createBEM: () => zI,
    createNamespace: () => BH,
    createTranslate: () => HI
});
var MH = IH(GI),
    Lm = Zs,
    RH = ib,
    kH = OH(vH);

function HI(t) {
    const e = (0, RH.camelize)(t) + ".";
    return (n, ...r) => {
        const i = kH.default.messages(),
            s = (0, Lm.get)(i, e + n) || (0, Lm.get)(i, n);
        return (0, Lm.isFunction)(s) ? s(...r) : s
    }
}

function Pv(t, e) {
    return e ? typeof e == "string" ? ` ${t}--${e}` : Array.isArray(e) ? e.reduce((n, r) => n + Pv(t, r), "") : Object.keys(e).reduce((n, r) => n + (e[r] ? Pv(t, r) : ""), "") : ""
}

function zI(t) {
    return (e, n) => (e && typeof e != "string" && (n = e, e = ""), e = e ? `${t}__${e}` : t, `${e}${Pv(e,n)}`)
}

function BH(t) {
    const e = `van-${t}`;
    return [e, zI(e), HI(e)]
}
var ab = Object.defineProperty,
    DH = Object.getOwnPropertyDescriptor,
    $H = Object.getOwnPropertyNames,
    FH = Object.prototype.hasOwnProperty,
    LH = (t, e) => {
        for (var n in e) ab(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    NH = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of $H(e)) !FH.call(t, i) && i !== n && ab(t, i, {
                get: () => e[i],
                enumerable: !(r = DH(e, i)) || r.enumerable
            });
        return t
    },
    UH = t => NH(ab({}, "__esModule", {
        value: !0
    }), t),
    jI = {};
LH(jI, {
    BORDER: () => Qs,
    BORDER_BOTTOM: () => VH,
    BORDER_LEFT: () => zH,
    BORDER_RIGHT: () => jH,
    BORDER_SURROUND: () => WH,
    BORDER_TOP: () => HH,
    BORDER_TOP_BOTTOM: () => YH,
    BORDER_UNSET_TOP_BOTTOM: () => XH,
    FORM_KEY: () => KH,
    HAPTICS_FEEDBACK: () => qH,
    LONG_PRESS_START_TIME: () => JH,
    TAP_OFFSET: () => ZH
});
var GH = UH(jI);
const Qs = "van-hairline",
    HH = `${Qs}--top`,
    zH = `${Qs}--left`,
    jH = `${Qs}--right`,
    VH = `${Qs}--bottom`,
    WH = `${Qs}--surround`,
    YH = `${Qs}--top-bottom`,
    XH = `${Qs}-unset--top-bottom`,
    qH = "van-haptics-feedback",
    KH = Symbol("van-form"),
    JH = 500,
    ZH = 5;
var lb = Object.defineProperty,
    QH = Object.getOwnPropertyDescriptor,
    e8 = Object.getOwnPropertyNames,
    t8 = Object.prototype.hasOwnProperty,
    n8 = (t, e) => {
        for (var n in e) lb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    r8 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of e8(e)) !t8.call(t, i) && i !== n && lb(t, i, {
                get: () => e[i],
                enumerable: !(r = QH(e, i)) || r.enumerable
            });
        return t
    },
    i8 = t => r8(lb({}, "__esModule", {
        value: !0
    }), t),
    VI = {};
n8(VI, {
    callInterceptor: () => o8
});
var s8 = i8(VI),
    VE = Zs;

function o8(t, {
    args: e = [],
    done: n,
    canceled: r,
    error: i
}) {
    if (t) {
        const s = t.apply(null, e);
        (0, VE.isPromise)(s) ? s.then(o => {
            o ? n() : r && r()
        }).catch(i || VE.noop): s ? n() : r && r()
    } else n()
}
var cb = Object.defineProperty,
    a8 = Object.getOwnPropertyDescriptor,
    l8 = Object.getOwnPropertyNames,
    c8 = Object.prototype.hasOwnProperty,
    u8 = (t, e) => {
        for (var n in e) cb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    d8 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of l8(e)) !c8.call(t, i) && i !== n && cb(t, i, {
                get: () => e[i],
                enumerable: !(r = a8(e, i)) || r.enumerable
            });
        return t
    },
    f8 = t => d8(cb({}, "__esModule", {
        value: !0
    }), t),
    WI = {};
u8(WI, {
    withInstall: () => m8
});
var h8 = f8(WI),
    p8 = ib;

function m8(t) {
    return t.install = e => {
        const {
            name: n
        } = t;
        n && (e.component(n, t), e.component((0, p8.camelize)(`-${n}`), t))
    }, t
}
var ub = Object.defineProperty,
    g8 = Object.getOwnPropertyDescriptor,
    y8 = Object.getOwnPropertyNames,
    v8 = Object.prototype.hasOwnProperty,
    _8 = (t, e) => {
        for (var n in e) ub(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    b8 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of y8(e)) !v8.call(t, i) && i !== n && ub(t, i, {
                get: () => e[i],
                enumerable: !(r = g8(e, i)) || r.enumerable
            });
        return t
    },
    x8 = t => b8(ub({}, "__esModule", {
        value: !0
    }), t),
    YI = {};
_8(YI, {
    closest: () => E8
});
var w8 = x8(YI);

function E8(t, e) {
    return t.reduce((n, r) => Math.abs(n - e) < Math.abs(r - e) ? n : r)
}(function(t) {
    var e = Object.defineProperty,
        n = Object.getOwnPropertyDescriptor,
        r = Object.getOwnPropertyNames,
        i = Object.prototype.hasOwnProperty,
        s = (c, u, d, f) => {
            if (u && typeof u == "object" || typeof u == "function")
                for (let h of r(u)) !i.call(c, h) && h !== d && e(c, h, {
                    get: () => u[h],
                    enumerable: !(f = n(u, h)) || f.enumerable
                });
            return c
        },
        o = (c, u, d) => (s(c, u, "default"), d && s(d, u, "default")),
        a = c => s(e({}, "__esModule", {
            value: !0
        }), c),
        l = {};
    t.exports = a(l), o(l, Zs, t.exports), o(l, Y6, t.exports), o(l, CI, t.exports), o(l, MH, t.exports), o(l, ib, t.exports), o(l, GH, t.exports), o(l, s8, t.exports), o(l, h8, t.exports), o(l, w8, t.exports)
})(fI);
var on = fI.exports,
    db = Object.defineProperty,
    S8 = Object.getOwnPropertyDescriptor,
    T8 = Object.getOwnPropertyNames,
    C8 = Object.prototype.hasOwnProperty,
    P8 = (t, e) => {
        for (var n in e) db(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    A8 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of T8(e)) !C8.call(t, i) && i !== n && db(t, i, {
                get: () => e[i],
                enumerable: !(r = S8(e, i)) || r.enumerable
            });
        return t
    },
    O8 = t => A8(db({}, "__esModule", {
        value: !0
    }), t),
    XI = {};
P8(XI, {
    useExpose: () => R8
});
var qI = O8(XI),
    I8 = sn,
    M8 = on;

function R8(t) {
    const e = (0, I8.getCurrentInstance)();
    e && (0, M8.extend)(e.proxy, t)
}
var fb = Object.defineProperty,
    k8 = Object.getOwnPropertyDescriptor,
    B8 = Object.getOwnPropertyNames,
    D8 = Object.prototype.hasOwnProperty,
    $8 = (t, e) => {
        for (var n in e) fb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    F8 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of B8(e)) !D8.call(t, i) && i !== n && fb(t, i, {
                get: () => e[i],
                enumerable: !(r = k8(e, i)) || r.enumerable
            });
        return t
    },
    L8 = t => F8(fb({}, "__esModule", {
        value: !0
    }), t),
    KI = {};
$8(KI, {
    mountComponent: () => z8,
    usePopupState: () => H8
});
var N8 = L8(KI),
    JI = sn,
    U8 = Zs,
    G8 = qI;

function H8() {
    const t = (0, JI.reactive)({
            show: !1
        }),
        e = i => {
            t.show = i
        },
        n = i => {
            (0, U8.extend)(t, i, {
                transitionAppear: !0
            }), e(!0)
        },
        r = () => e(!1);
    return (0, G8.useExpose)({
        open: n,
        close: r,
        toggle: e
    }), {
        open: n,
        close: r,
        state: t,
        toggle: e
    }
}

function z8(t) {
    const e = (0, JI.createApp)(t),
        n = document.createElement("div");
    return document.body.appendChild(n), {
        instance: e.mount(n),
        unmount() {
            e.unmount(), document.body.removeChild(n)
        }
    }
}
var hb = Object.defineProperty,
    j8 = Object.getOwnPropertyDescriptor,
    V8 = Object.getOwnPropertyNames,
    W8 = Object.prototype.hasOwnProperty,
    Y8 = (t, e) => {
        for (var n in e) hb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    X8 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of V8(e)) !W8.call(t, i) && i !== n && hb(t, i, {
                get: () => e[i],
                enumerable: !(r = j8(e, i)) || r.enumerable
            });
        return t
    },
    q8 = t => X8(hb({}, "__esModule", {
        value: !0
    }), t),
    ZI = {};
Y8(ZI, {
    lockClick: () => J8
});
var K8 = q8(ZI);
let ic = 0;

function J8(t) {
    t ? (ic || document.body.classList.add("van-toast--unclickable"), ic++) : ic && (ic--, ic || document.body.classList.remove("van-toast--unclickable"))
}
var pb = Object.defineProperty,
    Z8 = Object.getOwnPropertyDescriptor,
    Q8 = Object.getOwnPropertyNames,
    ez = Object.prototype.hasOwnProperty,
    tz = (t, e) => {
        for (var n in e) pb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    nz = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of Q8(e)) !ez.call(t, i) && i !== n && pb(t, i, {
                get: () => e[i],
                enumerable: !(r = Z8(e, i)) || r.enumerable
            });
        return t
    },
    rz = t => nz(pb({}, "__esModule", {
        value: !0
    }), t),
    QI = {};
tz(QI, {
    badgeProps: () => tM,
    default: () => sz
});
var eM = rz(QI),
    Nd = sn,
    vn = on;
const [iz, WE] = (0, vn.createNamespace)("badge"), tM = {
    dot: Boolean,
    max: vn.numericProp,
    tag: (0, vn.makeStringProp)("div"),
    color: String,
    offset: Array,
    content: vn.numericProp,
    showZero: vn.truthProp,
    position: (0, vn.makeStringProp)("top-right")
};
var sz = (0, Nd.defineComponent)({
        name: iz,
        props: tM,
        setup(t, {
            slots: e
        }) {
            const n = () => {
                    if (e.content) return !0;
                    const {
                        content: a,
                        showZero: l
                    } = t;
                    return (0, vn.isDef)(a) && a !== "" && (l || a !== 0 && a !== "0")
                },
                r = () => {
                    const {
                        dot: a,
                        max: l,
                        content: c
                    } = t;
                    if (!a && n()) return e.content ? e.content() : (0, vn.isDef)(l) && (0, vn.isNumeric)(c) && +c > +l ? `${l}+` : c
                },
                i = a => a.startsWith("-") ? a.replace("-", "") : `-${a}`,
                s = (0, Nd.computed)(() => {
                    const a = {
                        background: t.color
                    };
                    if (t.offset) {
                        const [l, c] = t.offset, {
                            position: u
                        } = t, [d, f] = u.split("-");
                        e.default ? (typeof c == "number" ? a[d] = (0, vn.addUnit)(d === "top" ? c : -c) : a[d] = d === "top" ? (0, vn.addUnit)(c) : i(c), typeof l == "number" ? a[f] = (0, vn.addUnit)(f === "left" ? l : -l) : a[f] = f === "left" ? (0, vn.addUnit)(l) : i(l)) : (a.marginTop = (0, vn.addUnit)(c), a.marginLeft = (0, vn.addUnit)(l))
                    }
                    return a
                }),
                o = () => {
                    if (n() || t.dot) return (0, Nd.createVNode)("div", {
                        class: WE([t.position, {
                            dot: t.dot,
                            fixed: !!e.default
                        }]),
                        style: s.value
                    }, [r()])
                };
            return () => {
                if (e.default) {
                    const {
                        tag: a
                    } = t;
                    return (0, Nd.createVNode)(a, {
                        class: WE("wrapper")
                    }, {
                        default: () => [e.default(), o()]
                    })
                }
                return o()
            }
        }
    }),
    oz = Object.create,
    Ep = Object.defineProperty,
    az = Object.getOwnPropertyDescriptor,
    lz = Object.getOwnPropertyNames,
    cz = Object.getPrototypeOf,
    uz = Object.prototype.hasOwnProperty,
    dz = (t, e) => {
        for (var n in e) Ep(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    nM = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of lz(e)) !uz.call(t, i) && i !== n && Ep(t, i, {
                get: () => e[i],
                enumerable: !(r = az(e, i)) || r.enumerable
            });
        return t
    },
    fz = (t, e, n) => (n = t != null ? oz(cz(t)) : {}, nM(e || !t || !t.__esModule ? Ep(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    hz = t => nM(Ep({}, "__esModule", {
        value: !0
    }), t),
    rM = {};
dz(rM, {
    Badge: () => iM,
    badgeProps: () => yz.badgeProps,
    default: () => vz
});
var pz = hz(rM),
    mz = on,
    gz = fz(eM),
    yz = eM;
const iM = (0, mz.withInstall)(gz.default);
var vz = iM,
    mb = Object.defineProperty,
    _z = Object.getOwnPropertyDescriptor,
    bz = Object.getOwnPropertyNames,
    xz = Object.prototype.hasOwnProperty,
    wz = (t, e) => {
        for (var n in e) mb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    Ez = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of bz(e)) !xz.call(t, i) && i !== n && mb(t, i, {
                get: () => e[i],
                enumerable: !(r = _z(e, i)) || r.enumerable
            });
        return t
    },
    Sz = t => Ez(mb({}, "__esModule", {
        value: !0
    }), t),
    sM = {};
wz(sM, {
    setGlobalZIndex: () => Cz,
    useGlobalZIndex: () => Tz
});
var oM = Sz(sM);
let aM = 2e3;
const Tz = () => ++aM,
    Cz = t => {
        aM = t
    };
var gb = Object.defineProperty,
    Pz = Object.getOwnPropertyDescriptor,
    Az = Object.getOwnPropertyNames,
    Oz = Object.prototype.hasOwnProperty,
    Iz = (t, e) => {
        for (var n in e) gb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    Mz = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of Az(e)) !Oz.call(t, i) && i !== n && gb(t, i, {
                get: () => e[i],
                enumerable: !(r = Pz(e, i)) || r.enumerable
            });
        return t
    },
    Rz = t => Mz(gb({}, "__esModule", {
        value: !0
    }), t),
    lM = {};
Iz(lM, {
    CONFIG_PROVIDER_KEY: () => uM,
    configProviderProps: () => dM,
    default: () => Lz
});
var kz = Rz(lM),
    xr = sn,
    Ho = on,
    Bz = oM;
const [cM, Dz] = (0, Ho.createNamespace)("config-provider"), uM = Symbol(cM), dM = {
    tag: (0, Ho.makeStringProp)("div"),
    theme: (0, Ho.makeStringProp)("light"),
    zIndex: Number,
    themeVars: Object,
    themeVarsDark: Object,
    themeVarsLight: Object,
    themeVarsScope: (0, Ho.makeStringProp)("local"),
    iconPrefix: String
};

function $z(t) {
    return t.replace(/([a-zA-Z])(\d)/g, "$1-$2")
}

function Fz(t) {
    const e = {};
    return Object.keys(t).forEach(n => {
        const r = $z((0, Ho.kebabCase)(n));
        e[`--van-${r}`] = t[n]
    }), e
}

function Ud(t = {}, e = {}) {
    Object.keys(t).forEach(n => {
        t[n] !== e[n] && document.documentElement.style.setProperty(n, t[n])
    }), Object.keys(e).forEach(n => {
        t[n] || document.documentElement.style.removeProperty(n)
    })
}
var Lz = (0, xr.defineComponent)({
        name: cM,
        props: dM,
        setup(t, {
            slots: e
        }) {
            const n = (0, xr.computed)(() => Fz((0, Ho.extend)({}, t.themeVars, t.theme === "dark" ? t.themeVarsDark : t.themeVarsLight)));
            if (Ho.inBrowser) {
                const r = () => {
                        document.documentElement.classList.add(`van-theme-${t.theme}`)
                    },
                    i = (s = t.theme) => {
                        document.documentElement.classList.remove(`van-theme-${s}`)
                    };
                (0, xr.watch)(() => t.theme, (s, o) => {
                    o && i(o), r()
                }, {
                    immediate: !0
                }), (0, xr.onActivated)(r), (0, xr.onDeactivated)(i), (0, xr.onBeforeUnmount)(i), (0, xr.watch)(n, (s, o) => {
                    t.themeVarsScope === "global" && Ud(s, o)
                }), (0, xr.watch)(() => t.themeVarsScope, (s, o) => {
                    o === "global" && Ud({}, n.value), s === "global" && Ud(n.value, {})
                }), t.themeVarsScope === "global" && Ud(n.value, {})
            }
            return (0, xr.provide)(uM, t), (0, xr.watchEffect)(() => {
                t.zIndex !== void 0 && (0, Bz.setGlobalZIndex)(t.zIndex)
            }), () => (0, xr.createVNode)(t.tag, {
                class: Dz(),
                style: t.themeVarsScope === "local" ? n.value : void 0
            }, {
                default: () => {
                    var r;
                    return [(r = e.default) == null ? void 0 : r.call(e)]
                }
            })
        }
    }),
    yb = Object.defineProperty,
    Nz = Object.getOwnPropertyDescriptor,
    Uz = Object.getOwnPropertyNames,
    Gz = Object.prototype.hasOwnProperty,
    Hz = (t, e) => {
        for (var n in e) yb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    zz = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of Uz(e)) !Gz.call(t, i) && i !== n && yb(t, i, {
                get: () => e[i],
                enumerable: !(r = Nz(e, i)) || r.enumerable
            });
        return t
    },
    jz = t => zz(yb({}, "__esModule", {
        value: !0
    }), t),
    fM = {};
Hz(fM, {
    default: () => qz,
    iconProps: () => pM
});
var hM = jz(fM),
    Aa = sn,
    Gc = on,
    Vz = pz,
    Wz = kz;
const [Yz, YE] = (0, Gc.createNamespace)("icon"), Xz = t => t == null ? void 0 : t.includes("/"), pM = {
    dot: Boolean,
    tag: (0, Gc.makeStringProp)("i"),
    name: String,
    size: Gc.numericProp,
    badge: Gc.numericProp,
    color: String,
    badgeProps: Object,
    classPrefix: String
};
var qz = (0, Aa.defineComponent)({
        name: Yz,
        props: pM,
        setup(t, {
            slots: e
        }) {
            const n = (0, Aa.inject)(Wz.CONFIG_PROVIDER_KEY, null),
                r = (0, Aa.computed)(() => t.classPrefix || (n == null ? void 0 : n.iconPrefix) || YE());
            return () => {
                const {
                    tag: i,
                    dot: s,
                    name: o,
                    size: a,
                    badge: l,
                    color: c
                } = t, u = Xz(o);
                return (0, Aa.createVNode)(Vz.Badge, (0, Aa.mergeProps)({
                    dot: s,
                    tag: i,
                    class: [r.value, u ? "" : `${r.value}-${o}`],
                    style: {
                        color: c,
                        fontSize: (0, Gc.addUnit)(a)
                    },
                    content: l
                }, t.badgeProps), {
                    default: () => {
                        var d;
                        return [(d = e.default) == null ? void 0 : d.call(e), u && (0, Aa.createVNode)("img", {
                            class: YE("image"),
                            src: o
                        }, null)]
                    }
                })
            }
        }
    }),
    Kz = Object.create,
    Sp = Object.defineProperty,
    Jz = Object.getOwnPropertyDescriptor,
    Zz = Object.getOwnPropertyNames,
    Qz = Object.getPrototypeOf,
    ej = Object.prototype.hasOwnProperty,
    tj = (t, e) => {
        for (var n in e) Sp(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    mM = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of Zz(e)) !ej.call(t, i) && i !== n && Sp(t, i, {
                get: () => e[i],
                enumerable: !(r = Jz(e, i)) || r.enumerable
            });
        return t
    },
    nj = (t, e, n) => (n = t != null ? Kz(Qz(t)) : {}, mM(e || !t || !t.__esModule ? Sp(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    rj = t => mM(Sp({}, "__esModule", {
        value: !0
    }), t),
    gM = {};
tj(gM, {
    Icon: () => vM,
    default: () => aj,
    iconProps: () => oj.iconProps
});
var yM = rj(gM),
    ij = on,
    sj = nj(hM),
    oj = hM;
const vM = (0, ij.withInstall)(sj.default);
var aj = vM,
    vb = Object.defineProperty,
    lj = Object.getOwnPropertyDescriptor,
    cj = Object.getOwnPropertyNames,
    uj = Object.prototype.hasOwnProperty,
    dj = (t, e) => {
        for (var n in e) vb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    fj = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of cj(e)) !uj.call(t, i) && i !== n && vb(t, i, {
                get: () => e[i],
                enumerable: !(r = lj(e, i)) || r.enumerable
            });
        return t
    },
    hj = t => fj(vb({}, "__esModule", {
        value: !0
    }), t),
    _M = {};
dj(_M, {
    popupSharedPropKeys: () => mj,
    popupSharedProps: () => bM
});
var pj = hj(_M),
    uo = on;
const bM = {
        show: Boolean,
        zIndex: uo.numericProp,
        overlay: uo.truthProp,
        duration: uo.numericProp,
        teleport: [String, Object],
        lockScroll: uo.truthProp,
        lazyRender: uo.truthProp,
        beforeClose: Function,
        overlayProps: Object,
        overlayStyle: Object,
        overlayClass: uo.unknownProp,
        transitionAppear: Boolean,
        closeOnClickOverlay: uo.truthProp
    },
    mj = Object.keys(bM);
var _b = Object.defineProperty,
    gj = Object.getOwnPropertyDescriptor,
    yj = Object.getOwnPropertyNames,
    vj = Object.prototype.hasOwnProperty,
    _j = (t, e) => {
        for (var n in e) _b(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    bj = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of yj(e)) !vj.call(t, i) && i !== n && _b(t, i, {
                get: () => e[i],
                enumerable: !(r = gj(e, i)) || r.enumerable
            });
        return t
    },
    xj = t => bj(_b({}, "__esModule", {
        value: !0
    }), t),
    xM = {};
_j(xM, {
    useTouch: () => Sj
});
var wj = xj(xM),
    ds = sn,
    XE = on;

function Ej(t, e) {
    return t > e ? "horizontal" : e > t ? "vertical" : ""
}

function Sj() {
    const t = (0, ds.ref)(0),
        e = (0, ds.ref)(0),
        n = (0, ds.ref)(0),
        r = (0, ds.ref)(0),
        i = (0, ds.ref)(0),
        s = (0, ds.ref)(0),
        o = (0, ds.ref)(""),
        a = (0, ds.ref)(!0),
        l = () => o.value === "vertical",
        c = () => o.value === "horizontal",
        u = () => {
            n.value = 0, r.value = 0, i.value = 0, s.value = 0, o.value = "", a.value = !0
        };
    return {
        move: h => {
            const p = h.touches[0];
            n.value = (p.clientX < 0 ? 0 : p.clientX) - t.value, r.value = p.clientY - e.value, i.value = Math.abs(n.value), s.value = Math.abs(r.value);
            const b = 10;
            (!o.value || i.value < b && s.value < b) && (o.value = Ej(i.value, s.value)), a.value && (i.value > XE.TAP_OFFSET || s.value > XE.TAP_OFFSET) && (a.value = !1)
        },
        start: h => {
            u(), t.value = h.touches[0].clientX, e.value = h.touches[0].clientY
        },
        reset: u,
        startX: t,
        startY: e,
        deltaX: n,
        deltaY: r,
        offsetX: i,
        offsetY: s,
        direction: o,
        isVertical: l,
        isHorizontal: c,
        isTap: a
    }
}
var bb = Object.defineProperty,
    Tj = Object.getOwnPropertyDescriptor,
    Cj = Object.getOwnPropertyNames,
    Pj = Object.prototype.hasOwnProperty,
    Aj = (t, e) => {
        for (var n in e) bb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    Oj = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of Cj(e)) !Pj.call(t, i) && i !== n && bb(t, i, {
                get: () => e[i],
                enumerable: !(r = Tj(e, i)) || r.enumerable
            });
        return t
    },
    Ij = t => Oj(bb({}, "__esModule", {
        value: !0
    }), t),
    wM = {};
Aj(wM, {
    useLockScroll: () => Bj
});
var Mj = Ij(wM),
    Nm = sn,
    qE = bp,
    Rj = wj,
    kj = on;
let sc = 0;
const KE = "van-overflow-hidden";

function Bj(t, e) {
    const n = (0, Rj.useTouch)(),
        r = "01",
        i = "10",
        s = u => {
            n.move(u);
            const d = n.deltaY.value > 0 ? i : r,
                f = (0, qE.getScrollParent)(u.target, t.value),
                {
                    scrollHeight: h,
                    offsetHeight: p,
                    scrollTop: b
                } = f;
            let y = "11";
            b === 0 ? y = p >= h ? "00" : "01" : b + p >= h && (y = "10"), y !== "11" && n.isVertical() && !(parseInt(y, 2) & parseInt(d, 2)) && (0, kj.preventDefault)(u, !0)
        },
        o = () => {
            document.addEventListener("touchstart", n.start), document.addEventListener("touchmove", s, {
                passive: !1
            }), sc || document.body.classList.add(KE), sc++
        },
        a = () => {
            sc && (document.removeEventListener("touchstart", n.start), document.removeEventListener("touchmove", s), sc--, sc || document.body.classList.remove(KE))
        },
        l = () => e() && o(),
        c = () => e() && a();
    (0, qE.onMountedOrActivated)(l), (0, Nm.onDeactivated)(c), (0, Nm.onBeforeUnmount)(c), (0, Nm.watch)(e, u => {
        u ? o() : a()
    })
}
var xb = Object.defineProperty,
    Dj = Object.getOwnPropertyDescriptor,
    $j = Object.getOwnPropertyNames,
    Fj = Object.prototype.hasOwnProperty,
    Lj = (t, e) => {
        for (var n in e) xb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    Nj = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of $j(e)) !Fj.call(t, i) && i !== n && xb(t, i, {
                get: () => e[i],
                enumerable: !(r = Dj(e, i)) || r.enumerable
            });
        return t
    },
    Uj = t => Nj(xb({}, "__esModule", {
        value: !0
    }), t),
    EM = {};
Lj(EM, {
    useLazyRender: () => Gj
});
var SM = Uj(EM),
    JE = sn;

function Gj(t) {
    const e = (0, JE.ref)(!1);
    return (0, JE.watch)(t, n => {
        n && (e.value = n)
    }, {
        immediate: !0
    }), n => () => e.value ? n() : null
}
var wb = Object.defineProperty,
    Hj = Object.getOwnPropertyDescriptor,
    zj = Object.getOwnPropertyNames,
    jj = Object.prototype.hasOwnProperty,
    Vj = (t, e) => {
        for (var n in e) wb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    Wj = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of zj(e)) !jj.call(t, i) && i !== n && wb(t, i, {
                get: () => e[i],
                enumerable: !(r = Hj(e, i)) || r.enumerable
            });
        return t
    },
    Yj = t => Wj(wb({}, "__esModule", {
        value: !0
    }), t),
    TM = {};
Vj(TM, {
    POPUP_TOGGLE_KEY: () => CM,
    onPopupReopen: () => qj
});
var Xj = Yj(TM),
    ZE = sn;
const CM = Symbol();

function qj(t) {
    const e = (0, ZE.inject)(CM, null);
    e && (0, ZE.watch)(e, n => {
        n && t()
    })
}
var Eb = Object.defineProperty,
    Kj = Object.getOwnPropertyDescriptor,
    Jj = Object.getOwnPropertyNames,
    Zj = Object.prototype.hasOwnProperty,
    Qj = (t, e) => {
        for (var n in e) Eb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    e5 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of Jj(e)) !Zj.call(t, i) && i !== n && Eb(t, i, {
                get: () => e[i],
                enumerable: !(r = Kj(e, i)) || r.enumerable
            });
        return t
    },
    t5 = t => e5(Eb({}, "__esModule", {
        value: !0
    }), t),
    PM = {};
Qj(PM, {
    useScopeId: () => i5
});
var n5 = t5(PM),
    r5 = sn;
const i5 = () => {
    var t;
    const {
        scopeId: e
    } = ((t = (0, r5.getCurrentInstance)()) == null ? void 0 : t.vnode) || {};
    return e ? {
        [e]: ""
    } : null
};
var Sb = Object.defineProperty,
    s5 = Object.getOwnPropertyDescriptor,
    o5 = Object.getOwnPropertyNames,
    a5 = Object.prototype.hasOwnProperty,
    l5 = (t, e) => {
        for (var n in e) Sb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    c5 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of o5(e)) !a5.call(t, i) && i !== n && Sb(t, i, {
                get: () => e[i],
                enumerable: !(r = s5(e, i)) || r.enumerable
            });
        return t
    },
    u5 = t => c5(Sb({}, "__esModule", {
        value: !0
    }), t),
    AM = {};
l5(AM, {
    default: () => m5,
    overlayProps: () => IM
});
var OM = u5(AM),
    Hr = sn,
    ei = on,
    d5 = bp,
    f5 = SM;
const [h5, p5] = (0, ei.createNamespace)("overlay"), IM = {
    show: Boolean,
    zIndex: ei.numericProp,
    duration: ei.numericProp,
    className: ei.unknownProp,
    lockScroll: ei.truthProp,
    lazyRender: ei.truthProp,
    customStyle: Object,
    teleport: [String, Object]
};
var m5 = (0, Hr.defineComponent)({
        name: h5,
        inheritAttrs: !1,
        props: IM,
        setup(t, {
            attrs: e,
            slots: n
        }) {
            const r = (0, Hr.ref)(),
                i = (0, f5.useLazyRender)(() => t.show || !t.lazyRender),
                s = a => {
                    t.lockScroll && (0, ei.preventDefault)(a, !0)
                },
                o = i(() => {
                    var a;
                    const l = (0, ei.extend)((0, ei.getZIndexStyle)(t.zIndex), t.customStyle);
                    return (0, ei.isDef)(t.duration) && (l.animationDuration = `${t.duration}s`), (0, Hr.withDirectives)((0, Hr.createVNode)("div", (0, Hr.mergeProps)({
                        ref: r,
                        style: l,
                        class: [p5(), t.className]
                    }, e), [(a = n.default) == null ? void 0 : a.call(n)]), [
                        [Hr.vShow, t.show]
                    ])
                });
            return (0, d5.useEventListener)("touchmove", s, {
                target: r
            }), () => {
                const a = (0, Hr.createVNode)(Hr.Transition, {
                    name: "van-fade",
                    appear: !0
                }, {
                    default: o
                });
                return t.teleport ? (0, Hr.createVNode)(Hr.Teleport, {
                    to: t.teleport
                }, {
                    default: () => [a]
                }) : a
            }
        }
    }),
    g5 = Object.create,
    Tp = Object.defineProperty,
    y5 = Object.getOwnPropertyDescriptor,
    v5 = Object.getOwnPropertyNames,
    _5 = Object.getPrototypeOf,
    b5 = Object.prototype.hasOwnProperty,
    x5 = (t, e) => {
        for (var n in e) Tp(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    MM = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of v5(e)) !b5.call(t, i) && i !== n && Tp(t, i, {
                get: () => e[i],
                enumerable: !(r = y5(e, i)) || r.enumerable
            });
        return t
    },
    w5 = (t, e, n) => (n = t != null ? g5(_5(t)) : {}, MM(e || !t || !t.__esModule ? Tp(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    E5 = t => MM(Tp({}, "__esModule", {
        value: !0
    }), t),
    RM = {};
x5(RM, {
    Overlay: () => kM,
    default: () => A5,
    overlayProps: () => P5.overlayProps
});
var S5 = E5(RM),
    T5 = on,
    C5 = w5(OM),
    P5 = OM;
const kM = (0, T5.withInstall)(C5.default);
var A5 = kM,
    Tb = Object.defineProperty,
    O5 = Object.getOwnPropertyDescriptor,
    I5 = Object.getOwnPropertyNames,
    M5 = Object.prototype.hasOwnProperty,
    R5 = (t, e) => {
        for (var n in e) Tb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    k5 = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of I5(e)) !M5.call(t, i) && i !== n && Tb(t, i, {
                get: () => e[i],
                enumerable: !(r = O5(e, i)) || r.enumerable
            });
        return t
    },
    B5 = t => k5(Tb({}, "__esModule", {
        value: !0
    }), t),
    BM = {};
R5(BM, {
    default: () => V5,
    popupProps: () => $M
});
var DM = B5(BM),
    bt = sn,
    D5 = pj,
    Di = on,
    $5 = bp,
    F5 = qI,
    L5 = Mj,
    N5 = SM,
    U5 = Xj,
    G5 = oM,
    QE = n5,
    H5 = yM,
    z5 = S5;
const $M = (0, Di.extend)({}, D5.popupSharedProps, {
        round: Boolean,
        position: (0, Di.makeStringProp)("center"),
        closeIcon: (0, Di.makeStringProp)("cross"),
        closeable: Boolean,
        transition: String,
        iconPrefix: String,
        closeOnPopstate: Boolean,
        closeIconPosition: (0, Di.makeStringProp)("top-right"),
        destroyOnClose: Boolean,
        safeAreaInsetTop: Boolean,
        safeAreaInsetBottom: Boolean
    }),
    [j5, eS] = (0, Di.createNamespace)("popup");
var V5 = (0, bt.defineComponent)({
        name: j5,
        inheritAttrs: !1,
        props: $M,
        emits: ["open", "close", "opened", "closed", "keydown", "update:show", "clickOverlay", "clickCloseIcon"],
        setup(t, {
            emit: e,
            attrs: n,
            slots: r
        }) {
            let i, s;
            const o = (0, bt.ref)(),
                a = (0, bt.ref)(),
                l = (0, N5.useLazyRender)(() => t.show || !t.lazyRender),
                c = (0, bt.computed)(() => {
                    const w = {
                        zIndex: o.value
                    };
                    if ((0, Di.isDef)(t.duration)) {
                        const E = t.position === "center" ? "animationDuration" : "transitionDuration";
                        w[E] = `${t.duration}s`
                    }
                    return w
                }),
                u = () => {
                    i || (i = !0, o.value = t.zIndex !== void 0 ? +t.zIndex : (0, G5.useGlobalZIndex)(), e("open"))
                },
                d = () => {
                    i && (0, Di.callInterceptor)(t.beforeClose, {
                        done() {
                            i = !1, e("close"), e("update:show", !1)
                        }
                    })
                },
                f = w => {
                    e("clickOverlay", w), t.closeOnClickOverlay && d()
                },
                h = () => {
                    if (t.overlay) {
                        const w = (0, Di.extend)({
                            show: t.show,
                            class: t.overlayClass,
                            zIndex: o.value,
                            duration: t.duration,
                            customStyle: t.overlayStyle,
                            role: t.closeOnClickOverlay ? "button" : void 0,
                            tabindex: t.closeOnClickOverlay ? 0 : void 0
                        }, t.overlayProps);
                        return (0, bt.createVNode)(z5.Overlay, (0, bt.mergeProps)(w, (0, QE.useScopeId)(), {
                            onClick: f
                        }), {
                            default: r["overlay-content"]
                        })
                    }
                },
                p = w => {
                    e("clickCloseIcon", w), d()
                },
                b = () => {
                    if (t.closeable) return (0, bt.createVNode)(H5.Icon, {
                        role: "button",
                        tabindex: 0,
                        name: t.closeIcon,
                        class: [eS("close-icon", t.closeIconPosition), Di.HAPTICS_FEEDBACK],
                        classPrefix: t.iconPrefix,
                        onClick: p
                    }, null)
                };
            let y;
            const m = () => {
                    y && clearTimeout(y), y = setTimeout(() => {
                        e("opened")
                    })
                },
                g = () => e("closed"),
                v = w => e("keydown", w),
                _ = l(() => {
                    var w;
                    const {
                        destroyOnClose: E,
                        round: C,
                        position: A,
                        safeAreaInsetTop: T,
                        safeAreaInsetBottom: S,
                        show: P
                    } = t;
                    if (!(!P && E)) return (0, bt.withDirectives)((0, bt.createVNode)("div", (0, bt.mergeProps)({
                        ref: a,
                        style: c.value,
                        role: "dialog",
                        tabindex: 0,
                        class: [eS({
                            round: C,
                            [A]: A
                        }), {
                            "van-safe-area-top": T,
                            "van-safe-area-bottom": S
                        }],
                        onKeydown: v
                    }, n, (0, QE.useScopeId)()), [(w = r.default) == null ? void 0 : w.call(r), b()]), [
                        [bt.vShow, P]
                    ])
                }),
                x = () => {
                    const {
                        position: w,
                        transition: E,
                        transitionAppear: C
                    } = t, A = w === "center" ? "van-fade" : `van-popup-slide-${w}`;
                    return (0, bt.createVNode)(bt.Transition, {
                        name: E || A,
                        appear: C,
                        onAfterEnter: m,
                        onAfterLeave: g
                    }, {
                        default: _
                    })
                };
            return (0, bt.watch)(() => t.show, w => {
                w && !i && (u(), n.tabindex === 0 && (0, bt.nextTick)(() => {
                    var E;
                    (E = a.value) == null || E.focus()
                })), !w && i && (i = !1, e("close"))
            }), (0, F5.useExpose)({
                popupRef: a
            }), (0, L5.useLockScroll)(a, () => t.show && t.lockScroll), (0, $5.useEventListener)("popstate", () => {
                t.closeOnPopstate && (d(), s = !1)
            }), (0, bt.onMounted)(() => {
                t.show && u()
            }), (0, bt.onActivated)(() => {
                s && (e("update:show", !0), s = !1)
            }), (0, bt.onDeactivated)(() => {
                t.show && t.teleport && (d(), s = !0)
            }), (0, bt.provide)(U5.POPUP_TOGGLE_KEY, () => t.show), () => t.teleport ? (0, bt.createVNode)(bt.Teleport, {
                to: t.teleport
            }, {
                default: () => [h(), x()]
            }) : (0, bt.createVNode)(bt.Fragment, null, [h(), x()])
        }
    }),
    W5 = Object.create,
    Cp = Object.defineProperty,
    Y5 = Object.getOwnPropertyDescriptor,
    X5 = Object.getOwnPropertyNames,
    q5 = Object.getPrototypeOf,
    K5 = Object.prototype.hasOwnProperty,
    J5 = (t, e) => {
        for (var n in e) Cp(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    FM = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of X5(e)) !K5.call(t, i) && i !== n && Cp(t, i, {
                get: () => e[i],
                enumerable: !(r = Y5(e, i)) || r.enumerable
            });
        return t
    },
    Z5 = (t, e, n) => (n = t != null ? W5(q5(t)) : {}, FM(e || !t || !t.__esModule ? Cp(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    Q5 = t => FM(Cp({}, "__esModule", {
        value: !0
    }), t),
    LM = {};
J5(LM, {
    Popup: () => NM,
    default: () => iV,
    popupProps: () => rV.popupProps
});
var eV = Q5(LM),
    tV = on,
    nV = Z5(DM),
    rV = DM;
const NM = (0, tV.withInstall)(nV.default);
var iV = NM,
    Cb = Object.defineProperty,
    sV = Object.getOwnPropertyDescriptor,
    oV = Object.getOwnPropertyNames,
    aV = Object.prototype.hasOwnProperty,
    lV = (t, e) => {
        for (var n in e) Cb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    cV = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of oV(e)) !aV.call(t, i) && i !== n && Cb(t, i, {
                get: () => e[i],
                enumerable: !(r = sV(e, i)) || r.enumerable
            });
        return t
    },
    uV = t => cV(Cb({}, "__esModule", {
        value: !0
    }), t),
    UM = {};
lV(UM, {
    default: () => pV,
    loadingProps: () => HM
});
var GM = uV(UM),
    ws = sn,
    zo = on;
const [dV, Hc] = (0, zo.createNamespace)("loading"), fV = Array(12).fill(null).map((t, e) => (0, ws.createVNode)("i", {
    class: Hc("line", String(e + 1))
}, null)), hV = (0, ws.createVNode)("svg", {
    class: Hc("circular"),
    viewBox: "25 25 50 50"
}, [(0, ws.createVNode)("circle", {
    cx: "50",
    cy: "50",
    r: "20",
    fill: "none"
}, null)]), HM = {
    size: zo.numericProp,
    type: (0, zo.makeStringProp)("circular"),
    color: String,
    vertical: Boolean,
    textSize: zo.numericProp,
    textColor: String
};
var pV = (0, ws.defineComponent)({
        name: dV,
        props: HM,
        setup(t, {
            slots: e
        }) {
            const n = (0, ws.computed)(() => (0, zo.extend)({
                    color: t.color
                }, (0, zo.getSizeStyle)(t.size))),
                r = () => {
                    const s = t.type === "spinner" ? fV : hV;
                    return (0, ws.createVNode)("span", {
                        class: Hc("spinner", t.type),
                        style: n.value
                    }, [e.icon ? e.icon() : s])
                },
                i = () => {
                    var s;
                    if (e.default) return (0, ws.createVNode)("span", {
                        class: Hc("text"),
                        style: {
                            fontSize: (0, zo.addUnit)(t.textSize),
                            color: (s = t.textColor) != null ? s : t.color
                        }
                    }, [e.default()])
                };
            return () => {
                const {
                    type: s,
                    vertical: o
                } = t;
                return (0, ws.createVNode)("div", {
                    class: Hc([s, {
                        vertical: o
                    }]),
                    "aria-live": "polite",
                    "aria-busy": !0
                }, [r(), i()])
            }
        }
    }),
    mV = Object.create,
    Pp = Object.defineProperty,
    gV = Object.getOwnPropertyDescriptor,
    yV = Object.getOwnPropertyNames,
    vV = Object.getPrototypeOf,
    _V = Object.prototype.hasOwnProperty,
    bV = (t, e) => {
        for (var n in e) Pp(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    zM = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of yV(e)) !_V.call(t, i) && i !== n && Pp(t, i, {
                get: () => e[i],
                enumerable: !(r = gV(e, i)) || r.enumerable
            });
        return t
    },
    xV = (t, e, n) => (n = t != null ? mV(vV(t)) : {}, zM(e || !t || !t.__esModule ? Pp(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    wV = t => zM(Pp({}, "__esModule", {
        value: !0
    }), t),
    jM = {};
bV(jM, {
    Loading: () => VM,
    default: () => PV,
    loadingProps: () => CV.loadingProps
});
var EV = wV(jM),
    SV = on,
    TV = xV(GM),
    CV = GM;
const VM = (0, SV.withInstall)(TV.default);
var PV = VM,
    Pb = Object.defineProperty,
    AV = Object.getOwnPropertyDescriptor,
    OV = Object.getOwnPropertyNames,
    IV = Object.prototype.hasOwnProperty,
    MV = (t, e) => {
        for (var n in e) Pb(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    RV = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of OV(e)) !IV.call(t, i) && i !== n && Pb(t, i, {
                get: () => e[i],
                enumerable: !(r = AV(e, i)) || r.enumerable
            });
        return t
    },
    kV = t => RV(Pb({}, "__esModule", {
        value: !0
    }), t),
    WM = {};
MV(WM, {
    default: () => GV,
    toastProps: () => YM
});
var BV = kV(WM),
    ar = sn,
    dr = on,
    DV = K8,
    $V = yM,
    FV = eV,
    LV = EV;
const [NV, Oa] = (0, dr.createNamespace)("toast"), UV = ["show", "overlay", "teleport", "transition", "overlayClass", "overlayStyle", "closeOnClickOverlay", "zIndex"], YM = {
    icon: String,
    show: Boolean,
    type: (0, dr.makeStringProp)("text"),
    overlay: Boolean,
    message: dr.numericProp,
    iconSize: dr.numericProp,
    duration: (0, dr.makeNumberProp)(2e3),
    position: (0, dr.makeStringProp)("middle"),
    teleport: [String, Object],
    wordBreak: String,
    className: dr.unknownProp,
    iconPrefix: String,
    transition: (0, dr.makeStringProp)("van-fade"),
    loadingType: String,
    forbidClick: Boolean,
    overlayClass: dr.unknownProp,
    overlayStyle: Object,
    closeOnClick: Boolean,
    closeOnClickOverlay: Boolean,
    zIndex: dr.numericProp
};
var GV = (0, ar.defineComponent)({
        name: NV,
        props: YM,
        emits: ["update:show"],
        setup(t, {
            emit: e,
            slots: n
        }) {
            let r, i = !1;
            const s = () => {
                    const d = t.show && t.forbidClick;
                    i !== d && (i = d, (0, DV.lockClick)(i))
                },
                o = d => e("update:show", d),
                a = () => {
                    t.closeOnClick && o(!1)
                },
                l = () => clearTimeout(r),
                c = () => {
                    const {
                        icon: d,
                        type: f,
                        iconSize: h,
                        iconPrefix: p,
                        loadingType: b
                    } = t;
                    if (d || f === "success" || f === "fail") return (0, ar.createVNode)($V.Icon, {
                        name: d || f,
                        size: h,
                        class: Oa("icon"),
                        classPrefix: p
                    }, null);
                    if (f === "loading") return (0, ar.createVNode)(LV.Loading, {
                        class: Oa("loading"),
                        size: h,
                        type: b
                    }, null)
                },
                u = () => {
                    const {
                        type: d,
                        message: f
                    } = t;
                    if (n.message) return (0, ar.createVNode)("div", {
                        class: Oa("text")
                    }, [n.message()]);
                    if ((0, dr.isDef)(f) && f !== "") return d === "html" ? (0, ar.createVNode)("div", {
                        key: 0,
                        class: Oa("text"),
                        innerHTML: String(f)
                    }, null) : (0, ar.createVNode)("div", {
                        class: Oa("text")
                    }, [f])
                };
            return (0, ar.watch)(() => [t.show, t.forbidClick], s), (0, ar.watch)(() => [t.show, t.type, t.message, t.duration], () => {
                l(), t.show && t.duration > 0 && (r = setTimeout(() => {
                    o(!1)
                }, t.duration))
            }), (0, ar.onMounted)(s), (0, ar.onUnmounted)(s), () => (0, ar.createVNode)(FV.Popup, (0, ar.mergeProps)({
                class: [Oa([t.position, t.wordBreak === "normal" ? "break-normal" : t.wordBreak, {
                    [t.type]: !t.icon
                }]), t.className],
                lockScroll: !1,
                onClick: a,
                onClosed: l,
                "onUpdate:show": o
            }, (0, dr.pick)(t, UV)), {
                default: () => [c(), u()]
            })
        }
    }),
    HV = Object.create,
    Ap = Object.defineProperty,
    zV = Object.getOwnPropertyDescriptor,
    jV = Object.getOwnPropertyNames,
    VV = Object.getPrototypeOf,
    WV = Object.prototype.hasOwnProperty,
    YV = (t, e) => {
        for (var n in e) Ap(t, n, {
            get: e[n],
            enumerable: !0
        })
    },
    XM = (t, e, n, r) => {
        if (e && typeof e == "object" || typeof e == "function")
            for (let i of jV(e)) !WV.call(t, i) && i !== n && Ap(t, i, {
                get: () => e[i],
                enumerable: !(r = zV(e, i)) || r.enumerable
            });
        return t
    },
    XV = (t, e, n) => (n = t != null ? HV(VV(t)) : {}, XM(e || !t || !t.__esModule ? Ap(n, "default", {
        value: t,
        enumerable: !0
    }) : n, t)),
    qV = t => XM(Ap({}, "__esModule", {
        value: !0
    }), t),
    qM = {};
YV(qM, {
    allowMultipleToast: () => sW,
    closeToast: () => nW,
    resetToastDefaultOptions: () => iW,
    setToastDefaultOptions: () => rW,
    showFailToast: () => tW,
    showLoadingToast: () => QV,
    showSuccessToast: () => eW,
    showToast: () => ZM
});
var Ube = qV(qM),
    oc = sn,
    Zo = on,
    tS = N8,
    KV = XV(BV);
const KM = {
    icon: "",
    type: "text",
    message: "",
    className: "",
    overlay: !1,
    onClose: void 0,
    onOpened: void 0,
    duration: 2e3,
    teleport: "body",
    iconSize: void 0,
    iconPrefix: void 0,
    position: "middle",
    transition: "van-fade",
    forbidClick: !1,
    loadingType: void 0,
    overlayClass: "",
    overlayStyle: void 0,
    closeOnClick: !1,
    closeOnClickOverlay: !1
};
let Ar = [],
    Op = !1,
    mh = (0, Zo.extend)({}, KM);
const gh = new Map;

function JM(t) {
    return (0, Zo.isObject)(t) ? t : {
        message: t
    }
}

function JV() {
    const {
        instance: t,
        unmount: e
    } = (0, tS.mountComponent)({
        setup() {
            const n = (0, oc.ref)(""),
                {
                    open: r,
                    state: i,
                    close: s,
                    toggle: o
                } = (0, tS.usePopupState)(),
                a = () => {
                    Op && (Ar = Ar.filter(c => c !== t), e())
                },
                l = () => {
                    const c = {
                        onClosed: a,
                        "onUpdate:show": o
                    };
                    return (0, oc.createVNode)(KV.default, (0, oc.mergeProps)(i, c), null)
                };
            return (0, oc.watch)(n, c => {
                i.message = c
            }), (0, oc.getCurrentInstance)().render = l, {
                open: r,
                close: s,
                message: n
            }
        }
    });
    return t
}

function ZV() {
    if (!Ar.length || Op) {
        const t = JV();
        Ar.push(t)
    }
    return Ar[Ar.length - 1]
}

function ZM(t = {}) {
    if (!Zo.inBrowser) return {};
    const e = ZV(),
        n = JM(t);
    return e.open((0, Zo.extend)({}, mh, gh.get(n.type || mh.type), n)), e
}
const Ab = t => e => ZM((0, Zo.extend)({
        type: t
    }, JM(e))),
    QV = Ab("loading"),
    eW = Ab("success"),
    tW = Ab("fail"),
    nW = t => {
        var e;
        Ar.length && (t ? (Ar.forEach(n => {
            n.close()
        }), Ar = []) : Op ? (e = Ar.shift()) == null || e.close() : Ar[0].close())
    };

function rW(t, e) {
    typeof t == "string" ? gh.set(t, e) : (0, Zo.extend)(mh, t)
}
const iW = t => {
        typeof t == "string" ? gh.delete(t) : (mh = (0, Zo.extend)({}, KM), gh.clear())
    },
    sW = (t = !0) => {
        Op = t
    };
var QM = {
    exports: {}
};
(function(t, e) {
    (function(n) {
        t.exports = n()
    })(function(n) {
        var r = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];

        function i(m, g) {
            var v = m[0],
                _ = m[1],
                x = m[2],
                w = m[3];
            v += (_ & x | ~_ & w) + g[0] - 680876936 | 0, v = (v << 7 | v >>> 25) + _ | 0, w += (v & _ | ~v & x) + g[1] - 389564586 | 0, w = (w << 12 | w >>> 20) + v | 0, x += (w & v | ~w & _) + g[2] + 606105819 | 0, x = (x << 17 | x >>> 15) + w | 0, _ += (x & w | ~x & v) + g[3] - 1044525330 | 0, _ = (_ << 22 | _ >>> 10) + x | 0, v += (_ & x | ~_ & w) + g[4] - 176418897 | 0, v = (v << 7 | v >>> 25) + _ | 0, w += (v & _ | ~v & x) + g[5] + 1200080426 | 0, w = (w << 12 | w >>> 20) + v | 0, x += (w & v | ~w & _) + g[6] - 1473231341 | 0, x = (x << 17 | x >>> 15) + w | 0, _ += (x & w | ~x & v) + g[7] - 45705983 | 0, _ = (_ << 22 | _ >>> 10) + x | 0, v += (_ & x | ~_ & w) + g[8] + 1770035416 | 0, v = (v << 7 | v >>> 25) + _ | 0, w += (v & _ | ~v & x) + g[9] - 1958414417 | 0, w = (w << 12 | w >>> 20) + v | 0, x += (w & v | ~w & _) + g[10] - 42063 | 0, x = (x << 17 | x >>> 15) + w | 0, _ += (x & w | ~x & v) + g[11] - 1990404162 | 0, _ = (_ << 22 | _ >>> 10) + x | 0, v += (_ & x | ~_ & w) + g[12] + 1804603682 | 0, v = (v << 7 | v >>> 25) + _ | 0, w += (v & _ | ~v & x) + g[13] - 40341101 | 0, w = (w << 12 | w >>> 20) + v | 0, x += (w & v | ~w & _) + g[14] - 1502002290 | 0, x = (x << 17 | x >>> 15) + w | 0, _ += (x & w | ~x & v) + g[15] + 1236535329 | 0, _ = (_ << 22 | _ >>> 10) + x | 0, v += (_ & w | x & ~w) + g[1] - 165796510 | 0, v = (v << 5 | v >>> 27) + _ | 0, w += (v & x | _ & ~x) + g[6] - 1069501632 | 0, w = (w << 9 | w >>> 23) + v | 0, x += (w & _ | v & ~_) + g[11] + 643717713 | 0, x = (x << 14 | x >>> 18) + w | 0, _ += (x & v | w & ~v) + g[0] - 373897302 | 0, _ = (_ << 20 | _ >>> 12) + x | 0, v += (_ & w | x & ~w) + g[5] - 701558691 | 0, v = (v << 5 | v >>> 27) + _ | 0, w += (v & x | _ & ~x) + g[10] + 38016083 | 0, w = (w << 9 | w >>> 23) + v | 0, x += (w & _ | v & ~_) + g[15] - 660478335 | 0, x = (x << 14 | x >>> 18) + w | 0, _ += (x & v | w & ~v) + g[4] - 405537848 | 0, _ = (_ << 20 | _ >>> 12) + x | 0, v += (_ & w | x & ~w) + g[9] + 568446438 | 0, v = (v << 5 | v >>> 27) + _ | 0, w += (v & x | _ & ~x) + g[14] - 1019803690 | 0, w = (w << 9 | w >>> 23) + v | 0, x += (w & _ | v & ~_) + g[3] - 187363961 | 0, x = (x << 14 | x >>> 18) + w | 0, _ += (x & v | w & ~v) + g[8] + 1163531501 | 0, _ = (_ << 20 | _ >>> 12) + x | 0, v += (_ & w | x & ~w) + g[13] - 1444681467 | 0, v = (v << 5 | v >>> 27) + _ | 0, w += (v & x | _ & ~x) + g[2] - 51403784 | 0, w = (w << 9 | w >>> 23) + v | 0, x += (w & _ | v & ~_) + g[7] + 1735328473 | 0, x = (x << 14 | x >>> 18) + w | 0, _ += (x & v | w & ~v) + g[12] - 1926607734 | 0, _ = (_ << 20 | _ >>> 12) + x | 0, v += (_ ^ x ^ w) + g[5] - 378558 | 0, v = (v << 4 | v >>> 28) + _ | 0, w += (v ^ _ ^ x) + g[8] - 2022574463 | 0, w = (w << 11 | w >>> 21) + v | 0, x += (w ^ v ^ _) + g[11] + 1839030562 | 0, x = (x << 16 | x >>> 16) + w | 0, _ += (x ^ w ^ v) + g[14] - 35309556 | 0, _ = (_ << 23 | _ >>> 9) + x | 0, v += (_ ^ x ^ w) + g[1] - 1530992060 | 0, v = (v << 4 | v >>> 28) + _ | 0, w += (v ^ _ ^ x) + g[4] + 1272893353 | 0, w = (w << 11 | w >>> 21) + v | 0, x += (w ^ v ^ _) + g[7] - 155497632 | 0, x = (x << 16 | x >>> 16) + w | 0, _ += (x ^ w ^ v) + g[10] - 1094730640 | 0, _ = (_ << 23 | _ >>> 9) + x | 0, v += (_ ^ x ^ w) + g[13] + 681279174 | 0, v = (v << 4 | v >>> 28) + _ | 0, w += (v ^ _ ^ x) + g[0] - 358537222 | 0, w = (w << 11 | w >>> 21) + v | 0, x += (w ^ v ^ _) + g[3] - 722521979 | 0, x = (x << 16 | x >>> 16) + w | 0, _ += (x ^ w ^ v) + g[6] + 76029189 | 0, _ = (_ << 23 | _ >>> 9) + x | 0, v += (_ ^ x ^ w) + g[9] - 640364487 | 0, v = (v << 4 | v >>> 28) + _ | 0, w += (v ^ _ ^ x) + g[12] - 421815835 | 0, w = (w << 11 | w >>> 21) + v | 0, x += (w ^ v ^ _) + g[15] + 530742520 | 0, x = (x << 16 | x >>> 16) + w | 0, _ += (x ^ w ^ v) + g[2] - 995338651 | 0, _ = (_ << 23 | _ >>> 9) + x | 0, v += (x ^ (_ | ~w)) + g[0] - 198630844 | 0, v = (v << 6 | v >>> 26) + _ | 0, w += (_ ^ (v | ~x)) + g[7] + 1126891415 | 0, w = (w << 10 | w >>> 22) + v | 0, x += (v ^ (w | ~_)) + g[14] - 1416354905 | 0, x = (x << 15 | x >>> 17) + w | 0, _ += (w ^ (x | ~v)) + g[5] - 57434055 | 0, _ = (_ << 21 | _ >>> 11) + x | 0, v += (x ^ (_ | ~w)) + g[12] + 1700485571 | 0, v = (v << 6 | v >>> 26) + _ | 0, w += (_ ^ (v | ~x)) + g[3] - 1894986606 | 0, w = (w << 10 | w >>> 22) + v | 0, x += (v ^ (w | ~_)) + g[10] - 1051523 | 0, x = (x << 15 | x >>> 17) + w | 0, _ += (w ^ (x | ~v)) + g[1] - 2054922799 | 0, _ = (_ << 21 | _ >>> 11) + x | 0, v += (x ^ (_ | ~w)) + g[8] + 1873313359 | 0, v = (v << 6 | v >>> 26) + _ | 0, w += (_ ^ (v | ~x)) + g[15] - 30611744 | 0, w = (w << 10 | w >>> 22) + v | 0, x += (v ^ (w | ~_)) + g[6] - 1560198380 | 0, x = (x << 15 | x >>> 17) + w | 0, _ += (w ^ (x | ~v)) + g[13] + 1309151649 | 0, _ = (_ << 21 | _ >>> 11) + x | 0, v += (x ^ (_ | ~w)) + g[4] - 145523070 | 0, v = (v << 6 | v >>> 26) + _ | 0, w += (_ ^ (v | ~x)) + g[11] - 1120210379 | 0, w = (w << 10 | w >>> 22) + v | 0, x += (v ^ (w | ~_)) + g[2] + 718787259 | 0, x = (x << 15 | x >>> 17) + w | 0, _ += (w ^ (x | ~v)) + g[9] - 343485551 | 0, _ = (_ << 21 | _ >>> 11) + x | 0, m[0] = v + m[0] | 0, m[1] = _ + m[1] | 0, m[2] = x + m[2] | 0, m[3] = w + m[3] | 0
        }

        function s(m) {
            var g = [],
                v;
            for (v = 0; v < 64; v += 4) g[v >> 2] = m.charCodeAt(v) + (m.charCodeAt(v + 1) << 8) + (m.charCodeAt(v + 2) << 16) + (m.charCodeAt(v + 3) << 24);
            return g
        }

        function o(m) {
            var g = [],
                v;
            for (v = 0; v < 64; v += 4) g[v >> 2] = m[v] + (m[v + 1] << 8) + (m[v + 2] << 16) + (m[v + 3] << 24);
            return g
        }

        function a(m) {
            var g = m.length,
                v = [1732584193, -271733879, -1732584194, 271733878],
                _, x, w, E, C, A;
            for (_ = 64; _ <= g; _ += 64) i(v, s(m.substring(_ - 64, _)));
            for (m = m.substring(_ - 64), x = m.length, w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], _ = 0; _ < x; _ += 1) w[_ >> 2] |= m.charCodeAt(_) << (_ % 4 << 3);
            if (w[_ >> 2] |= 128 << (_ % 4 << 3), _ > 55)
                for (i(v, w), _ = 0; _ < 16; _ += 1) w[_] = 0;
            return E = g * 8, E = E.toString(16).match(/(.*?)(.{0,8})$/), C = parseInt(E[2], 16), A = parseInt(E[1], 16) || 0, w[14] = C, w[15] = A, i(v, w), v
        }

        function l(m) {
            var g = m.length,
                v = [1732584193, -271733879, -1732584194, 271733878],
                _, x, w, E, C, A;
            for (_ = 64; _ <= g; _ += 64) i(v, o(m.subarray(_ - 64, _)));
            for (m = _ - 64 < g ? m.subarray(_ - 64) : new Uint8Array(0), x = m.length, w = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], _ = 0; _ < x; _ += 1) w[_ >> 2] |= m[_] << (_ % 4 << 3);
            if (w[_ >> 2] |= 128 << (_ % 4 << 3), _ > 55)
                for (i(v, w), _ = 0; _ < 16; _ += 1) w[_] = 0;
            return E = g * 8, E = E.toString(16).match(/(.*?)(.{0,8})$/), C = parseInt(E[2], 16), A = parseInt(E[1], 16) || 0, w[14] = C, w[15] = A, i(v, w), v
        }

        function c(m) {
            var g = "",
                v;
            for (v = 0; v < 4; v += 1) g += r[m >> v * 8 + 4 & 15] + r[m >> v * 8 & 15];
            return g
        }

        function u(m) {
            var g;
            for (g = 0; g < m.length; g += 1) m[g] = c(m[g]);
            return m.join("")
        }
        u(a("hello")), typeof ArrayBuffer < "u" && !ArrayBuffer.prototype.slice && function() {
            function m(g, v) {
                return g = g | 0 || 0, g < 0 ? Math.max(g + v, 0) : Math.min(g, v)
            }
            ArrayBuffer.prototype.slice = function(g, v) {
                var _ = this.byteLength,
                    x = m(g, _),
                    w = _,
                    E, C, A, T;
                return v !== n && (w = m(v, _)), x > w ? new ArrayBuffer(0) : (E = w - x, C = new ArrayBuffer(E), A = new Uint8Array(C), T = new Uint8Array(this, x, E), A.set(T), C)
            }
        }();

        function d(m) {
            return /[\u0080-\uFFFF]/.test(m) && (m = unescape(encodeURIComponent(m))), m
        }

        function f(m, g) {
            var v = m.length,
                _ = new ArrayBuffer(v),
                x = new Uint8Array(_),
                w;
            for (w = 0; w < v; w += 1) x[w] = m.charCodeAt(w);
            return g ? x : _
        }

        function h(m) {
            return String.fromCharCode.apply(null, new Uint8Array(m))
        }

        function p(m, g, v) {
            var _ = new Uint8Array(m.byteLength + g.byteLength);
            return _.set(new Uint8Array(m)), _.set(new Uint8Array(g), m.byteLength), v ? _ : _.buffer
        }

        function b(m) {
            var g = [],
                v = m.length,
                _;
            for (_ = 0; _ < v - 1; _ += 2) g.push(parseInt(m.substr(_, 2), 16));
            return String.fromCharCode.apply(String, g)
        }

        function y() {
            this.reset()
        }
        return y.prototype.append = function(m) {
            return this.appendBinary(d(m)), this
        }, y.prototype.appendBinary = function(m) {
            this._buff += m, this._length += m.length;
            var g = this._buff.length,
                v;
            for (v = 64; v <= g; v += 64) i(this._hash, s(this._buff.substring(v - 64, v)));
            return this._buff = this._buff.substring(v - 64), this
        }, y.prototype.end = function(m) {
            var g = this._buff,
                v = g.length,
                _, x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                w;
            for (_ = 0; _ < v; _ += 1) x[_ >> 2] |= g.charCodeAt(_) << (_ % 4 << 3);
            return this._finish(x, v), w = u(this._hash), m && (w = b(w)), this.reset(), w
        }, y.prototype.reset = function() {
            return this._buff = "", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this
        }, y.prototype.getState = function() {
            return {
                buff: this._buff,
                length: this._length,
                hash: this._hash.slice()
            }
        }, y.prototype.setState = function(m) {
            return this._buff = m.buff, this._length = m.length, this._hash = m.hash, this
        }, y.prototype.destroy = function() {
            delete this._hash, delete this._buff, delete this._length
        }, y.prototype._finish = function(m, g) {
            var v = g,
                _, x, w;
            if (m[v >> 2] |= 128 << (v % 4 << 3), v > 55)
                for (i(this._hash, m), v = 0; v < 16; v += 1) m[v] = 0;
            _ = this._length * 8, _ = _.toString(16).match(/(.*?)(.{0,8})$/), x = parseInt(_[2], 16), w = parseInt(_[1], 16) || 0, m[14] = x, m[15] = w, i(this._hash, m)
        }, y.hash = function(m, g) {
            return y.hashBinary(d(m), g)
        }, y.hashBinary = function(m, g) {
            var v = a(m),
                _ = u(v);
            return g ? b(_) : _
        }, y.ArrayBuffer = function() {
            this.reset()
        }, y.ArrayBuffer.prototype.append = function(m) {
            var g = p(this._buff.buffer, m, !0),
                v = g.length,
                _;
            for (this._length += m.byteLength, _ = 64; _ <= v; _ += 64) i(this._hash, o(g.subarray(_ - 64, _)));
            return this._buff = _ - 64 < v ? new Uint8Array(g.buffer.slice(_ - 64)) : new Uint8Array(0), this
        }, y.ArrayBuffer.prototype.end = function(m) {
            var g = this._buff,
                v = g.length,
                _ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                x, w;
            for (x = 0; x < v; x += 1) _[x >> 2] |= g[x] << (x % 4 << 3);
            return this._finish(_, v), w = u(this._hash), m && (w = b(w)), this.reset(), w
        }, y.ArrayBuffer.prototype.reset = function() {
            return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this
        }, y.ArrayBuffer.prototype.getState = function() {
            var m = y.prototype.getState.call(this);
            return m.buff = h(m.buff), m
        }, y.ArrayBuffer.prototype.setState = function(m) {
            return m.buff = f(m.buff, !0), y.prototype.setState.call(this, m)
        }, y.ArrayBuffer.prototype.destroy = y.prototype.destroy, y.ArrayBuffer.prototype._finish = y.prototype._finish, y.ArrayBuffer.hash = function(m, g) {
            var v = l(new Uint8Array(m)),
                _ = u(v);
            return g ? b(_) : _
        }, y
    })
})(QM);
var oW = QM.exports;
const Gbe = Hl(oW);
var e2 = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r()
    })(Jo, function() {
        var n = 1e3,
            r = 6e4,
            i = 36e5,
            s = "millisecond",
            o = "second",
            a = "minute",
            l = "hour",
            c = "day",
            u = "week",
            d = "month",
            f = "quarter",
            h = "year",
            p = "date",
            b = "Invalid Date",
            y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
            m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
            g = {
                name: "en",
                weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                ordinal: function(D) {
                    var H = ["th", "st", "nd", "rd"],
                        B = D % 100;
                    return "[" + D + (H[(B - 20) % 10] || H[B] || H[0]) + "]"
                }
            },
            v = function(D, H, B) {
                var N = String(D);
                return !N || N.length >= H ? D : "" + Array(H + 1 - N.length).join(B) + D
            },
            _ = {
                s: v,
                z: function(D) {
                    var H = -D.utcOffset(),
                        B = Math.abs(H),
                        N = Math.floor(B / 60),
                        V = B % 60;
                    return (H <= 0 ? "+" : "-") + v(N, 2, "0") + ":" + v(V, 2, "0")
                },
                m: function D(H, B) {
                    if (H.date() < B.date()) return -D(B, H);
                    var N = 12 * (B.year() - H.year()) + (B.month() - H.month()),
                        V = H.clone().add(N, d),
                        Y = B - V < 0,
                        le = H.clone().add(N + (Y ? -1 : 1), d);
                    return +(-(N + (B - V) / (Y ? V - le : le - V)) || 0)
                },
                a: function(D) {
                    return D < 0 ? Math.ceil(D) || 0 : Math.floor(D)
                },
                p: function(D) {
                    return {
                        M: d,
                        y: h,
                        w: u,
                        d: c,
                        D: p,
                        h: l,
                        m: a,
                        s: o,
                        ms: s,
                        Q: f
                    }[D] || String(D || "").toLowerCase().replace(/s$/, "")
                },
                u: function(D) {
                    return D === void 0
                }
            },
            x = "en",
            w = {};
        w[x] = g;
        var E = "$isDayjsObject",
            C = function(D) {
                return D instanceof P || !(!D || !D[E])
            },
            A = function D(H, B, N) {
                var V;
                if (!H) return x;
                if (typeof H == "string") {
                    var Y = H.toLowerCase();
                    w[Y] && (V = Y), B && (w[Y] = B, V = Y);
                    var le = H.split("-");
                    if (!V && le.length > 1) return D(le[0])
                } else {
                    var ae = H.name;
                    w[ae] = H, V = ae
                }
                return !N && V && (x = V), V || !N && x
            },
            T = function(D, H) {
                if (C(D)) return D.clone();
                var B = typeof H == "object" ? H : {};
                return B.date = D, B.args = arguments, new P(B)
            },
            S = _;
        S.l = A, S.i = C, S.w = function(D, H) {
            return T(D, {
                locale: H.$L,
                utc: H.$u,
                x: H.$x,
                $offset: H.$offset
            })
        };
        var P = function() {
                function D(B) {
                    this.$L = A(B.locale, null, !0), this.parse(B), this.$x = this.$x || B.x || {}, this[E] = !0
                }
                var H = D.prototype;
                return H.parse = function(B) {
                    this.$d = function(N) {
                        var V = N.date,
                            Y = N.utc;
                        if (V === null) return new Date(NaN);
                        if (S.u(V)) return new Date;
                        if (V instanceof Date) return new Date(V);
                        if (typeof V == "string" && !/Z$/i.test(V)) {
                            var le = V.match(y);
                            if (le) {
                                var ae = le[2] - 1 || 0,
                                    W = (le[7] || "0").substring(0, 3);
                                return Y ? new Date(Date.UTC(le[1], ae, le[3] || 1, le[4] || 0, le[5] || 0, le[6] || 0, W)) : new Date(le[1], ae, le[3] || 1, le[4] || 0, le[5] || 0, le[6] || 0, W)
                            }
                        }
                        return new Date(V)
                    }(B), this.init()
                }, H.init = function() {
                    var B = this.$d;
                    this.$y = B.getFullYear(), this.$M = B.getMonth(), this.$D = B.getDate(), this.$W = B.getDay(), this.$H = B.getHours(), this.$m = B.getMinutes(), this.$s = B.getSeconds(), this.$ms = B.getMilliseconds()
                }, H.$utils = function() {
                    return S
                }, H.isValid = function() {
                    return this.$d.toString() !== b
                }, H.isSame = function(B, N) {
                    var V = T(B);
                    return this.startOf(N) <= V && V <= this.endOf(N)
                }, H.isAfter = function(B, N) {
                    return T(B) < this.startOf(N)
                }, H.isBefore = function(B, N) {
                    return this.endOf(N) < T(B)
                }, H.$g = function(B, N, V) {
                    return S.u(B) ? this[N] : this.set(V, B)
                }, H.unix = function() {
                    return Math.floor(this.valueOf() / 1e3)
                }, H.valueOf = function() {
                    return this.$d.getTime()
                }, H.startOf = function(B, N) {
                    var V = this,
                        Y = !!S.u(N) || N,
                        le = S.p(B),
                        ae = function(K, ce) {
                            var de = S.w(V.$u ? Date.UTC(V.$y, ce, K) : new Date(V.$y, ce, K), V);
                            return Y ? de : de.endOf(c)
                        },
                        W = function(K, ce) {
                            return S.w(V.toDate()[K].apply(V.toDate("s"), (Y ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ce)), V)
                        },
                        ne = this.$W,
                        fe = this.$M,
                        $ = this.$D,
                        X = "set" + (this.$u ? "UTC" : "");
                    switch (le) {
                        case h:
                            return Y ? ae(1, 0) : ae(31, 11);
                        case d:
                            return Y ? ae(1, fe) : ae(0, fe + 1);
                        case u:
                            var F = this.$locale().weekStart || 0,
                                Z = (ne < F ? ne + 7 : ne) - F;
                            return ae(Y ? $ - Z : $ + (6 - Z), fe);
                        case c:
                        case p:
                            return W(X + "Hours", 0);
                        case l:
                            return W(X + "Minutes", 1);
                        case a:
                            return W(X + "Seconds", 2);
                        case o:
                            return W(X + "Milliseconds", 3);
                        default:
                            return this.clone()
                    }
                }, H.endOf = function(B) {
                    return this.startOf(B, !1)
                }, H.$set = function(B, N) {
                    var V, Y = S.p(B),
                        le = "set" + (this.$u ? "UTC" : ""),
                        ae = (V = {}, V[c] = le + "Date", V[p] = le + "Date", V[d] = le + "Month", V[h] = le + "FullYear", V[l] = le + "Hours", V[a] = le + "Minutes", V[o] = le + "Seconds", V[s] = le + "Milliseconds", V)[Y],
                        W = Y === c ? this.$D + (N - this.$W) : N;
                    if (Y === d || Y === h) {
                        var ne = this.clone().set(p, 1);
                        ne.$d[ae](W), ne.init(), this.$d = ne.set(p, Math.min(this.$D, ne.daysInMonth())).$d
                    } else ae && this.$d[ae](W);
                    return this.init(), this
                }, H.set = function(B, N) {
                    return this.clone().$set(B, N)
                }, H.get = function(B) {
                    return this[S.p(B)]()
                }, H.add = function(B, N) {
                    var V, Y = this;
                    B = Number(B);
                    var le = S.p(N),
                        ae = function(fe) {
                            var $ = T(Y);
                            return S.w($.date($.date() + Math.round(fe * B)), Y)
                        };
                    if (le === d) return this.set(d, this.$M + B);
                    if (le === h) return this.set(h, this.$y + B);
                    if (le === c) return ae(1);
                    if (le === u) return ae(7);
                    var W = (V = {}, V[a] = r, V[l] = i, V[o] = n, V)[le] || 1,
                        ne = this.$d.getTime() + B * W;
                    return S.w(ne, this)
                }, H.subtract = function(B, N) {
                    return this.add(-1 * B, N)
                }, H.format = function(B) {
                    var N = this,
                        V = this.$locale();
                    if (!this.isValid()) return V.invalidDate || b;
                    var Y = B || "YYYY-MM-DDTHH:mm:ssZ",
                        le = S.z(this),
                        ae = this.$H,
                        W = this.$m,
                        ne = this.$M,
                        fe = V.weekdays,
                        $ = V.months,
                        X = V.meridiem,
                        F = function(ce, de, ge, O) {
                            return ce && (ce[de] || ce(N, Y)) || ge[de].slice(0, O)
                        },
                        Z = function(ce) {
                            return S.s(ae % 12 || 12, ce, "0")
                        },
                        K = X || function(ce, de, ge) {
                            var O = ce < 12 ? "AM" : "PM";
                            return ge ? O.toLowerCase() : O
                        };
                    return Y.replace(m, function(ce, de) {
                        return de || function(ge) {
                            switch (ge) {
                                case "YY":
                                    return String(N.$y).slice(-2);
                                case "YYYY":
                                    return S.s(N.$y, 4, "0");
                                case "M":
                                    return ne + 1;
                                case "MM":
                                    return S.s(ne + 1, 2, "0");
                                case "MMM":
                                    return F(V.monthsShort, ne, $, 3);
                                case "MMMM":
                                    return F($, ne);
                                case "D":
                                    return N.$D;
                                case "DD":
                                    return S.s(N.$D, 2, "0");
                                case "d":
                                    return String(N.$W);
                                case "dd":
                                    return F(V.weekdaysMin, N.$W, fe, 2);
                                case "ddd":
                                    return F(V.weekdaysShort, N.$W, fe, 3);
                                case "dddd":
                                    return fe[N.$W];
                                case "H":
                                    return String(ae);
                                case "HH":
                                    return S.s(ae, 2, "0");
                                case "h":
                                    return Z(1);
                                case "hh":
                                    return Z(2);
                                case "a":
                                    return K(ae, W, !0);
                                case "A":
                                    return K(ae, W, !1);
                                case "m":
                                    return String(W);
                                case "mm":
                                    return S.s(W, 2, "0");
                                case "s":
                                    return String(N.$s);
                                case "ss":
                                    return S.s(N.$s, 2, "0");
                                case "SSS":
                                    return S.s(N.$ms, 3, "0");
                                case "Z":
                                    return le
                            }
                            return null
                        }(ce) || le.replace(":", "")
                    })
                }, H.utcOffset = function() {
                    return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
                }, H.diff = function(B, N, V) {
                    var Y, le = this,
                        ae = S.p(N),
                        W = T(B),
                        ne = (W.utcOffset() - this.utcOffset()) * r,
                        fe = this - W,
                        $ = function() {
                            return S.m(le, W)
                        };
                    switch (ae) {
                        case h:
                            Y = $() / 12;
                            break;
                        case d:
                            Y = $();
                            break;
                        case f:
                            Y = $() / 3;
                            break;
                        case u:
                            Y = (fe - ne) / 6048e5;
                            break;
                        case c:
                            Y = (fe - ne) / 864e5;
                            break;
                        case l:
                            Y = fe / i;
                            break;
                        case a:
                            Y = fe / r;
                            break;
                        case o:
                            Y = fe / n;
                            break;
                        default:
                            Y = fe
                    }
                    return V ? Y : S.a(Y)
                }, H.daysInMonth = function() {
                    return this.endOf(d).$D
                }, H.$locale = function() {
                    return w[this.$L]
                }, H.locale = function(B, N) {
                    if (!B) return this.$L;
                    var V = this.clone(),
                        Y = A(B, N, !0);
                    return Y && (V.$L = Y), V
                }, H.clone = function() {
                    return S.w(this.$d, this)
                }, H.toDate = function() {
                    return new Date(this.valueOf())
                }, H.toJSON = function() {
                    return this.isValid() ? this.toISOString() : null
                }, H.toISOString = function() {
                    return this.$d.toISOString()
                }, H.toString = function() {
                    return this.$d.toUTCString()
                }, D
            }(),
            R = P.prototype;
        return T.prototype = R, [
            ["$ms", s],
            ["$s", o],
            ["$m", a],
            ["$H", l],
            ["$W", c],
            ["$M", d],
            ["$y", h],
            ["$D", p]
        ].forEach(function(D) {
            R[D[1]] = function(H) {
                return this.$g(H, D[0], D[1])
            }
        }), T.extend = function(D, H) {
            return D.$i || (D(H, P, T), D.$i = !0), T
        }, T.locale = A, T.isDayjs = C, T.unix = function(D) {
            return T(1e3 * D)
        }, T.en = w[x], T.Ls = w, T.p = {}, T
    })
})(e2);
var Ob = e2.exports;
const Hbe = Hl(Ob);

function Av() {}
const Le = Object.assign,
    ui = typeof window < "u",
    di = t => t !== null && typeof t == "object",
    gt = t => t != null,
    gl = t => typeof t == "function",
    Ib = t => di(t) && gl(t.then) && gl(t.catch),
    yu = t => Object.prototype.toString.call(t) === "[object Date]" && !Number.isNaN(t.getTime()),
    t2 = t => typeof t == "number" || /^\d+(\.\d+)?$/.test(t),
    aW = () => ui ? /ios|iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()) : !1;

function nS(t, e) {
    const n = e.split(".");
    let r = t;
    return n.forEach(i => {
        var s;
        r = di(r) && (s = r[i]) != null ? s : ""
    }), r
}

function yt(t, e, n) {
    return e.reduce((r, i) => ((!n || t[i] !== void 0) && (r[i] = t[i]), r), {})
}
const $s = (t, e) => JSON.stringify(t) === JSON.stringify(e),
    yh = t => Array.isArray(t) ? t : [t],
    Ut = null,
    be = [Number, String],
    me = {
        type: Boolean,
        default: !0
    },
    xn = t => ({
        type: t,
        required: !0
    }),
    Xi = () => ({
        type: Array,
        default: () => []
    }),
    Ip = t => ({
        type: Number,
        default: t
    }),
    Fe = t => ({
        type: be,
        default: t
    }),
    Pe = t => ({
        type: String,
        default: t
    });

function od(t) {
    const e = "scrollTop" in t ? t.scrollTop : t.pageYOffset;
    return Math.max(e, 0)
}

function vh(t, e) {
    "scrollTop" in t ? t.scrollTop = e : t.scrollTo(t.scrollX, e)
}

function Mb() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
}

function Rb(t) {
    vh(window, t), vh(document.body, t)
}

function rS(t, e) {
    if (t === window) return 0;
    const n = e ? od(e) : Mb();
    return jt(t).top + n
}
const lW = aW();

function n2() {
    lW && Rb(Mb())
}
const r2 = t => t.stopPropagation();

function Zt(t, e) {
    (typeof t.cancelable != "boolean" || t.cancelable) && t.preventDefault(), e && r2(t)
}

function yl(t) {
    const e = En(t);
    if (!e) return !1;
    const n = window.getComputedStyle(e),
        r = n.display === "none",
        i = e.offsetParent === null && n.position !== "fixed";
    return r || i
}
const {
    width: Li,
    height: Fs
} = wI();

function We(t) {
    if (gt(t)) return t2(t) ? `${t}px` : String(t)
}

function _a(t) {
    if (gt(t)) {
        if (Array.isArray(t)) return {
            width: We(t[0]),
            height: We(t[1])
        };
        const e = We(t);
        return {
            width: e,
            height: e
        }
    }
}

function i2(t) {
    const e = {};
    return t !== void 0 && (e.zIndex = +t), e
}
let Um;

function cW() {
    if (!Um) {
        const t = document.documentElement,
            e = t.style.fontSize || window.getComputedStyle(t).fontSize;
        Um = parseFloat(e)
    }
    return Um
}

function uW(t) {
    return t = t.replace(/rem/g, ""), +t * cW()
}

function dW(t) {
    return t = t.replace(/vw/g, ""), +t * Li.value / 100
}

function fW(t) {
    return t = t.replace(/vh/g, ""), +t * Fs.value / 100
}

function kb(t) {
    if (typeof t == "number") return t;
    if (ui) {
        if (t.includes("rem")) return uW(t);
        if (t.includes("vw")) return dW(t);
        if (t.includes("vh")) return fW(t)
    }
    return parseFloat(t)
}
const hW = /-(\w)/g,
    s2 = t => t.replace(hW, (e, n) => n.toUpperCase());

function To(t, e = 2) {
    let n = t + "";
    for (; n.length < e;) n = "0" + n;
    return n
}
const tn = (t, e, n) => Math.min(Math.max(t, e), n);

function iS(t, e, n) {
    const r = t.indexOf(e);
    return r === -1 ? t : e === "-" && r !== 0 ? t.slice(0, r) : t.slice(0, r + 1) + t.slice(r).replace(n, "")
}

function Ov(t, e = !0, n = !0) {
    e ? t = iS(t, ".", /\./g) : t = t.split(".")[0], n ? t = iS(t, "-", /-/g) : t = t.replace(/-/, "");
    const r = e ? /[^-0-9.]/g : /[^-0-9]/g;
    return t.replace(r, "")
}

function o2(t, e) {
    return Math.round((t + e) * 1e10) / 1e10
}
const {
    hasOwnProperty: pW
} = Object.prototype;

function mW(t, e, n) {
    const r = e[n];
    gt(r) && (!pW.call(t, n) || !di(r) ? t[n] = r : t[n] = a2(Object(t[n]), r))
}

function a2(t, e) {
    return Object.keys(e).forEach(n => {
        mW(t, e, n)
    }), t
}
var gW = {
    name: "",
    tel: "",
    save: "",
    clear: "",
    cancel: "",
    confirm: "",
    delete: "",
    loading: "...",
    noCoupon: "",
    nameEmpty: "",
    addContact: "",
    telInvalid: "",
    vanCalendar: {
        end: "",
        start: "",
        title: "",
        weekdays: ["", "", "", "", "", "", ""],
        monthTitle: (t, e) => `${t}${e}`,
        rangePrompt: t => ` ${t} `
    },
    vanCascader: {
        select: ""
    },
    vanPagination: {
        prev: "",
        next: ""
    },
    vanPullRefresh: {
        pulling: "...",
        loosing: "..."
    },
    vanSubmitBar: {
        label: ":"
    },
    vanCoupon: {
        unlimited: "",
        discount: t => `${t}`,
        condition: t => `${t}`
    },
    vanCouponCell: {
        title: "",
        count: t => `${t}`
    },
    vanCouponList: {
        exchange: "",
        close: "",
        enable: "",
        disabled: "",
        placeholder: ""
    },
    vanAddressEdit: {
        area: "",
        areaEmpty: "",
        addressEmpty: "",
        addressDetail: "",
        defaultAddress: ""
    },
    vanAddressList: {
        add: ""
    }
};
const sS = q("zh-CN"),
    oS = ft({
        "zh-CN": gW
    }),
    yW = {
        messages() {
            return oS[sS.value]
        },
        use(t, e) {
            sS.value = t, this.add({
                [t]: e
            })
        },
        add(t = {}) {
            a2(oS, t)
        }
    };
var vW = yW;

function _W(t) {
    const e = s2(t) + ".";
    return (n, ...r) => {
        const i = vW.messages(),
            s = nS(i, e + n) || nS(i, n);
        return gl(s) ? s(...r) : s
    }
}

function Iv(t, e) {
    return e ? typeof e == "string" ? ` ${t}--${e}` : Array.isArray(e) ? e.reduce((n, r) => n + Iv(t, r), "") : Object.keys(e).reduce((n, r) => n + (e[r] ? Iv(t, r) : ""), "") : ""
}

function bW(t) {
    return (e, n) => (e && typeof e != "string" && (n = e, e = ""), e = e ? `${t}__${e}` : t, `${e}${Iv(e,n)}`)
}

function Ee(t) {
    const e = `van-${t}`;
    return [e, bW(e), _W(e)]
}
const eo = "van-hairline",
    l2 = `${eo}--top`,
    xW = `${eo}--left`,
    wW = `${eo}--right`,
    EW = `${eo}--bottom`,
    Lf = `${eo}--surround`,
    c2 = `${eo}--top-bottom`,
    SW = `${eo}-unset--top-bottom`,
    qi = "van-haptics-feedback",
    u2 = Symbol("van-form"),
    d2 = 500,
    aS = 5;

function jl(t, {
    args: e = [],
    done: n,
    canceled: r,
    error: i
}) {
    if (t) {
        const s = t.apply(null, e);
        Ib(s) ? s.then(o => {
            o ? n() : r && r()
        }).catch(i || Av) : s ? n() : r && r()
    } else n()
}

function Ae(t) {
    return t.install = e => {
        const {
            name: n
        } = t;
        n && (e.component(n, t), e.component(s2(`-${n}`), t))
    }, t
}

function lS(t, e) {
    return t.reduce((n, r) => Math.abs(n - e) < Math.abs(r - e) ? n : r)
}
const f2 = Symbol();

function Bb(t) {
    const e = Nt(f2, null);
    e && he(e, n => {
        n && t()
    })
}
const h2 = (t, e) => {
    const n = q(),
        r = () => {
            n.value = jt(t).height
        };
    return _t(() => {
        if (Ue(r), e)
            for (let i = 1; i <= 3; i++) setTimeout(r, 100 * i)
    }), Bb(() => Ue(r)), he([Li, Fs], r), n
};

function TW(t, e) {
    const n = h2(t, !0);
    return r => I("div", {
        class: e("placeholder"),
        style: {
            height: n.value ? `${n.value}px` : void 0
        }
    }, [r()])
}
const [p2, cS] = Ee("action-bar"), m2 = Symbol(p2), CW = {
    placeholder: Boolean,
    safeAreaInsetBottom: me
};
var PW = ve({
    name: p2,
    props: CW,
    setup(t, {
        slots: e
    }) {
        const n = q(),
            r = TW(n, cS),
            {
                linkChildren: i
            } = Lr(m2);
        i();
        const s = () => {
            var o;
            return I("div", {
                ref: n,
                class: [cS(), {
                    "van-safe-area-bottom": t.safeAreaInsetBottom
                }]
            }, [(o = e.default) == null ? void 0 : o.call(e)])
        };
        return () => t.placeholder ? r(s) : s()
    }
});
const AW = Ae(PW);

function Tt(t) {
    const e = rt();
    e && Le(e.proxy, t)
}
const Vl = {
    to: [String, Object],
    url: String,
    replace: Boolean
};

function g2({
    to: t,
    url: e,
    replace: n,
    $router: r
}) {
    t && r ? r[n ? "replace" : "push"](t) : e && (n ? location.replace(e) : location.href = e)
}

function ad() {
    const t = rt().proxy;
    return () => g2(t)
}
const [OW, uS] = Ee("badge"), IW = {
    dot: Boolean,
    max: be,
    tag: Pe("div"),
    color: String,
    offset: Array,
    content: be,
    showZero: me,
    position: Pe("top-right")
};
var MW = ve({
    name: OW,
    props: IW,
    setup(t, {
        slots: e
    }) {
        const n = () => {
                if (e.content) return !0;
                const {
                    content: a,
                    showZero: l
                } = t;
                return gt(a) && a !== "" && (l || a !== 0 && a !== "0")
            },
            r = () => {
                const {
                    dot: a,
                    max: l,
                    content: c
                } = t;
                if (!a && n()) return e.content ? e.content() : gt(l) && t2(c) && +c > +l ? `${l}+` : c
            },
            i = a => a.startsWith("-") ? a.replace("-", "") : `-${a}`,
            s = te(() => {
                const a = {
                    background: t.color
                };
                if (t.offset) {
                    const [l, c] = t.offset, {
                        position: u
                    } = t, [d, f] = u.split("-");
                    e.default ? (typeof c == "number" ? a[d] = We(d === "top" ? c : -c) : a[d] = d === "top" ? We(c) : i(c), typeof l == "number" ? a[f] = We(f === "left" ? l : -l) : a[f] = f === "left" ? We(l) : i(l)) : (a.marginTop = We(c), a.marginLeft = We(l))
                }
                return a
            }),
            o = () => {
                if (n() || t.dot) return I("div", {
                    class: uS([t.position, {
                        dot: t.dot,
                        fixed: !!e.default
                    }]),
                    style: s.value
                }, [r()])
            };
        return () => {
            if (e.default) {
                const {
                    tag: a
                } = t;
                return I(a, {
                    class: uS("wrapper")
                }, {
                    default: () => [e.default(), o()]
                })
            }
            return o()
        }
    }
});
const Mp = Ae(MW);
let RW = 2e3;
const kW = () => ++RW,
    [BW, zbe] = Ee("config-provider"),
    DW = Symbol(BW),
    [$W, dS] = Ee("icon"),
    FW = t => t == null ? void 0 : t.includes("/"),
    LW = {
        dot: Boolean,
        tag: Pe("i"),
        name: String,
        size: be,
        badge: be,
        color: String,
        badgeProps: Object,
        classPrefix: String
    };
var NW = ve({
    name: $W,
    props: LW,
    setup(t, {
        slots: e
    }) {
        const n = Nt(DW, null),
            r = te(() => t.classPrefix || (n == null ? void 0 : n.iconPrefix) || dS());
        return () => {
            const {
                tag: i,
                dot: s,
                name: o,
                size: a,
                badge: l,
                color: c
            } = t, u = FW(o);
            return I(Mp, Ke({
                dot: s,
                tag: i,
                class: [r.value, u ? "" : `${r.value}-${o}`],
                style: {
                    color: c,
                    fontSize: We(a)
                },
                content: l
            }, t.badgeProps), {
                default: () => {
                    var d;
                    return [(d = e.default) == null ? void 0 : d.call(e), u && I("img", {
                        class: dS("image"),
                        src: o
                    }, null)]
                }
            })
        }
    }
});
const Mt = Ae(NW);
var UW = Mt;
const [GW, zc] = Ee("loading"), HW = Array(12).fill(null).map((t, e) => I("i", {
    class: zc("line", String(e + 1))
}, null)), zW = I("svg", {
    class: zc("circular"),
    viewBox: "25 25 50 50"
}, [I("circle", {
    cx: "50",
    cy: "50",
    r: "20",
    fill: "none"
}, null)]), jW = {
    size: be,
    type: Pe("circular"),
    color: String,
    vertical: Boolean,
    textSize: be,
    textColor: String
};
var VW = ve({
    name: GW,
    props: jW,
    setup(t, {
        slots: e
    }) {
        const n = te(() => Le({
                color: t.color
            }, _a(t.size))),
            r = () => {
                const s = t.type === "spinner" ? HW : zW;
                return I("span", {
                    class: zc("spinner", t.type),
                    style: n.value
                }, [e.icon ? e.icon() : s])
            },
            i = () => {
                var s;
                if (e.default) return I("span", {
                    class: zc("text"),
                    style: {
                        fontSize: We(t.textSize),
                        color: (s = t.textColor) != null ? s : t.color
                    }
                }, [e.default()])
            };
        return () => {
            const {
                type: s,
                vertical: o
            } = t;
            return I("div", {
                class: zc([s, {
                    vertical: o
                }]),
                "aria-live": "polite",
                "aria-busy": !0
            }, [r(), i()])
        }
    }
});
const ss = Ae(VW),
    [WW, Ia] = Ee("button"),
    YW = Le({}, Vl, {
        tag: Pe("button"),
        text: String,
        icon: String,
        type: Pe("default"),
        size: Pe("normal"),
        color: String,
        block: Boolean,
        plain: Boolean,
        round: Boolean,
        square: Boolean,
        loading: Boolean,
        hairline: Boolean,
        disabled: Boolean,
        iconPrefix: String,
        nativeType: Pe("button"),
        loadingSize: be,
        loadingText: String,
        loadingType: String,
        iconPosition: Pe("left")
    });
var XW = ve({
    name: WW,
    props: YW,
    emits: ["click"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = ad(),
            i = () => n.loading ? n.loading() : I(ss, {
                size: t.loadingSize,
                type: t.loadingType,
                class: Ia("loading")
            }, null),
            s = () => {
                if (t.loading) return i();
                if (n.icon) return I("div", {
                    class: Ia("icon")
                }, [n.icon()]);
                if (t.icon) return I(Mt, {
                    name: t.icon,
                    class: Ia("icon"),
                    classPrefix: t.iconPrefix
                }, null)
            },
            o = () => {
                let c;
                if (t.loading ? c = t.loadingText : c = n.default ? n.default() : t.text, c) return I("span", {
                    class: Ia("text")
                }, [c])
            },
            a = () => {
                const {
                    color: c,
                    plain: u
                } = t;
                if (c) {
                    const d = {
                        color: u ? c : "white"
                    };
                    return u || (d.background = c), c.includes("gradient") ? d.border = 0 : d.borderColor = c, d
                }
            },
            l = c => {
                t.loading ? Zt(c) : t.disabled || (e("click", c), r())
            };
        return () => {
            const {
                tag: c,
                type: u,
                size: d,
                block: f,
                round: h,
                plain: p,
                square: b,
                loading: y,
                disabled: m,
                hairline: g,
                nativeType: v,
                iconPosition: _
            } = t, x = [Ia([u, d, {
                plain: p,
                block: f,
                round: h,
                square: b,
                loading: y,
                disabled: m,
                hairline: g
            }]), {
                [Lf]: g
            }];
            return I(c, {
                type: v,
                class: x,
                style: a(),
                disabled: m,
                onClick: l
            }, {
                default: () => [I("div", {
                    class: Ia("content")
                }, [_ === "left" && s(), o(), _ === "right" && s()])]
            })
        }
    }
});
const _h = Ae(XW),
    [qW, KW] = Ee("action-bar-button"),
    JW = Le({}, Vl, {
        type: String,
        text: String,
        icon: String,
        color: String,
        loading: Boolean,
        disabled: Boolean
    });
var ZW = ve({
    name: qW,
    props: JW,
    setup(t, {
        slots: e
    }) {
        const n = ad(),
            {
                parent: r,
                index: i
            } = rr(m2),
            s = te(() => {
                if (r) {
                    const a = r.children[i.value - 1];
                    return !(a && "isButton" in a)
                }
            }),
            o = te(() => {
                if (r) {
                    const a = r.children[i.value + 1];
                    return !(a && "isButton" in a)
                }
            });
        return Tt({
            isButton: !0
        }), () => {
            const {
                type: a,
                icon: l,
                text: c,
                color: u,
                loading: d,
                disabled: f
            } = t;
            return I(_h, {
                class: KW([a, {
                    last: o.value,
                    first: s.value
                }]),
                size: "large",
                type: a,
                icon: l,
                color: u,
                loading: d,
                disabled: f,
                onClick: n
            }, {
                default: () => [e.default ? e.default() : c]
            })
        }
    }
});
const fS = Ae(ZW),
    ld = {
        show: Boolean,
        zIndex: be,
        overlay: me,
        duration: be,
        teleport: [String, Object],
        lockScroll: me,
        lazyRender: me,
        beforeClose: Function,
        overlayProps: Object,
        overlayStyle: Object,
        overlayClass: Ut,
        transitionAppear: Boolean,
        closeOnClickOverlay: me
    },
    y2 = Object.keys(ld);

function QW(t, e) {
    return t > e ? "horizontal" : e > t ? "vertical" : ""
}

function ba() {
    const t = q(0),
        e = q(0),
        n = q(0),
        r = q(0),
        i = q(0),
        s = q(0),
        o = q(""),
        a = q(!0),
        l = () => o.value === "vertical",
        c = () => o.value === "horizontal",
        u = () => {
            n.value = 0, r.value = 0, i.value = 0, s.value = 0, o.value = "", a.value = !0
        };
    return {
        move: h => {
            const p = h.touches[0];
            n.value = (p.clientX < 0 ? 0 : p.clientX) - t.value, r.value = p.clientY - e.value, i.value = Math.abs(n.value), s.value = Math.abs(r.value);
            const b = 10;
            (!o.value || i.value < b && s.value < b) && (o.value = QW(i.value, s.value)), a.value && (i.value > aS || s.value > aS) && (a.value = !1)
        },
        start: h => {
            u(), t.value = h.touches[0].clientX, e.value = h.touches[0].clientY
        },
        reset: u,
        startX: t,
        startY: e,
        deltaX: n,
        deltaY: r,
        offsetX: i,
        offsetY: s,
        direction: o,
        isVertical: l,
        isHorizontal: c,
        isTap: a
    }
}
let ac = 0;
const hS = "van-overflow-hidden";

function e7(t, e) {
    const n = ba(),
        r = "01",
        i = "10",
        s = u => {
            n.move(u);
            const d = n.deltaY.value > 0 ? i : r,
                f = Q_(u.target, t.value),
                {
                    scrollHeight: h,
                    offsetHeight: p,
                    scrollTop: b
                } = f;
            let y = "11";
            b === 0 ? y = p >= h ? "00" : "01" : b + p >= h && (y = "10"), y !== "11" && n.isVertical() && !(parseInt(y, 2) & parseInt(d, 2)) && Zt(u, !0)
        },
        o = () => {
            document.addEventListener("touchstart", n.start), document.addEventListener("touchmove", s, {
                passive: !1
            }), ac || document.body.classList.add(hS), ac++
        },
        a = () => {
            ac && (document.removeEventListener("touchstart", n.start), document.removeEventListener("touchmove", s), ac--, ac || document.body.classList.remove(hS))
        },
        l = () => e() && o(),
        c = () => e() && a();
    zl(l), hi(c), nr(c), he(e, u => {
        u ? o() : a()
    })
}

function Db(t) {
    const e = q(!1);
    return he(t, n => {
        n && (e.value = n)
    }, {
        immediate: !0
    }), n => () => e.value ? n() : null
}
const Mv = () => {
        var t;
        const {
            scopeId: e
        } = ((t = rt()) == null ? void 0 : t.vnode) || {};
        return e ? {
            [e]: ""
        } : null
    },
    [t7, n7] = Ee("overlay"),
    r7 = {
        show: Boolean,
        zIndex: be,
        duration: be,
        className: Ut,
        lockScroll: me,
        lazyRender: me,
        customStyle: Object,
        teleport: [String, Object]
    };
var i7 = ve({
    name: t7,
    inheritAttrs: !1,
    props: r7,
    setup(t, {
        attrs: e,
        slots: n
    }) {
        const r = q(),
            i = Db(() => t.show || !t.lazyRender),
            s = a => {
                t.lockScroll && Zt(a, !0)
            },
            o = i(() => {
                var a;
                const l = Le(i2(t.zIndex), t.customStyle);
                return gt(t.duration) && (l.animationDuration = `${t.duration}s`), mr(I("div", Ke({
                    ref: r,
                    style: l,
                    class: [n7(), t.className]
                }, e), [(a = n.default) == null ? void 0 : a.call(n)]), [
                    [yr, t.show]
                ])
            });
        return An("touchmove", s, {
            target: r
        }), () => {
            const a = I(rd, {
                name: "van-fade",
                appear: !0
            }, {
                default: o
            });
            return t.teleport ? I(dp, {
                to: t.teleport
            }, {
                default: () => [a]
            }) : a
        }
    }
});
const s7 = Ae(i7),
    o7 = Le({}, ld, {
        round: Boolean,
        position: Pe("center"),
        closeIcon: Pe("cross"),
        closeable: Boolean,
        transition: String,
        iconPrefix: String,
        closeOnPopstate: Boolean,
        closeIconPosition: Pe("top-right"),
        destroyOnClose: Boolean,
        safeAreaInsetTop: Boolean,
        safeAreaInsetBottom: Boolean
    }),
    [a7, pS] = Ee("popup");
var l7 = ve({
    name: a7,
    inheritAttrs: !1,
    props: o7,
    emits: ["open", "close", "opened", "closed", "keydown", "update:show", "clickOverlay", "clickCloseIcon"],
    setup(t, {
        emit: e,
        attrs: n,
        slots: r
    }) {
        let i, s;
        const o = q(),
            a = q(),
            l = Db(() => t.show || !t.lazyRender),
            c = te(() => {
                const w = {
                    zIndex: o.value
                };
                if (gt(t.duration)) {
                    const E = t.position === "center" ? "animationDuration" : "transitionDuration";
                    w[E] = `${t.duration}s`
                }
                return w
            }),
            u = () => {
                i || (i = !0, o.value = t.zIndex !== void 0 ? +t.zIndex : kW(), e("open"))
            },
            d = () => {
                i && jl(t.beforeClose, {
                    done() {
                        i = !1, e("close"), e("update:show", !1)
                    }
                })
            },
            f = w => {
                e("clickOverlay", w), t.closeOnClickOverlay && d()
            },
            h = () => {
                if (t.overlay) {
                    const w = Le({
                        show: t.show,
                        class: t.overlayClass,
                        zIndex: o.value,
                        duration: t.duration,
                        customStyle: t.overlayStyle,
                        role: t.closeOnClickOverlay ? "button" : void 0,
                        tabindex: t.closeOnClickOverlay ? 0 : void 0
                    }, t.overlayProps);
                    return I(s7, Ke(w, Mv(), {
                        onClick: f
                    }), {
                        default: r["overlay-content"]
                    })
                }
            },
            p = w => {
                e("clickCloseIcon", w), d()
            },
            b = () => {
                if (t.closeable) return I(Mt, {
                    role: "button",
                    tabindex: 0,
                    name: t.closeIcon,
                    class: [pS("close-icon", t.closeIconPosition), qi],
                    classPrefix: t.iconPrefix,
                    onClick: p
                }, null)
            };
        let y;
        const m = () => {
                y && clearTimeout(y), y = setTimeout(() => {
                    e("opened")
                })
            },
            g = () => e("closed"),
            v = w => e("keydown", w),
            _ = l(() => {
                var w;
                const {
                    destroyOnClose: E,
                    round: C,
                    position: A,
                    safeAreaInsetTop: T,
                    safeAreaInsetBottom: S,
                    show: P
                } = t;
                if (!(!P && E)) return mr(I("div", Ke({
                    ref: a,
                    style: c.value,
                    role: "dialog",
                    tabindex: 0,
                    class: [pS({
                        round: C,
                        [A]: A
                    }), {
                        "van-safe-area-top": T,
                        "van-safe-area-bottom": S
                    }],
                    onKeydown: v
                }, n, Mv()), [(w = r.default) == null ? void 0 : w.call(r), b()]), [
                    [yr, P]
                ])
            }),
            x = () => {
                const {
                    position: w,
                    transition: E,
                    transitionAppear: C
                } = t, A = w === "center" ? "van-fade" : `van-popup-slide-${w}`;
                return I(rd, {
                    name: E || A,
                    appear: C,
                    onAfterEnter: m,
                    onAfterLeave: g
                }, {
                    default: _
                })
            };
        return he(() => t.show, w => {
            w && !i && (u(), n.tabindex === 0 && Ue(() => {
                var E;
                (E = a.value) == null || E.focus()
            })), !w && i && (i = !1, e("close"))
        }), Tt({
            popupRef: a
        }), e7(a, () => t.show && t.lockScroll), An("popstate", () => {
            t.closeOnPopstate && (d(), s = !1)
        }), _t(() => {
            t.show && u()
        }), ns(() => {
            s && (e("update:show", !0), s = !1)
        }), hi(() => {
            t.show && t.teleport && (d(), s = !0)
        }), gr(f2, () => t.show), () => t.teleport ? I(dp, {
            to: t.teleport
        }, {
            default: () => [h(), x()]
        }) : I(mt, null, [h(), x()])
    }
});
const xa = Ae(l7),
    [c7, lr] = Ee("action-sheet"),
    u7 = Le({}, ld, {
        title: String,
        round: me,
        actions: Xi(),
        closeIcon: Pe("cross"),
        closeable: me,
        cancelText: String,
        description: String,
        closeOnPopstate: me,
        closeOnClickAction: Boolean,
        safeAreaInsetBottom: me
    }),
    d7 = [...y2, "round", "closeOnPopstate", "safeAreaInsetBottom"];
var f7 = ve({
    name: c7,
    props: u7,
    emits: ["select", "cancel", "update:show"],
    setup(t, {
        slots: e,
        emit: n
    }) {
        const r = d => n("update:show", d),
            i = () => {
                r(!1), n("cancel")
            },
            s = () => {
                if (t.title) return I("div", {
                    class: lr("header")
                }, [t.title, t.closeable && I(Mt, {
                    name: t.closeIcon,
                    class: [lr("close"), qi],
                    onClick: i
                }, null)])
            },
            o = () => {
                if (e.cancel || t.cancelText) return [I("div", {
                    class: lr("gap")
                }, null), I("button", {
                    type: "button",
                    class: lr("cancel"),
                    onClick: i
                }, [e.cancel ? e.cancel() : t.cancelText])]
            },
            a = d => {
                if (d.icon) return I(Mt, {
                    class: lr("item-icon"),
                    name: d.icon
                }, null)
            },
            l = (d, f) => d.loading ? I(ss, {
                class: lr("loading-icon")
            }, null) : e.action ? e.action({
                action: d,
                index: f
            }) : [I("span", {
                class: lr("name")
            }, [d.name]), d.subname && I("div", {
                class: lr("subname")
            }, [d.subname])],
            c = (d, f) => {
                const {
                    color: h,
                    loading: p,
                    callback: b,
                    disabled: y,
                    className: m
                } = d, g = () => {
                    y || p || (b && b(d), t.closeOnClickAction && r(!1), Ue(() => n("select", d, f)))
                };
                return I("button", {
                    type: "button",
                    style: {
                        color: h
                    },
                    class: [lr("item", {
                        loading: p,
                        disabled: y
                    }), m],
                    onClick: g
                }, [a(d), l(d, f)])
            },
            u = () => {
                if (t.description || e.description) {
                    const d = e.description ? e.description() : t.description;
                    return I("div", {
                        class: lr("description")
                    }, [d])
                }
            };
        return () => I(xa, Ke({
            class: lr(),
            position: "bottom",
            "onUpdate:show": r
        }, yt(t, d7)), {
            default: () => {
                var d;
                return [s(), u(), I("div", {
                    class: lr("content")
                }, [t.actions.map(c), (d = e.default) == null ? void 0 : d.call(e)]), o()]
            }
        })
    }
});
const jbe = Ae(f7),
    [h7, Bi, mS] = Ee("picker"),
    v2 = t => t.find(e => !e.disabled) || t[0];

function p7(t, e) {
    const n = t[0];
    if (n) {
        if (Array.isArray(n)) return "multiple";
        if (e.children in n) return "cascade"
    }
    return "default"
}

function Nf(t, e) {
    e = tn(e, 0, t.length);
    for (let n = e; n < t.length; n++)
        if (!t[n].disabled) return n;
    for (let n = e - 1; n >= 0; n--)
        if (!t[n].disabled) return n;
    return 0
}
const gS = (t, e, n) => e !== void 0 && t.some(r => r[n.value] === e);

function Rv(t, e, n) {
    const r = t.findIndex(s => s[n.value] === e),
        i = Nf(t, r);
    return t[i]
}

function m7(t, e, n) {
    const r = [];
    let i = {
            [e.children]: t
        },
        s = 0;
    for (; i && i[e.children];) {
        const o = i[e.children],
            a = n.value[s];
        if (i = gt(a) ? Rv(o, a, e) : void 0, !i && o.length) {
            const l = v2(o)[e.value];
            i = Rv(o, l, e)
        }
        s++, r.push(o)
    }
    return r
}

function g7(t) {
    const {
        transform: e
    } = window.getComputedStyle(t), n = e.slice(7, e.length - 1).split(", ")[5];
    return Number(n)
}

function y7(t) {
    return Le({
        text: "text",
        value: "value",
        children: "children"
    }, t)
}
const yS = 200,
    vS = 300,
    v7 = 15,
    [_2, Gm] = Ee("picker-column"),
    b2 = Symbol(_2);
var _7 = ve({
    name: _2,
    props: {
        value: be,
        fields: xn(Object),
        options: Xi(),
        readonly: Boolean,
        allowHtml: Boolean,
        optionHeight: xn(Number),
        swipeDuration: xn(be),
        visibleOptionNum: xn(be)
    },
    emits: ["change", "clickOption", "scrollInto"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        let r, i, s, o, a;
        const l = q(),
            c = q(),
            u = q(0),
            d = q(0),
            f = ba(),
            h = () => t.options.length,
            p = () => t.optionHeight * (+t.visibleOptionNum - 1) / 2,
            b = T => {
                let S = Nf(t.options, T);
                const P = -S * t.optionHeight,
                    R = () => {
                        S > h() - 1 && (S = Nf(t.options, T));
                        const D = t.options[S][t.fields.value];
                        D !== t.value && e("change", D)
                    };
                r && P !== u.value ? a = R : R(), u.value = P
            },
            y = () => t.readonly || !t.options.length,
            m = T => {
                r || y() || (a = null, d.value = yS, b(T), e("clickOption", t.options[T]))
            },
            g = T => tn(Math.round(-T / t.optionHeight), 0, h() - 1),
            v = te(() => g(u.value)),
            _ = (T, S) => {
                const P = Math.abs(T / S);
                T = u.value + P / .003 * (T < 0 ? -1 : 1);
                const R = g(T);
                d.value = +t.swipeDuration, b(R)
            },
            x = () => {
                r = !1, d.value = 0, a && (a(), a = null)
            },
            w = T => {
                if (!y()) {
                    if (f.start(T), r) {
                        const S = g7(c.value);
                        u.value = Math.min(0, S - p())
                    }
                    d.value = 0, i = u.value, s = Date.now(), o = i, a = null
                }
            },
            E = T => {
                if (y()) return;
                f.move(T), f.isVertical() && (r = !0, Zt(T, !0));
                const S = tn(i + f.deltaY.value, -(h() * t.optionHeight), t.optionHeight),
                    P = g(S);
                P !== v.value && e("scrollInto", t.options[P]), u.value = S;
                const R = Date.now();
                R - s > vS && (s = R, o = S)
            },
            C = () => {
                if (y()) return;
                const T = u.value - o,
                    S = Date.now() - s;
                if (S < vS && Math.abs(T) > v7) {
                    _(T, S);
                    return
                }
                const R = g(u.value);
                d.value = yS, b(R), setTimeout(() => {
                    r = !1
                }, 0)
            },
            A = () => {
                const T = {
                    height: `${t.optionHeight}px`
                };
                return t.options.map((S, P) => {
                    const R = S[t.fields.text],
                        {
                            disabled: D
                        } = S,
                        H = S[t.fields.value],
                        B = {
                            role: "button",
                            style: T,
                            tabindex: D ? -1 : 0,
                            class: [Gm("item", {
                                disabled: D,
                                selected: H === t.value
                            }), S.className],
                            onClick: () => m(P)
                        },
                        N = {
                            class: "van-ellipsis",
                            [t.allowHtml ? "innerHTML" : "textContent"]: R
                        };
                    return I("li", B, [n.option ? n.option(S, P) : I("div", N, null)])
                })
            };
        return rr(b2), Tt({
            stopMomentum: x
        }), Ul(() => {
            const T = r ? Math.floor(-u.value / t.optionHeight) : t.options.findIndex(R => R[t.fields.value] === t.value),
                S = Nf(t.options, T),
                P = -S * t.optionHeight;
            r && S < T && x(), u.value = P
        }), An("touchmove", E, {
            target: l
        }), () => I("div", {
            ref: l,
            class: Gm(),
            onTouchstartPassive: w,
            onTouchend: C,
            onTouchcancel: C
        }, [I("ul", {
            ref: c,
            style: {
                transform: `translate3d(0, ${u.value+p()}px, 0)`,
                transitionDuration: `${d.value}ms`,
                transitionProperty: d.value ? "all" : "none"
            },
            class: Gm("wrapper"),
            onTransitionend: x
        }, [A()])])
    }
});
const [b7] = Ee("picker-toolbar"), Rp = {
    title: String,
    cancelButtonText: String,
    confirmButtonText: String
}, x7 = ["cancel", "confirm", "title", "toolbar"], w7 = Object.keys(Rp);
var E7 = ve({
    name: b7,
    props: Rp,
    emits: ["confirm", "cancel"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = () => {
                if (n.title) return n.title();
                if (t.title) return I("div", {
                    class: [Bi("title"), "van-ellipsis"]
                }, [t.title])
            },
            i = () => e("cancel"),
            s = () => e("confirm"),
            o = () => {
                var l;
                const c = (l = t.cancelButtonText) != null ? l : mS("cancel");
                if (!(!n.cancel && !c)) return I("button", {
                    type: "button",
                    class: [Bi("cancel"), qi],
                    onClick: i
                }, [n.cancel ? n.cancel() : c])
            },
            a = () => {
                var l;
                const c = (l = t.confirmButtonText) != null ? l : mS("confirm");
                if (!(!n.confirm && !c)) return I("button", {
                    type: "button",
                    class: [Bi("confirm"), qi],
                    onClick: s
                }, [n.confirm ? n.confirm() : c])
            };
        return () => I("div", {
            class: Bi("toolbar")
        }, [n.toolbar ? n.toolbar() : [o(), r(), a()]])
    }
});
const S7 = (t, e) => {
    const n = q(t());
    return he(t, r => {
        r !== n.value && (n.value = r)
    }), he(n, r => {
        r !== t() && e(r)
    }), n
};
/**
 * @vue/shared v3.5.17
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/
const x2 = Array.isArray,
    vu = t => typeof t == "string",
    w2 = t => t !== null && typeof t == "object",
    T7 = t => {
        const e = Object.create(null);
        return n => e[n] || (e[n] = t(n))
    },
    C7 = /\B([A-Z])/g,
    P7 = T7(t => t.replace(C7, "-$1").toLowerCase());

function E2(t) {
    if (x2(t)) {
        const e = {};
        for (let n = 0; n < t.length; n++) {
            const r = t[n],
                i = vu(r) ? M7(r) : E2(r);
            if (i)
                for (const s in i) e[s] = i[s]
        }
        return e
    } else if (vu(t) || w2(t)) return t
}
const A7 = /;(?![^(]*\))/g,
    O7 = /:([^]+)/,
    I7 = /\/\*[^]*?\*\//g;

function M7(t) {
    const e = {};
    return t.replace(I7, "").split(A7).forEach(n => {
        if (n) {
            const r = n.split(O7);
            r.length > 1 && (e[r[0].trim()] = r[1].trim())
        }
    }), e
}

function R7(t) {
    if (!t) return "";
    if (vu(t)) return t;
    let e = "";
    for (const n in t) {
        const r = t[n];
        if (vu(r) || typeof r == "number") {
            const i = n.startsWith("--") ? n : P7(n);
            e += `${i}:${r};`
        }
    }
    return e
}

function S2(t) {
    let e = "";
    if (vu(t)) e = t;
    else if (x2(t))
        for (let n = 0; n < t.length; n++) {
            const r = S2(t[n]);
            r && (e += r + " ")
        } else if (w2(t))
            for (const n in t) t[n] && (e += n + " ");
    return e.trim()
}

function k7(t, e, n) {
    let r, i = 0;
    const s = t.scrollLeft,
        o = n === 0 ? 1 : Math.round(n * 1e3 / 16);
    let a = s;

    function l() {
        id(r)
    }

    function c() {
        a += (e - s) / o, t.scrollLeft = a, ++i < o && (r = Sn(c))
    }
    return c(), l
}

function B7(t, e, n, r) {
    let i, s = od(t);
    const o = s < e,
        a = n === 0 ? 1 : Math.round(n * 1e3 / 16),
        l = (e - s) / a;

    function c() {
        id(i)
    }

    function u() {
        s += l, (o && s > e || !o && s < e) && (s = e), vh(t, s), o && s < e || !o && s > e ? i = Sn(u) : r && (i = Sn(r))
    }
    return u(), c
}
let D7 = 0;

function $b() {
    const t = rt(),
        {
            name: e = "unknown"
        } = (t == null ? void 0 : t.type) || {};
    return `${e}-${++D7}`
}

function T2() {
    const t = q([]),
        e = [];
    return up(() => {
        t.value = []
    }), [t, r => (e[r] || (e[r] = i => {
        t.value[r] = i
    }), e[r])]
}

function C2(t, e) {
    if (!ui || !window.IntersectionObserver) return;
    const n = new IntersectionObserver(s => {
            e(s[0].intersectionRatio > 0)
        }, {
            root: document.body
        }),
        r = () => {
            t.value && n.observe(t.value)
        },
        i = () => {
            t.value && n.unobserve(t.value)
        };
    hi(i), nr(i), zl(r)
}
const [$7, F7] = Ee("sticky"), L7 = {
    zIndex: be,
    position: Pe("top"),
    container: Object,
    offsetTop: Fe(0),
    offsetBottom: Fe(0)
};
var N7 = ve({
    name: $7,
    props: L7,
    emits: ["scroll", "change"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = q(),
            i = sd(r),
            s = ft({
                fixed: !1,
                width: 0,
                height: 0,
                transform: 0
            }),
            o = q(!1),
            a = te(() => kb(t.position === "top" ? t.offsetTop : t.offsetBottom)),
            l = te(() => {
                if (o.value) return;
                const {
                    fixed: f,
                    height: h,
                    width: p
                } = s;
                if (f) return {
                    width: `${p}px`,
                    height: `${h}px`
                }
            }),
            c = te(() => {
                if (!s.fixed || o.value) return;
                const f = Le(i2(t.zIndex), {
                    width: `${s.width}px`,
                    height: `${s.height}px`,
                    [t.position]: `${a.value}px`
                });
                return s.transform && (f.transform = `translate3d(0, ${s.transform}px, 0)`), f
            }),
            u = f => e("scroll", {
                scrollTop: f,
                isFixed: s.fixed
            }),
            d = () => {
                if (!r.value || yl(r)) return;
                const {
                    container: f,
                    position: h
                } = t, p = jt(r), b = od(window);
                if (s.width = p.width, s.height = p.height, h === "top")
                    if (f) {
                        const y = jt(f),
                            m = y.bottom - a.value - s.height;
                        s.fixed = a.value > p.top && y.bottom > 0, s.transform = m < 0 ? m : 0
                    } else s.fixed = a.value > p.top;
                else {
                    const {
                        clientHeight: y
                    } = document.documentElement;
                    if (f) {
                        const m = jt(f),
                            g = y - m.top - a.value - s.height;
                        s.fixed = y - a.value < p.bottom && y > m.top, s.transform = g < 0 ? -g : 0
                    } else s.fixed = y - a.value < p.bottom
                }
                u(b)
            };
        return he(() => s.fixed, f => e("change", f)), An("scroll", d, {
            target: i,
            passive: !0
        }), C2(r, d), he([Li, Fs], () => {
            !r.value || yl(r) || !s.fixed || (o.value = !0, Ue(() => {
                const f = jt(r);
                s.width = f.width, s.height = f.height, o.value = !1
            }))
        }), () => {
            var f;
            return I("div", {
                ref: r,
                style: l.value
            }, [I("div", {
                class: F7({
                    fixed: s.fixed && !o.value
                }),
                style: c.value
            }, [(f = n.default) == null ? void 0 : f.call(n)])])
        }
    }
});
const U7 = Ae(N7),
    [P2, Gd] = Ee("swipe"),
    G7 = {
        loop: me,
        width: be,
        height: be,
        vertical: Boolean,
        autoplay: Fe(0),
        duration: Fe(500),
        touchable: me,
        lazyRender: Boolean,
        initialSwipe: Fe(0),
        indicatorColor: String,
        showIndicators: me,
        stopPropagation: me
    },
    A2 = Symbol(P2);
var H7 = ve({
    name: P2,
    props: G7,
    emits: ["change", "dragStart", "dragEnd"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = q(),
            i = q(),
            s = ft({
                rect: null,
                width: 0,
                height: 0,
                offset: 0,
                active: 0,
                swiping: !1
            });
        let o = !1;
        const a = ba(),
            {
                children: l,
                linkChildren: c
            } = Lr(A2),
            u = te(() => l.length),
            d = te(() => s[t.vertical ? "height" : "width"]),
            f = te(() => t.vertical ? a.deltaY.value : a.deltaX.value),
            h = te(() => s.rect ? (t.vertical ? s.rect.height : s.rect.width) - d.value * u.value : 0),
            p = te(() => d.value ? Math.ceil(Math.abs(h.value) / d.value) : u.value),
            b = te(() => u.value * d.value),
            y = te(() => (s.active + u.value) % u.value),
            m = te(() => {
                const ae = t.vertical ? "vertical" : "horizontal";
                return a.direction.value === ae
            }),
            g = te(() => {
                const ae = {
                    transitionDuration: `${s.swiping?0:t.duration}ms`,
                    transform: `translate${t.vertical?"Y":"X"}(${+s.offset.toFixed(2)}px)`
                };
                if (d.value) {
                    const W = t.vertical ? "height" : "width",
                        ne = t.vertical ? "width" : "height";
                    ae[W] = `${b.value}px`, ae[ne] = t[ne] ? `${t[ne]}px` : ""
                }
                return ae
            }),
            v = ae => {
                const {
                    active: W
                } = s;
                return ae ? t.loop ? tn(W + ae, -1, u.value) : tn(W + ae, 0, p.value) : W
            },
            _ = (ae, W = 0) => {
                let ne = ae * d.value;
                t.loop || (ne = Math.min(ne, -h.value));
                let fe = W - ne;
                return t.loop || (fe = tn(fe, h.value, 0)), fe
            },
            x = ({
                pace: ae = 0,
                offset: W = 0,
                emitChange: ne
            }) => {
                if (u.value <= 1) return;
                const {
                    active: fe
                } = s, $ = v(ae), X = _($, W);
                if (t.loop) {
                    if (l[0] && X !== h.value) {
                        const F = X < h.value;
                        l[0].setOffset(F ? b.value : 0)
                    }
                    if (l[u.value - 1] && X !== 0) {
                        const F = X > 0;
                        l[u.value - 1].setOffset(F ? -b.value : 0)
                    }
                }
                s.active = $, s.offset = X, ne && $ !== fe && e("change", y.value)
            },
            w = () => {
                s.swiping = !0, s.active <= -1 ? x({
                    pace: u.value
                }) : s.active >= u.value && x({
                    pace: -u.value
                })
            },
            E = () => {
                w(), a.reset(), Ao(() => {
                    s.swiping = !1, x({
                        pace: -1,
                        emitChange: !0
                    })
                })
            },
            C = () => {
                w(), a.reset(), Ao(() => {
                    s.swiping = !1, x({
                        pace: 1,
                        emitChange: !0
                    })
                })
            };
        let A;
        const T = () => clearTimeout(A),
            S = () => {
                T(), +t.autoplay > 0 && u.value > 1 && (A = setTimeout(() => {
                    C(), S()
                }, +t.autoplay))
            },
            P = (ae = +t.initialSwipe) => {
                if (!r.value) return;
                const W = () => {
                    var ne, fe;
                    if (!yl(r)) {
                        const $ = {
                            width: r.value.offsetWidth,
                            height: r.value.offsetHeight
                        };
                        s.rect = $, s.width = +((ne = t.width) != null ? ne : $.width), s.height = +((fe = t.height) != null ? fe : $.height)
                    }
                    u.value && (ae = Math.min(u.value - 1, ae), ae === -1 && (ae = u.value - 1)), s.active = ae, s.swiping = !0, s.offset = _(ae), l.forEach($ => {
                        $.setOffset(0)
                    }), S()
                };
                yl(r) ? Ue().then(W) : W()
            },
            R = () => P(s.active);
        let D;
        const H = ae => {
                !t.touchable || ae.touches.length > 1 || (a.start(ae), o = !1, D = Date.now(), T(), w())
            },
            B = ae => {
                t.touchable && s.swiping && (a.move(ae), m.value && (!t.loop && (s.active === 0 && f.value > 0 || s.active === u.value - 1 && f.value < 0) || (Zt(ae, t.stopPropagation), x({
                    offset: f.value
                }), o || (e("dragStart", {
                    index: y.value
                }), o = !0))))
            },
            N = () => {
                if (!t.touchable || !s.swiping) return;
                const ae = Date.now() - D,
                    W = f.value / ae;
                if ((Math.abs(W) > .25 || Math.abs(f.value) > d.value / 2) && m.value) {
                    const fe = t.vertical ? a.offsetY.value : a.offsetX.value;
                    let $ = 0;
                    t.loop ? $ = fe > 0 ? f.value > 0 ? -1 : 1 : 0 : $ = -Math[f.value > 0 ? "ceil" : "floor"](f.value / d.value), x({
                        pace: $,
                        emitChange: !0
                    })
                } else f.value && x({
                    pace: 0
                });
                o = !1, s.swiping = !1, e("dragEnd", {
                    index: y.value
                }), S()
            },
            V = (ae, W = {}) => {
                w(), a.reset(), Ao(() => {
                    let ne;
                    t.loop && ae === u.value ? ne = s.active === 0 ? 0 : ae : ne = ae % u.value, W.immediate ? Ao(() => {
                        s.swiping = !1
                    }) : s.swiping = !1, x({
                        pace: ne - s.active,
                        emitChange: !0
                    })
                })
            },
            Y = (ae, W) => {
                const ne = W === y.value,
                    fe = ne ? {
                        backgroundColor: t.indicatorColor
                    } : void 0;
                return I("i", {
                    style: fe,
                    class: Gd("indicator", {
                        active: ne
                    })
                }, null)
            },
            le = () => {
                if (n.indicator) return n.indicator({
                    active: y.value,
                    total: u.value
                });
                if (t.showIndicators && u.value > 1) return I("div", {
                    class: Gd("indicators", {
                        vertical: t.vertical
                    })
                }, [Array(u.value).fill("").map(Y)])
            };
        return Tt({
            prev: E,
            next: C,
            state: s,
            resize: R,
            swipeTo: V
        }), c({
            size: d,
            props: t,
            count: u,
            activeIndicator: y
        }), he(() => t.initialSwipe, ae => P(+ae)), he(u, () => P(s.active)), he(() => t.autoplay, S), he([Li, Fs, () => t.width, () => t.height], R), he(SI(), ae => {
            ae === "visible" ? S() : T()
        }), _t(P), ns(() => P(s.active)), Bb(() => P(s.active)), hi(T), nr(T), An("touchmove", B, {
            target: i
        }), () => {
            var ae;
            return I("div", {
                ref: r,
                class: Gd()
            }, [I("div", {
                ref: i,
                style: g.value,
                class: Gd("track", {
                    vertical: t.vertical
                }),
                onTouchstartPassive: H,
                onTouchend: N,
                onTouchcancel: N
            }, [(ae = n.default) == null ? void 0 : ae.call(n)]), le()])
        }
    }
});
const O2 = Ae(H7),
    [z7, _S] = Ee("tabs");
var j7 = ve({
    name: z7,
    props: {
        count: xn(Number),
        inited: Boolean,
        animated: Boolean,
        duration: xn(be),
        swipeable: Boolean,
        lazyRender: Boolean,
        currentIndex: xn(Number)
    },
    emits: ["change"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = q(),
            i = a => e("change", a),
            s = () => {
                var a;
                const l = (a = n.default) == null ? void 0 : a.call(n);
                return t.animated || t.swipeable ? I(O2, {
                    ref: r,
                    loop: !1,
                    class: _S("track"),
                    duration: +t.duration * 1e3,
                    touchable: t.swipeable,
                    lazyRender: t.lazyRender,
                    showIndicators: !1,
                    onChange: i
                }, {
                    default: () => [l]
                }) : l
            },
            o = a => {
                const l = r.value;
                l && l.state.active !== a && l.swipeTo(a, {
                    immediate: !t.inited
                })
            };
        return he(() => t.currentIndex, o), _t(() => {
            o(t.currentIndex)
        }), Tt({
            swipeRef: r
        }), () => I("div", {
            class: _S("content", {
                animated: t.animated || t.swipeable
            })
        }, [s()])
    }
});
const [I2, Hd] = Ee("tabs"), V7 = {
    type: Pe("line"),
    color: String,
    border: Boolean,
    sticky: Boolean,
    shrink: Boolean,
    active: Fe(0),
    duration: Fe(.3),
    animated: Boolean,
    ellipsis: me,
    swipeable: Boolean,
    scrollspy: Boolean,
    offsetTop: Fe(0),
    background: String,
    lazyRender: me,
    showHeader: me,
    lineWidth: be,
    lineHeight: be,
    beforeChange: Function,
    swipeThreshold: Fe(5),
    titleActiveColor: String,
    titleInactiveColor: String
}, M2 = Symbol(I2);
var W7 = ve({
    name: I2,
    props: V7,
    emits: ["change", "scroll", "rendered", "clickTab", "update:active"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        let r, i, s, o, a;
        const l = q(),
            c = q(),
            u = q(),
            d = q(),
            f = $b(),
            h = sd(l),
            [p, b] = T2(),
            {
                children: y,
                linkChildren: m
            } = Lr(M2),
            g = ft({
                inited: !1,
                position: "",
                lineStyle: {},
                currentIndex: -1
            }),
            v = te(() => y.length > +t.swipeThreshold || !t.ellipsis || t.shrink),
            _ = te(() => ({
                borderColor: t.color,
                background: t.background
            })),
            x = ($, X) => {
                var F;
                return (F = $.name) != null ? F : X
            },
            w = te(() => {
                const $ = y[g.currentIndex];
                if ($) return x($, g.currentIndex)
            }),
            E = te(() => kb(t.offsetTop)),
            C = te(() => t.sticky ? E.value + r : 0),
            A = $ => {
                const X = c.value,
                    F = p.value;
                if (!v.value || !X || !F || !F[g.currentIndex]) return;
                const Z = F[g.currentIndex].$el,
                    K = Z.offsetLeft - (X.offsetWidth - Z.offsetWidth) / 2;
                o && o(), o = k7(X, K, $ ? 0 : +t.duration)
            },
            T = () => {
                const $ = g.inited;
                Ue(() => {
                    const X = p.value;
                    if (!X || !X[g.currentIndex] || t.type !== "line" || yl(l.value)) return;
                    const F = X[g.currentIndex].$el,
                        {
                            lineWidth: Z,
                            lineHeight: K
                        } = t,
                        ce = F.offsetLeft + F.offsetWidth / 2,
                        de = {
                            width: We(Z),
                            backgroundColor: t.color,
                            transform: `translateX(${ce}px) translateX(-50%)`
                        };
                    if ($ && (de.transitionDuration = `${t.duration}s`), gt(K)) {
                        const ge = We(K);
                        de.height = ge, de.borderRadius = ge
                    }
                    g.lineStyle = de
                })
            },
            S = $ => {
                const X = $ < g.currentIndex ? -1 : 1;
                for (; $ >= 0 && $ < y.length;) {
                    if (!y[$].disabled) return $;
                    $ += X
                }
            },
            P = ($, X) => {
                const F = S($);
                if (!gt(F)) return;
                const Z = y[F],
                    K = x(Z, F),
                    ce = g.currentIndex !== null;
                g.currentIndex !== F && (g.currentIndex = F, X || A(), T()), K !== t.active && (e("update:active", K), ce && e("change", K, Z.title)), s && !t.scrollspy && Rb(Math.ceil(rS(l.value) - E.value))
            },
            R = ($, X) => {
                const F = y.findIndex((Z, K) => x(Z, K) === $);
                P(F === -1 ? 0 : F, X)
            },
            D = ($ = !1) => {
                if (t.scrollspy) {
                    const X = y[g.currentIndex].$el;
                    if (X && h.value) {
                        const F = rS(X, h.value) - C.value;
                        i = !0, a && a(), a = B7(h.value, F, $ ? 0 : +t.duration, () => {
                            i = !1
                        })
                    }
                }
            },
            H = ($, X, F) => {
                const {
                    title: Z,
                    disabled: K
                } = y[X], ce = x(y[X], X);
                K || (jl(t.beforeChange, {
                    args: [ce],
                    done: () => {
                        P(X), D()
                    }
                }), g2($)), e("clickTab", {
                    name: ce,
                    title: Z,
                    event: F,
                    disabled: K
                })
            },
            B = $ => {
                s = $.isFixed, e("scroll", $)
            },
            N = $ => {
                Ue(() => {
                    R($), D(!0)
                })
            },
            V = () => {
                for (let $ = 0; $ < y.length; $++) {
                    const {
                        top: X
                    } = jt(y[$].$el);
                    if (X > C.value) return $ === 0 ? 0 : $ - 1
                }
                return y.length - 1
            },
            Y = () => {
                if (t.scrollspy && !i) {
                    const $ = V();
                    P($)
                }
            },
            le = () => {
                if (t.type === "line" && y.length) return I("div", {
                    class: Hd("line"),
                    style: g.lineStyle
                }, null)
            },
            ae = () => {
                var $, X, F;
                const {
                    type: Z,
                    border: K,
                    sticky: ce
                } = t, de = [I("div", {
                    ref: ce ? void 0 : u,
                    class: [Hd("wrap"), {
                        [c2]: Z === "line" && K
                    }]
                }, [I("div", {
                    ref: c,
                    role: "tablist",
                    class: Hd("nav", [Z, {
                        shrink: t.shrink,
                        complete: v.value
                    }]),
                    style: _.value,
                    "aria-orientation": "horizontal"
                }, [($ = n["nav-left"]) == null ? void 0 : $.call(n), y.map(ge => ge.renderTitle(H)), le(), (X = n["nav-right"]) == null ? void 0 : X.call(n)])]), (F = n["nav-bottom"]) == null ? void 0 : F.call(n)];
                return ce ? I("div", {
                    ref: u
                }, [de]) : de
            },
            W = () => {
                T(), Ue(() => {
                    var $, X;
                    A(!0), (X = ($ = d.value) == null ? void 0 : $.swipeRef.value) == null || X.resize()
                })
            };
        he(() => [t.color, t.duration, t.lineWidth, t.lineHeight], T), he(Li, W), he(() => t.active, $ => {
            $ !== w.value && R($)
        }), he(() => y.length, () => {
            g.inited && (R(t.active), T(), Ue(() => {
                A(!0)
            }))
        });
        const ne = () => {
                R(t.active, !0), Ue(() => {
                    g.inited = !0, u.value && (r = jt(u.value).height), A(!0)
                })
            },
            fe = ($, X) => e("rendered", $, X);
        return Tt({
            resize: W,
            scrollTo: N
        }), ns(T), Bb(T), zl(ne), C2(l, T), An("scroll", Y, {
            target: h,
            passive: !0
        }), m({
            id: f,
            props: t,
            setLine: T,
            scrollable: v,
            onRendered: fe,
            currentName: w,
            setTitleRefs: b,
            scrollIntoView: A
        }), () => I("div", {
            ref: l,
            class: Hd([t.type])
        }, [t.showHeader ? t.sticky ? I(U7, {
            container: l.value,
            offsetTop: E.value,
            onScroll: B
        }, {
            default: () => [ae()]
        }) : ae() : null, I(j7, {
            ref: d,
            count: y.length,
            inited: g.inited,
            animated: t.animated,
            duration: t.duration,
            swipeable: t.swipeable,
            lazyRender: t.lazyRender,
            currentIndex: g.currentIndex,
            onChange: P
        }, {
            default: () => {
                var $;
                return [($ = n.default) == null ? void 0 : $.call(n)]
            }
        })])
    }
});
const Y7 = Symbol(),
    R2 = Symbol(),
    k2 = () => Nt(R2, null),
    X7 = t => {
        const e = k2();
        gr(Y7, t), gr(R2, te(() => (e == null || e.value) && t.value))
    },
    [q7, bS] = Ee("tab"),
    K7 = ve({
        name: q7,
        props: {
            id: String,
            dot: Boolean,
            type: String,
            color: String,
            title: String,
            badge: be,
            shrink: Boolean,
            isActive: Boolean,
            disabled: Boolean,
            controls: String,
            scrollable: Boolean,
            activeColor: String,
            inactiveColor: String,
            showZeroBadge: me
        },
        setup(t, {
            slots: e
        }) {
            const n = te(() => {
                    const i = {},
                        {
                            type: s,
                            color: o,
                            disabled: a,
                            isActive: l,
                            activeColor: c,
                            inactiveColor: u
                        } = t;
                    o && s === "card" && (i.borderColor = o, a || (l ? i.backgroundColor = o : i.color = o));
                    const f = l ? c : u;
                    return f && (i.color = f), i
                }),
                r = () => {
                    const i = I("span", {
                        class: bS("text", {
                            ellipsis: !t.scrollable
                        })
                    }, [e.title ? e.title() : t.title]);
                    return t.dot || gt(t.badge) && t.badge !== "" ? I(Mp, {
                        dot: t.dot,
                        content: t.badge,
                        showZero: t.showZeroBadge
                    }, {
                        default: () => [i]
                    }) : i
                };
            return () => I("div", {
                id: t.id,
                role: "tab",
                class: [bS([t.type, {
                    grow: t.scrollable && !t.shrink,
                    shrink: t.shrink,
                    active: t.isActive,
                    disabled: t.disabled
                }])],
                style: n.value,
                tabindex: t.disabled ? void 0 : t.isActive ? 0 : -1,
                "aria-selected": t.isActive,
                "aria-disabled": t.disabled || void 0,
                "aria-controls": t.controls,
                "data-allow-mismatch": "attribute"
            }, [r()])
        }
    }),
    [J7, Z7] = Ee("swipe-item");
var Q7 = ve({
    name: J7,
    setup(t, {
        slots: e
    }) {
        let n;
        const r = ft({
                offset: 0,
                inited: !1,
                mounted: !1
            }),
            {
                parent: i,
                index: s
            } = rr(A2);
        if (!i) {
            console.error("[Vant] <SwipeItem> must be a child component of <Swipe>.");
            return
        }
        const o = te(() => {
                const c = {},
                    {
                        vertical: u
                    } = i.props;
                return i.size.value && (c[u ? "height" : "width"] = `${i.size.value}px`), r.offset && (c.transform = `translate${u?"Y":"X"}(${r.offset}px)`), c
            }),
            a = te(() => {
                const {
                    loop: c,
                    lazyRender: u
                } = i.props;
                if (!u || n) return !0;
                if (!r.mounted) return !1;
                const d = i.activeIndicator.value,
                    f = i.count.value - 1,
                    h = d === 0 && c ? f : d - 1,
                    p = d === f && c ? 0 : d + 1;
                return n = s.value === d || s.value === h || s.value === p, n
            }),
            l = c => {
                r.offset = c
            };
        return _t(() => {
            Ue(() => {
                r.mounted = !0
            })
        }), Tt({
            setOffset: l
        }), () => {
            var c;
            return I("div", {
                class: Z7(),
                style: o.value
            }, [a.value ? (c = e.default) == null ? void 0 : c.call(e) : null])
        }
    }
});
const B2 = Ae(Q7),
    [eY, Hm] = Ee("tab"),
    tY = Le({}, Vl, {
        dot: Boolean,
        name: be,
        badge: be,
        title: String,
        disabled: Boolean,
        titleClass: Ut,
        titleStyle: [String, Object],
        showZeroBadge: me
    });
var nY = ve({
    name: eY,
    props: tY,
    setup(t, {
        slots: e
    }) {
        const n = $b(),
            r = q(!1),
            i = rt(),
            {
                parent: s,
                index: o
            } = rr(M2);
        if (!s) {
            console.error("[Vant] <Tab> must be a child component of <Tabs>.");
            return
        }
        const a = () => {
                var p;
                return (p = t.name) != null ? p : o.value
            },
            l = () => {
                r.value = !0, s.props.lazyRender && Ue(() => {
                    s.onRendered(a(), t.title)
                })
            },
            c = te(() => {
                const p = a() === s.currentName.value;
                return p && !r.value && l(), p
            }),
            u = q(""),
            d = q("");
        Ul(() => {
            const {
                titleClass: p,
                titleStyle: b
            } = t;
            u.value = p ? S2(p) : "", d.value = b && typeof b != "string" ? R7(E2(b)) : b
        });
        const f = p => I(K7, Ke({
                key: n,
                id: `${s.id}-${o.value}`,
                ref: s.setTitleRefs(o.value),
                style: d.value,
                class: u.value,
                isActive: c.value,
                controls: n,
                scrollable: s.scrollable.value,
                activeColor: s.props.titleActiveColor,
                inactiveColor: s.props.titleInactiveColor,
                onClick: b => p(i.proxy, o.value, b)
            }, yt(s.props, ["type", "color", "shrink"]), yt(t, ["dot", "badge", "title", "disabled", "showZeroBadge"])), {
                title: e.title
            }),
            h = q(!c.value);
        return he(c, p => {
            p ? h.value = !1 : Ao(() => {
                h.value = !0
            })
        }), he(() => t.title, () => {
            s.setLine(), s.scrollIntoView()
        }), X7(c), Tt({
            id: n,
            renderTitle: f
        }), () => {
            var p;
            const b = `${s.id}-${o.value}`,
                {
                    animated: y,
                    swipeable: m,
                    scrollspy: g,
                    lazyRender: v
                } = s.props;
            if (!e.default && !y) return;
            const _ = g || c.value;
            if (y || m) return I(B2, {
                id: n,
                role: "tabpanel",
                class: Hm("panel-wrapper", {
                    inactive: h.value
                }),
                tabindex: c.value ? 0 : -1,
                "aria-hidden": !c.value,
                "aria-labelledby": b,
                "data-allow-mismatch": "attribute"
            }, {
                default: () => {
                    var E;
                    return [I("div", {
                        class: Hm("panel")
                    }, [(E = e.default) == null ? void 0 : E.call(e)])]
                }
            });
            const w = r.value || g || !v ? (p = e.default) == null ? void 0 : p.call(e) : null;
            return mr(I("div", {
                id: n,
                role: "tabpanel",
                class: Hm("panel"),
                tabindex: _ ? 0 : -1,
                "aria-labelledby": b,
                "data-allow-mismatch": "attribute"
            }, [w]), [
                [yr, _]
            ])
        }
    }
});
const Vbe = Ae(nY),
    Wbe = Ae(W7),
    [rY, Ybe] = Ee("picker-group"),
    iY = Symbol(rY);
Le({
    tabs: Xi(),
    activeTab: Fe(0),
    nextStepText: String,
    showToolbar: me
}, Rp);
const Fb = Le({
        loading: Boolean,
        readonly: Boolean,
        allowHtml: Boolean,
        optionHeight: Fe(44),
        showToolbar: me,
        swipeDuration: Fe(1e3),
        visibleOptionNum: Fe(6)
    }, Rp),
    sY = Le({}, Fb, {
        columns: Xi(),
        modelValue: Xi(),
        toolbarPosition: Pe("top"),
        columnsFieldNames: Object
    });
var oY = ve({
    name: h7,
    props: sY,
    emits: ["confirm", "cancel", "change", "scrollInto", "clickOption", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = q(),
            i = q(t.modelValue.slice(0)),
            {
                parent: s
            } = rr(iY),
            {
                children: o,
                linkChildren: a
            } = Lr(b2);
        a();
        const l = te(() => y7(t.columnsFieldNames)),
            c = te(() => kb(t.optionHeight)),
            u = te(() => p7(t.columns, l.value)),
            d = te(() => {
                const {
                    columns: P
                } = t;
                switch (u.value) {
                    case "multiple":
                        return P;
                    case "cascade":
                        return m7(P, l.value, i);
                    default:
                        return [P]
                }
            }),
            f = te(() => d.value.some(P => P.length)),
            h = te(() => d.value.map((P, R) => Rv(P, i.value[R], l.value))),
            p = te(() => d.value.map((P, R) => P.findIndex(D => D[l.value.value] === i.value[R]))),
            b = (P, R) => {
                if (i.value[P] !== R) {
                    const D = i.value.slice(0);
                    D[P] = R, i.value = D
                }
            },
            y = () => ({
                selectedValues: i.value.slice(0),
                selectedOptions: h.value,
                selectedIndexes: p.value
            }),
            m = (P, R) => {
                b(R, P), u.value === "cascade" && i.value.forEach((D, H) => {
                    const B = d.value[H];
                    gS(B, D, l.value) || b(H, B.length ? B[0][l.value.value] : void 0)
                }), Ue(() => {
                    e("change", Le({
                        columnIndex: R
                    }, y()))
                })
            },
            g = (P, R) => {
                const D = {
                    columnIndex: R,
                    currentOption: P
                };
                e("clickOption", Le(y(), D)), e("scrollInto", D)
            },
            v = () => {
                o.forEach(R => R.stopMomentum());
                const P = y();
                return Ue(() => {
                    const R = y();
                    e("confirm", R)
                }), P
            },
            _ = () => e("cancel", y()),
            x = () => d.value.map((P, R) => I(_7, {
                value: i.value[R],
                fields: l.value,
                options: P,
                readonly: t.readonly,
                allowHtml: t.allowHtml,
                optionHeight: c.value,
                swipeDuration: t.swipeDuration,
                visibleOptionNum: t.visibleOptionNum,
                onChange: D => m(D, R),
                onClickOption: D => g(D, R),
                onScrollInto: D => {
                    e("scrollInto", {
                        currentOption: D,
                        columnIndex: R
                    })
                }
            }, {
                option: n.option
            })),
            w = P => {
                if (f.value) {
                    const R = {
                            height: `${c.value}px`
                        },
                        D = {
                            backgroundSize: `100% ${(P-c.value)/2}px`
                        };
                    return [I("div", {
                        class: Bi("mask"),
                        style: D
                    }, null), I("div", {
                        class: [SW, Bi("frame")],
                        style: R
                    }, null)]
                }
            },
            E = () => {
                const P = c.value * +t.visibleOptionNum,
                    R = {
                        height: `${P}px`
                    };
                return !t.loading && !f.value && n.empty ? n.empty() : I("div", {
                    ref: r,
                    class: Bi("columns"),
                    style: R
                }, [x(), w(P)])
            },
            C = () => {
                if (t.showToolbar && !s) return I(E7, Ke(yt(t, w7), {
                    onConfirm: v,
                    onCancel: _
                }), yt(n, x7))
            },
            A = P => {
                P.forEach((R, D) => {
                    R.length && !gS(R, i.value[D], l.value) && b(D, v2(R)[l.value.value])
                })
            };
        he(d, P => A(P), {
            immediate: !0
        });
        let T;
        return he(() => t.modelValue, P => {
            !$s(P, i.value) && !$s(P, T) && (i.value = P.slice(0), T = P.slice(0)), t.modelValue.length === 0 && A(d.value)
        }, {
            deep: !0
        }), he(i, P => {
            $s(P, t.modelValue) || (T = P.slice(0), e("update:modelValue", T))
        }, {
            immediate: !0
        }), An("touchmove", Zt, {
            target: r
        }), Tt({
            confirm: v,
            getSelectedOptions: () => h.value
        }), () => {
            var P, R;
            return I("div", {
                class: Bi()
            }, [t.toolbarPosition === "top" ? C() : null, t.loading ? I(ss, {
                class: Bi("loading")
            }, null) : null, (P = n["columns-top"]) == null ? void 0 : P.call(n), E(), (R = n["columns-bottom"]) == null ? void 0 : R.call(n), t.toolbarPosition === "bottom" ? C() : null])
        }
    }
});
const aY = Ae(oY),
    [lY, Ma] = Ee("cell"),
    kp = {
        tag: Pe("div"),
        icon: String,
        size: String,
        title: be,
        value: be,
        label: be,
        center: Boolean,
        isLink: Boolean,
        border: me,
        iconPrefix: String,
        valueClass: Ut,
        labelClass: Ut,
        titleClass: Ut,
        titleStyle: null,
        arrowDirection: String,
        required: {
            type: [Boolean, String],
            default: null
        },
        clickable: {
            type: Boolean,
            default: null
        }
    },
    cY = Le({}, kp, Vl);
var uY = ve({
    name: lY,
    props: cY,
    setup(t, {
        slots: e
    }) {
        const n = ad(),
            r = () => {
                if (e.label || gt(t.label)) return I("div", {
                    class: [Ma("label"), t.labelClass]
                }, [e.label ? e.label() : t.label])
            },
            i = () => {
                var l;
                if (e.title || gt(t.title)) {
                    const c = (l = e.title) == null ? void 0 : l.call(e);
                    return Array.isArray(c) && c.length === 0 ? void 0 : I("div", {
                        class: [Ma("title"), t.titleClass],
                        style: t.titleStyle
                    }, [c || I("span", null, [t.title]), r()])
                }
            },
            s = () => {
                const l = e.value || e.default;
                if (l || gt(t.value)) return I("div", {
                    class: [Ma("value"), t.valueClass]
                }, [l ? l() : I("span", null, [t.value])])
            },
            o = () => {
                if (e.icon) return e.icon();
                if (t.icon) return I(Mt, {
                    name: t.icon,
                    class: Ma("left-icon"),
                    classPrefix: t.iconPrefix
                }, null)
            },
            a = () => {
                if (e["right-icon"]) return e["right-icon"]();
                if (t.isLink) {
                    const l = t.arrowDirection && t.arrowDirection !== "right" ? `arrow-${t.arrowDirection}` : "arrow";
                    return I(Mt, {
                        name: l,
                        class: Ma("right-icon")
                    }, null)
                }
            };
        return () => {
            var l;
            const {
                tag: c,
                size: u,
                center: d,
                border: f,
                isLink: h,
                required: p
            } = t, b = (l = t.clickable) != null ? l : h, y = {
                center: d,
                required: !!p,
                clickable: b,
                borderless: !f
            };
            return u && (y[u] = !!u), I(c, {
                class: Ma(y),
                role: b ? "button" : void 0,
                tabindex: b ? 0 : void 0,
                onClick: n
            }, {
                default: () => {
                    var m;
                    return [o(), i(), s(), a(), (m = e.extra) == null ? void 0 : m.call(e)]
                }
            })
        }
    }
});
const D2 = Ae(uY),
    [dY, fY] = Ee("form"),
    hY = {
        colon: Boolean,
        disabled: Boolean,
        readonly: Boolean,
        required: [Boolean, String],
        showError: Boolean,
        labelWidth: be,
        labelAlign: String,
        inputAlign: String,
        scrollToError: Boolean,
        scrollToErrorPosition: String,
        validateFirst: Boolean,
        submitOnEnter: me,
        showErrorMessage: me,
        errorMessageAlign: String,
        validateTrigger: {
            type: [String, Array],
            default: "onBlur"
        }
    };
var pY = ve({
    name: dY,
    props: hY,
    emits: ["submit", "failed"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            children: r,
            linkChildren: i
        } = Lr(u2), s = y => y ? r.filter(m => y.includes(m.name)) : r, o = y => new Promise((m, g) => {
            const v = [];
            s(y).reduce((x, w) => x.then(() => {
                if (!v.length) return w.validate().then(E => {
                    E && v.push(E)
                })
            }), Promise.resolve()).then(() => {
                v.length ? g(v) : m()
            })
        }), a = y => new Promise((m, g) => {
            const v = s(y);
            Promise.all(v.map(_ => _.validate())).then(_ => {
                _ = _.filter(Boolean), _.length ? g(_) : m()
            })
        }), l = y => {
            const m = r.find(g => g.name === y);
            return m ? new Promise((g, v) => {
                m.validate().then(_ => {
                    _ ? v(_) : g()
                })
            }) : Promise.reject()
        }, c = y => typeof y == "string" ? l(y) : t.validateFirst ? o(y) : a(y), u = y => {
            typeof y == "string" && (y = [y]), s(y).forEach(g => {
                g.resetValidation()
            })
        }, d = () => r.reduce((y, m) => (y[m.name] = m.getValidationStatus(), y), {}), f = (y, m) => {
            r.some(g => g.name === y ? (g.$el.scrollIntoView(m), !0) : !1)
        }, h = () => r.reduce((y, m) => (m.name !== void 0 && (y[m.name] = m.formValue.value), y), {}), p = () => {
            const y = h();
            c().then(() => e("submit", y)).catch(m => {
                e("failed", {
                    values: y,
                    errors: m
                });
                const {
                    scrollToError: g,
                    scrollToErrorPosition: v
                } = t;
                g && m[0].name && f(m[0].name, v ? {
                    block: v
                } : void 0)
            })
        }, b = y => {
            Zt(y), p()
        };
        return i({
            props: t
        }), Tt({
            submit: p,
            validate: c,
            getValues: h,
            scrollToField: f,
            resetValidation: u,
            getValidationStatus: d
        }), () => {
            var y;
            return I("form", {
                class: fY(),
                onSubmit: b
            }, [(y = n.default) == null ? void 0 : y.call(n)])
        }
    }
});
const Xbe = Ae(pY);

function $2(t) {
    return Array.isArray(t) ? !t.length : t === 0 ? !1 : !t
}

function mY(t, e) {
    if ($2(t)) {
        if (e.required) return !1;
        if (e.validateEmpty === !1) return !0
    }
    return !(e.pattern && !e.pattern.test(String(t)))
}

function gY(t, e) {
    return new Promise(n => {
        const r = e.validator(t, e);
        if (Ib(r)) {
            r.then(n);
            return
        }
        n(r)
    })
}

function xS(t, e) {
    const {
        message: n
    } = e;
    return gl(n) ? n(t, e) : n || ""
}

function yY({
    target: t
}) {
    t.composing = !0
}

function wS({
    target: t
}) {
    t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")))
}

function vY(t, e) {
    const n = Mb();
    t.style.height = "auto";
    let r = t.scrollHeight;
    if (di(e)) {
        const {
            maxHeight: i,
            minHeight: s
        } = e;
        i !== void 0 && (r = Math.min(r, i)), s !== void 0 && (r = Math.max(r, s))
    }
    r && (t.style.height = `${r}px`, Rb(n))
}

function _Y(t, e) {
    return t === "number" && (t = "text", e ? ? (e = "decimal")), t === "digit" && (t = "tel", e ? ? (e = "numeric")), {
        type: t,
        inputmode: e
    }
}

function _i(t) {
    return [...t].length
}

function zm(t, e) {
    return [...t].slice(0, e).join("")
}
const [bY, cr] = Ee("field"), xY = {
    id: String,
    name: String,
    leftIcon: String,
    rightIcon: String,
    autofocus: Boolean,
    clearable: Boolean,
    maxlength: be,
    max: Number,
    min: Number,
    formatter: Function,
    clearIcon: Pe("clear"),
    modelValue: Fe(""),
    inputAlign: String,
    placeholder: String,
    autocomplete: String,
    autocapitalize: String,
    autocorrect: String,
    errorMessage: String,
    enterkeyhint: String,
    clearTrigger: Pe("focus"),
    formatTrigger: Pe("onChange"),
    spellcheck: {
        type: Boolean,
        default: null
    },
    error: {
        type: Boolean,
        default: null
    },
    disabled: {
        type: Boolean,
        default: null
    },
    readonly: {
        type: Boolean,
        default: null
    },
    inputmode: String
}, wY = Le({}, kp, xY, {
    rows: be,
    type: Pe("text"),
    rules: Array,
    autosize: [Boolean, Object],
    labelWidth: be,
    labelClass: Ut,
    labelAlign: String,
    showWordLimit: Boolean,
    errorMessageAlign: String,
    colon: {
        type: Boolean,
        default: null
    }
});
var EY = ve({
    name: bY,
    props: wY,
    emits: ["blur", "focus", "clear", "keypress", "clickInput", "endValidate", "startValidate", "clickLeftIcon", "clickRightIcon", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = $b(),
            i = ft({
                status: "unvalidated",
                focused: !1,
                validateMessage: ""
            }),
            s = q(),
            o = q(),
            a = q(),
            {
                parent: l
            } = rr(u2),
            c = () => {
                var F;
                return String((F = t.modelValue) != null ? F : "")
            },
            u = F => {
                if (gt(t[F])) return t[F];
                if (l && gt(l.props[F])) return l.props[F]
            },
            d = te(() => {
                const F = u("readonly");
                if (t.clearable && !F) {
                    const Z = c() !== "",
                        K = t.clearTrigger === "always" || t.clearTrigger === "focus" && i.focused;
                    return Z && K
                }
                return !1
            }),
            f = te(() => a.value && n.input ? a.value() : t.modelValue),
            h = te(() => {
                var F;
                const Z = u("required");
                return Z === "auto" ? (F = t.rules) == null ? void 0 : F.some(K => K.required) : Z
            }),
            p = F => F.reduce((Z, K) => Z.then(() => {
                if (i.status === "failed") return;
                let {
                    value: ce
                } = f;
                if (K.formatter && (ce = K.formatter(ce, K)), !mY(ce, K)) {
                    i.status = "failed", i.validateMessage = xS(ce, K);
                    return
                }
                if (K.validator) return $2(ce) && K.validateEmpty === !1 ? void 0 : gY(ce, K).then(de => {
                    de && typeof de == "string" ? (i.status = "failed", i.validateMessage = de) : de === !1 && (i.status = "failed", i.validateMessage = xS(ce, K))
                })
            }), Promise.resolve()),
            b = () => {
                i.status = "unvalidated", i.validateMessage = ""
            },
            y = () => e("endValidate", {
                status: i.status,
                message: i.validateMessage
            }),
            m = (F = t.rules) => new Promise(Z => {
                b(), F ? (e("startValidate"), p(F).then(() => {
                    i.status === "failed" ? (Z({
                        name: t.name,
                        message: i.validateMessage
                    }), y()) : (i.status = "passed", Z(), y())
                })) : Z()
            }),
            g = F => {
                if (l && t.rules) {
                    const {
                        validateTrigger: Z
                    } = l.props, K = yh(Z).includes(F), ce = t.rules.filter(de => de.trigger ? yh(de.trigger).includes(F) : K);
                    ce.length && m(ce)
                }
            },
            v = F => {
                var Z;
                const {
                    maxlength: K
                } = t;
                if (gt(K) && _i(F) > +K) {
                    const ce = c();
                    if (ce && _i(ce) === +K) return ce;
                    const de = (Z = s.value) == null ? void 0 : Z.selectionEnd;
                    if (i.focused && de) {
                        const ge = [...F],
                            O = ge.length - +K;
                        return ge.splice(de - O, O), ge.join("")
                    }
                    return zm(F, +K)
                }
                return F
            },
            _ = (F, Z = "onChange") => {
                var K, ce;
                const de = F;
                F = v(F);
                const ge = _i(de) - _i(F);
                if (t.type === "number" || t.type === "digit") {
                    const L = t.type === "number";
                    if (F = Ov(F, L, L), Z === "onBlur" && F !== "" && (t.min !== void 0 || t.max !== void 0)) {
                        const j = tn(+F, (K = t.min) != null ? K : -1 / 0, (ce = t.max) != null ? ce : 1 / 0); + F !== j && (F = j.toString())
                    }
                }
                let O = 0;
                if (t.formatter && Z === t.formatTrigger) {
                    const {
                        formatter: L,
                        maxlength: j
                    } = t;
                    if (F = L(F), gt(j) && _i(F) > +j && (F = zm(F, +j)), s.value && i.focused) {
                        const {
                            selectionEnd: ie
                        } = s.value, oe = zm(de, ie);
                        O = _i(L(oe)) - _i(oe)
                    }
                }
                if (s.value && s.value.value !== F)
                    if (i.focused) {
                        let {
                            selectionStart: L,
                            selectionEnd: j
                        } = s.value;
                        if (s.value.value = F, gt(L) && gt(j)) {
                            const ie = _i(F);
                            ge ? (L -= ge, j -= ge) : O && (L += O, j += O), s.value.setSelectionRange(Math.min(L, ie), Math.min(j, ie))
                        }
                    } else s.value.value = F;
                F !== t.modelValue && e("update:modelValue", F)
            },
            x = F => {
                F.target.composing || _(F.target.value)
            },
            w = () => {
                var F;
                return (F = s.value) == null ? void 0 : F.blur()
            },
            E = () => {
                var F;
                return (F = s.value) == null ? void 0 : F.focus()
            },
            C = () => {
                const F = s.value;
                t.type === "textarea" && t.autosize && F && vY(F, t.autosize)
            },
            A = F => {
                i.focused = !0, e("focus", F), Ue(C), u("readonly") && w()
            },
            T = F => {
                i.focused = !1, _(c(), "onBlur"), e("blur", F), !u("readonly") && (g("onBlur"), Ue(C), n2())
            },
            S = F => e("clickInput", F),
            P = F => e("clickLeftIcon", F),
            R = F => e("clickRightIcon", F),
            D = F => {
                Zt(F), e("update:modelValue", ""), e("clear", F)
            },
            H = te(() => {
                if (typeof t.error == "boolean") return t.error;
                if (l && l.props.showError && i.status === "failed") return !0
            }),
            B = te(() => {
                const F = u("labelWidth"),
                    Z = u("labelAlign");
                if (F && Z !== "top") return {
                    width: We(F)
                }
            }),
            N = F => {
                F.keyCode === 13 && (!(l && l.props.submitOnEnter) && t.type !== "textarea" && Zt(F), t.type === "search" && w()), e("keypress", F)
            },
            V = () => t.id || `${r}-input`,
            Y = () => i.status,
            le = () => {
                const F = cr("control", [u("inputAlign"), {
                    error: H.value,
                    custom: !!n.input,
                    "min-height": t.type === "textarea" && !t.autosize
                }]);
                if (n.input) return I("div", {
                    class: F,
                    onClick: S
                }, [n.input()]);
                const Z = {
                    id: V(),
                    ref: s,
                    name: t.name,
                    rows: t.rows !== void 0 ? +t.rows : void 0,
                    class: F,
                    disabled: u("disabled"),
                    readonly: u("readonly"),
                    autofocus: t.autofocus,
                    placeholder: t.placeholder,
                    autocomplete: t.autocomplete,
                    autocapitalize: t.autocapitalize,
                    autocorrect: t.autocorrect,
                    enterkeyhint: t.enterkeyhint,
                    spellcheck: t.spellcheck,
                    "aria-labelledby": t.label ? `${r}-label` : void 0,
                    "data-allow-mismatch": "attribute",
                    onBlur: T,
                    onFocus: A,
                    onInput: x,
                    onClick: S,
                    onChange: wS,
                    onKeypress: N,
                    onCompositionend: wS,
                    onCompositionstart: yY
                };
                return t.type === "textarea" ? I("textarea", Ke(Z, {
                    inputmode: t.inputmode
                }), null) : I("input", Ke(_Y(t.type, t.inputmode), Z), null)
            },
            ae = () => {
                const F = n["left-icon"];
                if (t.leftIcon || F) return I("div", {
                    class: cr("left-icon"),
                    onClick: P
                }, [F ? F() : I(Mt, {
                    name: t.leftIcon,
                    classPrefix: t.iconPrefix
                }, null)])
            },
            W = () => {
                const F = n["right-icon"];
                if (t.rightIcon || F) return I("div", {
                    class: cr("right-icon"),
                    onClick: R
                }, [F ? F() : I(Mt, {
                    name: t.rightIcon,
                    classPrefix: t.iconPrefix
                }, null)])
            },
            ne = () => {
                if (t.showWordLimit && t.maxlength) {
                    const F = _i(c());
                    return I("div", {
                        class: cr("word-limit")
                    }, [I("span", {
                        class: cr("word-num")
                    }, [F]), pp("/"), t.maxlength])
                }
            },
            fe = () => {
                if (l && l.props.showErrorMessage === !1) return;
                const F = t.errorMessage || i.validateMessage;
                if (F) {
                    const Z = n["error-message"],
                        K = u("errorMessageAlign");
                    return I("div", {
                        class: cr("error-message", K)
                    }, [Z ? Z({
                        message: F
                    }) : F])
                }
            },
            $ = () => {
                const F = u("labelWidth"),
                    Z = u("labelAlign"),
                    K = u("colon") ? ":" : "";
                if (n.label) return [n.label(), K];
                if (t.label) return I("label", {
                    id: `${r}-label`,
                    for: n.input ? void 0 : V(),
                    "data-allow-mismatch": "attribute",
                    onClick: ce => {
                        Zt(ce), E()
                    },
                    style: Z === "top" && F ? {
                        width: We(F)
                    } : void 0
                }, [t.label + K])
            },
            X = () => [I("div", {
                class: cr("body")
            }, [le(), d.value && I(Mt, {
                ref: o,
                name: t.clearIcon,
                class: cr("clear")
            }, null), W(), n.button && I("div", {
                class: cr("button")
            }, [n.button()])]), ne(), fe()];
        return Tt({
            blur: w,
            focus: E,
            validate: m,
            formValue: f,
            resetValidation: b,
            getValidationStatus: Y
        }), gr(eb, {
            customValue: a,
            resetValidation: b,
            validateWithTrigger: g
        }), he(() => t.modelValue, () => {
            _(c()), b(), g("onChange"), Ue(C)
        }), _t(() => {
            _(c(), t.formatTrigger), Ue(C)
        }), An("touchstart", D, {
            target: te(() => {
                var F;
                return (F = o.value) == null ? void 0 : F.$el
            })
        }), () => {
            const F = u("disabled"),
                Z = u("labelAlign"),
                K = ae(),
                ce = () => {
                    const de = $();
                    return Z === "top" ? [K, de].filter(Boolean) : de || []
                };
            return I(D2, {
                size: t.size,
                class: cr({
                    error: H.value,
                    disabled: F,
                    [`label-${Z}`]: Z
                }),
                center: t.center,
                border: t.border,
                isLink: t.isLink,
                clickable: t.clickable,
                titleStyle: B.value,
                valueClass: cr("value"),
                titleClass: [cr("label", [Z, {
                    required: h.value
                }]), t.labelClass],
                arrowDirection: t.arrowDirection
            }, {
                icon: K && Z !== "top" ? () => K : null,
                title: ce,
                value: X,
                extra: n.extra
            })
        }
    }
});
const qbe = Ae(EY);
let lc = 0;

function SY(t) {
    t ? (lc || document.body.classList.add("van-toast--unclickable"), lc++) : lc && (lc--, lc || document.body.classList.remove("van-toast--unclickable"))
}
const [TY, Ra] = Ee("toast"), CY = ["show", "overlay", "teleport", "transition", "overlayClass", "overlayStyle", "closeOnClickOverlay", "zIndex"], PY = {
    icon: String,
    show: Boolean,
    type: Pe("text"),
    overlay: Boolean,
    message: be,
    iconSize: be,
    duration: Ip(2e3),
    position: Pe("middle"),
    teleport: [String, Object],
    wordBreak: String,
    className: Ut,
    iconPrefix: String,
    transition: Pe("van-fade"),
    loadingType: String,
    forbidClick: Boolean,
    overlayClass: Ut,
    overlayStyle: Object,
    closeOnClick: Boolean,
    closeOnClickOverlay: Boolean,
    zIndex: be
};
var F2 = ve({
    name: TY,
    props: PY,
    emits: ["update:show"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        let r, i = !1;
        const s = () => {
                const d = t.show && t.forbidClick;
                i !== d && (i = d, SY(i))
            },
            o = d => e("update:show", d),
            a = () => {
                t.closeOnClick && o(!1)
            },
            l = () => clearTimeout(r),
            c = () => {
                const {
                    icon: d,
                    type: f,
                    iconSize: h,
                    iconPrefix: p,
                    loadingType: b
                } = t;
                if (d || f === "success" || f === "fail") return I(Mt, {
                    name: d || f,
                    size: h,
                    class: Ra("icon"),
                    classPrefix: p
                }, null);
                if (f === "loading") return I(ss, {
                    class: Ra("loading"),
                    size: h,
                    type: b
                }, null)
            },
            u = () => {
                const {
                    type: d,
                    message: f
                } = t;
                if (n.message) return I("div", {
                    class: Ra("text")
                }, [n.message()]);
                if (gt(f) && f !== "") return d === "html" ? I("div", {
                    key: 0,
                    class: Ra("text"),
                    innerHTML: String(f)
                }, null) : I("div", {
                    class: Ra("text")
                }, [f])
            };
        return he(() => [t.show, t.forbidClick], s), he(() => [t.show, t.type, t.message, t.duration], () => {
            l(), t.show && t.duration > 0 && (r = setTimeout(() => {
                o(!1)
            }, t.duration))
        }), _t(s), is(s), () => I(xa, Ke({
            class: [Ra([t.position, t.wordBreak === "normal" ? "break-normal" : t.wordBreak, {
                [t.type]: !t.icon
            }]), t.className],
            lockScroll: !1,
            onClick: a,
            onClosed: l,
            "onUpdate:show": o
        }, yt(t, CY)), {
            default: () => [c(), u()]
        })
    }
});

function Bp() {
    const t = ft({
            show: !1
        }),
        e = i => {
            t.show = i
        },
        n = i => {
            Le(t, i, {
                transitionAppear: !0
            }), e(!0)
        },
        r = () => e(!1);
    return Tt({
        open: n,
        close: r,
        toggle: e
    }), {
        open: n,
        close: r,
        state: t,
        toggle: e
    }
}

function Dp(t) {
    const e = JO(t),
        n = document.createElement("div");
    return document.body.appendChild(n), {
        instance: e.mount(n),
        unmount() {
            e.unmount(), document.body.removeChild(n)
        }
    }
}
const AY = {
    icon: "",
    type: "text",
    message: "",
    className: "",
    overlay: !1,
    onClose: void 0,
    onOpened: void 0,
    duration: 2e3,
    teleport: "body",
    iconSize: void 0,
    iconPrefix: void 0,
    position: "middle",
    transition: "van-fade",
    forbidClick: !1,
    loadingType: void 0,
    overlayClass: "",
    overlayStyle: void 0,
    closeOnClick: !1,
    closeOnClickOverlay: !1
};
let Ts = [],
    OY = !1,
    kv = Le({}, AY);
const L2 = new Map;

function N2(t) {
    return di(t) ? t : {
        message: t
    }
}

function IY() {
    const {
        instance: t,
        unmount: e
    } = Dp({
        setup() {
            const n = q(""),
                {
                    open: r,
                    state: i,
                    close: s,
                    toggle: o
                } = Bp(),
                a = () => {},
                l = () => I(F2, Ke(i, {
                    onClosed: a,
                    "onUpdate:show": o
                }), null);
            return he(n, c => {
                i.message = c
            }), rt().render = l, {
                open: r,
                close: s,
                message: n
            }
        }
    });
    return t
}

function MY() {
    if (!Ts.length || OY) {
        const t = IY();
        Ts.push(t)
    }
    return Ts[Ts.length - 1]
}

function Bv(t = {}) {
    if (!ui) return {};
    const e = MY(),
        n = N2(t);
    return e.open(Le({}, kv, L2.get(n.type || kv.type), n)), e
}
const Lb = t => e => Bv(Le({
        type: t
    }, N2(e))),
    Kbe = Lb("loading"),
    Jbe = Lb("success"),
    Zbe = Lb("fail"),
    Qbe = t => {
        Ts.length && (t ? (Ts.forEach(e => {
            e.close()
        }), Ts = []) : Ts[0].close())
    };

function exe(t, e) {
    typeof t == "string" ? L2.set(t, e) : Le(kv, t)
}
const txe = Ae(F2),
    [RY, jm] = Ee("switch"),
    kY = {
        size: be,
        loading: Boolean,
        disabled: Boolean,
        modelValue: Ut,
        activeColor: String,
        inactiveColor: String,
        activeValue: {
            type: Ut,
            default: !0
        },
        inactiveValue: {
            type: Ut,
            default: !1
        }
    };
var BY = ve({
    name: RY,
    props: kY,
    emits: ["change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = () => t.modelValue === t.activeValue,
            i = () => {
                if (!t.disabled && !t.loading) {
                    const o = r() ? t.inactiveValue : t.activeValue;
                    e("update:modelValue", o), e("change", o)
                }
            },
            s = () => {
                if (t.loading) {
                    const o = r() ? t.activeColor : t.inactiveColor;
                    return I(ss, {
                        class: jm("loading"),
                        color: o
                    }, null)
                }
                if (n.node) return n.node()
            };
        return va(() => t.modelValue), () => {
            var o;
            const {
                size: a,
                loading: l,
                disabled: c,
                activeColor: u,
                inactiveColor: d
            } = t, f = r(), h = {
                fontSize: We(a),
                backgroundColor: f ? u : d
            };
            return I("div", {
                role: "switch",
                class: jm({
                    on: f,
                    loading: l,
                    disabled: c
                }),
                style: h,
                tabindex: c ? void 0 : 0,
                "aria-checked": f,
                onClick: i
            }, [I("div", {
                class: jm("node")
            }, [s()]), (o = n.background) == null ? void 0 : o.call(n)])
        }
    }
});
const nxe = Ae(BY),
    [U2, DY] = Ee("radio-group"),
    $Y = {
        shape: String,
        disabled: Boolean,
        iconSize: be,
        direction: String,
        modelValue: Ut,
        checkedColor: String
    },
    G2 = Symbol(U2);
var FY = ve({
    name: U2,
    props: $Y,
    emits: ["change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            linkChildren: r
        } = Lr(G2), i = s => e("update:modelValue", s);
        return he(() => t.modelValue, s => e("change", s)), r({
            props: t,
            updateValue: i
        }), va(() => t.modelValue), () => {
            var s;
            return I("div", {
                class: DY([t.direction]),
                role: "radiogroup"
            }, [(s = n.default) == null ? void 0 : s.call(n)])
        }
    }
});
const rxe = Ae(FY),
    [LY, ixe] = Ee("checkbox-group"),
    NY = Symbol(LY),
    Nb = {
        name: Ut,
        disabled: Boolean,
        iconSize: be,
        modelValue: Ut,
        checkedColor: String,
        labelPosition: String,
        labelDisabled: Boolean
    };
var H2 = ve({
    props: Le({}, Nb, {
        bem: xn(Function),
        role: String,
        shape: String,
        parent: Object,
        checked: Boolean,
        bindGroup: me,
        indeterminate: {
            type: Boolean,
            default: null
        }
    }),
    emits: ["click", "toggle"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = q(),
            i = f => {
                if (t.parent && t.bindGroup) return t.parent.props[f]
            },
            s = te(() => {
                if (t.parent && t.bindGroup) {
                    const f = i("disabled") || t.disabled;
                    if (t.role === "checkbox") {
                        const h = i("modelValue").length,
                            p = i("max"),
                            b = p && h >= +p;
                        return f || b && !t.checked
                    }
                    return f
                }
                return t.disabled
            }),
            o = te(() => i("direction")),
            a = te(() => {
                const f = t.checkedColor || i("checkedColor");
                if (f && (t.checked || t.indeterminate) && !s.value) return {
                    borderColor: f,
                    backgroundColor: f
                }
            }),
            l = te(() => t.shape || i("shape") || "round"),
            c = f => {
                const {
                    target: h
                } = f, p = r.value, b = p === h || (p == null ? void 0 : p.contains(h));
                !s.value && (b || !t.labelDisabled) && e("toggle"), e("click", f)
            },
            u = () => {
                var f, h;
                const {
                    bem: p,
                    checked: b,
                    indeterminate: y
                } = t, m = t.iconSize || i("iconSize");
                return I("div", {
                    ref: r,
                    class: p("icon", [l.value, {
                        disabled: s.value,
                        checked: b,
                        indeterminate: y
                    }]),
                    style: l.value !== "dot" ? {
                        fontSize: We(m)
                    } : {
                        width: We(m),
                        height: We(m),
                        borderColor: (f = a.value) == null ? void 0 : f.borderColor
                    }
                }, [n.icon ? n.icon({
                    checked: b,
                    disabled: s.value
                }) : l.value !== "dot" ? I(Mt, {
                    name: y ? "minus" : "success",
                    style: a.value
                }, null) : I("div", {
                    class: p("icon--dot__icon"),
                    style: {
                        backgroundColor: (h = a.value) == null ? void 0 : h.backgroundColor
                    }
                }, null)])
            },
            d = () => {
                const {
                    checked: f
                } = t;
                if (n.default) return I("span", {
                    class: t.bem("label", [t.labelPosition, {
                        disabled: s.value
                    }])
                }, [n.default({
                    checked: f,
                    disabled: s.value
                })])
            };
        return () => {
            const f = t.labelPosition === "left" ? [d(), u()] : [u(), d()];
            return I("div", {
                role: t.role,
                class: t.bem([{
                    disabled: s.value,
                    "label-disabled": t.labelDisabled
                }, o.value]),
                tabindex: s.value ? void 0 : 0,
                "aria-checked": t.checked,
                onClick: c
            }, [f])
        }
    }
});
const UY = Le({}, Nb, {
        shape: String
    }),
    [GY, HY] = Ee("radio");
var zY = ve({
    name: GY,
    props: UY,
    emits: ["update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            parent: r
        } = rr(G2), i = () => (r ? r.props.modelValue : t.modelValue) === t.name, s = () => {
            r ? r.updateValue(t.name) : e("update:modelValue", t.name)
        };
        return () => I(H2, Ke({
            bem: HY,
            role: "radio",
            parent: r,
            checked: i(),
            onToggle: s
        }, t), yt(n, ["default", "icon"]))
    }
});
const sxe = Ae(zY),
    [jY, VY] = Ee("checkbox"),
    WY = Le({}, Nb, {
        shape: String,
        bindGroup: me,
        indeterminate: {
            type: Boolean,
            default: null
        }
    });
var YY = ve({
    name: jY,
    props: WY,
    emits: ["change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            parent: r
        } = rr(NY), i = a => {
            const {
                name: l
            } = t, {
                max: c,
                modelValue: u
            } = r.props, d = u.slice();
            if (a) !(c && d.length >= +c) && !d.includes(l) && (d.push(l), t.bindGroup && r.updateValue(d));
            else {
                const f = d.indexOf(l);
                f !== -1 && (d.splice(f, 1), t.bindGroup && r.updateValue(d))
            }
        }, s = te(() => r && t.bindGroup ? r.props.modelValue.indexOf(t.name) !== -1 : !!t.modelValue), o = (a = !s.value) => {
            r && t.bindGroup ? i(a) : e("update:modelValue", a), t.indeterminate !== null && e("change", a)
        };
        return he(() => t.modelValue, a => {
            t.indeterminate === null && e("change", a)
        }), Tt({
            toggle: o,
            props: t,
            checked: s
        }), va(() => t.modelValue), () => I(H2, Ke({
            bem: VY,
            role: "checkbox",
            parent: r,
            checked: s.value,
            onToggle: o
        }, t), yt(n, ["default", "icon"]))
    }
});
const oxe = Ae(YY),
    [XY, Ot, Ni] = Ee("calendar"),
    qY = t => Ni("monthTitle", t.getFullYear(), t.getMonth() + 1);

function Oo(t, e) {
    const n = t.getFullYear(),
        r = e.getFullYear();
    if (n === r) {
        const i = t.getMonth(),
            s = e.getMonth();
        return i === s ? 0 : i > s ? 1 : -1
    }
    return n > r ? 1 : -1
}

function Mn(t, e) {
    const n = Oo(t, e);
    if (n === 0) {
        const r = t.getDate(),
            i = e.getDate();
        return r === i ? 0 : r > i ? 1 : -1
    }
    return n
}
const vl = t => new Date(t),
    ES = t => Array.isArray(t) ? t.map(vl) : vl(t);

function Ub(t, e) {
    const n = vl(t);
    return n.setDate(n.getDate() + e), n
}

function Gb(t, e) {
    const n = vl(t);
    return n.setMonth(n.getMonth() + e), n.getDate() !== t.getDate() && n.setDate(0), n
}

function z2(t, e) {
    const n = vl(t);
    return n.setFullYear(n.getFullYear() + e), n.getDate() !== t.getDate() && n.setDate(0), n
}
const Dv = t => Ub(t, -1),
    $v = t => Ub(t, 1),
    SS = t => Gb(t, -1),
    TS = t => Gb(t, 1),
    CS = t => z2(t, -1),
    PS = t => z2(t, 1),
    zd = () => {
        const t = new Date;
        return t.setHours(0, 0, 0, 0), t
    };

function KY(t) {
    const e = t[0].getTime();
    return (t[1].getTime() - e) / (1e3 * 60 * 60 * 24) + 1
}

function JY(t, e = 0) {
    const n = new Date(t.getFullYear(), t.getMonth() + 1, 0),
        r = e + t.getDate() - 1,
        i = e + n.getDate() - 1;
    return Math.floor(r / 7) === Math.floor(i / 7)
}
const ZY = Le({}, Fb, {
        modelValue: Xi(),
        filter: Function,
        formatter: {
            type: Function,
            default: (t, e) => e
        }
    }),
    QY = Object.keys(Fb);

function eX(t, e) {
    if (t < 0) return [];
    const n = Array(t);
    let r = -1;
    for (; ++r < t;) n[r] = e(r);
    return n
}
const j2 = (t, e) => 32 - new Date(t, e - 1, 32).getDate(),
    Vm = (t, e, n, r, i, s) => {
        const o = eX(e - t + 1, a => {
            const l = To(t + a);
            return r(n, {
                text: l,
                value: l
            })
        });
        return i ? i(n, o, s) : o
    },
    tX = (t, e) => t.map((n, r) => {
        const i = e[r];
        if (i.length) {
            const s = +i[0].value,
                o = +i[i.length - 1].value;
            return To(tn(+n, s, o))
        }
        return n
    }),
    [nX] = Ee("calendar-day");
var rX = ve({
    name: nX,
    props: {
        item: xn(Object),
        color: String,
        index: Number,
        offset: Ip(0),
        rowHeight: String
    },
    emits: ["click", "clickDisabledDate"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = te(() => {
                const {
                    item: c,
                    index: u,
                    color: d,
                    offset: f,
                    rowHeight: h
                } = t, p = {
                    height: h
                };
                if (c.type === "placeholder") return p.width = "100%", p;
                if (u === 0 && (p.marginLeft = `${100*f/7}%`), d) switch (c.type) {
                    case "end":
                    case "start":
                    case "start-end":
                    case "multiple-middle":
                    case "multiple-selected":
                        p.background = d;
                        break;
                    case "middle":
                        p.color = d;
                        break
                }
                return c.date && JY(c.date, f) && (p.marginBottom = 0), p
            }),
            i = () => {
                t.item.type !== "disabled" ? e("click", t.item) : e("clickDisabledDate", t.item)
            },
            s = () => {
                const {
                    topInfo: c
                } = t.item;
                if (c || n["top-info"]) return I("div", {
                    class: Ot("top-info")
                }, [n["top-info"] ? n["top-info"](t.item) : c])
            },
            o = () => {
                const {
                    bottomInfo: c
                } = t.item;
                if (c || n["bottom-info"]) return I("div", {
                    class: Ot("bottom-info")
                }, [n["bottom-info"] ? n["bottom-info"](t.item) : c])
            },
            a = () => n.text ? n.text(t.item) : t.item.text,
            l = () => {
                const {
                    item: c,
                    color: u,
                    rowHeight: d
                } = t, {
                    type: f
                } = c, h = [s(), a(), o()];
                return f === "selected" ? I("div", {
                    class: Ot("selected-day"),
                    style: {
                        width: d,
                        height: d,
                        background: u
                    }
                }, [h]) : h
            };
        return () => {
            const {
                type: c,
                className: u
            } = t.item;
            return c === "placeholder" ? I("div", {
                class: Ot("day"),
                style: r.value
            }, null) : I("div", {
                role: "gridcell",
                style: r.value,
                class: [Ot("day", c), u],
                tabindex: c === "disabled" ? void 0 : -1,
                onClick: i
            }, [l()])
        }
    }
});
const [iX] = Ee("calendar-month"), sX = {
    date: xn(Date),
    type: String,
    color: String,
    minDate: Date,
    maxDate: Date,
    showMark: Boolean,
    rowHeight: be,
    formatter: Function,
    lazyRender: Boolean,
    currentDate: [Date, Array],
    allowSameDay: Boolean,
    showSubtitle: Boolean,
    showMonthTitle: Boolean,
    firstDayOfWeek: Number
};
var oX = ve({
    name: iX,
    props: sX,
    emits: ["click", "clickDisabledDate"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const [r, i] = yI(), s = q(), o = q(), a = h2(o), l = te(() => qY(t.date)), c = te(() => We(t.rowHeight)), u = te(() => {
            const T = t.date.getDate(),
                P = (t.date.getDay() - T % 7 + 8) % 7;
            return t.firstDayOfWeek ? (P + 7 - t.firstDayOfWeek) % 7 : P
        }), d = te(() => j2(t.date.getFullYear(), t.date.getMonth() + 1)), f = te(() => r.value || !t.lazyRender), h = () => l.value, p = T => {
            const S = P => t.currentDate.some(R => Mn(R, P) === 0);
            if (S(T)) {
                const P = Dv(T),
                    R = $v(T),
                    D = S(P),
                    H = S(R);
                return D && H ? "multiple-middle" : D ? "end" : H ? "start" : "multiple-selected"
            }
            return ""
        }, b = T => {
            const [S, P] = t.currentDate;
            if (!S) return "";
            const R = Mn(T, S);
            if (!P) return R === 0 ? "start" : "";
            const D = Mn(T, P);
            return t.allowSameDay && R === 0 && D === 0 ? "start-end" : R === 0 ? "start" : D === 0 ? "end" : R > 0 && D < 0 ? "middle" : ""
        }, y = T => {
            const {
                type: S,
                minDate: P,
                maxDate: R,
                currentDate: D
            } = t;
            if (P && Mn(T, P) < 0 || R && Mn(T, R) > 0) return "disabled";
            if (D === null) return "";
            if (Array.isArray(D)) {
                if (S === "multiple") return p(T);
                if (S === "range") return b(T)
            } else if (S === "single") return Mn(T, D) === 0 ? "selected" : "";
            return ""
        }, m = T => {
            if (t.type === "range") {
                if (T === "start" || T === "end") return Ni(T);
                if (T === "start-end") return `${Ni("start")}/${Ni("end")}`
            }
        }, g = () => {
            if (t.showMonthTitle) return I("div", {
                class: Ot("month-title")
            }, [n["month-title"] ? n["month-title"]({
                date: t.date,
                text: l.value
            }) : l.value])
        }, v = () => {
            if (t.showMark && f.value) return I("div", {
                class: Ot("month-mark")
            }, [t.date.getMonth() + 1])
        }, _ = te(() => {
            const T = Math.ceil((d.value + u.value) / 7);
            return Array(T).fill({
                type: "placeholder"
            })
        }), x = te(() => {
            const T = [],
                S = t.date.getFullYear(),
                P = t.date.getMonth();
            for (let R = 1; R <= d.value; R++) {
                const D = new Date(S, P, R),
                    H = y(D);
                let B = {
                    date: D,
                    type: H,
                    text: R,
                    bottomInfo: m(H)
                };
                t.formatter && (B = t.formatter(B)), T.push(B)
            }
            return T
        }), w = te(() => x.value.filter(T => T.type === "disabled")), E = (T, S) => {
            if (s.value) {
                const P = jt(s.value),
                    R = _.value.length,
                    H = (Math.ceil((S.getDate() + u.value) / 7) - 1) * P.height / R;
                vh(T, P.top + H + T.scrollTop - jt(T).top)
            }
        }, C = (T, S) => I(rX, {
            item: T,
            index: S,
            color: t.color,
            offset: u.value,
            rowHeight: c.value,
            onClick: P => e("click", P),
            onClickDisabledDate: P => e("clickDisabledDate", P)
        }, yt(n, ["top-info", "bottom-info", "text"])), A = () => I("div", {
            ref: s,
            role: "grid",
            class: Ot("days")
        }, [v(), (f.value ? x : _).value.map(C)]);
        return Tt({
            getTitle: h,
            getHeight: () => a.value,
            setVisible: i,
            scrollToDate: E,
            disabledDays: w
        }), () => I("div", {
            class: Ot("month"),
            ref: o
        }, [g(), A()])
    }
});
const [aX] = Ee("calendar-header");
var lX = ve({
    name: aX,
    props: {
        date: Date,
        minDate: Date,
        maxDate: Date,
        title: String,
        subtitle: String,
        showTitle: Boolean,
        showSubtitle: Boolean,
        firstDayOfWeek: Number,
        switchMode: Pe("none")
    },
    emits: ["clickSubtitle", "panelChange"],
    setup(t, {
        slots: e,
        emit: n
    }) {
        const r = te(() => t.date && t.minDate && Oo(SS(t.date), t.minDate) < 0),
            i = te(() => t.date && t.minDate && Oo(CS(t.date), t.minDate) < 0),
            s = te(() => t.date && t.maxDate && Oo(TS(t.date), t.maxDate) > 0),
            o = te(() => t.date && t.maxDate && Oo(PS(t.date), t.maxDate) > 0),
            a = () => {
                if (t.showTitle) {
                    const h = t.title || Ni("title"),
                        p = e.title ? e.title() : h;
                    return I("div", {
                        class: Ot("header-title")
                    }, [p])
                }
            },
            l = h => n("clickSubtitle", h),
            c = h => n("panelChange", h),
            u = h => {
                const p = t.switchMode === "year-month",
                    b = e[h ? "next-month" : "prev-month"],
                    y = e[h ? "next-year" : "prev-year"],
                    m = h ? s.value : r.value,
                    g = h ? o.value : i.value,
                    v = h ? "arrow" : "arrow-left",
                    _ = h ? "arrow-double-right" : "arrow-double-left",
                    x = () => c((h ? TS : SS)(t.date)),
                    w = () => c((h ? PS : CS)(t.date)),
                    E = I("view", {
                        class: Ot("header-action", {
                            disabled: m
                        }),
                        onClick: m ? void 0 : x
                    }, [b ? b({
                        disabled: m
                    }) : I(Mt, {
                        class: {
                            [qi]: !m
                        },
                        name: v
                    }, null)]),
                    C = p && I("view", {
                        class: Ot("header-action", {
                            disabled: g
                        }),
                        onClick: g ? void 0 : w
                    }, [y ? y({
                        disabled: g
                    }) : I(Mt, {
                        class: {
                            [qi]: !g
                        },
                        name: _
                    }, null)]);
                return h ? [E, C] : [C, E]
            },
            d = () => {
                if (t.showSubtitle) {
                    const h = e.subtitle ? e.subtitle({
                            date: t.date,
                            text: t.subtitle
                        }) : t.subtitle,
                        p = t.switchMode !== "none";
                    return I("div", {
                        class: Ot("header-subtitle", {
                            "with-switch": p
                        }),
                        onClick: l
                    }, [p ? [u(), I("div", {
                        class: Ot("header-subtitle-text")
                    }, [h]), u(!0)] : h])
                }
            },
            f = () => {
                const {
                    firstDayOfWeek: h
                } = t, p = Ni("weekdays"), b = [...p.slice(h, 7), ...p.slice(0, h)];
                return I("div", {
                    class: Ot("weekdays")
                }, [b.map(y => I("span", {
                    class: Ot("weekday")
                }, [y]))])
            };
        return () => I("div", {
            class: Ot("header")
        }, [a(), d(), f()])
    }
});
const cX = {
    show: Boolean,
    type: Pe("single"),
    switchMode: Pe("none"),
    title: String,
    color: String,
    round: me,
    readonly: Boolean,
    poppable: me,
    maxRange: Fe(null),
    position: Pe("bottom"),
    teleport: [String, Object],
    showMark: me,
    showTitle: me,
    formatter: Function,
    rowHeight: be,
    confirmText: String,
    rangePrompt: String,
    lazyRender: me,
    showConfirm: me,
    defaultDate: [Date, Array],
    allowSameDay: Boolean,
    showSubtitle: me,
    closeOnPopstate: me,
    showRangePrompt: me,
    confirmDisabledText: String,
    closeOnClickOverlay: me,
    safeAreaInsetTop: Boolean,
    safeAreaInsetBottom: me,
    minDate: {
        type: Date,
        validator: yu
    },
    maxDate: {
        type: Date,
        validator: yu
    },
    firstDayOfWeek: {
        type: be,
        default: 0,
        validator: t => t >= 0 && t <= 6
    }
};
var uX = ve({
    name: XY,
    props: cX,
    emits: ["select", "confirm", "unselect", "monthShow", "overRange", "update:show", "clickSubtitle", "clickDisabledDate", "clickOverlay", "panelChange"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = te(() => t.switchMode !== "none"),
            i = te(() => !t.minDate && !r.value ? zd() : t.minDate),
            s = te(() => !t.maxDate && !r.value ? Gb(zd(), 6) : t.maxDate),
            o = (W, ne = i.value, fe = s.value) => ne && Mn(W, ne) === -1 ? ne : fe && Mn(W, fe) === 1 ? fe : W,
            a = (W = t.defaultDate) => {
                const {
                    type: ne,
                    allowSameDay: fe
                } = t;
                if (W === null) return W;
                const $ = zd();
                if (ne === "range") {
                    Array.isArray(W) || (W = []), W.length === 1 && Mn(W[0], $) === 1 && (W = []);
                    const X = i.value,
                        F = s.value,
                        Z = o(W[0] || $, X, F ? fe ? F : Dv(F) : void 0),
                        K = o(W[1] || (fe ? $ : $v($)), X ? fe ? X : $v(X) : void 0);
                    return [Z, K]
                }
                return ne === "multiple" ? Array.isArray(W) ? W.map(X => o(X)) : [o($)] : ((!W || Array.isArray(W)) && (W = $), o(W))
            },
            l = () => {
                const W = Array.isArray(d.value) ? d.value[0] : d.value;
                return W || o(zd())
            };
        let c;
        const u = q(),
            d = q(a()),
            f = q(l()),
            h = q(),
            [p, b] = T2(),
            y = te(() => t.firstDayOfWeek ? +t.firstDayOfWeek % 7 : 0),
            m = te(() => {
                const W = [];
                if (!i.value || !s.value) return W;
                const ne = new Date(i.value);
                ne.setDate(1);
                do W.push(new Date(ne)), ne.setMonth(ne.getMonth() + 1); while (Oo(ne, s.value) !== 1);
                return W
            }),
            g = te(() => {
                if (d.value) {
                    if (t.type === "range") return !d.value[0] || !d.value[1];
                    if (t.type === "multiple") return !d.value.length
                }
                return !d.value
            }),
            v = () => d.value,
            _ = () => {
                const W = od(u.value),
                    ne = W + c,
                    fe = m.value.map((K, ce) => p.value[ce].getHeight()),
                    $ = fe.reduce((K, ce) => K + ce, 0);
                if (ne > $ && W > 0) return;
                let X = 0,
                    F;
                const Z = [-1, -1];
                for (let K = 0; K < m.value.length; K++) {
                    const ce = p.value[K];
                    X <= ne && X + fe[K] >= W && (Z[1] = K, F || (F = ce, Z[0] = K), p.value[K].showed || (p.value[K].showed = !0, e("monthShow", {
                        date: ce.date,
                        title: ce.getTitle()
                    }))), X += fe[K]
                }
                m.value.forEach((K, ce) => {
                    const de = ce >= Z[0] - 1 && ce <= Z[1] + 1;
                    p.value[ce].setVisible(de)
                }), F && (h.value = F)
            },
            x = W => {
                r.value ? f.value = W : Sn(() => {
                    m.value.some((ne, fe) => Oo(ne, W) === 0 ? (u.value && p.value[fe].scrollToDate(u.value, W), !0) : !1), _()
                })
            },
            w = () => {
                if (!(t.poppable && !t.show))
                    if (d.value) {
                        const W = t.type === "single" ? d.value : d.value[0];
                        yu(W) && x(W)
                    } else r.value || Sn(_)
            },
            E = () => {
                t.poppable && !t.show || (r.value || Sn(() => {
                    c = Math.floor(jt(u).height)
                }), w())
            },
            C = (W = a()) => {
                d.value = W, w()
            },
            A = W => {
                const {
                    maxRange: ne,
                    rangePrompt: fe,
                    showRangePrompt: $
                } = t;
                return ne && KY(W) > +ne ? ($ && Bv(fe || Ni("rangePrompt", ne)), e("overRange"), !1) : !0
            },
            T = W => {
                f.value = W, e("panelChange", {
                    date: W
                })
            },
            S = () => {
                var W;
                return e("confirm", (W = d.value) != null ? W : ES(d.value))
            },
            P = (W, ne) => {
                const fe = $ => {
                    d.value = $, e("select", ES($))
                };
                if (ne && t.type === "range" && !A(W)) {
                    fe([W[0], Ub(W[0], +t.maxRange - 1)]);
                    return
                }
                fe(W), ne && !t.showConfirm && S()
            },
            R = (W, ne, fe) => {
                var $;
                return ($ = W.find(X => Mn(ne, X.date) === -1 && Mn(X.date, fe) === -1)) == null ? void 0 : $.date
            },
            D = te(() => p.value.reduce((W, ne) => {
                var fe, $;
                return W.push(...($ = (fe = ne.disabledDays) == null ? void 0 : fe.value) != null ? $ : []), W
            }, [])),
            H = W => {
                if (t.readonly || !W.date) return;
                const {
                    date: ne
                } = W, {
                    type: fe
                } = t;
                if (fe === "range") {
                    if (!d.value) {
                        P([ne]);
                        return
                    }
                    const [$, X] = d.value;
                    if ($ && !X) {
                        const F = Mn(ne, $);
                        if (F === 1) {
                            const Z = R(D.value, $, ne);
                            if (Z) {
                                const K = Dv(Z);
                                Mn($, K) === -1 ? P([$, K]) : P([ne])
                            } else P([$, ne], !0)
                        } else F === -1 ? P([ne]) : t.allowSameDay && P([ne, ne], !0)
                    } else P([ne])
                } else if (fe === "multiple") {
                    if (!d.value) {
                        P([ne]);
                        return
                    }
                    const $ = d.value,
                        X = $.findIndex(F => Mn(F, ne) === 0);
                    if (X !== -1) {
                        const [F] = $.splice(X, 1);
                        e("unselect", vl(F))
                    } else t.maxRange && $.length >= +t.maxRange ? Bv(t.rangePrompt || Ni("rangePrompt", t.maxRange)) : P([...$, ne])
                } else P(ne, !0)
            },
            B = W => e("clickOverlay", W),
            N = W => e("update:show", W),
            V = (W, ne) => {
                const fe = ne !== 0 || !t.showSubtitle;
                return I(oX, Ke({
                    ref: r.value ? h : b(ne),
                    date: W,
                    currentDate: d.value,
                    showMonthTitle: fe,
                    firstDayOfWeek: y.value,
                    lazyRender: r.value ? !1 : t.lazyRender,
                    maxDate: s.value,
                    minDate: i.value
                }, yt(t, ["type", "color", "showMark", "formatter", "rowHeight", "showSubtitle", "allowSameDay"]), {
                    onClick: H,
                    onClickDisabledDate: $ => e("clickDisabledDate", $)
                }), yt(n, ["top-info", "bottom-info", "month-title", "text"]))
            },
            Y = () => {
                if (n.footer) return n.footer();
                if (t.showConfirm) {
                    const W = n["confirm-text"],
                        ne = g.value,
                        fe = ne ? t.confirmDisabledText : t.confirmText;
                    return I(_h, {
                        round: !0,
                        block: !0,
                        type: "primary",
                        color: t.color,
                        class: Ot("confirm"),
                        disabled: ne,
                        nativeType: "button",
                        onClick: S
                    }, {
                        default: () => [W ? W({
                            disabled: ne
                        }) : fe || Ni("confirm")]
                    })
                }
            },
            le = () => I("div", {
                class: [Ot("footer"), {
                    "van-safe-area-bottom": t.safeAreaInsetBottom
                }]
            }, [Y()]),
            ae = () => {
                var W, ne;
                return I("div", {
                    class: Ot()
                }, [I(lX, {
                    date: (W = h.value) == null ? void 0 : W.date,
                    maxDate: s.value,
                    minDate: i.value,
                    title: t.title,
                    subtitle: (ne = h.value) == null ? void 0 : ne.getTitle(),
                    showTitle: t.showTitle,
                    showSubtitle: t.showSubtitle,
                    switchMode: t.switchMode,
                    firstDayOfWeek: y.value,
                    onClickSubtitle: fe => e("clickSubtitle", fe),
                    onPanelChange: T
                }, yt(n, ["title", "subtitle", "prev-month", "prev-year", "next-month", "next-year"])), I("div", {
                    ref: u,
                    class: Ot("body"),
                    onScroll: r.value ? void 0 : _
                }, [r.value ? V(f.value, 0) : m.value.map(V)]), le()])
            };
        return he(() => t.show, E), he(() => [t.type, t.minDate, t.maxDate, t.switchMode], () => C(a(d.value))), he(() => t.defaultDate, W => {
            C(W)
        }), Tt({
            reset: C,
            scrollToDate: x,
            getSelectedDate: v
        }), zl(E), () => t.poppable ? I(xa, {
            show: t.show,
            class: Ot("popup"),
            round: t.round,
            position: t.position,
            closeable: t.showTitle || t.showSubtitle,
            teleport: t.teleport,
            closeOnPopstate: t.closeOnPopstate,
            safeAreaInsetTop: t.safeAreaInsetTop,
            closeOnClickOverlay: t.closeOnClickOverlay,
            onClickOverlay: B,
            "onUpdate:show": N
        }, {
            default: ae
        }) : ae()
    }
});
const axe = Ae(uX),
    [dX, ka] = Ee("image"),
    fX = {
        src: String,
        alt: String,
        fit: String,
        position: String,
        round: Boolean,
        block: Boolean,
        width: be,
        height: be,
        radius: be,
        lazyLoad: Boolean,
        iconSize: be,
        showError: me,
        errorIcon: Pe("photo-fail"),
        iconPrefix: String,
        showLoading: me,
        loadingIcon: Pe("photo"),
        crossorigin: String,
        referrerpolicy: String,
        decoding: String
    };
var hX = ve({
    name: dX,
    props: fX,
    emits: ["load", "error"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = q(!1),
            i = q(!0),
            s = q(),
            {
                $Lazyload: o
            } = rt().proxy,
            a = te(() => {
                const y = {
                    width: We(t.width),
                    height: We(t.height)
                };
                return gt(t.radius) && (y.overflow = "hidden", y.borderRadius = We(t.radius)), y
            });
        he(() => t.src, () => {
            r.value = !1, i.value = !0
        });
        const l = y => {
                i.value && (i.value = !1, e("load", y))
            },
            c = () => {
                const y = new Event("load");
                Object.defineProperty(y, "target", {
                    value: s.value,
                    enumerable: !0
                }), l(y)
            },
            u = y => {
                r.value = !0, i.value = !1, e("error", y)
            },
            d = (y, m, g) => g ? g() : I(Mt, {
                name: y,
                size: t.iconSize,
                class: m,
                classPrefix: t.iconPrefix
            }, null),
            f = () => {
                if (i.value && t.showLoading) return I("div", {
                    class: ka("loading")
                }, [d(t.loadingIcon, ka("loading-icon"), n.loading)]);
                if (r.value && t.showError) return I("div", {
                    class: ka("error")
                }, [d(t.errorIcon, ka("error-icon"), n.error)])
            },
            h = () => {
                if (r.value || !t.src) return;
                const y = {
                    alt: t.alt,
                    class: ka("img"),
                    decoding: t.decoding,
                    style: {
                        objectFit: t.fit,
                        objectPosition: t.position
                    },
                    crossorigin: t.crossorigin,
                    referrerpolicy: t.referrerpolicy
                };
                return t.lazyLoad ? mr(I("img", Ke({
                    ref: s
                }, y), null), [
                    [eO("lazy"), t.src]
                ]) : I("img", Ke({
                    ref: s,
                    src: t.src,
                    onLoad: l,
                    onError: u
                }, y), null)
            },
            p = ({
                el: y
            }) => {
                const m = () => {
                    y === s.value && i.value && c()
                };
                s.value ? m() : Ue(m)
            },
            b = ({
                el: y
            }) => {
                y === s.value && !r.value && u()
            };
        return o && ui && (o.$on("loaded", p), o.$on("error", b), nr(() => {
            o.$off("loaded", p), o.$off("error", b)
        })), _t(() => {
            Ue(() => {
                var y;
                (y = s.value) != null && y.complete && !t.lazyLoad && c()
            })
        }), () => {
            var y;
            return I("div", {
                class: ka({
                    round: t.round,
                    block: t.block
                }),
                style: a.value
            }, [h(), f(), (y = n.default) == null ? void 0 : y.call(n)])
        }
    }
});
const V2 = Ae(hX),
    [pX, jd] = Ee("circle");
let mX = 0;
const AS = t => Math.min(Math.max(+t, 0), 100);

function gX(t, e) {
    const n = t ? 1 : 0;
    return `M ${e/2} ${e/2} m 0, -500 a 500, 500 0 1, ${n} 0, 1000 a 500, 500 0 1, ${n} 0, -1000`
}
const yX = {
    text: String,
    size: be,
    fill: Pe("none"),
    rate: Fe(100),
    speed: Fe(0),
    color: [String, Object],
    clockwise: me,
    layerColor: String,
    currentRate: Ip(0),
    strokeWidth: Fe(40),
    strokeLinecap: String,
    startPosition: Pe("top")
};
var vX = ve({
    name: pX,
    props: yX,
    emits: ["update:currentRate"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = `van-circle-${mX++}`,
            i = te(() => +t.strokeWidth + 1e3),
            s = te(() => gX(t.clockwise, i.value)),
            o = te(() => {
                const f = {
                    top: 0,
                    right: 90,
                    bottom: 180,
                    left: 270
                }[t.startPosition];
                if (f) return {
                    transform: `rotate(${f}deg)`
                }
            });
        he(() => t.rate, d => {
            let f;
            const h = Date.now(),
                p = t.currentRate,
                b = AS(d),
                y = Math.abs((p - b) * 1e3 / +t.speed),
                m = () => {
                    const g = Date.now(),
                        _ = Math.min((g - h) / y, 1) * (b - p) + p;
                    e("update:currentRate", AS(parseFloat(_.toFixed(1)))), (b > p ? _ < b : _ > b) && (f = Sn(m))
                };
            t.speed ? (f && id(f), f = Sn(m)) : e("update:currentRate", b)
        }, {
            immediate: !0
        });
        const a = () => {
                const {
                    strokeWidth: f,
                    currentRate: h,
                    strokeLinecap: p
                } = t, b = 3140 * h / 100, y = di(t.color) ? `url(#${r})` : t.color, m = {
                    stroke: y,
                    strokeWidth: `${+f+1}px`,
                    strokeLinecap: p,
                    strokeDasharray: `${b}px 3140px`
                };
                return I("path", {
                    d: s.value,
                    style: m,
                    class: jd("hover"),
                    stroke: y
                }, null)
            },
            l = () => {
                const d = {
                    fill: t.fill,
                    stroke: t.layerColor,
                    strokeWidth: `${t.strokeWidth}px`
                };
                return I("path", {
                    class: jd("layer"),
                    style: d,
                    d: s.value
                }, null)
            },
            c = () => {
                const {
                    color: d
                } = t;
                if (!di(d)) return;
                const f = Object.keys(d).sort((h, p) => parseFloat(h) - parseFloat(p)).map((h, p) => I("stop", {
                    key: p,
                    offset: h,
                    "stop-color": d[h]
                }, null));
                return I("defs", null, [I("linearGradient", {
                    id: r,
                    x1: "100%",
                    y1: "0%",
                    x2: "0%",
                    y2: "0%"
                }, [f])])
            },
            u = () => {
                if (n.default) return n.default();
                if (t.text) return I("div", {
                    class: jd("text")
                }, [t.text])
            };
        return () => I("div", {
            class: jd(),
            style: _a(t.size)
        }, [I("svg", {
            viewBox: `0 0 ${i.value} ${i.value}`,
            style: o.value
        }, [c(), l(), a()]), u()])
    }
});
const lxe = Ae(vX),
    [W2, _X] = Ee("row"),
    Y2 = Symbol(W2),
    bX = {
        tag: Pe("div"),
        wrap: me,
        align: String,
        gutter: {
            type: [String, Number, Array],
            default: 0
        },
        justify: String
    };
var xX = ve({
    name: W2,
    props: bX,
    setup(t, {
        slots: e
    }) {
        const {
            children: n,
            linkChildren: r
        } = Lr(Y2), i = te(() => {
            const a = [
                []
            ];
            let l = 0;
            return n.forEach((c, u) => {
                l += Number(c.span), l > 24 ? (a.push([u]), l -= 24) : a[a.length - 1].push(u)
            }), a
        }), s = te(() => {
            let a = 0;
            Array.isArray(t.gutter) ? a = Number(t.gutter[0]) || 0 : a = Number(t.gutter);
            const l = [];
            return a && i.value.forEach(c => {
                const u = a * (c.length - 1) / c.length;
                c.forEach((d, f) => {
                    if (f === 0) l.push({
                        right: u
                    });
                    else {
                        const h = a - l[d - 1].right,
                            p = u - h;
                        l.push({
                            left: h,
                            right: p
                        })
                    }
                })
            }), l
        }), o = te(() => {
            const {
                gutter: a
            } = t, l = [];
            if (Array.isArray(a) && a.length > 1) {
                const c = Number(a[1]) || 0;
                if (c <= 0) return l;
                i.value.forEach((u, d) => {
                    d !== i.value.length - 1 && u.forEach(() => {
                        l.push({
                            bottom: c
                        })
                    })
                })
            }
            return l
        });
        return r({
            spaces: s,
            verticalSpaces: o
        }), () => {
            const {
                tag: a,
                wrap: l,
                align: c,
                justify: u
            } = t;
            return I(a, {
                class: _X({
                    [`align-${c}`]: c,
                    [`justify-${u}`]: u,
                    nowrap: !l
                })
            }, {
                default: () => {
                    var d;
                    return [(d = e.default) == null ? void 0 : d.call(e)]
                }
            })
        }
    }
});
const [wX, EX] = Ee("col"), SX = {
    tag: Pe("div"),
    span: Fe(0),
    offset: be
};
var TX = ve({
    name: wX,
    props: SX,
    setup(t, {
        slots: e
    }) {
        const {
            parent: n,
            index: r
        } = rr(Y2), i = te(() => {
            if (!n) return;
            const {
                spaces: s,
                verticalSpaces: o
            } = n;
            let a = {};
            if (s && s.value && s.value[r.value]) {
                const {
                    left: c,
                    right: u
                } = s.value[r.value];
                a = {
                    paddingLeft: c ? `${c}px` : null,
                    paddingRight: u ? `${u}px` : null
                }
            }
            const {
                bottom: l
            } = o.value[r.value] || {};
            return Le(a, {
                marginBottom: l ? `${l}px` : null
            })
        });
        return () => {
            const {
                tag: s,
                span: o,
                offset: a
            } = t;
            return I(s, {
                style: i.value,
                class: EX({
                    [o]: o,
                    [`offset-${a}`]: a
                })
            }, {
                default: () => {
                    var l;
                    return [(l = e.default) == null ? void 0 : l.call(e)]
                }
            })
        }
    }
});
const cxe = Ae(TX),
    [X2, CX] = Ee("collapse"),
    q2 = Symbol(X2),
    PX = {
        border: me,
        accordion: Boolean,
        modelValue: {
            type: [String, Number, Array],
            default: ""
        }
    };

function AX(t, e) {
    return e && Array.isArray(t) ? (console.error('[Vant] Collapse: "v-model" should not be Array in accordion mode'), !1) : !e && !Array.isArray(t) ? (console.error('[Vant] Collapse: "v-model" should be Array in non-accordion mode'), !1) : !0
}
var OX = ve({
    name: X2,
    props: PX,
    emits: ["change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            linkChildren: r,
            children: i
        } = Lr(q2), s = c => {
            e("change", c), e("update:modelValue", c)
        }, o = (c, u) => {
            const {
                accordion: d,
                modelValue: f
            } = t;
            s(d ? c === f ? "" : c : u ? f.concat(c) : f.filter(h => h !== c))
        }, a = (c = {}) => {
            if (t.accordion) return;
            typeof c == "boolean" && (c = {
                expanded: c
            });
            const {
                expanded: u,
                skipDisabled: d
            } = c, h = i.filter(p => p.disabled && d ? p.expanded.value : u ? ? !p.expanded.value).map(p => p.itemName.value);
            s(h)
        }, l = c => {
            const {
                accordion: u,
                modelValue: d
            } = t;
            return AX(d, u) ? u ? d === c : d.includes(c) : !1
        };
        return Tt({
            toggleAll: a
        }), r({
            toggle: o,
            isExpanded: l
        }), () => {
            var c;
            return I("div", {
                class: [CX(), {
                    [c2]: t.border
                }]
            }, [(c = n.default) == null ? void 0 : c.call(n)])
        }
    }
});
const uxe = Ae(OX),
    [IX, Vd] = Ee("collapse-item"),
    MX = ["icon", "title", "value", "label", "right-icon"],
    RX = Le({}, kp, {
        name: be,
        isLink: me,
        disabled: Boolean,
        readonly: Boolean,
        lazyRender: me
    });
var kX = ve({
    name: IX,
    props: RX,
    setup(t, {
        slots: e
    }) {
        const n = q(),
            r = q(),
            {
                parent: i,
                index: s
            } = rr(q2);
        if (!i) {
            console.error("[Vant] <CollapseItem> must be a child component of <Collapse>.");
            return
        }
        const o = te(() => {
                var b;
                return (b = t.name) != null ? b : s.value
            }),
            a = te(() => i.isExpanded(o.value)),
            l = q(a.value),
            c = Db(() => l.value || !t.lazyRender),
            u = () => {
                a.value ? n.value && (n.value.style.height = "") : l.value = !1
            };
        he(a, (b, y) => {
            if (y === null) return;
            b && (l.value = !0), (b ? Ue : Sn)(() => {
                if (!r.value || !n.value) return;
                const {
                    offsetHeight: g
                } = r.value;
                if (g) {
                    const v = `${g}px`;
                    n.value.style.height = b ? "0" : v, Ao(() => {
                        n.value && (n.value.style.height = b ? v : "0")
                    })
                } else u()
            })
        });
        const d = (b = !a.value) => {
                i.toggle(o.value, b)
            },
            f = () => {
                !t.disabled && !t.readonly && d()
            },
            h = () => {
                const {
                    border: b,
                    disabled: y,
                    readonly: m
                } = t, g = yt(t, Object.keys(kp));
                return m && (g.isLink = !1), (y || m) && (g.clickable = !1), I(D2, Ke({
                    role: "button",
                    class: Vd("title", {
                        disabled: y,
                        expanded: a.value,
                        borderless: !b
                    }),
                    "aria-expanded": String(a.value),
                    onClick: f
                }, g), yt(e, MX))
            },
            p = c(() => {
                var b;
                return mr(I("div", {
                    ref: n,
                    class: Vd("wrapper"),
                    onTransitionend: u
                }, [I("div", {
                    ref: r,
                    class: Vd("content")
                }, [(b = e.default) == null ? void 0 : b.call(e)])]), [
                    [yr, l.value]
                ])
            });
        return Tt({
            toggle: d,
            expanded: a,
            itemName: o
        }), () => I("div", {
            class: [Vd({
                border: s.value && t.border
            })]
        }, [h(), p()])
    }
});
const dxe = Ae(kX);

function BX(t, e) {
    const {
        days: n
    } = e;
    let {
        hours: r,
        minutes: i,
        seconds: s,
        milliseconds: o
    } = e;
    if (t.includes("DD") ? t = t.replace("DD", To(n)) : r += n * 24, t.includes("HH") ? t = t.replace("HH", To(r)) : i += r * 60, t.includes("mm") ? t = t.replace("mm", To(i)) : s += i * 60, t.includes("ss") ? t = t.replace("ss", To(s)) : o += s * 1e3, t.includes("S")) {
        const a = To(o, 3);
        t.includes("SSS") ? t = t.replace("SSS", a) : t.includes("SS") ? t = t.replace("SS", a.slice(0, 2)) : t = t.replace("S", a.charAt(0))
    }
    return t
}
const [DX, $X] = Ee("count-down"), FX = {
    time: Fe(0),
    format: Pe("HH:mm:ss"),
    autoStart: me,
    millisecond: Boolean
};
var LX = ve({
    name: DX,
    props: FX,
    emits: ["change", "finish"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            start: r,
            pause: i,
            reset: s,
            current: o
        } = bI({
            time: +t.time,
            millisecond: t.millisecond,
            onChange: c => e("change", c),
            onFinish: () => e("finish")
        }), a = te(() => BX(t.format, o.value)), l = () => {
            s(+t.time), t.autoStart && r()
        };
        return he(() => t.time, l, {
            immediate: !0
        }), Tt({
            start: r,
            pause: i,
            reset: l
        }), () => I("div", {
            role: "timer",
            class: $X()
        }, [n.default ? n.default(o.value) : a.value])
    }
});
const fxe = Ae(LX),
    OS = new Date().getFullYear(),
    [NX] = Ee("date-picker"),
    UX = Le({}, ZY, {
        columnsType: {
            type: Array,
            default: () => ["year", "month", "day"]
        },
        minDate: {
            type: Date,
            default: () => new Date(OS - 10, 0, 1),
            validator: yu
        },
        maxDate: {
            type: Date,
            default: () => new Date(OS + 10, 11, 31),
            validator: yu
        }
    });
var GX = ve({
    name: NX,
    props: UX,
    emits: ["confirm", "cancel", "change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = q(t.modelValue),
            i = q(!1),
            s = q(),
            o = te(() => i.value ? t.modelValue : r.value),
            a = x => x === t.minDate.getFullYear(),
            l = x => x === t.maxDate.getFullYear(),
            c = x => x === t.minDate.getMonth() + 1,
            u = x => x === t.maxDate.getMonth() + 1,
            d = x => {
                const {
                    minDate: w,
                    columnsType: E
                } = t, C = E.indexOf(x), A = o.value[C];
                if (A) return +A;
                switch (x) {
                    case "year":
                        return w.getFullYear();
                    case "month":
                        return w.getMonth() + 1;
                    case "day":
                        return w.getDate()
                }
            },
            f = () => {
                const x = t.minDate.getFullYear(),
                    w = t.maxDate.getFullYear();
                return Vm(x, w, "year", t.formatter, t.filter, o.value)
            },
            h = () => {
                const x = d("year"),
                    w = a(x) ? t.minDate.getMonth() + 1 : 1,
                    E = l(x) ? t.maxDate.getMonth() + 1 : 12;
                return Vm(w, E, "month", t.formatter, t.filter, o.value)
            },
            p = () => {
                const x = d("year"),
                    w = d("month"),
                    E = a(x) && c(w) ? t.minDate.getDate() : 1,
                    C = l(x) && u(w) ? t.maxDate.getDate() : j2(x, w);
                return Vm(E, C, "day", t.formatter, t.filter, o.value)
            },
            b = () => {
                var x;
                return (x = s.value) == null ? void 0 : x.confirm()
            },
            y = () => r.value,
            m = te(() => t.columnsType.map(x => {
                switch (x) {
                    case "year":
                        return f();
                    case "month":
                        return h();
                    case "day":
                        return p();
                    default:
                        throw new Error(`[Vant] DatePicker: unsupported columns type: ${x}`)
                }
            }));
        he(r, x => {
            $s(x, t.modelValue) || e("update:modelValue", x)
        }), he(() => t.modelValue, (x, w) => {
            i.value = $s(w, r.value), x = tX(x, m.value), $s(x, r.value) || (r.value = x), i.value = !1
        }, {
            immediate: !0
        });
        const g = (...x) => e("change", ...x),
            v = (...x) => e("cancel", ...x),
            _ = (...x) => e("confirm", ...x);
        return Tt({
            confirm: b,
            getSelectedDate: y
        }), () => I(aY, Ke({
            ref: s,
            modelValue: r.value,
            "onUpdate:modelValue": x => r.value = x,
            columns: m.value,
            onChange: g,
            onCancel: v,
            onConfirm: _
        }, yt(t, QY)), n)
    }
});
const hxe = Ae(GX),
    [HX, wr, Wd] = Ee("dialog"),
    zX = Le({}, ld, {
        title: String,
        theme: String,
        width: be,
        message: [String, Function],
        callback: Function,
        allowHtml: Boolean,
        className: Ut,
        transition: Pe("van-dialog-bounce"),
        messageAlign: String,
        closeOnPopstate: me,
        showCancelButton: Boolean,
        cancelButtonText: String,
        cancelButtonColor: String,
        cancelButtonDisabled: Boolean,
        confirmButtonText: String,
        confirmButtonColor: String,
        confirmButtonDisabled: Boolean,
        showConfirmButton: me,
        closeOnClickOverlay: Boolean,
        keyboardEnabled: me,
        destroyOnClose: Boolean
    }),
    jX = [...y2, "transition", "closeOnPopstate", "destroyOnClose"];
var K2 = ve({
    name: HX,
    props: zX,
    emits: ["confirm", "cancel", "keydown", "update:show"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = q(),
            i = ft({
                confirm: !1,
                cancel: !1
            }),
            s = m => e("update:show", m),
            o = m => {
                var g;
                s(!1), (g = t.callback) == null || g.call(t, m)
            },
            a = m => () => {
                t.show && (e(m), t.beforeClose ? (i[m] = !0, jl(t.beforeClose, {
                    args: [m],
                    done() {
                        o(m), i[m] = !1
                    },
                    canceled() {
                        i[m] = !1
                    }
                })) : o(m))
            },
            l = a("cancel"),
            c = a("confirm"),
            u = WO(m => {
                var g, v;
                if (!t.keyboardEnabled || m.target !== ((v = (g = r.value) == null ? void 0 : g.popupRef) == null ? void 0 : v.value)) return;
                ({
                    Enter: t.showConfirmButton ? c : Av,
                    Escape: t.showCancelButton ? l : Av
                })[m.key](), e("keydown", m)
            }, ["enter", "esc"]),
            d = () => {
                const m = n.title ? n.title() : t.title;
                if (m) return I("div", {
                    class: wr("header", {
                        isolated: !t.message && !n.default
                    })
                }, [m])
            },
            f = m => {
                const {
                    message: g,
                    allowHtml: v,
                    messageAlign: _
                } = t, x = wr("message", {
                    "has-title": m,
                    [_]: _
                }), w = gl(g) ? g() : g;
                return v && typeof w == "string" ? I("div", {
                    class: x,
                    innerHTML: w
                }, null) : I("div", {
                    class: x
                }, [w])
            },
            h = () => {
                if (n.default) return I("div", {
                    class: wr("content")
                }, [n.default()]);
                const {
                    title: m,
                    message: g,
                    allowHtml: v
                } = t;
                if (g) {
                    const _ = !!(m || n.title);
                    return I("div", {
                        key: v ? 1 : 0,
                        class: wr("content", {
                            isolated: !_
                        })
                    }, [f(_)])
                }
            },
            p = () => I("div", {
                class: [l2, wr("footer")]
            }, [t.showCancelButton && I(_h, {
                size: "large",
                text: t.cancelButtonText || Wd("cancel"),
                class: wr("cancel"),
                style: {
                    color: t.cancelButtonColor
                },
                loading: i.cancel,
                disabled: t.cancelButtonDisabled,
                onClick: l
            }, null), t.showConfirmButton && I(_h, {
                size: "large",
                text: t.confirmButtonText || Wd("confirm"),
                class: [wr("confirm"), {
                    [xW]: t.showCancelButton
                }],
                style: {
                    color: t.confirmButtonColor
                },
                loading: i.confirm,
                disabled: t.confirmButtonDisabled,
                onClick: c
            }, null)]),
            b = () => I(AW, {
                class: wr("footer")
            }, {
                default: () => [t.showCancelButton && I(fS, {
                    type: "warning",
                    text: t.cancelButtonText || Wd("cancel"),
                    class: wr("cancel"),
                    color: t.cancelButtonColor,
                    loading: i.cancel,
                    disabled: t.cancelButtonDisabled,
                    onClick: l
                }, null), t.showConfirmButton && I(fS, {
                    type: "danger",
                    text: t.confirmButtonText || Wd("confirm"),
                    class: wr("confirm"),
                    color: t.confirmButtonColor,
                    loading: i.confirm,
                    disabled: t.confirmButtonDisabled,
                    onClick: c
                }, null)]
            }),
            y = () => n.footer ? n.footer() : t.theme === "round-button" ? b() : p();
        return () => {
            const {
                width: m,
                title: g,
                theme: v,
                message: _,
                className: x
            } = t;
            return I(xa, Ke({
                ref: r,
                role: "dialog",
                class: [wr([v]), x],
                style: {
                    width: We(m)
                },
                tabindex: 0,
                "aria-labelledby": g || _,
                onKeydown: u,
                "onUpdate:show": s
            }, yt(t, jX)), {
                default: () => [d(), h(), y()]
            })
        }
    }
});
let Fv;
const VX = {
    title: "",
    width: "",
    theme: null,
    message: "",
    overlay: !0,
    callback: null,
    teleport: "body",
    className: "",
    allowHtml: !1,
    lockScroll: !0,
    transition: void 0,
    beforeClose: null,
    overlayClass: "",
    overlayStyle: void 0,
    messageAlign: "",
    cancelButtonText: "",
    cancelButtonColor: null,
    cancelButtonDisabled: !1,
    confirmButtonText: "",
    confirmButtonColor: null,
    confirmButtonDisabled: !1,
    showConfirmButton: !0,
    showCancelButton: !1,
    closeOnPopstate: !0,
    closeOnClickOverlay: !1,
    destroyOnClose: !1
};
let WX = Le({}, VX);

function YX() {
    ({
        instance: Fv
    } = Dp({
        setup() {
            const {
                state: e,
                toggle: n
            } = Bp();
            return () => I(K2, Ke(e, {
                "onUpdate:show": n
            }), null)
        }
    }))
}

function XX(t) {
    return ui ? new Promise((e, n) => {
        Fv || YX(), Fv.open(Le({}, WX, t, {
            callback: r => {
                (r === "confirm" ? e : n)(r)
            }
        }))
    }) : Promise.resolve(void 0)
}
const pxe = t => XX(Le({
        showCancelButton: !0
    }, t)),
    mxe = Ae(K2),
    [qX, KX] = Ee("divider"),
    JX = {
        dashed: Boolean,
        hairline: me,
        vertical: Boolean,
        contentPosition: Pe("center")
    };
var ZX = ve({
    name: qX,
    props: JX,
    setup(t, {
        slots: e
    }) {
        return () => {
            var n;
            return I("div", {
                role: "separator",
                class: KX({
                    dashed: t.dashed,
                    hairline: t.hairline,
                    vertical: t.vertical,
                    [`content-${t.contentPosition}`]: !!e.default && !t.vertical
                })
            }, [!t.vertical && ((n = e.default) == null ? void 0 : n.call(e))])
        }
    }
});
const gxe = Ae(ZX),
    QX = {
        gap: {
            type: [Number, Object],
            default: 24
        },
        icon: String,
        axis: Pe("y"),
        magnetic: String,
        offset: Object,
        teleport: {
            type: [String, Object],
            default: "body"
        }
    },
    [eq, IS] = Ee("floating-bubble");
var tq = ve({
    name: eq,
    inheritAttrs: !1,
    props: QX,
    emits: ["click", "update:offset", "offsetChange"],
    setup(t, {
        slots: e,
        emit: n,
        attrs: r
    }) {
        const i = q(),
            s = q({
                x: 0,
                y: 0,
                width: 0,
                height: 0
            }),
            o = te(() => di(t.gap) ? t.gap.x : t.gap),
            a = te(() => di(t.gap) ? t.gap.y : t.gap),
            l = te(() => ({
                top: a.value,
                right: Li.value - s.value.width - o.value,
                bottom: Fs.value - s.value.height - a.value,
                left: o.value
            })),
            c = q(!1);
        let u = !1;
        const d = te(() => {
                const x = {},
                    w = We(s.value.x),
                    E = We(s.value.y);
                return x.transform = `translate3d(${w}, ${E}, 0)`, (c.value || !u) && (x.transition = "none"), x
            }),
            f = () => {
                if (!_.value) return;
                const {
                    width: x,
                    height: w
                } = jt(i.value), {
                    offset: E
                } = t;
                s.value = {
                    x: E ? E.x : Li.value - x - o.value,
                    y: E ? E.y : Fs.value - w - a.value,
                    width: x,
                    height: w
                }
            },
            h = ba();
        let p = 0,
            b = 0;
        const y = x => {
            h.start(x), c.value = !0, p = s.value.x, b = s.value.y
        };
        An("touchmove", x => {
            if (x.preventDefault(), h.move(x), t.axis !== "lock" && !h.isTap.value) {
                if (t.axis === "x" || t.axis === "xy") {
                    let E = p + h.deltaX.value;
                    E < l.value.left && (E = l.value.left), E > l.value.right && (E = l.value.right), s.value.x = E
                }
                if (t.axis === "y" || t.axis === "xy") {
                    let E = b + h.deltaY.value;
                    E < l.value.top && (E = l.value.top), E > l.value.bottom && (E = l.value.bottom), s.value.y = E
                }
                const w = yt(s.value, ["x", "y"]);
                n("update:offset", w)
            }
        }, {
            target: i
        });
        const g = () => {
                c.value = !1, Ue(() => {
                    if (t.magnetic === "x") {
                        const x = lS([l.value.left, l.value.right], s.value.x);
                        s.value.x = x
                    }
                    if (t.magnetic === "y") {
                        const x = lS([l.value.top, l.value.bottom], s.value.y);
                        s.value.y = x
                    }
                    if (!h.isTap.value) {
                        const x = yt(s.value, ["x", "y"]);
                        n("update:offset", x), (p !== x.x || b !== x.y) && n("offsetChange", x)
                    }
                })
            },
            v = x => {
                h.isTap.value ? n("click", x) : x.stopPropagation()
            };
        _t(() => {
            f(), Ue(() => {
                u = !0
            })
        }), he([Li, Fs, o, a, () => t.offset], f, {
            deep: !0
        });
        const _ = q(!0);
        return ns(() => {
            _.value = !0
        }), hi(() => {
            t.teleport && (_.value = !1)
        }), () => {
            const x = mr(I("div", Ke({
                class: IS(),
                ref: i,
                onTouchstartPassive: y,
                onTouchend: g,
                onTouchcancel: g,
                onClickCapture: v,
                style: d.value
            }, r), [e.default ? e.default() : I(UW, {
                name: t.icon,
                class: IS("icon")
            }, null)]), [
                [yr, _.value]
            ]);
            return t.teleport ? I(dp, {
                to: t.teleport
            }, {
                default: () => [x]
            }) : x
        }
    }
});
const yxe = Ae(tq),
    [J2, nq] = Ee("grid"),
    rq = {
        square: Boolean,
        center: me,
        border: me,
        gutter: be,
        reverse: Boolean,
        iconSize: be,
        direction: String,
        clickable: Boolean,
        columnNum: Fe(4)
    },
    Z2 = Symbol(J2);
var iq = ve({
    name: J2,
    props: rq,
    setup(t, {
        slots: e
    }) {
        const {
            linkChildren: n
        } = Lr(Z2);
        return n({
            props: t
        }), () => {
            var r;
            return I("div", {
                style: {
                    paddingLeft: We(t.gutter)
                },
                class: [nq(), {
                    [l2]: t.border && !t.gutter
                }]
            }, [(r = e.default) == null ? void 0 : r.call(e)])
        }
    }
});
const vxe = Ae(iq),
    [sq, Yd] = Ee("grid-item"),
    oq = Le({}, Vl, {
        dot: Boolean,
        text: String,
        icon: String,
        badge: be,
        iconColor: String,
        iconPrefix: String,
        badgeProps: Object
    });
var aq = ve({
    name: sq,
    props: oq,
    setup(t, {
        slots: e
    }) {
        const {
            parent: n,
            index: r
        } = rr(Z2), i = ad();
        if (!n) {
            console.error("[Vant] <GridItem> must be a child component of <Grid>.");
            return
        }
        const s = te(() => {
                const {
                    square: u,
                    gutter: d,
                    columnNum: f
                } = n.props, h = `${100/+f}%`, p = {
                    flexBasis: h
                };
                if (u) p.paddingTop = h;
                else if (d) {
                    const b = We(d);
                    p.paddingRight = b, r.value >= +f && (p.marginTop = b)
                }
                return p
            }),
            o = te(() => {
                const {
                    square: u,
                    gutter: d
                } = n.props;
                if (u && d) {
                    const f = We(d);
                    return {
                        right: f,
                        bottom: f,
                        height: "auto"
                    }
                }
            }),
            a = () => {
                if (e.icon) return I(Mp, Ke({
                    dot: t.dot,
                    content: t.badge
                }, t.badgeProps), {
                    default: e.icon
                });
                if (t.icon) return I(Mt, {
                    dot: t.dot,
                    name: t.icon,
                    size: n.props.iconSize,
                    badge: t.badge,
                    class: Yd("icon"),
                    color: t.iconColor,
                    badgeProps: t.badgeProps,
                    classPrefix: t.iconPrefix
                }, null)
            },
            l = () => {
                if (e.text) return e.text();
                if (t.text) return I("span", {
                    class: Yd("text")
                }, [t.text])
            },
            c = () => e.default ? e.default() : [a(), l()];
        return () => {
            const {
                center: u,
                border: d,
                square: f,
                gutter: h,
                reverse: p,
                direction: b,
                clickable: y
            } = n.props, m = [Yd("content", [b, {
                center: u,
                square: f,
                reverse: p,
                clickable: y,
                surround: d && h
            }]), {
                [eo]: d
            }];
            return I("div", {
                class: [Yd({
                    square: f
                })],
                style: s.value
            }, [I("div", {
                role: y ? "button" : void 0,
                class: m,
                style: o.value,
                tabindex: y ? 0 : void 0,
                onClick: i
            }, [c()])])
        }
    }
});
const _xe = Ae(aq),
    MS = t => Math.sqrt((t[0].clientX - t[1].clientX) ** 2 + (t[0].clientY - t[1].clientY) ** 2),
    lq = t => ({
        x: (t[0].clientX + t[1].clientX) / 2,
        y: (t[0].clientY + t[1].clientY) / 2
    }),
    Wm = Ee("image-preview")[1],
    RS = 2.6,
    cq = {
        src: String,
        show: Boolean,
        active: Number,
        minZoom: xn(be),
        maxZoom: xn(be),
        rootWidth: xn(Number),
        rootHeight: xn(Number),
        disableZoom: Boolean,
        doubleScale: Boolean,
        closeOnClickImage: Boolean,
        closeOnClickOverlay: Boolean,
        vertical: Boolean
    };
var uq = ve({
    props: cq,
    emits: ["scale", "close", "longPress"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = ft({
                scale: 1,
                moveX: 0,
                moveY: 0,
                moving: !1,
                zooming: !1,
                initializing: !1,
                imageRatio: 0
            }),
            i = ba(),
            s = q(),
            o = q(),
            a = q(!1),
            l = q(!1);
        let c = 0;
        const u = te(() => {
                const {
                    scale: B,
                    moveX: N,
                    moveY: V,
                    moving: Y,
                    zooming: le,
                    initializing: ae
                } = r, W = {
                    transitionDuration: le || Y || ae ? "0s" : ".3s"
                };
                return (B !== 1 || l.value) && (W.transform = `matrix(${B}, 0, 0, ${B}, ${N}, ${V})`), W
            }),
            d = te(() => {
                if (r.imageRatio) {
                    const {
                        rootWidth: B,
                        rootHeight: N
                    } = t, V = a.value ? N / r.imageRatio : B;
                    return Math.max(0, (r.scale * V - B) / 2)
                }
                return 0
            }),
            f = te(() => {
                if (r.imageRatio) {
                    const {
                        rootWidth: B,
                        rootHeight: N
                    } = t, V = a.value ? N : B * r.imageRatio;
                    return Math.max(0, (r.scale * V - N) / 2)
                }
                return 0
            }),
            h = (B, N) => {
                var V;
                if (B = tn(B, +t.minZoom, +t.maxZoom + 1), B !== r.scale) {
                    const Y = B / r.scale;
                    if (r.scale = B, N) {
                        const le = jt((V = s.value) == null ? void 0 : V.$el),
                            ae = {
                                x: le.width * .5,
                                y: le.height * .5
                            },
                            W = r.moveX - (N.x - le.left - ae.x) * (Y - 1),
                            ne = r.moveY - (N.y - le.top - ae.y) * (Y - 1);
                        r.moveX = tn(W, -d.value, d.value), r.moveY = tn(ne, -f.value, f.value)
                    } else r.moveX = 0, r.moveY = l.value ? c : 0;
                    e("scale", {
                        scale: B,
                        index: t.active
                    })
                }
            },
            p = () => {
                h(1)
            },
            b = () => {
                const B = r.scale > 1 ? 1 : 2;
                h(B, B === 2 || l.value ? {
                    x: i.startX.value,
                    y: i.startY.value
                } : void 0)
            };
        let y, m, g, v, _, x, w, E, C = !1;
        const A = B => {
                const {
                    touches: N
                } = B;
                if (y = N.length, y === 2 && t.disableZoom) return;
                const {
                    offsetX: V
                } = i;
                i.start(B), m = r.moveX, g = r.moveY, E = Date.now(), C = !1, r.moving = y === 1 && (r.scale !== 1 || l.value), r.zooming = y === 2 && !V.value, r.zooming && (v = r.scale, _ = MS(N))
            },
            T = B => {
                const {
                    touches: N
                } = B;
                if (i.move(B), r.moving) {
                    const {
                        deltaX: V,
                        deltaY: Y
                    } = i, le = V.value + m, ae = Y.value + g;
                    if ((t.vertical ? i.isVertical() && Math.abs(ae) > f.value : i.isHorizontal() && Math.abs(le) > d.value) && !C) {
                        r.moving = !1;
                        return
                    }
                    C = !0, Zt(B, !0), r.moveX = tn(le, -d.value, d.value), r.moveY = tn(ae, -f.value, f.value)
                }
                if (r.zooming && (Zt(B, !0), N.length === 2)) {
                    const V = MS(N),
                        Y = v * V / _;
                    x = lq(N), h(Y, x)
                }
            },
            S = B => {
                var N;
                const V = (N = o.value) == null ? void 0 : N.$el;
                if (!V) return;
                const Y = V.firstElementChild,
                    le = B.target === V,
                    ae = Y == null ? void 0 : Y.contains(B.target);
                !t.closeOnClickImage && ae || !t.closeOnClickOverlay && le || e("close")
            },
            P = B => {
                if (y > 1) return;
                const N = Date.now() - E,
                    V = 250;
                i.isTap.value && (N < V ? t.doubleScale ? w ? (clearTimeout(w), w = null, b()) : w = setTimeout(() => {
                    S(B), w = null
                }, V) : S(B) : N > d2 && e("longPress"))
            },
            R = B => {
                let N = !1;
                if ((r.moving || r.zooming) && (N = !0, r.moving && m === r.moveX && g === r.moveY && (N = !1), !B.touches.length)) {
                    r.zooming && (r.moveX = tn(r.moveX, -d.value, d.value), r.moveY = tn(r.moveY, -f.value, f.value), r.zooming = !1), r.moving = !1, m = 0, g = 0, v = 1, r.scale < 1 && p();
                    const V = +t.maxZoom;
                    r.scale > V && h(V, x)
                }
                Zt(B, N), P(B), i.reset()
            },
            D = () => {
                const {
                    rootWidth: B,
                    rootHeight: N
                } = t, V = N / B, {
                    imageRatio: Y
                } = r;
                a.value = r.imageRatio > V && Y < RS, l.value = r.imageRatio > V && Y >= RS, l.value && (c = (Y * B - N) / 2, r.moveY = c, r.initializing = !0, Sn(() => {
                    r.initializing = !1
                })), p()
            },
            H = B => {
                const {
                    naturalWidth: N,
                    naturalHeight: V
                } = B.target;
                r.imageRatio = V / N, D()
            };
        return he(() => t.active, p), he(() => t.show, B => {
            B || p()
        }), he(() => [t.rootWidth, t.rootHeight], D), An("touchmove", T, {
            target: te(() => {
                var B;
                return (B = o.value) == null ? void 0 : B.$el
            })
        }), Tt({
            resetScale: p
        }), () => {
            const B = {
                loading: () => I(ss, {
                    type: "spinner"
                }, null)
            };
            return I(B2, {
                ref: o,
                class: Wm("swipe-item"),
                onTouchstartPassive: A,
                onTouchend: R,
                onTouchcancel: R
            }, {
                default: () => [n.image ? I("div", {
                    class: Wm("image-wrap")
                }, [n.image({
                    src: t.src,
                    onLoad: H,
                    style: u.value
                })]) : I(V2, {
                    ref: s,
                    src: t.src,
                    fit: "contain",
                    class: Wm("image", {
                        vertical: a.value
                    }),
                    style: u.value,
                    onLoad: H
                }, B)]
            })
        }
    }
});
const [dq, Ba] = Ee("image-preview"), fq = ["show", "teleport", "transition", "overlayStyle", "closeOnPopstate"], hq = {
    show: Boolean,
    loop: me,
    images: Xi(),
    minZoom: Fe(1 / 3),
    maxZoom: Fe(3),
    overlay: me,
    vertical: Boolean,
    closeable: Boolean,
    showIndex: me,
    className: Ut,
    closeIcon: Pe("clear"),
    transition: String,
    beforeClose: Function,
    doubleScale: me,
    overlayClass: Ut,
    overlayStyle: Object,
    swipeDuration: Fe(300),
    startPosition: Fe(0),
    showIndicators: Boolean,
    closeOnPopstate: me,
    closeOnClickImage: me,
    closeOnClickOverlay: me,
    closeIconPosition: Pe("top-right"),
    teleport: [String, Object]
};
var Q2 = ve({
    name: dq,
    props: hq,
    emits: ["scale", "close", "closed", "change", "longPress", "update:show"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = q(),
            i = q(),
            s = ft({
                active: 0,
                rootWidth: 0,
                rootHeight: 0,
                disableZoom: !1
            }),
            o = () => {
                if (r.value) {
                    const v = jt(r.value.$el);
                    s.rootWidth = v.width, s.rootHeight = v.height, r.value.resize()
                }
            },
            a = v => e("scale", v),
            l = v => e("update:show", v),
            c = () => {
                jl(t.beforeClose, {
                    args: [s.active],
                    done: () => l(!1)
                })
            },
            u = v => {
                v !== s.active && (s.active = v, e("change", v))
            },
            d = () => {
                if (t.showIndex) return I("div", {
                    class: Ba("index")
                }, [n.index ? n.index({
                    index: s.active
                }) : `${s.active+1} / ${t.images.length}`])
            },
            f = () => {
                if (n.cover) return I("div", {
                    class: Ba("cover")
                }, [n.cover()])
            },
            h = () => {
                s.disableZoom = !0
            },
            p = () => {
                s.disableZoom = !1
            },
            b = () => I(O2, {
                ref: r,
                lazyRender: !0,
                loop: t.loop,
                class: Ba("swipe"),
                vertical: t.vertical,
                duration: t.swipeDuration,
                initialSwipe: t.startPosition,
                showIndicators: t.showIndicators,
                indicatorColor: "white",
                onChange: u,
                onDragEnd: p,
                onDragStart: h
            }, {
                default: () => [t.images.map((v, _) => I(uq, {
                    ref: x => {
                        _ === s.active && (i.value = x)
                    },
                    src: v,
                    show: t.show,
                    active: s.active,
                    maxZoom: t.maxZoom,
                    minZoom: t.minZoom,
                    rootWidth: s.rootWidth,
                    rootHeight: s.rootHeight,
                    disableZoom: s.disableZoom,
                    doubleScale: t.doubleScale,
                    closeOnClickImage: t.closeOnClickImage,
                    closeOnClickOverlay: t.closeOnClickOverlay,
                    vertical: t.vertical,
                    onScale: a,
                    onClose: c,
                    onLongPress: () => e("longPress", {
                        index: _
                    })
                }, {
                    image: n.image
                }))]
            }),
            y = () => {
                if (t.closeable) return I(Mt, {
                    role: "button",
                    name: t.closeIcon,
                    class: [Ba("close-icon", t.closeIconPosition), qi],
                    onClick: c
                }, null)
            },
            m = () => e("closed"),
            g = (v, _) => {
                var x;
                return (x = r.value) == null ? void 0 : x.swipeTo(v, _)
            };
        return Tt({
            resetScale: () => {
                var v;
                (v = i.value) == null || v.resetScale()
            },
            swipeTo: g
        }), _t(o), he([Li, Fs], o), he(() => t.startPosition, v => u(+v)), he(() => t.show, v => {
            const {
                images: _,
                startPosition: x
            } = t;
            v ? (u(+x), Ue(() => {
                o(), g(+x, {
                    immediate: !0
                })
            })) : e("close", {
                index: s.active,
                url: _[s.active]
            })
        }), () => I(xa, Ke({
            class: [Ba(), t.className],
            overlayClass: [Ba("overlay"), t.overlayClass],
            onClosed: m,
            "onUpdate:show": l
        }, yt(t, fq)), {
            default: () => [y(), b(), d(), f()]
        })
    }
});
let Uf;
const pq = {
    loop: !0,
    images: [],
    maxZoom: 3,
    minZoom: 1 / 3,
    onScale: void 0,
    onClose: void 0,
    onChange: void 0,
    vertical: !1,
    teleport: "body",
    className: "",
    showIndex: !0,
    closeable: !1,
    closeIcon: "clear",
    transition: void 0,
    beforeClose: void 0,
    doubleScale: !0,
    overlayStyle: void 0,
    overlayClass: void 0,
    startPosition: 0,
    swipeDuration: 300,
    showIndicators: !1,
    closeOnPopstate: !0,
    closeOnClickOverlay: !0,
    closeIconPosition: "top-right"
};

function mq() {
    ({
        instance: Uf
    } = Dp({
        setup() {
            const {
                state: t,
                toggle: e
            } = Bp(), n = () => {
                t.images = []
            };
            return () => I(Q2, Ke(t, {
                onClosed: n,
                "onUpdate:show": e
            }), null)
        }
    }))
}
const gq = (t, e = 0) => {
    if (ui) return Uf || mq(), t = Array.isArray(t) ? {
        images: t,
        startPosition: e
    } : t, Uf.open(Le({}, pq, t)), Uf
};
Ae(Q2);
const [yq, Da, vq] = Ee("list"), _q = {
    error: Boolean,
    offset: Fe(300),
    loading: Boolean,
    disabled: Boolean,
    finished: Boolean,
    scroller: Object,
    errorText: String,
    direction: Pe("down"),
    loadingText: String,
    finishedText: String,
    immediateCheck: me
};
var bq = ve({
    name: yq,
    props: _q,
    emits: ["load", "update:error", "update:loading"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = q(t.loading),
            i = q(),
            s = q(),
            o = k2(),
            a = sd(i),
            l = te(() => t.scroller || a.value),
            c = () => {
                Ue(() => {
                    if (r.value || t.finished || t.disabled || t.error || (o == null ? void 0 : o.value) === !1) return;
                    const {
                        direction: p
                    } = t, b = +t.offset, y = jt(l);
                    if (!y.height || yl(i)) return;
                    let m = !1;
                    const g = jt(s);
                    p === "up" ? m = y.top - g.top <= b : m = g.bottom - y.bottom <= b, m && (r.value = !0, e("update:loading", !0), e("load"))
                })
            },
            u = () => {
                if (t.finished) {
                    const p = n.finished ? n.finished() : t.finishedText;
                    if (p) return I("div", {
                        class: Da("finished-text")
                    }, [p])
                }
            },
            d = () => {
                e("update:error", !1), c()
            },
            f = () => {
                if (t.error) {
                    const p = n.error ? n.error() : t.errorText;
                    if (p) return I("div", {
                        role: "button",
                        class: Da("error-text"),
                        tabindex: 0,
                        onClick: d
                    }, [p])
                }
            },
            h = () => {
                if (r.value && !t.finished && !t.disabled) return I("div", {
                    class: Da("loading")
                }, [n.loading ? n.loading() : I(ss, {
                    class: Da("loading-icon")
                }, {
                    default: () => [t.loadingText || vq("loading")]
                })])
            };
        return he(() => [t.loading, t.finished, t.error], c), o && he(o, p => {
            p && c()
        }), ga(() => {
            r.value = t.loading
        }), _t(() => {
            t.immediateCheck && c()
        }), Tt({
            check: c
        }), An("scroll", c, {
            target: l,
            passive: !0
        }), () => {
            var p;
            const b = (p = n.default) == null ? void 0 : p.call(n),
                y = I("div", {
                    ref: s,
                    class: Da("placeholder")
                }, null);
            return I("div", {
                ref: i,
                role: "feed",
                class: Da(),
                "aria-busy": r.value
            }, [t.direction === "down" ? b : y, h(), u(), f(), t.direction === "up" ? b : y])
        }
    }
});
const bxe = Ae(bq),
    [xq, wq] = Ee("notify"),
    Eq = ["lockScroll", "position", "show", "teleport", "zIndex"],
    Sq = Le({}, ld, {
        type: Pe("danger"),
        color: String,
        message: be,
        position: Pe("top"),
        className: Ut,
        background: String,
        lockScroll: Boolean
    });
var eR = ve({
    name: xq,
    props: Sq,
    emits: ["update:show"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = i => e("update:show", i);
        return () => I(xa, Ke({
            class: [wq([t.type]), t.className],
            style: {
                color: t.color,
                background: t.background
            },
            overlay: !1,
            duration: .2,
            "onUpdate:show": r
        }, yt(t, Eq)), {
            default: () => [n.default ? n.default() : t.message]
        })
    }
});
let kS, sl;
const Tq = t => di(t) ? t : {
    message: t
};

function Cq() {
    ({
        instance: sl
    } = Dp({
        setup() {
            const {
                state: t,
                toggle: e
            } = Bp();
            return () => I(eR, Ke(t, {
                "onUpdate:show": e
            }), null)
        }
    }))
}
const Pq = () => ({
    type: "danger",
    color: void 0,
    message: "",
    onClose: void 0,
    onClick: void 0,
    onOpened: void 0,
    duration: 3e3,
    position: void 0,
    className: "",
    lockScroll: !1,
    background: void 0
});
let Aq = Pq();
const Oq = () => {
    sl && sl.toggle(!1)
};

function xxe(t) {
    if (ui) return sl || Cq(), t = Le({}, Aq, Tq(t)), sl.open(t), clearTimeout(kS), t.duration > 0 && (kS = setTimeout(Oq, t.duration)), sl
}
Ae(eR);
const [Iq, $a, BS] = Ee("pagination"), Ym = (t, e, n) => ({
    number: t,
    text: e,
    active: n
}), Mq = {
    mode: Pe("multi"),
    prevText: String,
    nextText: String,
    pageCount: Fe(0),
    modelValue: Ip(0),
    totalItems: Fe(0),
    showPageSize: Fe(5),
    itemsPerPage: Fe(10),
    forceEllipses: Boolean,
    showPrevButton: me,
    showNextButton: me
};
var Rq = ve({
    name: Iq,
    props: Mq,
    emits: ["change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = te(() => {
                const {
                    pageCount: u,
                    totalItems: d,
                    itemsPerPage: f
                } = t, h = +u || Math.ceil(+d / +f);
                return Math.max(1, h)
            }),
            i = te(() => {
                const u = [],
                    d = r.value,
                    f = +t.showPageSize,
                    {
                        modelValue: h,
                        forceEllipses: p
                    } = t;
                let b = 1,
                    y = d;
                const m = f < d;
                m && (b = Math.max(h - Math.floor(f / 2), 1), y = b + f - 1, y > d && (y = d, b = y - f + 1));
                for (let g = b; g <= y; g++) {
                    const v = Ym(g, g, g === h);
                    u.push(v)
                }
                if (m && f > 0 && p) {
                    if (b > 1) {
                        const g = Ym(b - 1, "...");
                        u.unshift(g)
                    }
                    if (y < d) {
                        const g = Ym(y + 1, "...");
                        u.push(g)
                    }
                }
                return u
            }),
            s = (u, d) => {
                u = tn(u, 1, r.value), t.modelValue !== u && (e("update:modelValue", u), d && e("change", u))
            };
        Ul(() => s(t.modelValue));
        const o = () => I("li", {
                class: $a("page-desc")
            }, [n.pageDesc ? n.pageDesc() : `${t.modelValue}/${r.value}`]),
            a = () => {
                const {
                    mode: u,
                    modelValue: d,
                    showPrevButton: f
                } = t;
                if (!f) return;
                const h = n["prev-text"],
                    p = d === 1;
                return I("li", {
                    class: [$a("item", {
                        disabled: p,
                        border: u === "simple",
                        prev: !0
                    }), Lf]
                }, [I("button", {
                    type: "button",
                    disabled: p,
                    onClick: () => s(d - 1, !0)
                }, [h ? h() : t.prevText || BS("prev")])])
            },
            l = () => {
                const {
                    mode: u,
                    modelValue: d,
                    showNextButton: f
                } = t;
                if (!f) return;
                const h = n["next-text"],
                    p = d === r.value;
                return I("li", {
                    class: [$a("item", {
                        disabled: p,
                        border: u === "simple",
                        next: !0
                    }), Lf]
                }, [I("button", {
                    type: "button",
                    disabled: p,
                    onClick: () => s(d + 1, !0)
                }, [h ? h() : t.nextText || BS("next")])])
            },
            c = () => i.value.map(u => I("li", {
                class: [$a("item", {
                    active: u.active,
                    page: !0
                }), Lf]
            }, [I("button", {
                type: "button",
                "aria-current": u.active || void 0,
                onClick: () => s(u.number, !0)
            }, [n.page ? n.page(u) : u.text])]));
        return () => I("nav", {
            role: "navigation",
            class: $a()
        }, [I("ul", {
            class: $a("items")
        }, [a(), t.mode === "simple" ? o() : c(), l()])])
    }
});
const wxe = Ae(Rq);

function Nr(t) {
    if (t == null) return window;
    if (t.toString() !== "[object Window]") {
        var e = t.ownerDocument;
        return e && e.defaultView || window
    }
    return t
}

function Hb(t) {
    var e = Nr(t).Element;
    return t instanceof e || t instanceof Element
}

function kr(t) {
    var e = Nr(t).HTMLElement;
    return t instanceof e || t instanceof HTMLElement
}

function tR(t) {
    if (typeof ShadowRoot > "u") return !1;
    var e = Nr(t).ShadowRoot;
    return t instanceof e || t instanceof ShadowRoot
}
var _l = Math.round;

function Lv() {
    var t = navigator.userAgentData;
    return t != null && t.brands ? t.brands.map(function(e) {
        return e.brand + "/" + e.version
    }).join(" ") : navigator.userAgent
}

function kq() {
    return !/^((?!chrome|android).)*safari/i.test(Lv())
}

function bh(t, e, n) {
    e === void 0 && (e = !1), n === void 0 && (n = !1);
    var r = t.getBoundingClientRect(),
        i = 1,
        s = 1;
    e && kr(t) && (i = t.offsetWidth > 0 && _l(r.width) / t.offsetWidth || 1, s = t.offsetHeight > 0 && _l(r.height) / t.offsetHeight || 1);
    var o = Hb(t) ? Nr(t) : window,
        a = o.visualViewport,
        l = !kq() && n,
        c = (r.left + (l && a ? a.offsetLeft : 0)) / i,
        u = (r.top + (l && a ? a.offsetTop : 0)) / s,
        d = r.width / i,
        f = r.height / s;
    return {
        width: d,
        height: f,
        top: u,
        right: c + d,
        bottom: u + f,
        left: c,
        x: c,
        y: u
    }
}

function nR(t) {
    var e = Nr(t),
        n = e.pageXOffset,
        r = e.pageYOffset;
    return {
        scrollLeft: n,
        scrollTop: r
    }
}

function Bq(t) {
    return {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    }
}

function Dq(t) {
    return t === Nr(t) || !kr(t) ? nR(t) : Bq(t)
}

function Ki(t) {
    return t ? (t.nodeName || "").toLowerCase() : null
}

function $p(t) {
    return ((Hb(t) ? t.ownerDocument : t.document) || window.document).documentElement
}

function $q(t) {
    return bh($p(t)).left + nR(t).scrollLeft
}

function Ji(t) {
    return Nr(t).getComputedStyle(t)
}

function zb(t) {
    var e = Ji(t),
        n = e.overflow,
        r = e.overflowX,
        i = e.overflowY;
    return /auto|scroll|overlay|hidden/.test(n + i + r)
}

function Fq(t) {
    var e = t.getBoundingClientRect(),
        n = _l(e.width) / t.offsetWidth || 1,
        r = _l(e.height) / t.offsetHeight || 1;
    return n !== 1 || r !== 1
}

function Lq(t, e, n) {
    n === void 0 && (n = !1);
    var r = kr(e),
        i = kr(e) && Fq(e),
        s = $p(e),
        o = bh(t, i, n),
        a = {
            scrollLeft: 0,
            scrollTop: 0
        },
        l = {
            x: 0,
            y: 0
        };
    return (r || !r && !n) && ((Ki(e) !== "body" || zb(s)) && (a = Dq(e)), kr(e) ? (l = bh(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : s && (l.x = $q(s))), {
        x: o.left + a.scrollLeft - l.x,
        y: o.top + a.scrollTop - l.y,
        width: o.width,
        height: o.height
    }
}

function Nq(t) {
    var e = bh(t),
        n = t.offsetWidth,
        r = t.offsetHeight;
    return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), {
        x: t.offsetLeft,
        y: t.offsetTop,
        width: n,
        height: r
    }
}

function jb(t) {
    return Ki(t) === "html" ? t : t.assignedSlot || t.parentNode || (tR(t) ? t.host : null) || $p(t)
}

function rR(t) {
    return ["html", "body", "#document"].indexOf(Ki(t)) >= 0 ? t.ownerDocument.body : kr(t) && zb(t) ? t : rR(jb(t))
}

function Gf(t, e) {
    var n;
    e === void 0 && (e = []);
    var r = rR(t),
        i = r === ((n = t.ownerDocument) == null ? void 0 : n.body),
        s = Nr(r),
        o = i ? [s].concat(s.visualViewport || [], zb(r) ? r : []) : r,
        a = e.concat(o);
    return i ? a : a.concat(Gf(jb(o)))
}

function Uq(t) {
    return ["table", "td", "th"].indexOf(Ki(t)) >= 0
}

function DS(t) {
    return !kr(t) || Ji(t).position === "fixed" ? null : t.offsetParent
}

function Gq(t) {
    var e = /firefox/i.test(Lv()),
        n = /Trident/i.test(Lv());
    if (n && kr(t)) {
        var r = Ji(t);
        if (r.position === "fixed") return null
    }
    var i = jb(t);
    for (tR(i) && (i = i.host); kr(i) && ["html", "body"].indexOf(Ki(i)) < 0;) {
        var s = Ji(i);
        if (s.transform !== "none" || s.perspective !== "none" || s.contain === "paint" || ["transform", "perspective"].indexOf(s.willChange) !== -1 || e && s.willChange === "filter" || e && s.filter && s.filter !== "none") return i;
        i = i.parentNode
    }
    return null
}

function iR(t) {
    for (var e = Nr(t), n = DS(t); n && Uq(n) && Ji(n).position === "static";) n = DS(n);
    return n && (Ki(n) === "html" || Ki(n) === "body" && Ji(n).position === "static") ? e : n || Gq(t) || e
}
var ol = "top",
    xh = "bottom",
    _u = "right",
    jo = "left",
    sR = "auto",
    Hq = [ol, xh, _u, jo],
    oR = "start",
    wh = "end",
    zq = [].concat(Hq, [sR]).reduce(function(t, e) {
        return t.concat([e, e + "-" + oR, e + "-" + wh])
    }, []),
    jq = "beforeRead",
    Vq = "read",
    Wq = "afterRead",
    Yq = "beforeMain",
    Xq = "main",
    qq = "afterMain",
    Kq = "beforeWrite",
    Jq = "write",
    Zq = "afterWrite",
    Nv = [jq, Vq, Wq, Yq, Xq, qq, Kq, Jq, Zq];

function Qq(t) {
    var e = new Map,
        n = new Set,
        r = [];
    t.forEach(function(s) {
        e.set(s.name, s)
    });

    function i(s) {
        n.add(s.name);
        var o = [].concat(s.requires || [], s.requiresIfExists || []);
        o.forEach(function(a) {
            if (!n.has(a)) {
                var l = e.get(a);
                l && i(l)
            }
        }), r.push(s)
    }
    return t.forEach(function(s) {
        n.has(s.name) || i(s)
    }), r
}

function eK(t) {
    var e = Qq(t);
    return Nv.reduce(function(n, r) {
        return n.concat(e.filter(function(i) {
            return i.phase === r
        }))
    }, [])
}

function tK(t) {
    var e;
    return function() {
        return e || (e = new Promise(function(n) {
            Promise.resolve().then(function() {
                e = void 0, n(t())
            })
        })), e
    }
}

function fs(t) {
    for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++) n[r - 1] = arguments[r];
    return [].concat(n).reduce(function(i, s) {
        return i.replace(/%s/, s)
    }, t)
}
var fo = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s',
    nK = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available',
    $S = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];

function rK(t) {
    t.forEach(function(e) {
        [].concat(Object.keys(e), $S).filter(function(n, r, i) {
            return i.indexOf(n) === r
        }).forEach(function(n) {
            switch (n) {
                case "name":
                    typeof e.name != "string" && console.error(fs(fo, String(e.name), '"name"', '"string"', '"' + String(e.name) + '"'));
                    break;
                case "enabled":
                    typeof e.enabled != "boolean" && console.error(fs(fo, e.name, '"enabled"', '"boolean"', '"' + String(e.enabled) + '"'));
                    break;
                case "phase":
                    Nv.indexOf(e.phase) < 0 && console.error(fs(fo, e.name, '"phase"', "either " + Nv.join(", "), '"' + String(e.phase) + '"'));
                    break;
                case "fn":
                    typeof e.fn != "function" && console.error(fs(fo, e.name, '"fn"', '"function"', '"' + String(e.fn) + '"'));
                    break;
                case "effect":
                    e.effect != null && typeof e.effect != "function" && console.error(fs(fo, e.name, '"effect"', '"function"', '"' + String(e.fn) + '"'));
                    break;
                case "requires":
                    e.requires != null && !Array.isArray(e.requires) && console.error(fs(fo, e.name, '"requires"', '"array"', '"' + String(e.requires) + '"'));
                    break;
                case "requiresIfExists":
                    Array.isArray(e.requiresIfExists) || console.error(fs(fo, e.name, '"requiresIfExists"', '"array"', '"' + String(e.requiresIfExists) + '"'));
                    break;
                case "options":
                case "data":
                    break;
                default:
                    console.error('PopperJS: an invalid property has been provided to the "' + e.name + '" modifier, valid properties are ' + $S.map(function(r) {
                        return '"' + r + '"'
                    }).join(", ") + '; but "' + n + '" was provided.')
            }
            e.requires && e.requires.forEach(function(r) {
                t.find(function(i) {
                    return i.name === r
                }) == null && console.error(fs(nK, String(e.name), r, r))
            })
        })
    })
}

function iK(t, e) {
    var n = new Set;
    return t.filter(function(r) {
        var i = e(r);
        if (!n.has(i)) return n.add(i), !0
    })
}

function Fp(t) {
    return t.split("-")[0]
}

function sK(t) {
    var e = t.reduce(function(n, r) {
        var i = n[r.name];
        return n[r.name] = i ? Object.assign({}, i, r, {
            options: Object.assign({}, i.options, r.options),
            data: Object.assign({}, i.data, r.data)
        }) : r, n
    }, {});
    return Object.keys(e).map(function(n) {
        return e[n]
    })
}

function aR(t) {
    return t.split("-")[1]
}

function oK(t) {
    return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y"
}

function aK(t) {
    var e = t.reference,
        n = t.element,
        r = t.placement,
        i = r ? Fp(r) : null,
        s = r ? aR(r) : null,
        o = e.x + e.width / 2 - n.width / 2,
        a = e.y + e.height / 2 - n.height / 2,
        l;
    switch (i) {
        case ol:
            l = {
                x: o,
                y: e.y - n.height
            };
            break;
        case xh:
            l = {
                x: o,
                y: e.y + e.height
            };
            break;
        case _u:
            l = {
                x: e.x + e.width,
                y: a
            };
            break;
        case jo:
            l = {
                x: e.x - n.width,
                y: a
            };
            break;
        default:
            l = {
                x: e.x,
                y: e.y
            }
    }
    var c = i ? oK(i) : null;
    if (c != null) {
        var u = c === "y" ? "height" : "width";
        switch (s) {
            case oR:
                l[c] = l[c] - (e[u] / 2 - n[u] / 2);
                break;
            case wh:
                l[c] = l[c] + (e[u] / 2 - n[u] / 2);
                break
        }
    }
    return l
}
var FS = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.",
    lK = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.",
    LS = {
        placement: "bottom",
        modifiers: [],
        strategy: "absolute"
    };

function NS() {
    for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
    return !e.some(function(r) {
        return !(r && typeof r.getBoundingClientRect == "function")
    })
}

function cK(t) {
    t === void 0 && (t = {});
    var e = t,
        n = e.defaultModifiers,
        r = n === void 0 ? [] : n,
        i = e.defaultOptions,
        s = i === void 0 ? LS : i;
    return function(a, l, c) {
        c === void 0 && (c = s);
        var u = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, LS, s),
                modifiersData: {},
                elements: {
                    reference: a,
                    popper: l
                },
                attributes: {},
                styles: {}
            },
            d = [],
            f = !1,
            h = {
                state: u,
                setOptions: function(m) {
                    var g = typeof m == "function" ? m(u.options) : m;
                    b(), u.options = Object.assign({}, s, u.options, g), u.scrollParents = {
                        reference: Hb(a) ? Gf(a) : a.contextElement ? Gf(a.contextElement) : [],
                        popper: Gf(l)
                    };
                    var v = eK(sK([].concat(r, u.options.modifiers)));
                    u.orderedModifiers = v.filter(function(S) {
                        return S.enabled
                    }); {
                        var _ = iK([].concat(v, u.options.modifiers), function(S) {
                            var P = S.name;
                            return P
                        });
                        if (rK(_), Fp(u.options.placement) === sR) {
                            var x = u.orderedModifiers.find(function(S) {
                                var P = S.name;
                                return P === "flip"
                            });
                            x || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "))
                        }
                        var w = Ji(l),
                            E = w.marginTop,
                            C = w.marginRight,
                            A = w.marginBottom,
                            T = w.marginLeft;
                        [E, C, A, T].some(function(S) {
                            return parseFloat(S)
                        }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "))
                    }
                    return p(), h.update()
                },
                forceUpdate: function() {
                    if (!f) {
                        var m = u.elements,
                            g = m.reference,
                            v = m.popper;
                        if (!NS(g, v)) {
                            console.error(FS);
                            return
                        }
                        u.rects = {
                            reference: Lq(g, iR(v), u.options.strategy === "fixed"),
                            popper: Nq(v)
                        }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(S) {
                            return u.modifiersData[S.name] = Object.assign({}, S.data)
                        });
                        for (var _ = 0, x = 0; x < u.orderedModifiers.length; x++) {
                            if (_ += 1, _ > 100) {
                                console.error(lK);
                                break
                            }
                            if (u.reset === !0) {
                                u.reset = !1, x = -1;
                                continue
                            }
                            var w = u.orderedModifiers[x],
                                E = w.fn,
                                C = w.options,
                                A = C === void 0 ? {} : C,
                                T = w.name;
                            typeof E == "function" && (u = E({
                                state: u,
                                options: A,
                                name: T,
                                instance: h
                            }) || u)
                        }
                    }
                },
                update: tK(function() {
                    return new Promise(function(y) {
                        h.forceUpdate(), y(u)
                    })
                }),
                destroy: function() {
                    b(), f = !0
                }
            };
        if (!NS(a, l)) return console.error(FS), h;
        h.setOptions(c).then(function(y) {
            !f && c.onFirstUpdate && c.onFirstUpdate(y)
        });

        function p() {
            u.orderedModifiers.forEach(function(y) {
                var m = y.name,
                    g = y.options,
                    v = g === void 0 ? {} : g,
                    _ = y.effect;
                if (typeof _ == "function") {
                    var x = _({
                            state: u,
                            name: m,
                            instance: h,
                            options: v
                        }),
                        w = function() {};
                    d.push(x || w)
                }
            })
        }

        function b() {
            d.forEach(function(y) {
                return y()
            }), d = []
        }
        return h
    }
}
var Xd = {
    passive: !0
};

function uK(t) {
    var e = t.state,
        n = t.instance,
        r = t.options,
        i = r.scroll,
        s = i === void 0 ? !0 : i,
        o = r.resize,
        a = o === void 0 ? !0 : o,
        l = Nr(e.elements.popper),
        c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
    return s && c.forEach(function(u) {
            u.addEventListener("scroll", n.update, Xd)
        }), a && l.addEventListener("resize", n.update, Xd),
        function() {
            s && c.forEach(function(u) {
                u.removeEventListener("scroll", n.update, Xd)
            }), a && l.removeEventListener("resize", n.update, Xd)
        }
}
var dK = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function() {},
    effect: uK,
    data: {}
};

function fK(t) {
    var e = t.state,
        n = t.name;
    e.modifiersData[n] = aK({
        reference: e.rects.reference,
        element: e.rects.popper,
        strategy: "absolute",
        placement: e.placement
    })
}
var hK = {
        name: "popperOffsets",
        enabled: !0,
        phase: "read",
        fn: fK,
        data: {}
    },
    pK = {
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto"
    };

function mK(t) {
    var e = t.x,
        n = t.y,
        r = window,
        i = r.devicePixelRatio || 1;
    return {
        x: _l(e * i) / i || 0,
        y: _l(n * i) / i || 0
    }
}

function US(t) {
    var e, n = t.popper,
        r = t.popperRect,
        i = t.placement,
        s = t.variation,
        o = t.offsets,
        a = t.position,
        l = t.gpuAcceleration,
        c = t.adaptive,
        u = t.roundOffsets,
        d = t.isFixed,
        f = o.x,
        h = f === void 0 ? 0 : f,
        p = o.y,
        b = p === void 0 ? 0 : p,
        y = typeof u == "function" ? u({
            x: h,
            y: b
        }) : {
            x: h,
            y: b
        };
    h = y.x, b = y.y;
    var m = o.hasOwnProperty("x"),
        g = o.hasOwnProperty("y"),
        v = jo,
        _ = ol,
        x = window;
    if (c) {
        var w = iR(n),
            E = "clientHeight",
            C = "clientWidth";
        if (w === Nr(n) && (w = $p(n), Ji(w).position !== "static" && a === "absolute" && (E = "scrollHeight", C = "scrollWidth")), w = w, i === ol || (i === jo || i === _u) && s === wh) {
            _ = xh;
            var A = d && w === x && x.visualViewport ? x.visualViewport.height : w[E];
            b -= A - r.height, b *= l ? 1 : -1
        }
        if (i === jo || (i === ol || i === xh) && s === wh) {
            v = _u;
            var T = d && w === x && x.visualViewport ? x.visualViewport.width : w[C];
            h -= T - r.width, h *= l ? 1 : -1
        }
    }
    var S = Object.assign({
            position: a
        }, c && pK),
        P = u === !0 ? mK({
            x: h,
            y: b
        }) : {
            x: h,
            y: b
        };
    if (h = P.x, b = P.y, l) {
        var R;
        return Object.assign({}, S, (R = {}, R[_] = g ? "0" : "", R[v] = m ? "0" : "", R.transform = (x.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + b + "px)" : "translate3d(" + h + "px, " + b + "px, 0)", R))
    }
    return Object.assign({}, S, (e = {}, e[_] = g ? b + "px" : "", e[v] = m ? h + "px" : "", e.transform = "", e))
}

function gK(t) {
    var e = t.state,
        n = t.options,
        r = n.gpuAcceleration,
        i = r === void 0 ? !0 : r,
        s = n.adaptive,
        o = s === void 0 ? !0 : s,
        a = n.roundOffsets,
        l = a === void 0 ? !0 : a; {
        var c = Ji(e.elements.popper).transitionProperty || "";
        o && ["transform", "top", "right", "bottom", "left"].some(function(d) {
            return c.indexOf(d) >= 0
        }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "))
    }
    var u = {
        placement: Fp(e.placement),
        variation: aR(e.placement),
        popper: e.elements.popper,
        popperRect: e.rects.popper,
        gpuAcceleration: i,
        isFixed: e.options.strategy === "fixed"
    };
    e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, US(Object.assign({}, u, {
        offsets: e.modifiersData.popperOffsets,
        position: e.options.strategy,
        adaptive: o,
        roundOffsets: l
    })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, US(Object.assign({}, u, {
        offsets: e.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: l
    })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
        "data-popper-placement": e.placement
    })
}
var yK = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: gK,
    data: {}
};

function vK(t) {
    var e = t.state;
    Object.keys(e.elements).forEach(function(n) {
        var r = e.styles[n] || {},
            i = e.attributes[n] || {},
            s = e.elements[n];
        !kr(s) || !Ki(s) || (Object.assign(s.style, r), Object.keys(i).forEach(function(o) {
            var a = i[o];
            a === !1 ? s.removeAttribute(o) : s.setAttribute(o, a === !0 ? "" : a)
        }))
    })
}

function _K(t) {
    var e = t.state,
        n = {
            popper: {
                position: e.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
            },
            arrow: {
                position: "absolute"
            },
            reference: {}
        };
    return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow),
        function() {
            Object.keys(e.elements).forEach(function(r) {
                var i = e.elements[r],
                    s = e.attributes[r] || {},
                    o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]),
                    a = o.reduce(function(l, c) {
                        return l[c] = "", l
                    }, {});
                !kr(i) || !Ki(i) || (Object.assign(i.style, a), Object.keys(s).forEach(function(l) {
                    i.removeAttribute(l)
                }))
            })
        }
}
var bK = {
        name: "applyStyles",
        enabled: !0,
        phase: "write",
        fn: vK,
        effect: _K,
        requires: ["computeStyles"]
    },
    xK = [dK, hK, yK, bK],
    wK = cK({
        defaultModifiers: xK
    });

function EK(t, e, n) {
    var r = Fp(t),
        i = [jo, ol].indexOf(r) >= 0 ? -1 : 1,
        s = typeof n == "function" ? n(Object.assign({}, e, {
            placement: t
        })) : n,
        o = s[0],
        a = s[1];
    return o = o || 0, a = (a || 0) * i, [jo, _u].indexOf(r) >= 0 ? {
        x: a,
        y: o
    } : {
        x: o,
        y: a
    }
}

function SK(t) {
    var e = t.state,
        n = t.options,
        r = t.name,
        i = n.offset,
        s = i === void 0 ? [0, 0] : i,
        o = zq.reduce(function(u, d) {
            return u[d] = EK(d, e.rects, s), u
        }, {}),
        a = o[e.placement],
        l = a.x,
        c = a.y;
    e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = o
}
var TK = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: SK
};
const [CK, ho] = Ee("popover"), PK = ["overlay", "duration", "teleport", "overlayStyle", "overlayClass", "closeOnClickOverlay"], AK = {
    show: Boolean,
    theme: Pe("light"),
    overlay: Boolean,
    actions: Xi(),
    actionsDirection: Pe("vertical"),
    trigger: Pe("click"),
    duration: be,
    showArrow: me,
    placement: Pe("bottom"),
    iconPrefix: String,
    overlayClass: Ut,
    overlayStyle: Object,
    closeOnClickAction: me,
    closeOnClickOverlay: me,
    closeOnClickOutside: me,
    offset: {
        type: Array,
        default: () => [0, 8]
    },
    teleport: {
        type: [String, Object],
        default: "body"
    }
};
var OK = ve({
    name: CK,
    props: AK,
    emits: ["select", "touchstart", "update:show"],
    setup(t, {
        emit: e,
        slots: n,
        attrs: r
    }) {
        let i;
        const s = q(),
            o = q(),
            a = q(),
            l = S7(() => t.show, g => e("update:show", g)),
            c = () => ({
                placement: t.placement,
                modifiers: [{
                    name: "computeStyles",
                    options: {
                        adaptive: !1,
                        gpuAcceleration: !1
                    }
                }, Le({}, TK, {
                    options: {
                        offset: t.offset
                    }
                })]
            }),
            u = () => o.value && a.value ? wK(o.value, a.value.popupRef.value, c()) : null,
            d = () => {
                Ue(() => {
                    l.value && (i ? i.setOptions(c()) : (i = u(), ui && (window.addEventListener("animationend", d), window.addEventListener("transitionend", d))))
                })
            },
            f = g => {
                l.value = g
            },
            h = () => {
                t.trigger === "click" && (l.value = !l.value)
            },
            p = (g, v) => {
                g.disabled || (e("select", g, v), t.closeOnClickAction && (l.value = !1))
            },
            b = () => {
                l.value && t.closeOnClickOutside && (!t.overlay || t.closeOnClickOverlay) && (l.value = !1)
            },
            y = (g, v) => n.action ? n.action({
                action: g,
                index: v
            }) : [g.icon && I(Mt, {
                name: g.icon,
                classPrefix: t.iconPrefix,
                class: ho("action-icon")
            }, null), I("div", {
                class: [ho("action-text"), {
                    [EW]: t.actionsDirection === "vertical"
                }]
            }, [g.text])],
            m = (g, v) => {
                const {
                    icon: _,
                    color: x,
                    disabled: w,
                    className: E
                } = g;
                return I("div", {
                    role: "menuitem",
                    class: [ho("action", {
                        disabled: w,
                        "with-icon": _
                    }), {
                        [wW]: t.actionsDirection === "horizontal"
                    }, E],
                    style: {
                        color: x
                    },
                    tabindex: w ? void 0 : 0,
                    "aria-disabled": w || void 0,
                    onClick: () => p(g, v)
                }, [y(g, v)])
            };
        return _t(() => {
            d(), Ul(() => {
                var g;
                s.value = (g = a.value) == null ? void 0 : g.popupRef.value
            })
        }), nr(() => {
            i && (ui && (window.removeEventListener("animationend", d), window.removeEventListener("transitionend", d)), i.destroy(), i = null)
        }), he(() => [l.value, t.offset, t.placement], d), xI([o, s], b, {
            eventName: "touchstart"
        }), () => {
            var g;
            return I(mt, null, [I("span", {
                ref: o,
                class: ho("wrapper"),
                onClick: h
            }, [(g = n.reference) == null ? void 0 : g.call(n)]), I(xa, Ke({
                ref: a,
                show: l.value,
                class: ho([t.theme]),
                position: "",
                transition: "van-popover-zoom",
                lockScroll: !1,
                "onUpdate:show": f
            }, r, Mv(), yt(t, PK)), {
                default: () => [t.showArrow && I("div", {
                    class: ho("arrow")
                }, null), I("div", {
                    role: "menu",
                    class: ho("content", t.actionsDirection)
                }, [n.default ? n.default() : t.actions.map(m)])]
            })])
        }
    }
});
const Exe = Ae(OK),
    [IK, Xm] = Ee("progress"),
    MK = {
        color: String,
        inactive: Boolean,
        pivotText: String,
        textColor: String,
        showPivot: me,
        pivotColor: String,
        trackColor: String,
        strokeWidth: be,
        percentage: {
            type: be,
            default: 0,
            validator: t => +t >= 0 && +t <= 100
        }
    };
var RK = ve({
    name: IK,
    props: MK,
    setup(t) {
        const e = te(() => t.inactive ? void 0 : t.color),
            n = i => Math.min(Math.max(+i, 0), 100),
            r = () => {
                const {
                    textColor: i,
                    pivotText: s,
                    pivotColor: o,
                    percentage: a
                } = t, l = n(a), c = s ? ? `${a}%`;
                if (t.showPivot && c) {
                    const u = {
                        color: i,
                        left: `${l}%`,
                        transform: `translate(-${l}%,-50%)`,
                        background: o || e.value
                    };
                    return I("span", {
                        style: u,
                        class: Xm("pivot", {
                            inactive: t.inactive
                        })
                    }, [c])
                }
            };
        return () => {
            const {
                trackColor: i,
                percentage: s,
                strokeWidth: o
            } = t, a = n(s), l = {
                background: i,
                height: We(o)
            }, c = {
                width: `${a}%`,
                background: e.value
            };
            return I("div", {
                class: Xm(),
                style: l
            }, [I("span", {
                class: Xm("portion", {
                    inactive: t.inactive
                }),
                style: c
            }, null), r()])
        }
    }
});
const Sxe = Ae(RK),
    [kK, cc, BK] = Ee("pull-refresh"),
    lR = 50,
    DK = ["pulling", "loosing", "success"],
    $K = {
        disabled: Boolean,
        modelValue: Boolean,
        headHeight: Fe(lR),
        successText: String,
        pullingText: String,
        loosingText: String,
        loadingText: String,
        pullDistance: be,
        successDuration: Fe(500),
        animationDuration: Fe(300)
    };
var FK = ve({
    name: kK,
    props: $K,
    emits: ["change", "refresh", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        let r;
        const i = q(),
            s = q(),
            o = sd(i),
            a = ft({
                status: "normal",
                distance: 0,
                duration: 0
            }),
            l = ba(),
            c = () => {
                if (t.headHeight !== lR) return {
                    height: `${t.headHeight}px`
                }
            },
            u = () => a.status !== "loading" && a.status !== "success" && !t.disabled,
            d = _ => {
                const x = +(t.pullDistance || t.headHeight);
                return _ > x && (_ < x * 2 ? _ = x + (_ - x) / 2 : _ = x * 1.5 + (_ - x * 2) / 4), Math.round(_)
            },
            f = (_, x) => {
                const w = +(t.pullDistance || t.headHeight);
                a.distance = _, x ? a.status = "loading" : _ === 0 ? a.status = "normal" : _ < w ? a.status = "pulling" : a.status = "loosing", e("change", {
                    status: a.status,
                    distance: _
                })
            },
            h = () => {
                const {
                    status: _
                } = a;
                return _ === "normal" ? "" : t[`${_}Text`] || BK(_)
            },
            p = () => {
                const {
                    status: _,
                    distance: x
                } = a;
                if (n[_]) return n[_]({
                    distance: x
                });
                const w = [];
                return DK.includes(_) && w.push(I("div", {
                    class: cc("text")
                }, [h()])), _ === "loading" && w.push(I(ss, {
                    class: cc("loading")
                }, {
                    default: h
                })), w
            },
            b = () => {
                a.status = "success", setTimeout(() => {
                    f(0)
                }, +t.successDuration)
            },
            y = _ => {
                r = od(o.value) === 0, r && (a.duration = 0, l.start(_))
            },
            m = _ => {
                u() && y(_)
            },
            g = _ => {
                if (u()) {
                    r || y(_);
                    const {
                        deltaY: x
                    } = l;
                    l.move(_), r && x.value >= 0 && l.isVertical() && (Zt(_), f(d(x.value)))
                }
            },
            v = () => {
                r && l.deltaY.value && u() && (a.duration = +t.animationDuration, a.status === "loosing" ? (f(+t.headHeight, !0), e("update:modelValue", !0), Ue(() => e("refresh"))) : f(0))
            };
        return he(() => t.modelValue, _ => {
            a.duration = +t.animationDuration, _ ? f(+t.headHeight, !0) : n.success || t.successText ? b() : f(0, !1)
        }), An("touchmove", g, {
            target: s
        }), () => {
            var _;
            const x = {
                transitionDuration: `${a.duration}ms`,
                transform: a.distance ? `translate3d(0,${a.distance}px, 0)` : ""
            };
            return I("div", {
                ref: i,
                class: cc()
            }, [I("div", {
                ref: s,
                class: cc("track"),
                style: x,
                onTouchstartPassive: m,
                onTouchend: v,
                onTouchcancel: v
            }, [I("div", {
                class: cc("head"),
                style: c()
            }, [p()]), (_ = n.default) == null ? void 0 : _.call(n)])])
        }
    }
});
const Txe = Ae(FK),
    Cxe = Ae(xX),
    [cR, LK] = Ee("sidebar"),
    uR = Symbol(cR),
    NK = {
        modelValue: Fe(0)
    };
var UK = ve({
    name: cR,
    props: NK,
    emits: ["change", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const {
            linkChildren: r
        } = Lr(uR), i = () => +t.modelValue;
        return r({
            getActive: i,
            setActive: o => {
                o !== i() && (e("update:modelValue", o), e("change", o))
            }
        }), () => {
            var o;
            return I("div", {
                role: "tablist",
                class: LK()
            }, [(o = n.default) == null ? void 0 : o.call(n)])
        }
    }
});
const Pxe = Ae(UK),
    [GK, GS] = Ee("sidebar-item"),
    HK = Le({}, Vl, {
        dot: Boolean,
        title: String,
        badge: be,
        disabled: Boolean,
        badgeProps: Object
    });
var zK = ve({
    name: GK,
    props: HK,
    emits: ["click"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = ad(),
            {
                parent: i,
                index: s
            } = rr(uR);
        if (!i) {
            console.error("[Vant] <SidebarItem> must be a child component of <Sidebar>.");
            return
        }
        const o = () => {
            t.disabled || (e("click", s.value), i.setActive(s.value), r())
        };
        return () => {
            const {
                dot: a,
                badge: l,
                title: c,
                disabled: u
            } = t, d = s.value === i.getActive();
            return I("div", {
                role: "tab",
                class: GS({
                    select: d,
                    disabled: u
                }),
                tabindex: u ? void 0 : 0,
                "aria-selected": d,
                onClick: o
            }, [I(Mp, Ke({
                dot: a,
                class: GS("text"),
                content: l
            }, t.badgeProps), {
                default: () => [n.title ? n.title() : c]
            })])
        }
    }
});
const Axe = Ae(zK),
    [jK, VK] = Ee("skeleton-title"),
    WK = {
        round: Boolean,
        titleWidth: be
    };
var YK = ve({
    name: jK,
    props: WK,
    setup(t) {
        return () => I("h3", {
            class: VK([{
                round: t.round
            }]),
            style: {
                width: We(t.titleWidth)
            }
        }, null)
    }
});
const XK = Ae(YK);
var qK = XK;
const [KK, JK] = Ee("skeleton-avatar"), ZK = {
    avatarSize: be,
    avatarShape: Pe("round")
};
var QK = ve({
    name: KK,
    props: ZK,
    setup(t) {
        return () => I("div", {
            class: JK([t.avatarShape]),
            style: _a(t.avatarSize)
        }, null)
    }
});
const eJ = Ae(QK);
var tJ = eJ;
const Vb = "100%",
    nJ = {
        round: Boolean,
        rowWidth: {
            type: be,
            default: Vb
        }
    },
    [rJ, iJ] = Ee("skeleton-paragraph");
var sJ = ve({
    name: rJ,
    props: nJ,
    setup(t) {
        return () => I("div", {
            class: iJ([{
                round: t.round
            }]),
            style: {
                width: t.rowWidth
            }
        }, null)
    }
});
const oJ = Ae(sJ);
var aJ = oJ;
const [lJ, HS] = Ee("skeleton"), cJ = "60%", uJ = {
    row: Fe(0),
    round: Boolean,
    title: Boolean,
    titleWidth: be,
    avatar: Boolean,
    avatarSize: be,
    avatarShape: Pe("round"),
    loading: me,
    animate: me,
    rowWidth: {
        type: [Number, String, Array],
        default: Vb
    }
};
var dJ = ve({
    name: lJ,
    inheritAttrs: !1,
    props: uJ,
    setup(t, {
        slots: e,
        attrs: n
    }) {
        const r = () => {
                if (t.avatar) return I(tJ, {
                    avatarShape: t.avatarShape,
                    avatarSize: t.avatarSize
                }, null)
            },
            i = () => {
                if (t.title) return I(qK, {
                    round: t.round,
                    titleWidth: t.titleWidth
                }, null)
            },
            s = l => {
                const {
                    rowWidth: c
                } = t;
                return c === Vb && l === +t.row - 1 ? cJ : Array.isArray(c) ? c[l] : c
            },
            o = () => Array(+t.row).fill("").map((l, c) => I(aJ, {
                key: c,
                round: t.round,
                rowWidth: We(s(c))
            }, null)),
            a = () => e.template ? e.template() : I(mt, null, [r(), I("div", {
                class: HS("content")
            }, [i(), o()])]);
        return () => {
            var l;
            return t.loading ? I("div", Ke({
                class: HS({
                    animate: t.animate,
                    round: t.round
                })
            }, n), [a()]) : (l = e.default) == null ? void 0 : l.call(e)
        }
    }
});
const Oxe = Ae(dJ),
    [fJ, uc] = Ee("slider"),
    hJ = {
        min: Fe(0),
        max: Fe(100),
        step: Fe(1),
        range: Boolean,
        reverse: Boolean,
        disabled: Boolean,
        readonly: Boolean,
        vertical: Boolean,
        barHeight: be,
        buttonSize: be,
        activeColor: String,
        inactiveColor: String,
        modelValue: {
            type: [Number, Array],
            default: 0
        }
    };
var pJ = ve({
    name: fJ,
    props: hJ,
    emits: ["change", "dragEnd", "dragStart", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        let r, i, s;
        const o = q(),
            a = [q(), q()],
            l = q(),
            c = ba(),
            u = te(() => Number(t.max) - Number(t.min)),
            d = te(() => {
                const S = t.vertical ? "width" : "height";
                return {
                    background: t.inactiveColor,
                    [S]: We(t.barHeight)
                }
            }),
            f = S => t.range && Array.isArray(S),
            h = () => {
                const {
                    modelValue: S,
                    min: P
                } = t;
                return f(S) ? `${(S[1]-S[0])*100/u.value}%` : `${(S-Number(P))*100/u.value}%`
            },
            p = () => {
                const {
                    modelValue: S,
                    min: P
                } = t;
                return f(S) ? `${(S[0]-Number(P))*100/u.value}%` : "0%"
            },
            b = te(() => {
                const P = {
                    [t.vertical ? "height" : "width"]: h(),
                    background: t.activeColor
                };
                l.value && (P.transition = "none");
                const R = () => t.vertical ? t.reverse ? "bottom" : "top" : t.reverse ? "right" : "left";
                return P[R()] = p(), P
            }),
            y = S => {
                const P = +t.min,
                    R = +t.max,
                    D = +t.step;
                S = tn(S, P, R);
                const H = Math.round((S - P) / D) * D;
                return o2(P, H)
            },
            m = () => {
                const S = t.modelValue;
                f(S) ? s = S.map(y) : s = y(S)
            },
            g = S => {
                var P, R;
                const D = (P = S[0]) != null ? P : Number(t.min),
                    H = (R = S[1]) != null ? R : Number(t.max);
                return D > H ? [H, D] : [D, H]
            },
            v = (S, P) => {
                f(S) ? S = g(S).map(y) : S = y(S), $s(S, t.modelValue) || e("update:modelValue", S), P && !$s(S, s) && e("change", S)
            },
            _ = S => {
                if (S.stopPropagation(), t.disabled || t.readonly) return;
                m();
                const {
                    min: P,
                    reverse: R,
                    vertical: D,
                    modelValue: H
                } = t, B = jt(o), N = () => D ? R ? B.bottom - S.clientY : S.clientY - B.top : R ? B.right - S.clientX : S.clientX - B.left, V = D ? B.height : B.width, Y = Number(P) + N() / V * u.value;
                if (f(H)) {
                    const [le, ae] = H, W = (le + ae) / 2;
                    Y <= W ? v([Y, ae], !0) : v([le, Y], !0)
                } else v(Y, !0)
            },
            x = S => {
                t.disabled || t.readonly || (c.start(S), i = t.modelValue, m(), l.value = "start")
            },
            w = S => {
                if (t.disabled || t.readonly) return;
                l.value === "start" && e("dragStart", S), Zt(S, !0), c.move(S), l.value = "dragging";
                const P = jt(o),
                    R = t.vertical ? c.deltaY.value : c.deltaX.value,
                    D = t.vertical ? P.height : P.width;
                let H = R / D * u.value;
                if (t.reverse && (H = -H), f(s)) {
                    const B = t.reverse ? 1 - r : r;
                    i[B] = s[B] + H
                } else i = s + H;
                v(i)
            },
            E = S => {
                t.disabled || t.readonly || (l.value === "dragging" && (v(i, !0), e("dragEnd", S)), l.value = "")
            },
            C = S => typeof S == "number" ? uc("button-wrapper", ["left", "right"][S]) : uc("button-wrapper", t.reverse ? "left" : "right"),
            A = (S, P) => {
                const R = l.value === "dragging";
                if (typeof P == "number") {
                    const D = n[P === 0 ? "left-button" : "right-button"];
                    let H;
                    if (R && Array.isArray(i) && (H = i[0] > i[1] ? r ^ 1 : r), D) return D({
                        value: S,
                        dragging: R,
                        dragIndex: H
                    })
                }
                return n.button ? n.button({
                    value: S,
                    dragging: R
                }) : I("div", {
                    class: uc("button"),
                    style: _a(t.buttonSize)
                }, null)
            },
            T = S => {
                const P = typeof S == "number" ? t.modelValue[S] : t.modelValue;
                return I("div", {
                    ref: a[S ? ? 0],
                    role: "slider",
                    class: C(S),
                    tabindex: t.disabled ? void 0 : 0,
                    "aria-valuemin": t.min,
                    "aria-valuenow": P,
                    "aria-valuemax": t.max,
                    "aria-disabled": t.disabled || void 0,
                    "aria-readonly": t.readonly || void 0,
                    "aria-orientation": t.vertical ? "vertical" : "horizontal",
                    onTouchstartPassive: R => {
                        typeof S == "number" && (r = S), x(R)
                    },
                    onTouchend: E,
                    onTouchcancel: E,
                    onClick: r2
                }, [A(P, S)])
            };
        return v(t.modelValue), va(() => t.modelValue), a.forEach(S => {
            An("touchmove", w, {
                target: S
            })
        }), () => I("div", {
            ref: o,
            style: d.value,
            class: uc({
                vertical: t.vertical,
                disabled: t.disabled
            }),
            onClick: _
        }, [I("div", {
            class: uc("bar"),
            style: b.value
        }, [t.range ? [T(0), T(1)] : T()])])
    }
});
const Ixe = Ae(pJ),
    [zS, mJ] = Ee("space"),
    gJ = {
        align: String,
        direction: {
            type: String,
            default: "horizontal"
        },
        size: {
            type: [Number, String, Array],
            default: 8
        },
        wrap: Boolean,
        fill: Boolean
    };

function dR(t = []) {
    const e = [];
    return t.forEach(n => {
        Array.isArray(n) ? e.push(...n) : n.type === mt ? e.push(...dR(n.children)) : e.push(n)
    }), e.filter(n => {
        var r;
        return !(n && (n.type === It || n.type === mt && ((r = n.children) == null ? void 0 : r.length) === 0 || n.type === li && n.children.trim() === ""))
    })
}
var yJ = ve({
    name: zS,
    props: gJ,
    setup(t, {
        slots: e
    }) {
        const n = te(() => {
                var s;
                return (s = t.align) != null ? s : t.direction === "horizontal" ? "center" : ""
            }),
            r = s => typeof s == "number" ? s + "px" : s,
            i = s => {
                const o = {},
                    a = `${r(Array.isArray(t.size)?t.size[0]:t.size)}`,
                    l = `${r(Array.isArray(t.size)?t.size[1]:t.size)}`;
                return s ? t.wrap ? {
                    marginBottom: l
                } : {} : (t.direction === "horizontal" && (o.marginRight = a), (t.direction === "vertical" || t.wrap) && (o.marginBottom = l), o)
            };
        return () => {
            var s;
            const o = dR((s = e.default) == null ? void 0 : s.call(e));
            return I("div", {
                class: [mJ({
                    [t.direction]: t.direction,
                    [`align-${n.value}`]: n.value,
                    wrap: t.wrap,
                    fill: t.fill
                })]
            }, [o.map((a, l) => I("div", {
                key: `item-${l}`,
                class: `${zS}-item`,
                style: i(l === o.length - 1)
            }, [a]))])
        }
    }
});
const Mxe = Ae(yJ),
    [vJ, qd] = Ee("stepper"),
    _J = 200,
    Kd = (t, e) => String(t) === String(e),
    bJ = {
        min: Fe(1),
        max: Fe(1 / 0),
        name: Fe(""),
        step: Fe(1),
        theme: String,
        integer: Boolean,
        disabled: Boolean,
        showPlus: me,
        showMinus: me,
        showInput: me,
        longPress: me,
        autoFixed: me,
        allowEmpty: Boolean,
        modelValue: be,
        inputWidth: be,
        buttonSize: be,
        placeholder: String,
        disablePlus: Boolean,
        disableMinus: Boolean,
        disableInput: Boolean,
        beforeChange: Function,
        defaultValue: Fe(1),
        decimalLength: be
    };
var xJ = ve({
    name: vJ,
    props: bJ,
    emits: ["plus", "blur", "minus", "focus", "change", "overlimit", "update:modelValue"],
    setup(t, {
        emit: e
    }) {
        const n = (C, A = !0) => {
                const {
                    min: T,
                    max: S,
                    allowEmpty: P,
                    decimalLength: R
                } = t;
                return P && C === "" || (C = Ov(String(C), !t.integer), C = C === "" ? 0 : +C, C = Number.isNaN(C) ? +T : C, C = A ? Math.max(Math.min(+S, C), +T) : C, gt(R) && (C = C.toFixed(+R))), C
            },
            r = () => {
                var C;
                const A = (C = t.modelValue) != null ? C : t.defaultValue,
                    T = n(A);
                return Kd(T, t.modelValue) || e("update:modelValue", T), T
            };
        let i;
        const s = q(),
            o = q(r()),
            a = te(() => t.disabled || t.disableMinus || +o.value <= +t.min),
            l = te(() => t.disabled || t.disablePlus || +o.value >= +t.max),
            c = te(() => ({
                width: We(t.inputWidth),
                height: We(t.buttonSize)
            })),
            u = te(() => _a(t.buttonSize)),
            d = () => {
                const C = n(o.value);
                Kd(C, o.value) || (o.value = C)
            },
            f = C => {
                t.beforeChange ? jl(t.beforeChange, {
                    args: [C],
                    done() {
                        o.value = C
                    }
                }) : o.value = C
            },
            h = () => {
                if (i === "plus" && l.value || i === "minus" && a.value) {
                    e("overlimit", i);
                    return
                }
                const C = i === "minus" ? -t.step : +t.step,
                    A = n(o2(+o.value, C));
                f(A), e(i)
            },
            p = C => {
                const A = C.target,
                    {
                        value: T
                    } = A,
                    {
                        decimalLength: S
                    } = t;
                let P = Ov(String(T), !t.integer);
                if (gt(S) && P.includes(".")) {
                    const D = P.split(".");
                    P = `${D[0]}.${D[1].slice(0,+S)}`
                }
                t.beforeChange ? A.value = String(o.value) : Kd(T, P) || (A.value = P);
                const R = P === String(+P);
                f(R ? +P : P)
            },
            b = C => {
                var A;
                t.disableInput ? (A = s.value) == null || A.blur() : e("focus", C)
            },
            y = C => {
                const A = C.target,
                    T = n(A.value, t.autoFixed);
                A.value = String(T), o.value = T, Ue(() => {
                    e("blur", C), n2()
                })
            };
        let m, g;
        const v = () => {
                g = setTimeout(() => {
                    h(), v()
                }, _J)
            },
            _ = () => {
                t.longPress && (m = !1, clearTimeout(g), g = setTimeout(() => {
                    m = !0, h(), v()
                }, d2))
            },
            x = C => {
                t.longPress && (clearTimeout(g), m && Zt(C))
            },
            w = C => {
                t.disableInput && Zt(C)
            },
            E = C => ({
                onClick: A => {
                    Zt(A), i = C, h()
                },
                onTouchstartPassive: () => {
                    i = C, _()
                },
                onTouchend: x,
                onTouchcancel: x
            });
        return he(() => [t.max, t.min, t.integer, t.decimalLength], d), he(() => t.modelValue, C => {
            Kd(C, o.value) || (o.value = n(C))
        }), he(o, C => {
            e("update:modelValue", C), e("change", C, {
                name: t.name
            })
        }), va(() => t.modelValue), () => I("div", {
            role: "group",
            class: qd([t.theme])
        }, [mr(I("button", Ke({
            type: "button",
            style: u.value,
            class: [qd("minus", {
                disabled: a.value
            }), {
                [qi]: !a.value
            }],
            "aria-disabled": a.value || void 0
        }, E("minus")), null), [
            [yr, t.showMinus]
        ]), mr(I("input", {
            ref: s,
            type: t.integer ? "tel" : "text",
            role: "spinbutton",
            class: qd("input"),
            value: o.value,
            style: c.value,
            disabled: t.disabled,
            readonly: t.disableInput,
            inputmode: t.integer ? "numeric" : "decimal",
            placeholder: t.placeholder,
            autocomplete: "off",
            "aria-valuemax": t.max,
            "aria-valuemin": t.min,
            "aria-valuenow": o.value,
            onBlur: y,
            onInput: p,
            onFocus: b,
            onMousedown: w
        }, null), [
            [yr, t.showInput]
        ]), mr(I("button", Ke({
            type: "button",
            style: u.value,
            class: [qd("plus", {
                disabled: l.value
            }), {
                [qi]: !l.value
            }],
            "aria-disabled": l.value || void 0
        }, E("plus")), null), [
            [yr, t.showPlus]
        ])])
    }
});
const Rxe = Ae(xJ),
    [wJ, zt, EJ] = Ee("uploader");

function jS(t, e) {
    return new Promise(n => {
        if (e === "file") {
            n();
            return
        }
        const r = new FileReader;
        r.onload = i => {
            n(i.target.result)
        }, e === "dataUrl" ? r.readAsDataURL(t) : e === "text" && r.readAsText(t)
    })
}

function fR(t, e) {
    return yh(t).some(n => n.file ? gl(e) ? e(n.file) : n.file.size > +e : !1)
}

function SJ(t, e) {
    const n = [],
        r = [];
    return t.forEach(i => {
        fR(i, e) ? r.push(i) : n.push(i)
    }), {
        valid: n,
        invalid: r
    }
}
const TJ = /\.(jpeg|jpg|gif|png|svg|webp|jfif|bmp|dpg|avif)/i,
    CJ = t => TJ.test(t);

function hR(t) {
    return t.isImage ? !0 : t.file && t.file.type ? t.file.type.indexOf("image") === 0 : t.url ? CJ(t.url) : typeof t.content == "string" ? t.content.indexOf("data:image") === 0 : !1
}
var PJ = ve({
    props: {
        name: be,
        item: xn(Object),
        index: Number,
        imageFit: String,
        lazyLoad: Boolean,
        deletable: Boolean,
        reupload: Boolean,
        previewSize: [Number, String, Array],
        beforeDelete: Function
    },
    emits: ["delete", "preview", "reupload"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = () => {
                const {
                    status: u,
                    message: d
                } = t.item;
                if (u === "uploading" || u === "failed") {
                    const f = u === "failed" ? I(Mt, {
                            name: "close",
                            class: zt("mask-icon")
                        }, null) : I(ss, {
                            class: zt("loading")
                        }, null),
                        h = gt(d) && d !== "";
                    return I("div", {
                        class: zt("mask")
                    }, [f, h && I("div", {
                        class: zt("mask-message")
                    }, [d])])
                }
            },
            i = u => {
                const {
                    name: d,
                    item: f,
                    index: h,
                    beforeDelete: p
                } = t;
                u.stopPropagation(), jl(p, {
                    args: [f, {
                        name: d,
                        index: h
                    }],
                    done: () => e("delete")
                })
            },
            s = () => e("preview"),
            o = () => e("reupload"),
            a = () => {
                if (t.deletable && t.item.status !== "uploading") {
                    const u = n["preview-delete"];
                    return I("div", {
                        role: "button",
                        class: zt("preview-delete", {
                            shadow: !u
                        }),
                        tabindex: 0,
                        "aria-label": EJ("delete"),
                        onClick: i
                    }, [u ? u() : I(Mt, {
                        name: "cross",
                        class: zt("preview-delete-icon")
                    }, null)])
                }
            },
            l = () => {
                if (n["preview-cover"]) {
                    const {
                        index: u,
                        item: d
                    } = t;
                    return I("div", {
                        class: zt("preview-cover")
                    }, [n["preview-cover"](Le({
                        index: u
                    }, d))])
                }
            },
            c = () => {
                const {
                    item: u,
                    lazyLoad: d,
                    imageFit: f,
                    previewSize: h,
                    reupload: p
                } = t;
                return hR(u) ? I(V2, {
                    fit: f,
                    src: u.objectUrl || u.content || u.url,
                    class: zt("preview-image"),
                    width: Array.isArray(h) ? h[0] : h,
                    height: Array.isArray(h) ? h[1] : h,
                    lazyLoad: d,
                    onClick: p ? o : s
                }, {
                    default: l
                }) : I("div", {
                    class: zt("file"),
                    style: _a(t.previewSize)
                }, [I(Mt, {
                    class: zt("file-icon"),
                    name: "description"
                }, null), I("div", {
                    class: [zt("file-name"), "van-ellipsis"]
                }, [u.file ? u.file.name : u.url]), l()])
            };
        return () => I("div", {
            class: zt("preview")
        }, [c(), r(), a()])
    }
});
const AJ = {
    name: Fe(""),
    accept: Pe("image/*"),
    capture: String,
    multiple: Boolean,
    disabled: Boolean,
    readonly: Boolean,
    lazyLoad: Boolean,
    maxCount: Fe(1 / 0),
    imageFit: Pe("cover"),
    resultType: Pe("dataUrl"),
    uploadIcon: Pe("photograph"),
    uploadText: String,
    deletable: me,
    reupload: Boolean,
    afterRead: Function,
    showUpload: me,
    modelValue: Xi(),
    beforeRead: Function,
    beforeDelete: Function,
    previewSize: [Number, String, Array],
    previewImage: me,
    previewOptions: Object,
    previewFullImage: me,
    maxSize: {
        type: [Number, String, Function],
        default: 1 / 0
    }
};
var OJ = ve({
    name: wJ,
    props: AJ,
    emits: ["delete", "oversize", "clickUpload", "closePreview", "clickPreview", "clickReupload", "update:modelValue"],
    setup(t, {
        emit: e,
        slots: n
    }) {
        const r = q(),
            i = [],
            s = q(-1),
            o = q(!1),
            a = (C = t.modelValue.length) => ({
                name: t.name,
                index: C
            }),
            l = () => {
                r.value && (r.value.value = "")
            },
            c = C => {
                if (l(), fR(C, t.maxSize))
                    if (Array.isArray(C)) {
                        const A = SJ(C, t.maxSize);
                        if (C = A.valid, e("oversize", A.invalid, a()), !C.length) return
                    } else {
                        e("oversize", C, a());
                        return
                    }
                if (C = ft(C), s.value > -1) {
                    const A = [...t.modelValue];
                    A.splice(s.value, 1, C), e("update:modelValue", A), s.value = -1
                } else e("update:modelValue", [...t.modelValue, ...yh(C)]);
                t.afterRead && t.afterRead(C, a())
            },
            u = C => {
                const {
                    maxCount: A,
                    modelValue: T,
                    resultType: S
                } = t;
                if (Array.isArray(C)) {
                    const P = +A - T.length;
                    C.length > P && (C = C.slice(0, P)), Promise.all(C.map(R => jS(R, S))).then(R => {
                        const D = C.map((H, B) => {
                            const N = {
                                file: H,
                                status: "",
                                message: "",
                                objectUrl: URL.createObjectURL(H)
                            };
                            return R[B] && (N.content = R[B]), N
                        });
                        c(D)
                    })
                } else jS(C, S).then(P => {
                    const R = {
                        file: C,
                        status: "",
                        message: "",
                        objectUrl: URL.createObjectURL(C)
                    };
                    P && (R.content = P), c(R)
                })
            },
            d = C => {
                const {
                    files: A
                } = C.target;
                if (t.disabled || !A || !A.length) return;
                const T = A.length === 1 ? A[0] : [].slice.call(A);
                if (t.beforeRead) {
                    const S = t.beforeRead(T, a());
                    if (!S) {
                        l();
                        return
                    }
                    if (Ib(S)) {
                        S.then(P => {
                            u(P || T)
                        }).catch(l);
                        return
                    }
                }
                u(T)
            };
        let f;
        const h = () => e("closePreview"),
            p = C => {
                if (t.previewFullImage) {
                    const A = t.modelValue.filter(hR),
                        T = A.map(S => (S.objectUrl && !S.url && S.status !== "failed" && (S.url = S.objectUrl, i.push(S.url)), S.url)).filter(Boolean);
                    f = gq(Le({
                        images: T,
                        startPosition: A.indexOf(C),
                        onClose: h
                    }, t.previewOptions))
                }
            },
            b = () => {
                f && f.close()
            },
            y = (C, A) => {
                const T = t.modelValue.slice(0);
                T.splice(A, 1), e("update:modelValue", T), e("delete", C, a(A))
            },
            m = C => {
                o.value = !0, s.value = C, Ue(() => E())
            },
            g = () => {
                o.value || (s.value = -1), o.value = !1
            },
            v = (C, A) => {
                const T = ["imageFit", "deletable", "reupload", "previewSize", "beforeDelete"],
                    S = Le(yt(t, T), yt(C, T, !0));
                return I(PJ, Ke({
                    item: C,
                    index: A,
                    onClick: () => e(t.reupload ? "clickReupload" : "clickPreview", C, a(A)),
                    onDelete: () => y(C, A),
                    onPreview: () => p(C),
                    onReupload: () => m(A)
                }, yt(t, ["name", "lazyLoad"]), S), yt(n, ["preview-cover", "preview-delete"]))
            },
            _ = () => {
                if (t.previewImage) return t.modelValue.map(v)
            },
            x = C => e("clickUpload", C),
            w = () => {
                const C = t.modelValue.length < +t.maxCount,
                    A = t.readonly ? null : I("input", {
                        ref: r,
                        type: "file",
                        class: zt("input"),
                        accept: t.accept,
                        capture: t.capture,
                        multiple: t.multiple && s.value === -1,
                        disabled: t.disabled,
                        onChange: d,
                        onClick: g
                    }, null);
                return n.default ? mr(I("div", {
                    class: zt("input-wrapper"),
                    onClick: x
                }, [n.default(), A]), [
                    [yr, C]
                ]) : mr(I("div", {
                    class: zt("upload", {
                        readonly: t.readonly
                    }),
                    style: _a(t.previewSize),
                    onClick: x
                }, [I(Mt, {
                    name: t.uploadIcon,
                    class: zt("upload-icon")
                }, null), t.uploadText && I("span", {
                    class: zt("upload-text")
                }, [t.uploadText]), A]), [
                    [yr, t.showUpload && C]
                ])
            },
            E = () => {
                r.value && !t.disabled && r.value.click()
            };
        return nr(() => {
            i.forEach(C => URL.revokeObjectURL(C))
        }), Tt({
            chooseFile: E,
            reuploadFile: m,
            closeImagePreview: b
        }), va(() => t.modelValue), () => I("div", {
            class: zt()
        }, [I("div", {
            class: zt("wrapper", {
                disabled: t.disabled
            })
        }, [_(), w()])])
    }
});
const kxe = Ae(OJ);
/*!
 * shared v11.1.10
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */
function os(t, e) {
    typeof console < "u" && (console.warn("[intlify] " + t), e && console.warn(e.stack))
}
const VS = {};

function Wb(t) {
    VS[t] || (VS[t] = !0, os(t))
}
const $r = typeof window < "u";
let Xn, Qo; {
    const t = $r && window.performance;
    t && t.mark && t.measure && t.clearMarks && t.clearMeasures && (Xn = e => {
        t.mark(e)
    }, Qo = (e, n, r) => {
        t.measure(e, n, r), t.clearMarks(n), t.clearMarks(r)
    })
}
const IJ = /\{([0-9a-zA-Z]+)\}/g;

function Lp(t, ...e) {
    return e.length === 1 && qe(e[0]) && (e = e[0]), (!e || !e.hasOwnProperty) && (e = {}), t.replace(IJ, (n, r) => e.hasOwnProperty(r) ? e[r] : "")
}
const mi = (t, e = !1) => e ? Symbol.for(t) : Symbol(t),
    MJ = (t, e, n) => RJ({
        l: t,
        k: e,
        s: n
    }),
    RJ = t => JSON.stringify(t).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027"),
    Lt = t => typeof t == "number" && isFinite(t),
    kJ = t => Yb(t) === "[object Date]",
    bl = t => Yb(t) === "[object RegExp]",
    Np = t => He(t) && Object.keys(t).length === 0,
    Vt = Object.assign,
    BJ = Object.create,
    at = (t = null) => BJ(t);
let WS;
const Io = () => WS || (WS = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : at());

function YS(t) {
    return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/\//g, "&#x2F;").replace(/=/g, "&#x3D;")
}

function XS(t) {
    return t.replace(/&(?![a-zA-Z0-9#]{2,6};)/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
}

function DJ(t) {
    return t = t.replace(/(\w+)\s*=\s*"([^"]*)"/g, (r, i, s) => `${i}="${XS(s)}"`), t = t.replace(/(\w+)\s*=\s*'([^']*)'/g, (r, i, s) => `${i}='${XS(s)}'`), /\s*on\w+\s*=\s*["']?[^"'>]+["']?/gi.test(t) && (os("Potentially dangerous event handlers detected in translation. Consider removing onclick, onerror, etc. from your translation messages."), t = t.replace(/(\s+)(on)(\w+\s*=)/gi, "$1&#111;n$3")), [/(\s+(?:href|src|action|formaction)\s*=\s*["']?)\s*javascript:/gi, /(style\s*=\s*["'][^"']*url\s*\(\s*)javascript:/gi].forEach(r => {
        t = t.replace(r, "$1javascript&#58;")
    }), t
}
const $J = Object.prototype.hasOwnProperty;

function Mr(t, e) {
    return $J.call(t, e)
}
const wt = Array.isArray,
    lt = t => typeof t == "function",
    _e = t => typeof t == "string",
    Ze = t => typeof t == "boolean",
    qe = t => t !== null && typeof t == "object",
    FJ = t => qe(t) && lt(t.then) && lt(t.catch),
    pR = Object.prototype.toString,
    Yb = t => pR.call(t),
    He = t => Yb(t) === "[object Object]",
    LJ = t => t == null ? "" : wt(t) || He(t) && t.toString === pR ? JSON.stringify(t, null, 2) : String(t);

function Xb(t, e = "") {
    return t.reduce((n, r, i) => i === 0 ? n + r : n + e + r, "")
}
const qS = 2;

function NJ(t, e = 0, n = t.length) {
    const r = t.split(/\r?\n/);
    let i = 0;
    const s = [];
    for (let o = 0; o < r.length; o++)
        if (i += r[o].length + 1, i >= e) {
            for (let a = o - qS; a <= o + qS || n > i; a++) {
                if (a < 0 || a >= r.length) continue;
                const l = a + 1;
                s.push(`${l}${" ".repeat(3-String(l).length)}|  ${r[a]}`);
                const c = r[a].length;
                if (a === o) {
                    const u = e - (i - c) + 1,
                        d = Math.max(1, n > i ? c - u : n - e);
                    s.push("   |  " + " ".repeat(u) + "^".repeat(d))
                } else if (a > o) {
                    if (n > i) {
                        const u = Math.max(Math.min(n - i, c), 1);
                        s.push("   |  " + "^".repeat(u))
                    }
                    i += c + 1
                }
            }
            break
        }
    return s.join(`
`)
}

function qb() {
    const t = new Map;
    return {
        events: t,
        on(n, r) {
            const i = t.get(n);
            i && i.push(r) || t.set(n, [r])
        },
        off(n, r) {
            const i = t.get(n);
            i && i.splice(i.indexOf(r) >>> 0, 1)
        },
        emit(n, r) {
            (t.get(n) || []).slice().map(i => i(r)), (t.get("*") || []).slice().map(i => i(n, r))
        }
    }
}
const Jd = t => !qe(t) || wt(t);

function Hf(t, e) {
    if (Jd(t) || Jd(e)) throw new Error("Invalid value");
    const n = [{
        src: t,
        des: e
    }];
    for (; n.length;) {
        const {
            src: r,
            des: i
        } = n.pop();
        Object.keys(r).forEach(s => {
            s !== "__proto__" && (qe(r[s]) && !qe(i[s]) && (i[s] = Array.isArray(r[s]) ? [] : at()), Jd(i[s]) || Jd(r[s]) ? i[s] = r[s] : n.push({
                src: r[s],
                des: i[s]
            }))
        })
    }
}
/*!
 * message-compiler v11.1.10
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */
function UJ(t, e, n) {
    return {
        line: t,
        column: e,
        offset: n
    }
}

function Uv(t, e, n) {
    const r = {
        start: t,
        end: e
    };
    return n != null && (r.source = n), r
}
const $e = {
        EXPECTED_TOKEN: 1,
        INVALID_TOKEN_IN_PLACEHOLDER: 2,
        UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
        UNKNOWN_ESCAPE_SEQUENCE: 4,
        INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
        UNBALANCED_CLOSING_BRACE: 6,
        UNTERMINATED_CLOSING_BRACE: 7,
        EMPTY_PLACEHOLDER: 8,
        NOT_ALLOW_NEST_PLACEHOLDER: 9,
        INVALID_LINKED_FORMAT: 10,
        MUST_HAVE_MESSAGES_IN_PLURAL: 11,
        UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
        UNEXPECTED_EMPTY_LINKED_KEY: 13,
        UNEXPECTED_LEXICAL_ANALYSIS: 14,
        UNHANDLED_CODEGEN_NODE_TYPE: 15,
        UNHANDLED_MINIFIER_NODE_TYPE: 16
    },
    GJ = 17,
    HJ = {
        [$e.EXPECTED_TOKEN]: "Expected token: '{0}'",
        [$e.INVALID_TOKEN_IN_PLACEHOLDER]: "Invalid token in placeholder: '{0}'",
        [$e.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: "Unterminated single quote in placeholder",
        [$e.UNKNOWN_ESCAPE_SEQUENCE]: "Unknown escape sequence: \\{0}",
        [$e.INVALID_UNICODE_ESCAPE_SEQUENCE]: "Invalid unicode escape sequence: {0}",
        [$e.UNBALANCED_CLOSING_BRACE]: "Unbalanced closing brace",
        [$e.UNTERMINATED_CLOSING_BRACE]: "Unterminated closing brace",
        [$e.EMPTY_PLACEHOLDER]: "Empty placeholder",
        [$e.NOT_ALLOW_NEST_PLACEHOLDER]: "Not allowed nest placeholder",
        [$e.INVALID_LINKED_FORMAT]: "Invalid linked format",
        [$e.MUST_HAVE_MESSAGES_IN_PLURAL]: "Plural must have messages",
        [$e.UNEXPECTED_EMPTY_LINKED_MODIFIER]: "Unexpected empty linked modifier",
        [$e.UNEXPECTED_EMPTY_LINKED_KEY]: "Unexpected empty linked key",
        [$e.UNEXPECTED_LEXICAL_ANALYSIS]: "Unexpected lexical analysis in token: '{0}'",
        [$e.UNHANDLED_CODEGEN_NODE_TYPE]: "unhandled codegen node type: '{0}'",
        [$e.UNHANDLED_MINIFIER_NODE_TYPE]: "unhandled mimifier node type: '{0}'"
    };

function Wl(t, e, n = {}) {
    const {
        domain: r,
        messages: i,
        args: s
    } = n, o = Lp((i || HJ)[t] || "", ...s || []), a = new SyntaxError(String(o));
    return a.code = t, e && (a.location = e), a.domain = r, a
}

function zJ(t) {
    throw t
}
const jJ = /<\/?[\w\s="/.':;#-\/]+>/,
    VJ = t => jJ.test(t),
    bi = " ",
    WJ = "\r",
    yn = `
`,
    YJ = String.fromCharCode(8232),
    XJ = String.fromCharCode(8233);

function qJ(t) {
    const e = t;
    let n = 0,
        r = 1,
        i = 1,
        s = 0;
    const o = E => e[E] === WJ && e[E + 1] === yn,
        a = E => e[E] === yn,
        l = E => e[E] === XJ,
        c = E => e[E] === YJ,
        u = E => o(E) || a(E) || l(E) || c(E),
        d = () => n,
        f = () => r,
        h = () => i,
        p = () => s,
        b = E => o(E) || l(E) || c(E) ? yn : e[E],
        y = () => b(n),
        m = () => b(n + s);

    function g() {
        return s = 0, u(n) && (r++, i = 0), o(n) && n++, n++, i++, e[n]
    }

    function v() {
        return o(n + s) && s++, s++, e[n + s]
    }

    function _() {
        n = 0, r = 1, i = 1, s = 0
    }

    function x(E = 0) {
        s = E
    }

    function w() {
        const E = n + s;
        for (; E !== n;) g();
        s = 0
    }
    return {
        index: d,
        line: f,
        column: h,
        peekOffset: p,
        charAt: b,
        currentChar: y,
        currentPeek: m,
        next: g,
        peek: v,
        reset: _,
        resetPeek: x,
        skipToPeek: w
    }
}
const hs = void 0,
    KJ = ".",
    KS = "'",
    JJ = "tokenizer";

function ZJ(t, e = {}) {
    const n = e.location !== !1,
        r = qJ(t),
        i = () => r.index(),
        s = () => UJ(r.line(), r.column(), r.index()),
        o = s(),
        a = i(),
        l = {
            currentType: 13,
            offset: a,
            startLoc: o,
            endLoc: o,
            lastType: 13,
            lastOffset: a,
            lastStartLoc: o,
            lastEndLoc: o,
            braceNest: 0,
            inLinked: !1,
            text: ""
        },
        c = () => l,
        {
            onError: u
        } = e;

    function d(M, k, U, ...J) {
        const se = c();
        if (k.column += U, k.offset += U, u) {
            const pe = n ? Uv(se.startLoc, k) : null,
                ue = Wl(M, pe, {
                    domain: JJ,
                    args: J
                });
            u(ue)
        }
    }

    function f(M, k, U) {
        M.endLoc = s(), M.currentType = k;
        const J = {
            type: k
        };
        return n && (J.loc = Uv(M.startLoc, M.endLoc)), U != null && (J.value = U), J
    }
    const h = M => f(M, 13);

    function p(M, k) {
        return M.currentChar() === k ? (M.next(), k) : (d($e.EXPECTED_TOKEN, s(), 0, k), "")
    }

    function b(M) {
        let k = "";
        for (; M.currentPeek() === bi || M.currentPeek() === yn;) k += M.currentPeek(), M.peek();
        return k
    }

    function y(M) {
        const k = b(M);
        return M.skipToPeek(), k
    }

    function m(M) {
        if (M === hs) return !1;
        const k = M.charCodeAt(0);
        return k >= 97 && k <= 122 || k >= 65 && k <= 90 || k === 95
    }

    function g(M) {
        if (M === hs) return !1;
        const k = M.charCodeAt(0);
        return k >= 48 && k <= 57
    }

    function v(M, k) {
        const {
            currentType: U
        } = k;
        if (U !== 2) return !1;
        b(M);
        const J = m(M.currentPeek());
        return M.resetPeek(), J
    }

    function _(M, k) {
        const {
            currentType: U
        } = k;
        if (U !== 2) return !1;
        b(M);
        const J = M.currentPeek() === "-" ? M.peek() : M.currentPeek(),
            se = g(J);
        return M.resetPeek(), se
    }

    function x(M, k) {
        const {
            currentType: U
        } = k;
        if (U !== 2) return !1;
        b(M);
        const J = M.currentPeek() === KS;
        return M.resetPeek(), J
    }

    function w(M, k) {
        const {
            currentType: U
        } = k;
        if (U !== 7) return !1;
        b(M);
        const J = M.currentPeek() === ".";
        return M.resetPeek(), J
    }

    function E(M, k) {
        const {
            currentType: U
        } = k;
        if (U !== 8) return !1;
        b(M);
        const J = m(M.currentPeek());
        return M.resetPeek(), J
    }

    function C(M, k) {
        const {
            currentType: U
        } = k;
        if (!(U === 7 || U === 11)) return !1;
        b(M);
        const J = M.currentPeek() === ":";
        return M.resetPeek(), J
    }

    function A(M, k) {
        const {
            currentType: U
        } = k;
        if (U !== 9) return !1;
        const J = () => {
                const pe = M.currentPeek();
                return pe === "{" ? m(M.peek()) : pe === "@" || pe === "|" || pe === ":" || pe === "." || pe === bi || !pe ? !1 : pe === yn ? (M.peek(), J()) : S(M, !1)
            },
            se = J();
        return M.resetPeek(), se
    }

    function T(M) {
        b(M);
        const k = M.currentPeek() === "|";
        return M.resetPeek(), k
    }

    function S(M, k = !0) {
        const U = (se = !1, pe = "") => {
                const ue = M.currentPeek();
                return ue === "{" || ue === "@" || !ue ? se : ue === "|" ? !(pe === bi || pe === yn) : ue === bi ? (M.peek(), U(!0, bi)) : ue === yn ? (M.peek(), U(!0, yn)) : !0
            },
            J = U();
        return k && M.resetPeek(), J
    }

    function P(M, k) {
        const U = M.currentChar();
        return U === hs ? hs : k(U) ? (M.next(), U) : null
    }

    function R(M) {
        const k = M.charCodeAt(0);
        return k >= 97 && k <= 122 || k >= 65 && k <= 90 || k >= 48 && k <= 57 || k === 95 || k === 36
    }

    function D(M) {
        return P(M, R)
    }

    function H(M) {
        const k = M.charCodeAt(0);
        return k >= 97 && k <= 122 || k >= 65 && k <= 90 || k >= 48 && k <= 57 || k === 95 || k === 36 || k === 45
    }

    function B(M) {
        return P(M, H)
    }

    function N(M) {
        const k = M.charCodeAt(0);
        return k >= 48 && k <= 57
    }

    function V(M) {
        return P(M, N)
    }

    function Y(M) {
        const k = M.charCodeAt(0);
        return k >= 48 && k <= 57 || k >= 65 && k <= 70 || k >= 97 && k <= 102
    }

    function le(M) {
        return P(M, Y)
    }

    function ae(M) {
        let k = "",
            U = "";
        for (; k = V(M);) U += k;
        return U
    }

    function W(M) {
        let k = "";
        for (;;) {
            const U = M.currentChar();
            if (U === "{" || U === "}" || U === "@" || U === "|" || !U) break;
            if (U === bi || U === yn)
                if (S(M)) k += U, M.next();
                else {
                    if (T(M)) break;
                    k += U, M.next()
                }
            else k += U, M.next()
        }
        return k
    }

    function ne(M) {
        y(M);
        let k = "",
            U = "";
        for (; k = B(M);) U += k;
        return M.currentChar() === hs && d($e.UNTERMINATED_CLOSING_BRACE, s(), 0), U
    }

    function fe(M) {
        y(M);
        let k = "";
        return M.currentChar() === "-" ? (M.next(), k += `-${ae(M)}`) : k += ae(M), M.currentChar() === hs && d($e.UNTERMINATED_CLOSING_BRACE, s(), 0), k
    }

    function $(M) {
        return M !== KS && M !== yn
    }

    function X(M) {
        y(M), p(M, "'");
        let k = "",
            U = "";
        for (; k = P(M, $);) k === "\\" ? U += F(M) : U += k;
        const J = M.currentChar();
        return J === yn || J === hs ? (d($e.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, s(), 0), J === yn && (M.next(), p(M, "'")), U) : (p(M, "'"), U)
    }

    function F(M) {
        const k = M.currentChar();
        switch (k) {
            case "\\":
            case "'":
                return M.next(), `\\${k}`;
            case "u":
                return Z(M, k, 4);
            case "U":
                return Z(M, k, 6);
            default:
                return d($e.UNKNOWN_ESCAPE_SEQUENCE, s(), 0, k), ""
        }
    }

    function Z(M, k, U) {
        p(M, k);
        let J = "";
        for (let se = 0; se < U; se++) {
            const pe = le(M);
            if (!pe) {
                d($e.INVALID_UNICODE_ESCAPE_SEQUENCE, s(), 0, `\\${k}${J}${M.currentChar()}`);
                break
            }
            J += pe
        }
        return `\\${k}${J}`
    }

    function K(M) {
        return M !== "{" && M !== "}" && M !== bi && M !== yn
    }

    function ce(M) {
        y(M);
        let k = "",
            U = "";
        for (; k = P(M, K);) U += k;
        return U
    }

    function de(M) {
        let k = "",
            U = "";
        for (; k = D(M);) U += k;
        return U
    }

    function ge(M) {
        const k = U => {
            const J = M.currentChar();
            return J === "{" || J === "@" || J === "|" || J === "(" || J === ")" || !J || J === bi ? U : (U += J, M.next(), k(U))
        };
        return k("")
    }

    function O(M) {
        y(M);
        const k = p(M, "|");
        return y(M), k
    }

    function L(M, k) {
        let U = null;
        switch (M.currentChar()) {
            case "{":
                return k.braceNest >= 1 && d($e.NOT_ALLOW_NEST_PLACEHOLDER, s(), 0), M.next(), U = f(k, 2, "{"), y(M), k.braceNest++, U;
            case "}":
                return k.braceNest > 0 && k.currentType === 2 && d($e.EMPTY_PLACEHOLDER, s(), 0), M.next(), U = f(k, 3, "}"), k.braceNest--, k.braceNest > 0 && y(M), k.inLinked && k.braceNest === 0 && (k.inLinked = !1), U;
            case "@":
                return k.braceNest > 0 && d($e.UNTERMINATED_CLOSING_BRACE, s(), 0), U = j(M, k) || h(k), k.braceNest = 0, U;
            default:
                {
                    let se = !0,
                        pe = !0,
                        ue = !0;
                    if (T(M)) return k.braceNest > 0 && d($e.UNTERMINATED_CLOSING_BRACE, s(), 0), U = f(k, 1, O(M)), k.braceNest = 0, k.inLinked = !1, U;
                    if (k.braceNest > 0 && (k.currentType === 4 || k.currentType === 5 || k.currentType === 6)) return d($e.UNTERMINATED_CLOSING_BRACE, s(), 0), k.braceNest = 0, ie(M, k);
                    if (se = v(M, k)) return U = f(k, 4, ne(M)), y(M), U;
                    if (pe = _(M, k)) return U = f(k, 5, fe(M)), y(M), U;
                    if (ue = x(M, k)) return U = f(k, 6, X(M)), y(M), U;
                    if (!se && !pe && !ue) return U = f(k, 12, ce(M)), d($e.INVALID_TOKEN_IN_PLACEHOLDER, s(), 0, U.value), y(M), U;
                    break
                }
        }
        return U
    }

    function j(M, k) {
        const {
            currentType: U
        } = k;
        let J = null;
        const se = M.currentChar();
        switch ((U === 7 || U === 8 || U === 11 || U === 9) && (se === yn || se === bi) && d($e.INVALID_LINKED_FORMAT, s(), 0), se) {
            case "@":
                return M.next(), J = f(k, 7, "@"), k.inLinked = !0, J;
            case ".":
                return y(M), M.next(), f(k, 8, ".");
            case ":":
                return y(M), M.next(), f(k, 9, ":");
            default:
                return T(M) ? (J = f(k, 1, O(M)), k.braceNest = 0, k.inLinked = !1, J) : w(M, k) || C(M, k) ? (y(M), j(M, k)) : E(M, k) ? (y(M), f(k, 11, de(M))) : A(M, k) ? (y(M), se === "{" ? L(M, k) || J : f(k, 10, ge(M))) : (U === 7 && d($e.INVALID_LINKED_FORMAT, s(), 0), k.braceNest = 0, k.inLinked = !1, ie(M, k))
        }
    }

    function ie(M, k) {
        let U = {
            type: 13
        };
        if (k.braceNest > 0) return L(M, k) || h(k);
        if (k.inLinked) return j(M, k) || h(k);
        switch (M.currentChar()) {
            case "{":
                return L(M, k) || h(k);
            case "}":
                return d($e.UNBALANCED_CLOSING_BRACE, s(), 0), M.next(), f(k, 3, "}");
            case "@":
                return j(M, k) || h(k);
            default:
                {
                    if (T(M)) return U = f(k, 1, O(M)), k.braceNest = 0, k.inLinked = !1, U;
                    if (S(M)) return f(k, 0, W(M));
                    break
                }
        }
        return U
    }

    function oe() {
        const {
            currentType: M,
            offset: k,
            startLoc: U,
            endLoc: J
        } = l;
        return l.lastType = M, l.lastOffset = k, l.lastStartLoc = U, l.lastEndLoc = J, l.offset = i(), l.startLoc = s(), r.currentChar() === hs ? f(l, 13) : ie(r, l)
    }
    return {
        nextToken: oe,
        currentOffset: i,
        currentPosition: s,
        context: c
    }
}
const QJ = "parser",
    eZ = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;

function tZ(t, e, n) {
    switch (t) {
        case "\\\\":
            return "\\";
        case "\\'":
            return "'";
        default:
            {
                const r = parseInt(e || n, 16);
                return r <= 55295 || r >= 57344 ? String.fromCodePoint(r) : ""
            }
    }
}

function nZ(t = {}) {
    const e = t.location !== !1,
        {
            onError: n
        } = t;

    function r(m, g, v, _, ...x) {
        const w = m.currentPosition();
        if (w.offset += _, w.column += _, n) {
            const E = e ? Uv(v, w) : null,
                C = Wl(g, E, {
                    domain: QJ,
                    args: x
                });
            n(C)
        }
    }

    function i(m, g, v) {
        const _ = {
            type: m
        };
        return e && (_.start = g, _.end = g, _.loc = {
            start: v,
            end: v
        }), _
    }

    function s(m, g, v, _) {
        e && (m.end = g, m.loc && (m.loc.end = v))
    }

    function o(m, g) {
        const v = m.context(),
            _ = i(3, v.offset, v.startLoc);
        return _.value = g, s(_, m.currentOffset(), m.currentPosition()), _
    }

    function a(m, g) {
        const v = m.context(),
            {
                lastOffset: _,
                lastStartLoc: x
            } = v,
            w = i(5, _, x);
        return w.index = parseInt(g, 10), m.nextToken(), s(w, m.currentOffset(), m.currentPosition()), w
    }

    function l(m, g) {
        const v = m.context(),
            {
                lastOffset: _,
                lastStartLoc: x
            } = v,
            w = i(4, _, x);
        return w.key = g, m.nextToken(), s(w, m.currentOffset(), m.currentPosition()), w
    }

    function c(m, g) {
        const v = m.context(),
            {
                lastOffset: _,
                lastStartLoc: x
            } = v,
            w = i(9, _, x);
        return w.value = g.replace(eZ, tZ), m.nextToken(), s(w, m.currentOffset(), m.currentPosition()), w
    }

    function u(m) {
        const g = m.nextToken(),
            v = m.context(),
            {
                lastOffset: _,
                lastStartLoc: x
            } = v,
            w = i(8, _, x);
        return g.type !== 11 ? (r(m, $e.UNEXPECTED_EMPTY_LINKED_MODIFIER, v.lastStartLoc, 0), w.value = "", s(w, _, x), {
            nextConsumeToken: g,
            node: w
        }) : (g.value == null && r(m, $e.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, zr(g)), w.value = g.value || "", s(w, m.currentOffset(), m.currentPosition()), {
            node: w
        })
    }

    function d(m, g) {
        const v = m.context(),
            _ = i(7, v.offset, v.startLoc);
        return _.value = g, s(_, m.currentOffset(), m.currentPosition()), _
    }

    function f(m) {
        const g = m.context(),
            v = i(6, g.offset, g.startLoc);
        let _ = m.nextToken();
        if (_.type === 8) {
            const x = u(m);
            v.modifier = x.node, _ = x.nextConsumeToken || m.nextToken()
        }
        switch (_.type !== 9 && r(m, $e.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, zr(_)), _ = m.nextToken(), _.type === 2 && (_ = m.nextToken()), _.type) {
            case 10:
                _.value == null && r(m, $e.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, zr(_)), v.key = d(m, _.value || "");
                break;
            case 4:
                _.value == null && r(m, $e.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, zr(_)), v.key = l(m, _.value || "");
                break;
            case 5:
                _.value == null && r(m, $e.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, zr(_)), v.key = a(m, _.value || "");
                break;
            case 6:
                _.value == null && r(m, $e.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, zr(_)), v.key = c(m, _.value || "");
                break;
            default:
                {
                    r(m, $e.UNEXPECTED_EMPTY_LINKED_KEY, g.lastStartLoc, 0);
                    const x = m.context(),
                        w = i(7, x.offset, x.startLoc);
                    return w.value = "",
                    s(w, x.offset, x.startLoc),
                    v.key = w,
                    s(v, x.offset, x.startLoc),
                    {
                        nextConsumeToken: _,
                        node: v
                    }
                }
        }
        return s(v, m.currentOffset(), m.currentPosition()), {
            node: v
        }
    }

    function h(m) {
        const g = m.context(),
            v = g.currentType === 1 ? m.currentOffset() : g.offset,
            _ = g.currentType === 1 ? g.endLoc : g.startLoc,
            x = i(2, v, _);
        x.items = [];
        let w = null;
        do {
            const A = w || m.nextToken();
            switch (w = null, A.type) {
                case 0:
                    A.value == null && r(m, $e.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, zr(A)), x.items.push(o(m, A.value || ""));
                    break;
                case 5:
                    A.value == null && r(m, $e.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, zr(A)), x.items.push(a(m, A.value || ""));
                    break;
                case 4:
                    A.value == null && r(m, $e.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, zr(A)), x.items.push(l(m, A.value || ""));
                    break;
                case 6:
                    A.value == null && r(m, $e.UNEXPECTED_LEXICAL_ANALYSIS, g.lastStartLoc, 0, zr(A)), x.items.push(c(m, A.value || ""));
                    break;
                case 7:
                    {
                        const T = f(m);x.items.push(T.node),
                        w = T.nextConsumeToken || null;
                        break
                    }
            }
        } while (g.currentType !== 13 && g.currentType !== 1);
        const E = g.currentType === 1 ? g.lastOffset : m.currentOffset(),
            C = g.currentType === 1 ? g.lastEndLoc : m.currentPosition();
        return s(x, E, C), x
    }

    function p(m, g, v, _) {
        const x = m.context();
        let w = _.items.length === 0;
        const E = i(1, g, v);
        E.cases = [], E.cases.push(_);
        do {
            const C = h(m);
            w || (w = C.items.length === 0), E.cases.push(C)
        } while (x.currentType !== 13);
        return w && r(m, $e.MUST_HAVE_MESSAGES_IN_PLURAL, v, 0), s(E, m.currentOffset(), m.currentPosition()), E
    }

    function b(m) {
        const g = m.context(),
            {
                offset: v,
                startLoc: _
            } = g,
            x = h(m);
        return g.currentType === 13 ? x : p(m, v, _, x)
    }

    function y(m) {
        const g = ZJ(m, Vt({}, t)),
            v = g.context(),
            _ = i(0, v.offset, v.startLoc);
        return e && _.loc && (_.loc.source = m), _.body = b(g), t.onCacheKey && (_.cacheKey = t.onCacheKey(m)), v.currentType !== 13 && r(g, $e.UNEXPECTED_LEXICAL_ANALYSIS, v.lastStartLoc, 0, m[v.offset] || ""), s(_, g.currentOffset(), g.currentPosition()), _
    }
    return {
        parse: y
    }
}

function zr(t) {
    if (t.type === 13) return "EOF";
    const e = (t.value || "").replace(/\r?\n/gu, "\\n");
    return e.length > 10 ? e.slice(0, 9) + "" : e
}

function rZ(t, e = {}) {
    const n = {
        ast: t,
        helpers: new Set
    };
    return {
        context: () => n,
        helper: s => (n.helpers.add(s), s)
    }
}

function JS(t, e) {
    for (let n = 0; n < t.length; n++) Kb(t[n], e)
}

function Kb(t, e) {
    switch (t.type) {
        case 1:
            JS(t.cases, e), e.helper("plural");
            break;
        case 2:
            JS(t.items, e);
            break;
        case 6:
            {
                Kb(t.key, e),
                e.helper("linked"),
                e.helper("type");
                break
            }
        case 5:
            e.helper("interpolate"), e.helper("list");
            break;
        case 4:
            e.helper("interpolate"), e.helper("named");
            break
    }
}

function iZ(t, e = {}) {
    const n = rZ(t);
    n.helper("normalize"), t.body && Kb(t.body, n);
    const r = n.context();
    t.helpers = Array.from(r.helpers)
}

function sZ(t) {
    const e = t.body;
    return e.type === 2 ? ZS(e) : e.cases.forEach(n => ZS(n)), t
}

function ZS(t) {
    if (t.items.length === 1) {
        const e = t.items[0];
        (e.type === 3 || e.type === 9) && (t.static = e.value, delete e.value)
    } else {
        const e = [];
        for (let n = 0; n < t.items.length; n++) {
            const r = t.items[n];
            if (!(r.type === 3 || r.type === 9) || r.value == null) break;
            e.push(r.value)
        }
        if (e.length === t.items.length) {
            t.static = Xb(e);
            for (let n = 0; n < t.items.length; n++) {
                const r = t.items[n];
                (r.type === 3 || r.type === 9) && delete r.value
            }
        }
    }
}
const oZ = "minifier";

function Ya(t) {
    switch (t.t = t.type, t.type) {
        case 0:
            {
                const e = t;Ya(e.body),
                e.b = e.body,
                delete e.body;
                break
            }
        case 1:
            {
                const e = t,
                    n = e.cases;
                for (let r = 0; r < n.length; r++) Ya(n[r]);e.c = n,
                delete e.cases;
                break
            }
        case 2:
            {
                const e = t,
                    n = e.items;
                for (let r = 0; r < n.length; r++) Ya(n[r]);e.i = n,
                delete e.items,
                e.static && (e.s = e.static, delete e.static);
                break
            }
        case 3:
        case 9:
        case 8:
        case 7:
            {
                const e = t;e.value && (e.v = e.value, delete e.value);
                break
            }
        case 6:
            {
                const e = t;Ya(e.key),
                e.k = e.key,
                delete e.key,
                e.modifier && (Ya(e.modifier), e.m = e.modifier, delete e.modifier);
                break
            }
        case 5:
            {
                const e = t;e.i = e.index,
                delete e.index;
                break
            }
        case 4:
            {
                const e = t;e.k = e.key,
                delete e.key;
                break
            }
        default:
            throw Wl($e.UNHANDLED_MINIFIER_NODE_TYPE, null, {
                domain: oZ,
                args: [t.type]
            })
    }
    delete t.type
}
const aZ = "parser";

function lZ(t, e) {
    const {
        sourceMap: n,
        filename: r,
        breakLineCode: i,
        needIndent: s
    } = e, o = e.location !== !1, a = {
        filename: r,
        code: "",
        column: 1,
        line: 1,
        offset: 0,
        map: void 0,
        breakLineCode: i,
        needIndent: s,
        indentLevel: 0
    };
    o && t.loc && (a.source = t.loc.source);
    const l = () => a;

    function c(y, m) {
        a.code += y
    }

    function u(y, m = !0) {
        const g = m ? i : "";
        c(s ? g + "  ".repeat(y) : g)
    }

    function d(y = !0) {
        const m = ++a.indentLevel;
        y && u(m)
    }

    function f(y = !0) {
        const m = --a.indentLevel;
        y && u(m)
    }

    function h() {
        u(a.indentLevel)
    }
    return {
        context: l,
        push: c,
        indent: d,
        deindent: f,
        newline: h,
        helper: y => `_${y}`,
        needIndent: () => a.needIndent
    }
}

function cZ(t, e) {
    const {
        helper: n
    } = t;
    t.push(`${n("linked")}(`), xl(t, e.key), e.modifier ? (t.push(", "), xl(t, e.modifier), t.push(", _type")) : t.push(", undefined, _type"), t.push(")")
}

function uZ(t, e) {
    const {
        helper: n,
        needIndent: r
    } = t;
    t.push(`${n("normalize")}([`), t.indent(r());
    const i = e.items.length;
    for (let s = 0; s < i && (xl(t, e.items[s]), s !== i - 1); s++) t.push(", ");
    t.deindent(r()), t.push("])")
}

function dZ(t, e) {
    const {
        helper: n,
        needIndent: r
    } = t;
    if (e.cases.length > 1) {
        t.push(`${n("plural")}([`), t.indent(r());
        const i = e.cases.length;
        for (let s = 0; s < i && (xl(t, e.cases[s]), s !== i - 1); s++) t.push(", ");
        t.deindent(r()), t.push("])")
    }
}

function fZ(t, e) {
    e.body ? xl(t, e.body) : t.push("null")
}

function xl(t, e) {
    const {
        helper: n
    } = t;
    switch (e.type) {
        case 0:
            fZ(t, e);
            break;
        case 1:
            dZ(t, e);
            break;
        case 2:
            uZ(t, e);
            break;
        case 6:
            cZ(t, e);
            break;
        case 8:
            t.push(JSON.stringify(e.value), e);
            break;
        case 7:
            t.push(JSON.stringify(e.value), e);
            break;
        case 5:
            t.push(`${n("interpolate")}(${n("list")}(${e.index}))`, e);
            break;
        case 4:
            t.push(`${n("interpolate")}(${n("named")}(${JSON.stringify(e.key)}))`, e);
            break;
        case 9:
            t.push(JSON.stringify(e.value), e);
            break;
        case 3:
            t.push(JSON.stringify(e.value), e);
            break;
        default:
            throw Wl($e.UNHANDLED_CODEGEN_NODE_TYPE, null, {
                domain: aZ,
                args: [e.type]
            })
    }
}
const hZ = (t, e = {}) => {
    const n = _e(e.mode) ? e.mode : "normal",
        r = _e(e.filename) ? e.filename : "message.intl",
        i = !!e.sourceMap,
        s = e.breakLineCode != null ? e.breakLineCode : n === "arrow" ? ";" : `
`,
        o = e.needIndent ? e.needIndent : n !== "arrow",
        a = t.helpers || [],
        l = lZ(t, {
            mode: n,
            filename: r,
            sourceMap: i,
            breakLineCode: s,
            needIndent: o
        });
    l.push(n === "normal" ? "function __msg__ (ctx) {" : "(ctx) => {"), l.indent(o), a.length > 0 && (l.push(`const { ${Xb(a.map(d=>`${d}: _${d}`),", ")} } = ctx`), l.newline()), l.push("return "), xl(l, t), l.deindent(o), l.push("}"), delete t.helpers;
    const {
        code: c,
        map: u
    } = l.context();
    return {
        ast: t,
        code: c,
        map: u ? u.toJSON() : void 0
    }
};

function pZ(t, e = {}) {
    const n = Vt({}, e),
        r = !!n.jit,
        i = !!n.minify,
        s = n.optimize == null ? !0 : n.optimize,
        a = nZ(n).parse(t);
    return r ? (s && sZ(a), i && Ya(a), {
        ast: a,
        code: ""
    }) : (iZ(a, n), hZ(a, n))
}
/*!
 * core-base v11.1.10
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */
function mZ() {
    typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Io().__INTLIFY_PROD_DEVTOOLS__ = !1), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Io().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1)
}

function vr(t) {
    return qe(t) && Jb(t) === 0 && (Mr(t, "b") || Mr(t, "body"))
}
const mR = ["b", "body"];

function gZ(t) {
    return to(t, mR)
}
const gR = ["c", "cases"];

function yZ(t) {
    return to(t, gR, [])
}
const yR = ["s", "static"];

function vZ(t) {
    return to(t, yR)
}
const vR = ["i", "items"];

function _Z(t) {
    return to(t, vR, [])
}
const _R = ["t", "type"];

function Jb(t) {
    return to(t, _R)
}
const bR = ["v", "value"];

function Zd(t, e) {
    const n = to(t, bR);
    if (n != null) return n;
    throw bu(e)
}
const xR = ["m", "modifier"];

function bZ(t) {
    return to(t, xR)
}
const wR = ["k", "key"];

function xZ(t) {
    const e = to(t, wR);
    if (e) return e;
    throw bu(6)
}

function to(t, e, n) {
    for (let r = 0; r < e.length; r++) {
        const i = e[r];
        if (Mr(t, i) && t[i] != null) return t[i]
    }
    return n
}
const ER = [...mR, ...gR, ...yR, ...vR, ...wR, ...xR, ...bR, ..._R];

function bu(t) {
    return new Error(`unhandled node type: ${t}`)
}

function qm(t) {
    return n => wZ(n, t)
}

function wZ(t, e) {
    const n = gZ(e);
    if (n == null) throw bu(0);
    if (Jb(n) === 1) {
        const s = yZ(n);
        return t.plural(s.reduce((o, a) => [...o, QS(t, a)], []))
    } else return QS(t, n)
}

function QS(t, e) {
    const n = vZ(e);
    if (n != null) return t.type === "text" ? n : t.normalize([n]); {
        const r = _Z(e).reduce((i, s) => [...i, Gv(t, s)], []);
        return t.normalize(r)
    }
}

function Gv(t, e) {
    const n = Jb(e);
    switch (n) {
        case 3:
            return Zd(e, n);
        case 9:
            return Zd(e, n);
        case 4:
            {
                const r = e;
                if (Mr(r, "k") && r.k) return t.interpolate(t.named(r.k));
                if (Mr(r, "key") && r.key) return t.interpolate(t.named(r.key));
                throw bu(n)
            }
        case 5:
            {
                const r = e;
                if (Mr(r, "i") && Lt(r.i)) return t.interpolate(t.list(r.i));
                if (Mr(r, "index") && Lt(r.index)) return t.interpolate(t.list(r.index));
                throw bu(n)
            }
        case 6:
            {
                const r = e,
                    i = bZ(r),
                    s = xZ(r);
                return t.linked(Gv(t, s), i ? Gv(t, i) : void 0, t.type)
            }
        case 7:
            return Zd(e, n);
        case 8:
            return Zd(e, n);
        default:
            throw new Error(`unhandled node on format message part: ${n}`)
    }
}
const EZ = "Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.";

function SZ(t, e) {
    e && VJ(t) && os(Lp(EZ, {
        source: t
    }))
}
const TZ = t => t;
let Qd = at();

function CZ(t, e = {}) {
    let n = !1;
    const r = e.onError || zJ;
    return e.onError = i => {
        n = !0, r(i)
    }, { ...pZ(t, e),
        detectError: n
    }
}

function PZ(t, e) {
    if (!__INTLIFY_DROP_MESSAGE_COMPILER__ && _e(t)) {
        const n = Ze(e.warnHtmlMessage) ? e.warnHtmlMessage : !0;
        SZ(t, n);
        const i = (e.onCacheKey || TZ)(t),
            s = Qd[i];
        if (s) return s;
        const {
            ast: o,
            detectError: a
        } = CZ(t, { ...e,
            location: !0,
            jit: !0
        }), l = qm(o);
        return a ? l : Qd[i] = l
    } else {
        if (!vr(t)) return os(`the message that is resolve with key '${e.key}' is not supported for jit compilation`), () => t;
        const n = t.cacheKey;
        if (n) {
            const r = Qd[n];
            return r || (Qd[n] = qm(t))
        } else return qm(t)
    }
}
let xu = null;

function AZ(t) {
    xu = t
}

function OZ(t, e, n) {
    xu && xu.emit("i18n:init", {
        timestamp: Date.now(),
        i18n: t,
        version: e,
        meta: n
    })
}
const IZ = MZ("function:translate");

function MZ(t) {
    return e => xu && xu.emit(t, e)
}
const ln = {
        INVALID_ARGUMENT: GJ,
        INVALID_DATE_ARGUMENT: 18,
        INVALID_ISO_DATE_ARGUMENT: 19,
        NOT_SUPPORT_NON_STRING_MESSAGE: 20,
        NOT_SUPPORT_LOCALE_PROMISE_VALUE: 21,
        NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: 22,
        NOT_SUPPORT_LOCALE_TYPE: 23
    },
    RZ = 24;

function $i(t) {
    return Wl(t, null, {
        messages: kZ
    })
}
const kZ = {
    [ln.INVALID_ARGUMENT]: "Invalid arguments",
    [ln.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
    [ln.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
    [ln.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
    [ln.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
    [ln.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
    [ln.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};

function Zb(t, e) {
    return e.locale != null ? e1(e.locale) : e1(t.locale)
}
let Km;

function e1(t) {
    if (_e(t)) return t;
    if (lt(t)) {
        if (t.resolvedOnce && Km != null) return Km;
        if (t.constructor.name === "Function") {
            const e = t();
            if (FJ(e)) throw $i(ln.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
            return Km = e
        } else throw $i(ln.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION)
    } else throw $i(ln.NOT_SUPPORT_LOCALE_TYPE)
}

function BZ(t, e, n) {
    return [...new Set([n, ...wt(e) ? e : qe(e) ? Object.keys(e) : _e(e) ? [e] : [n]])]
}

function SR(t, e, n) {
    const r = _e(n) ? n : wu,
        i = t;
    i.__localeChainCache || (i.__localeChainCache = new Map);
    let s = i.__localeChainCache.get(r);
    if (!s) {
        s = [];
        let o = [n];
        for (; wt(o);) o = t1(s, o, e);
        const a = wt(e) || !He(e) ? e : e.default ? e.default : null;
        o = _e(a) ? [a] : a, wt(o) && t1(s, o, !1), i.__localeChainCache.set(r, s)
    }
    return s
}

function t1(t, e, n) {
    let r = !0;
    for (let i = 0; i < e.length && Ze(r); i++) {
        const s = e[i];
        _e(s) && (r = DZ(t, e[i], n))
    }
    return r
}

function DZ(t, e, n) {
    let r;
    const i = e.split("-");
    do {
        const s = i.join("-");
        r = $Z(t, s, n), i.splice(-1, 1)
    } while (i.length && r === !0);
    return r
}

function $Z(t, e, n) {
    let r = !1;
    if (!t.includes(e) && (r = !0, e)) {
        r = e[e.length - 1] !== "!";
        const i = e.replace(/!/g, "");
        t.push(i), (wt(n) || He(n)) && n[i] && (r = n[i])
    }
    return r
}
const no = [];
no[0] = {
    w: [0],
    i: [3, 0],
    "[": [4],
    o: [7]
};
no[1] = {
    w: [1],
    ".": [2],
    "[": [4],
    o: [7]
};
no[2] = {
    w: [2],
    i: [3, 0],
    0: [3, 0]
};
no[3] = {
    i: [3, 0],
    0: [3, 0],
    w: [1, 1],
    ".": [2, 1],
    "[": [4, 1],
    o: [7, 1]
};
no[4] = {
    "'": [5, 0],
    '"': [6, 0],
    "[": [4, 2],
    "]": [1, 3],
    o: 8,
    l: [4, 0]
};
no[5] = {
    "'": [4, 0],
    o: 8,
    l: [5, 0]
};
no[6] = {
    '"': [4, 0],
    o: 8,
    l: [6, 0]
};
const FZ = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;

function LZ(t) {
    return FZ.test(t)
}

function NZ(t) {
    const e = t.charCodeAt(0),
        n = t.charCodeAt(t.length - 1);
    return e === n && (e === 34 || e === 39) ? t.slice(1, -1) : t
}

function UZ(t) {
    if (t == null) return "o";
    switch (t.charCodeAt(0)) {
        case 91:
        case 93:
        case 46:
        case 34:
        case 39:
            return t;
        case 95:
        case 36:
        case 45:
            return "i";
        case 9:
        case 10:
        case 13:
        case 160:
        case 65279:
        case 8232:
        case 8233:
            return "w"
    }
    return "i"
}

function GZ(t) {
    const e = t.trim();
    return t.charAt(0) === "0" && isNaN(parseInt(t)) ? !1 : LZ(e) ? NZ(e) : "*" + e
}

function HZ(t) {
    const e = [];
    let n = -1,
        r = 0,
        i = 0,
        s, o, a, l, c, u, d;
    const f = [];
    f[0] = () => {
        o === void 0 ? o = a : o += a
    }, f[1] = () => {
        o !== void 0 && (e.push(o), o = void 0)
    }, f[2] = () => {
        f[0](), i++
    }, f[3] = () => {
        if (i > 0) i--, r = 4, f[0]();
        else {
            if (i = 0, o === void 0 || (o = GZ(o), o === !1)) return !1;
            f[1]()
        }
    };

    function h() {
        const p = t[n + 1];
        if (r === 5 && p === "'" || r === 6 && p === '"') return n++, a = "\\" + p, f[0](), !0
    }
    for (; r !== null;)
        if (n++, s = t[n], !(s === "\\" && h())) {
            if (l = UZ(s), d = no[r], c = d[l] || d.l || 8, c === 8 || (r = c[0], c[1] !== void 0 && (u = f[c[1]], u && (a = s, u() === !1)))) return;
            if (r === 7) return e
        }
}
const n1 = new Map;

function zZ(t, e) {
    return qe(t) ? t[e] : null
}

function jZ(t, e) {
    if (!qe(t)) return null;
    let n = n1.get(e);
    if (n || (n = HZ(e), n && n1.set(e, n)), !n) return null;
    const r = n.length;
    let i = t,
        s = 0;
    for (; s < r;) {
        const o = n[s];
        if (ER.includes(o) && vr(i)) return null;
        const a = i[o];
        if (a === void 0 || lt(i)) return null;
        i = a, s++
    }
    return i
}
const Rn = {
        NOT_FOUND_KEY: 1,
        FALLBACK_TO_TRANSLATE: 2,
        CANNOT_FORMAT_NUMBER: 3,
        FALLBACK_TO_NUMBER_FORMAT: 4,
        CANNOT_FORMAT_DATE: 5,
        FALLBACK_TO_DATE_FORMAT: 6,
        EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: 7
    },
    VZ = 8,
    WZ = {
        [Rn.NOT_FOUND_KEY]: "Not found '{key}' key in '{locale}' locale messages.",
        [Rn.FALLBACK_TO_TRANSLATE]: "Fall back to translate '{key}' key with '{target}' locale.",
        [Rn.CANNOT_FORMAT_NUMBER]: "Cannot format a number value due to not supported Intl.NumberFormat.",
        [Rn.FALLBACK_TO_NUMBER_FORMAT]: "Fall back to number format '{key}' key with '{target}' locale.",
        [Rn.CANNOT_FORMAT_DATE]: "Cannot format a date value due to not supported Intl.DateTimeFormat.",
        [Rn.FALLBACK_TO_DATE_FORMAT]: "Fall back to datetime format '{key}' key with '{target}' locale.",
        [Rn.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: "This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future."
    };

function ea(t, ...e) {
    return Lp(WZ[t], ...e)
}
const YZ = "11.1.10",
    Up = -1,
    wu = "en-US",
    Eh = "",
    r1 = t => `${t.charAt(0).toLocaleUpperCase()}${t.substr(1)}`;

function XZ() {
    return {
        upper: (t, e) => e === "text" && _e(t) ? t.toUpperCase() : e === "vnode" && qe(t) && "__v_isVNode" in t ? t.children.toUpperCase() : t,
        lower: (t, e) => e === "text" && _e(t) ? t.toLowerCase() : e === "vnode" && qe(t) && "__v_isVNode" in t ? t.children.toLowerCase() : t,
        capitalize: (t, e) => e === "text" && _e(t) ? r1(t) : e === "vnode" && qe(t) && "__v_isVNode" in t ? r1(t.children) : t
    }
}
let TR;

function qZ(t) {
    TR = t
}
let CR;

function KZ(t) {
    CR = t
}
let PR;

function JZ(t) {
    PR = t
}
let AR = null;
const ZZ = t => {
        AR = t
    },
    QZ = () => AR;
let OR = null;
const i1 = t => {
        OR = t
    },
    eQ = () => OR;
let s1 = 0;

function tQ(t = {}) {
    const e = lt(t.onWarn) ? t.onWarn : os,
        n = _e(t.version) ? t.version : YZ,
        r = _e(t.locale) || lt(t.locale) ? t.locale : wu,
        i = lt(r) ? wu : r,
        s = wt(t.fallbackLocale) || He(t.fallbackLocale) || _e(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : i,
        o = He(t.messages) ? t.messages : Jm(i),
        a = He(t.datetimeFormats) ? t.datetimeFormats : Jm(i),
        l = He(t.numberFormats) ? t.numberFormats : Jm(i),
        c = Vt(at(), t.modifiers, XZ()),
        u = t.pluralRules || at(),
        d = lt(t.missing) ? t.missing : null,
        f = Ze(t.missingWarn) || bl(t.missingWarn) ? t.missingWarn : !0,
        h = Ze(t.fallbackWarn) || bl(t.fallbackWarn) ? t.fallbackWarn : !0,
        p = !!t.fallbackFormat,
        b = !!t.unresolving,
        y = lt(t.postTranslation) ? t.postTranslation : null,
        m = He(t.processor) ? t.processor : null,
        g = Ze(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
        v = !!t.escapeParameter,
        _ = lt(t.messageCompiler) ? t.messageCompiler : TR;
    lt(t.messageCompiler) && Wb(ea(Rn.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
    const x = lt(t.messageResolver) ? t.messageResolver : CR || zZ,
        w = lt(t.localeFallbacker) ? t.localeFallbacker : PR || BZ,
        E = qe(t.fallbackContext) ? t.fallbackContext : void 0,
        C = t,
        A = qe(C.__datetimeFormatters) ? C.__datetimeFormatters : new Map,
        T = qe(C.__numberFormatters) ? C.__numberFormatters : new Map,
        S = qe(C.__meta) ? C.__meta : {};
    s1++;
    const P = {
        version: n,
        cid: s1,
        locale: r,
        fallbackLocale: s,
        messages: o,
        modifiers: c,
        pluralRules: u,
        missing: d,
        missingWarn: f,
        fallbackWarn: h,
        fallbackFormat: p,
        unresolving: b,
        postTranslation: y,
        processor: m,
        warnHtmlMessage: g,
        escapeParameter: v,
        messageCompiler: _,
        messageResolver: x,
        localeFallbacker: w,
        fallbackContext: E,
        onWarn: e,
        __meta: S
    };
    return P.datetimeFormats = a, P.numberFormats = l, P.__datetimeFormatters = A, P.__numberFormatters = T, P.__v_emitter = C.__v_emitter != null ? C.__v_emitter : void 0, OZ(P, n, S), P
}
const Jm = t => ({
    [t]: at()
});

function Gp(t, e) {
    return t instanceof RegExp ? t.test(e) : t
}

function IR(t, e) {
    return t instanceof RegExp ? t.test(e) : t
}

function Qb(t, e, n, r, i) {
    const {
        missing: s,
        onWarn: o
    } = t; {
        const a = t.__v_emitter;
        a && a.emit("missing", {
            locale: n,
            key: e,
            type: i,
            groupId: `${i}:${e}`
        })
    }
    if (s !== null) {
        const a = s(t, n, e, i);
        return _e(a) ? a : e
    } else return IR(r, e) && o(ea(Rn.NOT_FOUND_KEY, {
        key: e,
        locale: n
    })), e
}

function dc(t, e, n) {
    const r = t;
    r.__localeChainCache = new Map, t.localeFallbacker(t, n, e)
}

function MR(t, e) {
    return t === e ? !1 : t.split("-")[0] === e.split("-")[0]
}

function nQ(t, e) {
    const n = e.indexOf(t);
    if (n === -1) return !1;
    for (let r = n + 1; r < e.length; r++)
        if (MR(t, e[r])) return !0;
    return !1
}
const o1 = typeof Intl < "u",
    RR = {
        dateTimeFormat: o1 && typeof Intl.DateTimeFormat < "u",
        numberFormat: o1 && typeof Intl.NumberFormat < "u"
    };

function a1(t, ...e) {
    const {
        datetimeFormats: n,
        unresolving: r,
        fallbackLocale: i,
        onWarn: s,
        localeFallbacker: o
    } = t, {
        __datetimeFormatters: a
    } = t;
    if (!RR.dateTimeFormat) return s(ea(Rn.CANNOT_FORMAT_DATE)), Eh;
    const [l, c, u, d] = Hv(...e), f = Ze(u.missingWarn) ? u.missingWarn : t.missingWarn, h = Ze(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn, p = !!u.part, b = Zb(t, u), y = o(t, i, b);
    if (!_e(l) || l === "") return new Intl.DateTimeFormat(b, d).format(c);
    let m = {},
        g, v = null,
        _ = b,
        x = null;
    const w = "datetime format";
    for (let A = 0; A < y.length; A++) {
        if (g = x = y[A], b !== g && Gp(h, l) && s(ea(Rn.FALLBACK_TO_DATE_FORMAT, {
                key: l,
                target: g
            })), b !== g) {
            const T = t.__v_emitter;
            T && T.emit("fallback", {
                type: w,
                key: l,
                from: _,
                to: x,
                groupId: `${w}:${l}`
            })
        }
        if (m = n[g] || {}, v = m[l], He(v)) break;
        Qb(t, l, g, f, w), _ = x
    }
    if (!He(v) || !_e(g)) return r ? Up : l;
    let E = `${g}__${l}`;
    Np(d) || (E = `${E}__${JSON.stringify(d)}`);
    let C = a.get(E);
    return C || (C = new Intl.DateTimeFormat(g, Vt({}, v, d)), a.set(E, C)), p ? C.formatToParts(c) : C.format(c)
}
const kR = ["localeMatcher", "weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "formatMatcher", "hour12", "timeZone", "dateStyle", "timeStyle", "calendar", "dayPeriod", "numberingSystem", "hourCycle", "fractionalSecondDigits"];

function Hv(...t) {
    const [e, n, r, i] = t, s = at();
    let o = at(),
        a;
    if (_e(e)) {
        const l = e.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
        if (!l) throw $i(ln.INVALID_ISO_DATE_ARGUMENT);
        const c = l[3] ? l[3].trim().startsWith("T") ? `${l[1].trim()}${l[3].trim()}` : `${l[1].trim()}T${l[3].trim()}` : l[1].trim();
        a = new Date(c);
        try {
            a.toISOString()
        } catch {
            throw $i(ln.INVALID_ISO_DATE_ARGUMENT)
        }
    } else if (kJ(e)) {
        if (isNaN(e.getTime())) throw $i(ln.INVALID_DATE_ARGUMENT);
        a = e
    } else if (Lt(e)) a = e;
    else throw $i(ln.INVALID_ARGUMENT);
    return _e(n) ? s.key = n : He(n) && Object.keys(n).forEach(l => {
        kR.includes(l) ? o[l] = n[l] : s[l] = n[l]
    }), _e(r) ? s.locale = r : He(r) && (o = r), He(i) && (o = i), [s.key || "", a, s, o]
}

function l1(t, e, n) {
    const r = t;
    for (const i in n) {
        const s = `${e}__${i}`;
        r.__datetimeFormatters.has(s) && r.__datetimeFormatters.delete(s)
    }
}

function c1(t, ...e) {
    const {
        numberFormats: n,
        unresolving: r,
        fallbackLocale: i,
        onWarn: s,
        localeFallbacker: o
    } = t, {
        __numberFormatters: a
    } = t;
    if (!RR.numberFormat) return s(ea(Rn.CANNOT_FORMAT_NUMBER)), Eh;
    const [l, c, u, d] = zv(...e), f = Ze(u.missingWarn) ? u.missingWarn : t.missingWarn, h = Ze(u.fallbackWarn) ? u.fallbackWarn : t.fallbackWarn, p = !!u.part, b = Zb(t, u), y = o(t, i, b);
    if (!_e(l) || l === "") return new Intl.NumberFormat(b, d).format(c);
    let m = {},
        g, v = null,
        _ = b,
        x = null;
    const w = "number format";
    for (let A = 0; A < y.length; A++) {
        if (g = x = y[A], b !== g && Gp(h, l) && s(ea(Rn.FALLBACK_TO_NUMBER_FORMAT, {
                key: l,
                target: g
            })), b !== g) {
            const T = t.__v_emitter;
            T && T.emit("fallback", {
                type: w,
                key: l,
                from: _,
                to: x,
                groupId: `${w}:${l}`
            })
        }
        if (m = n[g] || {}, v = m[l], He(v)) break;
        Qb(t, l, g, f, w), _ = x
    }
    if (!He(v) || !_e(g)) return r ? Up : l;
    let E = `${g}__${l}`;
    Np(d) || (E = `${E}__${JSON.stringify(d)}`);
    let C = a.get(E);
    return C || (C = new Intl.NumberFormat(g, Vt({}, v, d)), a.set(E, C)), p ? C.formatToParts(c) : C.format(c)
}
const BR = ["localeMatcher", "style", "currency", "currencyDisplay", "currencySign", "useGrouping", "minimumIntegerDigits", "minimumFractionDigits", "maximumFractionDigits", "minimumSignificantDigits", "maximumSignificantDigits", "compactDisplay", "notation", "signDisplay", "unit", "unitDisplay", "roundingMode", "roundingPriority", "roundingIncrement", "trailingZeroDisplay"];

function zv(...t) {
    const [e, n, r, i] = t, s = at();
    let o = at();
    if (!Lt(e)) throw $i(ln.INVALID_ARGUMENT);
    const a = e;
    return _e(n) ? s.key = n : He(n) && Object.keys(n).forEach(l => {
        BR.includes(l) ? o[l] = n[l] : s[l] = n[l]
    }), _e(r) ? s.locale = r : He(r) && (o = r), He(i) && (o = i), [s.key || "", a, s, o]
}

function u1(t, e, n) {
    const r = t;
    for (const i in n) {
        const s = `${e}__${i}`;
        r.__numberFormatters.has(s) && r.__numberFormatters.delete(s)
    }
}
const rQ = t => t,
    iQ = t => "",
    sQ = "text",
    oQ = t => t.length === 0 ? "" : Xb(t),
    aQ = LJ;

function d1(t, e) {
    return t = Math.abs(t), e === 2 ? t ? t > 1 ? 1 : 0 : 1 : t ? Math.min(t, 2) : 0
}

function lQ(t) {
    const e = Lt(t.pluralIndex) ? t.pluralIndex : -1;
    return t.named && (Lt(t.named.count) || Lt(t.named.n)) ? Lt(t.named.count) ? t.named.count : Lt(t.named.n) ? t.named.n : e : e
}

function cQ(t, e) {
    e.count || (e.count = t), e.n || (e.n = t)
}

function uQ(t = {}) {
    const e = t.locale,
        n = lQ(t),
        r = qe(t.pluralRules) && _e(e) && lt(t.pluralRules[e]) ? t.pluralRules[e] : d1,
        i = qe(t.pluralRules) && _e(e) && lt(t.pluralRules[e]) ? d1 : void 0,
        s = m => m[r(n, m.length, i)],
        o = t.list || [],
        a = m => o[m],
        l = t.named || at();
    Lt(t.pluralIndex) && cQ(n, l);
    const c = m => l[m];

    function u(m, g) {
        const v = lt(t.messages) ? t.messages(m, !!g) : qe(t.messages) ? t.messages[m] : !1;
        return v || (t.parent ? t.parent.message(m) : iQ)
    }
    const d = m => t.modifiers ? t.modifiers[m] : rQ,
        f = He(t.processor) && lt(t.processor.normalize) ? t.processor.normalize : oQ,
        h = He(t.processor) && lt(t.processor.interpolate) ? t.processor.interpolate : aQ,
        p = He(t.processor) && _e(t.processor.type) ? t.processor.type : sQ,
        y = {
            list: a,
            named: c,
            plural: s,
            linked: (m, ...g) => {
                const [v, _] = g;
                let x = "text",
                    w = "";
                g.length === 1 ? qe(v) ? (w = v.modifier || w, x = v.type || x) : _e(v) && (w = v || w) : g.length === 2 && (_e(v) && (w = v || w), _e(_) && (x = _ || x));
                const E = u(m, !0)(y),
                    C = x === "vnode" && wt(E) && w ? E[0] : E;
                return w ? d(w)(C, x) : C
            },
            message: u,
            type: p,
            interpolate: h,
            normalize: f,
            values: Vt(at(), o, l)
        };
    return y
}
const f1 = () => "",
    fr = t => lt(t);

function h1(t, ...e) {
    const {
        fallbackFormat: n,
        postTranslation: r,
        unresolving: i,
        messageCompiler: s,
        fallbackLocale: o,
        messages: a
    } = t, [l, c] = jv(...e), u = Ze(c.missingWarn) ? c.missingWarn : t.missingWarn, d = Ze(c.fallbackWarn) ? c.fallbackWarn : t.fallbackWarn, f = Ze(c.escapeParameter) ? c.escapeParameter : t.escapeParameter, h = !!c.resolvedMessage, p = _e(c.default) || Ze(c.default) ? Ze(c.default) ? s ? l : () => l : c.default : n ? s ? l : () => l : null, b = n || p != null && (_e(p) || lt(p)), y = Zb(t, c);
    f && dQ(c);
    let [m, g, v] = h ? [l, y, a[y] || at()] : DR(t, l, y, o, d, u), _ = m, x = l;
    if (!h && !(_e(_) || vr(_) || fr(_)) && b && (_ = p, x = _), !h && (!(_e(_) || vr(_) || fr(_)) || !_e(g))) return i ? Up : l;
    if (_e(_) && t.messageCompiler == null) return os(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${l}'.`), l;
    let w = !1;
    const E = () => {
            w = !0
        },
        C = fr(_) ? _ : $R(t, l, g, _, x, E);
    if (w) return _;
    const A = mQ(t, g, v, c),
        T = uQ(A),
        S = fQ(t, C, T);
    let P = r ? r(S, l) : S;
    f && _e(P) && (P = DJ(P)); {
        const R = {
            timestamp: Date.now(),
            key: _e(l) ? l : fr(_) ? _.key : "",
            locale: g || (fr(_) ? _.locale : ""),
            format: _e(_) ? _ : fr(_) ? _.source : "",
            message: P
        };
        R.meta = Vt({}, t.__meta, QZ() || {}), IZ(R)
    }
    return P
}

function dQ(t) {
    wt(t.list) ? t.list = t.list.map(e => _e(e) ? YS(e) : e) : qe(t.named) && Object.keys(t.named).forEach(e => {
        _e(t.named[e]) && (t.named[e] = YS(t.named[e]))
    })
}

function DR(t, e, n, r, i, s) {
    const {
        messages: o,
        onWarn: a,
        messageResolver: l,
        localeFallbacker: c
    } = t, u = c(t, r, n);
    let d = at(),
        f, h = null,
        p = n,
        b = null;
    const y = "translate";
    for (let m = 0; m < u.length; m++) {
        if (f = b = u[m], n !== f && !MR(n, f) && Gp(i, e) && a(ea(Rn.FALLBACK_TO_TRANSLATE, {
                key: e,
                target: f
            })), n !== f) {
            const x = t.__v_emitter;
            x && x.emit("fallback", {
                type: y,
                key: e,
                from: p,
                to: b,
                groupId: `${y}:${e}`
            })
        }
        d = o[f] || at();
        let g = null,
            v, _;
        if ($r && (g = window.performance.now(), v = "intlify-message-resolve-start", _ = "intlify-message-resolve-end", Xn && Xn(v)), (h = l(d, e)) === null && (h = d[e]), $r) {
            const x = window.performance.now(),
                w = t.__v_emitter;
            w && g && h && w.emit("message-resolve", {
                type: "message-resolve",
                key: e,
                message: h,
                time: x - g,
                groupId: `${y}:${e}`
            }), v && _ && Xn && Qo && (Xn(_), Qo("intlify message resolve", v, _))
        }
        if (_e(h) || vr(h) || fr(h)) break;
        if (!nQ(f, u)) {
            const x = Qb(t, e, f, s, y);
            x !== e && (h = x)
        }
        p = b
    }
    return [h, f, d]
}

function $R(t, e, n, r, i, s) {
    const {
        messageCompiler: o,
        warnHtmlMessage: a
    } = t;
    if (fr(r)) {
        const f = r;
        return f.locale = f.locale || n, f.key = f.key || e, f
    }
    if (o == null) {
        const f = () => r;
        return f.locale = n, f.key = e, f
    }
    let l = null,
        c, u;
    $r && (l = window.performance.now(), c = "intlify-message-compilation-start", u = "intlify-message-compilation-end", Xn && Xn(c));
    const d = o(r, hQ(t, n, i, r, a, s));
    if ($r) {
        const f = window.performance.now(),
            h = t.__v_emitter;
        h && l && h.emit("message-compilation", {
            type: "message-compilation",
            message: r,
            time: f - l,
            groupId: `translate:${e}`
        }), c && u && Xn && Qo && (Xn(u), Qo("intlify message compilation", c, u))
    }
    return d.locale = n, d.key = e, d.source = r, d
}

function fQ(t, e, n) {
    let r = null,
        i, s;
    $r && (r = window.performance.now(), i = "intlify-message-evaluation-start", s = "intlify-message-evaluation-end", Xn && Xn(i));
    const o = e(n);
    if ($r) {
        const a = window.performance.now(),
            l = t.__v_emitter;
        l && r && l.emit("message-evaluation", {
            type: "message-evaluation",
            value: o,
            time: a - r,
            groupId: `translate:${e.key}`
        }), i && s && Xn && Qo && (Xn(s), Qo("intlify message evaluation", i, s))
    }
    return o
}

function jv(...t) {
    const [e, n, r] = t, i = at();
    if (!_e(e) && !Lt(e) && !fr(e) && !vr(e)) throw $i(ln.INVALID_ARGUMENT);
    const s = Lt(e) ? String(e) : (fr(e), e);
    return Lt(n) ? i.plural = n : _e(n) ? i.default = n : He(n) && !Np(n) ? i.named = n : wt(n) && (i.list = n), Lt(r) ? i.plural = r : _e(r) ? i.default = r : He(r) && Vt(i, r), [s, i]
}

function hQ(t, e, n, r, i, s) {
    return {
        locale: e,
        key: n,
        warnHtmlMessage: i,
        onError: o => {
            s && s(o); {
                const a = pQ(r),
                    l = `Message compilation error: ${o.message}`,
                    c = o.location && a && NJ(a, o.location.start.offset, o.location.end.offset),
                    u = t.__v_emitter;
                u && a && u.emit("compile-error", {
                    message: a,
                    error: o.message,
                    start: o.location && o.location.start.offset,
                    end: o.location && o.location.end.offset,
                    groupId: `translate:${n}`
                }), console.error(c ? `${l}
${c}` : l)
            }
        },
        onCacheKey: o => MJ(e, n, o)
    }
}

function pQ(t) {
    if (_e(t)) return t;
    if (t.loc && t.loc.source) return t.loc.source
}

function mQ(t, e, n, r) {
    const {
        modifiers: i,
        pluralRules: s,
        messageResolver: o,
        fallbackLocale: a,
        fallbackWarn: l,
        missingWarn: c,
        fallbackContext: u
    } = t, f = {
        locale: e,
        modifiers: i,
        pluralRules: s,
        messages: (h, p) => {
            let b = o(n, h);
            if (b == null && (u || p)) {
                const [, , y] = DR(u || t, h, e, a, l, c);
                b = o(y, h)
            }
            if (_e(b) || vr(b)) {
                let y = !1;
                const g = $R(t, h, e, b, h, () => {
                    y = !0
                });
                return y ? f1 : g
            } else return fr(b) ? b : f1
        }
    };
    return t.processor && (f.processor = t.processor), r.list && (f.list = r.list), r.named && (f.named = r.named), Lt(r.plural) && (f.pluralIndex = r.plural), f
}
mZ();
/*!
 * vue-i18n v11.1.10
 * (c) 2025 kazuya kawaguchi
 * Released under the MIT License.
 */
const gQ = "11.1.10";

function yQ() {
    typeof __VUE_I18N_FULL_INSTALL__ != "boolean" && (Io().__VUE_I18N_FULL_INSTALL__ = !0), typeof __VUE_I18N_LEGACY_API__ != "boolean" && (Io().__VUE_I18N_LEGACY_API__ = !0), typeof __INTLIFY_DROP_MESSAGE_COMPILER__ != "boolean" && (Io().__INTLIFY_DROP_MESSAGE_COMPILER__ = !1), typeof __INTLIFY_PROD_DEVTOOLS__ != "boolean" && (Io().__INTLIFY_PROD_DEVTOOLS__ = !1)
}
const st = {
    UNEXPECTED_RETURN_TYPE: RZ,
    INVALID_ARGUMENT: 25,
    MUST_BE_CALL_SETUP_TOP: 26,
    NOT_INSTALLED: 27,
    REQUIRED_VALUE: 28,
    INVALID_VALUE: 29,
    CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: 30,
    NOT_INSTALLED_WITH_PROVIDE: 31,
    UNEXPECTED_ERROR: 32,
    NOT_COMPATIBLE_LEGACY_VUE_I18N: 33,
    NOT_AVAILABLE_COMPOSITION_IN_LEGACY: 34,
    DUPLICATE_USE_I18N_CALLING: 35
};

function Tn(t, ...e) {
    return Wl(t, null, {
        messages: vQ,
        args: e
    })
}
const vQ = {
        [st.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
        [st.INVALID_ARGUMENT]: "Invalid argument",
        [st.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
        [st.NOT_INSTALLED]: "Need to install with `app.use` function",
        [st.UNEXPECTED_ERROR]: "Unexpected error",
        [st.REQUIRED_VALUE]: "Required in value: {0}",
        [st.INVALID_VALUE]: "Invalid value",
        [st.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: "Cannot setup vue-devtools plugin",
        [st.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
        [st.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
        [st.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly",
        [st.DUPLICATE_USE_I18N_CALLING]: "Duplicate `useI18n` calling by local scope. Please don't call it on local scope"
    },
    Vv = mi("__translateVNode"),
    Wv = mi("__datetimeParts"),
    Yv = mi("__numberParts"),
    ta = mi("__enableEmitter"),
    Eu = mi("__disableEmitter"),
    FR = mi("__setPluralRules"),
    LR = mi("__injectWithOption"),
    Xv = mi("__dispose"),
    ti = {
        FALLBACK_TO_ROOT: VZ,
        NOT_FOUND_PARENT_SCOPE: 9,
        IGNORE_OBJ_FLATTEN: 10,
        DEPRECATE_LEGACY_MODE: 11,
        DEPRECATE_TRANSLATE_CUSTOME_DIRECTIVE: 12
    },
    _Q = {
        [ti.FALLBACK_TO_ROOT]: "Fall back to {type} '{key}' with root locale.",
        [ti.NOT_FOUND_PARENT_SCOPE]: "Not found parent scope. use the global scope.",
        [ti.IGNORE_OBJ_FLATTEN]: "Ignore object flatten: '{key}' key has an string value",
        [ti.DEPRECATE_LEGACY_MODE]: `Legacy API mode has been deprecated in v11. Use Composition API mode instead.
About how to use the Composition API mode, see https://vue-i18n.intlify.dev/guide/advanced/composition.html`,
        [ti.DEPRECATE_TRANSLATE_CUSTOME_DIRECTIVE]: "'v-t' has been deprecated in v11. Use translate APIs ('t' or '$t') instead."
    };

function cd(t, ...e) {
    return Lp(_Q[t], ...e)
}

function Su(t) {
    if (!qe(t) || vr(t)) return t;
    for (const e in t)
        if (Mr(t, e))
            if (!e.includes(".")) qe(t[e]) && Su(t[e]);
            else {
                const n = e.split("."),
                    r = n.length - 1;
                let i = t,
                    s = !1;
                for (let o = 0; o < r; o++) {
                    if (n[o] === "__proto__") throw new Error(`unsafe key: ${n[o]}`);
                    if (n[o] in i || (i[n[o]] = at()), !qe(i[n[o]])) {
                        os(cd(ti.IGNORE_OBJ_FLATTEN, {
                            key: n[o]
                        })), s = !0;
                        break
                    }
                    i = i[n[o]]
                }
                if (s || (vr(i) ? ER.includes(n[r]) || delete t[e] : (i[n[r]] = t[e], delete t[e])), !vr(i)) {
                    const o = i[n[r]];
                    qe(o) && Su(o)
                }
            }
    return t
}

function ex(t, e) {
    const {
        messages: n,
        __i18n: r,
        messageResolver: i,
        flatJson: s
    } = e, o = He(n) ? n : wt(r) ? at() : {
        [t]: at()
    };
    if (wt(r) && r.forEach(a => {
            if ("locale" in a && "resource" in a) {
                const {
                    locale: l,
                    resource: c
                } = a;
                l ? (o[l] = o[l] || at(), Hf(c, o[l])) : Hf(c, o)
            } else _e(a) && Hf(JSON.parse(a), o)
        }), i == null && s)
        for (const a in o) Mr(o, a) && Su(o[a]);
    return o
}

function NR(t) {
    return t.type
}

function UR(t, e, n) {
    let r = qe(e.messages) ? e.messages : at();
    "__i18nGlobal" in n && (r = ex(t.locale.value, {
        messages: r,
        __i18n: n.__i18nGlobal
    }));
    const i = Object.keys(r);
    i.length && i.forEach(s => {
        t.mergeLocaleMessage(s, r[s])
    }); {
        if (qe(e.datetimeFormats)) {
            const s = Object.keys(e.datetimeFormats);
            s.length && s.forEach(o => {
                t.mergeDateTimeFormat(o, e.datetimeFormats[o])
            })
        }
        if (qe(e.numberFormats)) {
            const s = Object.keys(e.numberFormats);
            s.length && s.forEach(o => {
                t.mergeNumberFormat(o, e.numberFormats[o])
            })
        }
    }
}

function p1(t) {
    return I(li, null, t, 0)
}
const m1 = "__INTLIFY_META__",
    g1 = () => [],
    bQ = () => !1;
let y1 = 0;

function v1(t) {
    return (e, n, r, i) => t(n, r, rt() || void 0, i)
}
const xQ = () => {
    const t = rt();
    let e = null;
    return t && (e = NR(t)[m1]) ? {
        [m1]: e
    } : null
};

function tx(t = {}) {
    const {
        __root: e,
        __injectWithOption: n
    } = t, r = e === void 0, i = t.flatJson, s = $r ? q : np;
    let o = Ze(t.inheritLocale) ? t.inheritLocale : !0;
    const a = s(e && o ? e.locale.value : _e(t.locale) ? t.locale : wu),
        l = s(e && o ? e.fallbackLocale.value : _e(t.fallbackLocale) || wt(t.fallbackLocale) || He(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : a.value),
        c = s(ex(a.value, t)),
        u = s(He(t.datetimeFormats) ? t.datetimeFormats : {
            [a.value]: {}
        }),
        d = s(He(t.numberFormats) ? t.numberFormats : {
            [a.value]: {}
        });
    let f = e ? e.missingWarn : Ze(t.missingWarn) || bl(t.missingWarn) ? t.missingWarn : !0,
        h = e ? e.fallbackWarn : Ze(t.fallbackWarn) || bl(t.fallbackWarn) ? t.fallbackWarn : !0,
        p = e ? e.fallbackRoot : Ze(t.fallbackRoot) ? t.fallbackRoot : !0,
        b = !!t.fallbackFormat,
        y = lt(t.missing) ? t.missing : null,
        m = lt(t.missing) ? v1(t.missing) : null,
        g = lt(t.postTranslation) ? t.postTranslation : null,
        v = e ? e.warnHtmlMessage : Ze(t.warnHtmlMessage) ? t.warnHtmlMessage : !0,
        _ = !!t.escapeParameter;
    const x = e ? e.modifiers : He(t.modifiers) ? t.modifiers : {};
    let w = t.pluralRules || e && e.pluralRules,
        E;
    E = (() => {
        r && i1(null);
        const z = {
            version: gQ,
            locale: a.value,
            fallbackLocale: l.value,
            messages: c.value,
            modifiers: x,
            pluralRules: w,
            missing: m === null ? void 0 : m,
            missingWarn: f,
            fallbackWarn: h,
            fallbackFormat: b,
            unresolving: !0,
            postTranslation: g === null ? void 0 : g,
            warnHtmlMessage: v,
            escapeParameter: _,
            messageResolver: t.messageResolver,
            messageCompiler: t.messageCompiler,
            __meta: {
                framework: "vue"
            }
        };
        z.datetimeFormats = u.value, z.numberFormats = d.value, z.__datetimeFormatters = He(E) ? E.__datetimeFormatters : void 0, z.__numberFormatters = He(E) ? E.__numberFormatters : void 0, z.__v_emitter = He(E) ? E.__v_emitter : void 0;
        const ee = tQ(z);
        return r && i1(ee), ee
    })(), dc(E, a.value, l.value);

    function A() {
        return [a.value, l.value, c.value, u.value, d.value]
    }
    const T = te({
            get: () => a.value,
            set: z => {
                E.locale = z, a.value = z
            }
        }),
        S = te({
            get: () => l.value,
            set: z => {
                E.fallbackLocale = z, l.value = z, dc(E, a.value, z)
            }
        }),
        P = te(() => c.value),
        R = te(() => u.value),
        D = te(() => d.value);

    function H() {
        return lt(g) ? g : null
    }

    function B(z) {
        g = z, E.postTranslation = z
    }

    function N() {
        return y
    }

    function V(z) {
        z !== null && (m = v1(z)), y = z, E.missing = m
    }

    function Y(z, ee) {
        return z !== "translate" || !ee.resolvedMessage
    }
    const le = (z, ee, xe, ke, Ve, ht) => {
        A();
        let Yt;
        try {
            r || (E.fallbackContext = e ? eQ() : void 0), Yt = z(E)
        } finally {
            r || (E.fallbackContext = void 0)
        }
        if (xe !== "translate exists" && Lt(Yt) && Yt === Up || xe === "translate exists" && !Yt) {
            const [On, Cd] = ee();
            if (e && _e(On) && Y(xe, Cd)) {
                p && (Gp(h, On) || IR(f, On)) && os(cd(ti.FALLBACK_TO_ROOT, {
                    key: On,
                    type: xe
                })); {
                    const {
                        __v_emitter: as
                    } = E;
                    as && p && as.emit("fallback", {
                        type: xe,
                        key: On,
                        to: "global",
                        groupId: `${xe}:${On}`
                    })
                }
            }
            return e && p ? ke(e) : Ve(On)
        } else {
            if (ht(Yt)) return Yt;
            throw Tn(st.UNEXPECTED_RETURN_TYPE)
        }
    };

    function ae(...z) {
        return le(ee => Reflect.apply(h1, null, [ee, ...z]), () => jv(...z), "translate", ee => Reflect.apply(ee.t, ee, [...z]), ee => ee, ee => _e(ee))
    }

    function W(...z) {
        const [ee, xe, ke] = z;
        if (ke && !qe(ke)) throw Tn(st.INVALID_ARGUMENT);
        return ae(ee, xe, Vt({
            resolvedMessage: !0
        }, ke || {}))
    }

    function ne(...z) {
        return le(ee => Reflect.apply(a1, null, [ee, ...z]), () => Hv(...z), "datetime format", ee => Reflect.apply(ee.d, ee, [...z]), () => Eh, ee => _e(ee) || wt(ee))
    }

    function fe(...z) {
        return le(ee => Reflect.apply(c1, null, [ee, ...z]), () => zv(...z), "number format", ee => Reflect.apply(ee.n, ee, [...z]), () => Eh, ee => _e(ee) || wt(ee))
    }

    function $(z) {
        return z.map(ee => _e(ee) || Lt(ee) || Ze(ee) ? p1(String(ee)) : ee)
    }
    const F = {
        normalize: $,
        interpolate: z => z,
        type: "vnode"
    };

    function Z(...z) {
        return le(ee => {
            let xe;
            const ke = ee;
            try {
                ke.processor = F, xe = Reflect.apply(h1, null, [ke, ...z])
            } finally {
                ke.processor = null
            }
            return xe
        }, () => jv(...z), "translate", ee => ee[Vv](...z), ee => [p1(ee)], ee => wt(ee))
    }

    function K(...z) {
        return le(ee => Reflect.apply(c1, null, [ee, ...z]), () => zv(...z), "number format", ee => ee[Yv](...z), g1, ee => _e(ee) || wt(ee))
    }

    function ce(...z) {
        return le(ee => Reflect.apply(a1, null, [ee, ...z]), () => Hv(...z), "datetime format", ee => ee[Wv](...z), g1, ee => _e(ee) || wt(ee))
    }

    function de(z) {
        w = z, E.pluralRules = w
    }

    function ge(z, ee) {
        return le(() => {
            if (!z) return !1;
            const xe = _e(ee) ? ee : a.value,
                ke = j(xe),
                Ve = E.messageResolver(ke, z);
            return vr(Ve) || fr(Ve) || _e(Ve)
        }, () => [z], "translate exists", xe => Reflect.apply(xe.te, xe, [z, ee]), bQ, xe => Ze(xe))
    }

    function O(z) {
        let ee = null;
        const xe = SR(E, l.value, a.value);
        for (let ke = 0; ke < xe.length; ke++) {
            const Ve = c.value[xe[ke]] || {},
                ht = E.messageResolver(Ve, z);
            if (ht != null) {
                ee = ht;
                break
            }
        }
        return ee
    }

    function L(z) {
        const ee = O(z);
        return ee ? ? (e ? e.tm(z) || {} : {})
    }

    function j(z) {
        return c.value[z] || {}
    }

    function ie(z, ee) {
        if (i) {
            const xe = {
                [z]: ee
            };
            for (const ke in xe) Mr(xe, ke) && Su(xe[ke]);
            ee = xe[z]
        }
        c.value[z] = ee, E.messages = c.value
    }

    function oe(z, ee) {
        c.value[z] = c.value[z] || {};
        const xe = {
            [z]: ee
        };
        if (i)
            for (const ke in xe) Mr(xe, ke) && Su(xe[ke]);
        ee = xe[z], Hf(ee, c.value[z]), E.messages = c.value
    }

    function M(z) {
        return u.value[z] || {}
    }

    function k(z, ee) {
        u.value[z] = ee, E.datetimeFormats = u.value, l1(E, z, ee)
    }

    function U(z, ee) {
        u.value[z] = Vt(u.value[z] || {}, ee), E.datetimeFormats = u.value, l1(E, z, ee)
    }

    function J(z) {
        return d.value[z] || {}
    }

    function se(z, ee) {
        d.value[z] = ee, E.numberFormats = d.value, u1(E, z, ee)
    }

    function pe(z, ee) {
        d.value[z] = Vt(d.value[z] || {}, ee), E.numberFormats = d.value, u1(E, z, ee)
    }
    y1++, e && $r && (he(e.locale, z => {
        o && (a.value = z, E.locale = z, dc(E, a.value, l.value))
    }), he(e.fallbackLocale, z => {
        o && (l.value = z, E.fallbackLocale = z, dc(E, a.value, l.value))
    }));
    const ue = {
        id: y1,
        locale: T,
        fallbackLocale: S,
        get inheritLocale() {
            return o
        },
        set inheritLocale(z) {
            o = z, z && e && (a.value = e.locale.value, l.value = e.fallbackLocale.value, dc(E, a.value, l.value))
        },
        get availableLocales() {
            return Object.keys(c.value).sort()
        },
        messages: P,
        get modifiers() {
            return x
        },
        get pluralRules() {
            return w || {}
        },
        get isGlobal() {
            return r
        },
        get missingWarn() {
            return f
        },
        set missingWarn(z) {
            f = z, E.missingWarn = f
        },
        get fallbackWarn() {
            return h
        },
        set fallbackWarn(z) {
            h = z, E.fallbackWarn = h
        },
        get fallbackRoot() {
            return p
        },
        set fallbackRoot(z) {
            p = z
        },
        get fallbackFormat() {
            return b
        },
        set fallbackFormat(z) {
            b = z, E.fallbackFormat = b
        },
        get warnHtmlMessage() {
            return v
        },
        set warnHtmlMessage(z) {
            v = z, E.warnHtmlMessage = z
        },
        get escapeParameter() {
            return _
        },
        set escapeParameter(z) {
            _ = z, E.escapeParameter = z
        },
        t: ae,
        getLocaleMessage: j,
        setLocaleMessage: ie,
        mergeLocaleMessage: oe,
        getPostTranslationHandler: H,
        setPostTranslationHandler: B,
        getMissingHandler: N,
        setMissingHandler: V,
        [FR]: de
    };
    return ue.datetimeFormats = R, ue.numberFormats = D, ue.rt = W, ue.te = ge, ue.tm = L, ue.d = ne, ue.n = fe, ue.getDateTimeFormat = M, ue.setDateTimeFormat = k, ue.mergeDateTimeFormat = U, ue.getNumberFormat = J, ue.setNumberFormat = se, ue.mergeNumberFormat = pe, ue[LR] = n, ue[Vv] = Z, ue[Wv] = ce, ue[Yv] = K, ue[ta] = z => {
        E.__v_emitter = z
    }, ue[Eu] = () => {
        E.__v_emitter = void 0
    }, ue
}
const GR = "vue-i18n: composer properties",
    Zm = {
        "vue-devtools-plugin-vue-i18n": "Vue I18n DevTools",
        "vue-i18n-resource-inspector": "Vue I18n DevTools",
        "vue-i18n-timeline": "Vue I18n"
    },
    wQ = {
        "vue-i18n-resource-inspector": "Search for scopes ..."
    },
    EQ = {
        "vue-i18n-timeline": 16764185
    };
let qv;
async function SQ(t, e) {
    return new Promise((n, r) => {
        try {
            _p({
                id: "vue-devtools-plugin-vue-i18n",
                label: Zm["vue-devtools-plugin-vue-i18n"],
                packageName: "vue-i18n",
                homepage: "https://vue-i18n.intlify.dev",
                logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
                componentStateTypes: [GR],
                app: t
            }, i => {
                qv = i, i.on.visitComponentTree(({
                    componentInstance: o,
                    treeNode: a
                }) => {
                    TQ(o, a, e)
                }), i.on.inspectComponent(({
                    componentInstance: o,
                    instanceData: a
                }) => {
                    o.vnode.el && o.vnode.el.__VUE_I18N__ && a && (e.mode === "legacy" ? o.vnode.el.__VUE_I18N__ !== e.global.__composer && _1(a, o.vnode.el.__VUE_I18N__) : _1(a, o.vnode.el.__VUE_I18N__))
                }), i.addInspector({
                    id: "vue-i18n-resource-inspector",
                    label: Zm["vue-i18n-resource-inspector"],
                    icon: "language",
                    treeFilterPlaceholder: wQ["vue-i18n-resource-inspector"]
                }), i.on.getInspectorTree(o => {
                    o.app === t && o.inspectorId === "vue-i18n-resource-inspector" && IQ(o, e)
                });
                const s = new Map;
                i.on.getInspectorState(async o => {
                    if (o.app === t && o.inspectorId === "vue-i18n-resource-inspector")
                        if (i.unhighlightElement(), RQ(o, e), o.nodeId === "global") {
                            if (!s.has(o.app)) {
                                const [a] = await i.getComponentInstances(o.app);
                                s.set(o.app, a)
                            }
                            i.highlightElement(s.get(o.app))
                        } else {
                            const a = MQ(o.nodeId, e);
                            a && i.highlightElement(a)
                        }
                }), i.on.editInspectorState(o => {
                    o.app === t && o.inspectorId === "vue-i18n-resource-inspector" && BQ(o, e)
                }), i.addTimelineLayer({
                    id: "vue-i18n-timeline",
                    label: Zm["vue-i18n-timeline"],
                    color: EQ["vue-i18n-timeline"]
                }), n(!0)
            })
        } catch (i) {
            console.error(i), r(!1)
        }
    })
}

function HR(t) {
    return t.type.name || t.type.displayName || t.type.__file || "Anonymous"
}

function TQ(t, e, n) {
    const r = n.mode === "composition" ? n.global : n.global.__composer;
    if (t && t.vnode.el && t.vnode.el.__VUE_I18N__ && t.vnode.el.__VUE_I18N__ !== r) {
        const i = {
            label: `i18n (${HR(t)} Scope)`,
            textColor: 0,
            backgroundColor: 16764185
        };
        e.tags.push(i)
    }
}

function _1(t, e) {
    const n = GR;
    t.state.push({
        type: n,
        key: "locale",
        editable: !0,
        value: e.locale.value
    }), t.state.push({
        type: n,
        key: "availableLocales",
        editable: !1,
        value: e.availableLocales
    }), t.state.push({
        type: n,
        key: "fallbackLocale",
        editable: !0,
        value: e.fallbackLocale.value
    }), t.state.push({
        type: n,
        key: "inheritLocale",
        editable: !0,
        value: e.inheritLocale
    }), t.state.push({
        type: n,
        key: "messages",
        editable: !1,
        value: nx(e.messages.value)
    }), t.state.push({
        type: n,
        key: "datetimeFormats",
        editable: !1,
        value: e.datetimeFormats.value
    }), t.state.push({
        type: n,
        key: "numberFormats",
        editable: !1,
        value: e.numberFormats.value
    })
}

function nx(t) {
    const e = {};
    return Object.keys(t).forEach(n => {
        const r = t[n];
        lt(r) && "source" in r ? e[n] = OQ(r) : vr(r) && r.loc && r.loc.source ? e[n] = r.loc.source : qe(r) ? e[n] = nx(r) : e[n] = r
    }), e
}
const CQ = {
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "&": "&amp;"
};

function PQ(t) {
    return t.replace(/[<>"&]/g, AQ)
}

function AQ(t) {
    return CQ[t] || t
}

function OQ(t) {
    return {
        _custom: {
            type: "function",
            display: `<span></span> ${t.source?`("${PQ(t.source)}")`:"(?)"}`
        }
    }
}

function IQ(t, e) {
    t.rootNodes.push({
        id: "global",
        label: "Global Scope"
    });
    const n = e.mode === "composition" ? e.global : e.global.__composer;
    for (const [r, i] of e.__instances) {
        const s = e.mode === "composition" ? i : i.__composer;
        n !== s && t.rootNodes.push({
            id: s.id.toString(),
            label: `${HR(r)} Scope`
        })
    }
}

function MQ(t, e) {
    let n = null;
    if (t !== "global") {
        for (const [r, i] of e.__instances.entries())
            if (i.id.toString() === t) {
                n = r;
                break
            }
    }
    return n
}

function zR(t, e) {
    if (t === "global") return e.mode === "composition" ? e.global : e.global.__composer; {
        const n = Array.from(e.__instances.values()).find(r => r.id.toString() === t);
        return n ? e.mode === "composition" ? n : n.__composer : null
    }
}

function RQ(t, e) {
    const n = zR(t.nodeId, e);
    return n && (t.state = kQ(n)), null
}

function kQ(t) {
    const e = {},
        n = "Locale related info",
        r = [{
            type: n,
            key: "locale",
            editable: !0,
            value: t.locale.value
        }, {
            type: n,
            key: "fallbackLocale",
            editable: !0,
            value: t.fallbackLocale.value
        }, {
            type: n,
            key: "availableLocales",
            editable: !1,
            value: t.availableLocales
        }, {
            type: n,
            key: "inheritLocale",
            editable: !0,
            value: t.inheritLocale
        }];
    e[n] = r;
    const i = "Locale messages info",
        s = [{
            type: i,
            key: "messages",
            editable: !1,
            value: nx(t.messages.value)
        }];
    e[i] = s; {
        const o = "Datetime formats info",
            a = [{
                type: o,
                key: "datetimeFormats",
                editable: !1,
                value: t.datetimeFormats.value
            }];
        e[o] = a;
        const l = "Datetime formats info",
            c = [{
                type: l,
                key: "numberFormats",
                editable: !1,
                value: t.numberFormats.value
            }];
        e[l] = c
    }
    return e
}

function Tu(t, e) {
    if (qv) {
        let n;
        e && "groupId" in e && (n = e.groupId, delete e.groupId), qv.addTimelineEvent({
            layerId: "vue-i18n-timeline",
            event: {
                title: t,
                groupId: n,
                time: Date.now(),
                meta: {},
                data: e || {},
                logType: t === "compile-error" ? "error" : t === "fallback" || t === "missing" ? "warning" : "default"
            }
        })
    }
}

function BQ(t, e) {
    const n = zR(t.nodeId, e);
    if (n) {
        const [r] = t.path;
        r === "locale" && _e(t.state.value) ? n.locale.value = t.state.value : r === "fallbackLocale" && (_e(t.state.value) || wt(t.state.value) || qe(t.state.value)) ? n.fallbackLocale.value = t.state.value : r === "inheritLocale" && Ze(t.state.value) && (n.inheritLocale = t.state.value)
    }
}

function DQ(t) {
    const e = _e(t.locale) ? t.locale : wu,
        n = _e(t.fallbackLocale) || wt(t.fallbackLocale) || He(t.fallbackLocale) || t.fallbackLocale === !1 ? t.fallbackLocale : e,
        r = lt(t.missing) ? t.missing : void 0,
        i = Ze(t.silentTranslationWarn) || bl(t.silentTranslationWarn) ? !t.silentTranslationWarn : !0,
        s = Ze(t.silentFallbackWarn) || bl(t.silentFallbackWarn) ? !t.silentFallbackWarn : !0,
        o = Ze(t.fallbackRoot) ? t.fallbackRoot : !0,
        a = !!t.formatFallbackMessages,
        l = He(t.modifiers) ? t.modifiers : {},
        c = t.pluralizationRules,
        u = lt(t.postTranslation) ? t.postTranslation : void 0,
        d = _e(t.warnHtmlInMessage) ? t.warnHtmlInMessage !== "off" : !0,
        f = !!t.escapeParameterHtml,
        h = Ze(t.sync) ? t.sync : !0;
    let p = t.messages;
    if (He(t.sharedMessages)) {
        const x = t.sharedMessages;
        p = Object.keys(x).reduce((E, C) => {
            const A = E[C] || (E[C] = {});
            return Vt(A, x[C]), E
        }, p || {})
    }
    const {
        __i18n: b,
        __root: y,
        __injectWithOption: m
    } = t, g = t.datetimeFormats, v = t.numberFormats, _ = t.flatJson;
    return {
        locale: e,
        fallbackLocale: n,
        messages: p,
        flatJson: _,
        datetimeFormats: g,
        numberFormats: v,
        missing: r,
        missingWarn: i,
        fallbackWarn: s,
        fallbackRoot: o,
        fallbackFormat: a,
        modifiers: l,
        pluralRules: c,
        postTranslation: u,
        warnHtmlMessage: d,
        escapeParameter: f,
        messageResolver: t.messageResolver,
        inheritLocale: h,
        __i18n: b,
        __root: y,
        __injectWithOption: m
    }
}

function Kv(t = {}) {
    const e = tx(DQ(t)),
        {
            __extender: n
        } = t,
        r = {
            id: e.id,
            get locale() {
                return e.locale.value
            },
            set locale(i) {
                e.locale.value = i
            },
            get fallbackLocale() {
                return e.fallbackLocale.value
            },
            set fallbackLocale(i) {
                e.fallbackLocale.value = i
            },
            get messages() {
                return e.messages.value
            },
            get datetimeFormats() {
                return e.datetimeFormats.value
            },
            get numberFormats() {
                return e.numberFormats.value
            },
            get availableLocales() {
                return e.availableLocales
            },
            get missing() {
                return e.getMissingHandler()
            },
            set missing(i) {
                e.setMissingHandler(i)
            },
            get silentTranslationWarn() {
                return Ze(e.missingWarn) ? !e.missingWarn : e.missingWarn
            },
            set silentTranslationWarn(i) {
                e.missingWarn = Ze(i) ? !i : i
            },
            get silentFallbackWarn() {
                return Ze(e.fallbackWarn) ? !e.fallbackWarn : e.fallbackWarn
            },
            set silentFallbackWarn(i) {
                e.fallbackWarn = Ze(i) ? !i : i
            },
            get modifiers() {
                return e.modifiers
            },
            get formatFallbackMessages() {
                return e.fallbackFormat
            },
            set formatFallbackMessages(i) {
                e.fallbackFormat = i
            },
            get postTranslation() {
                return e.getPostTranslationHandler()
            },
            set postTranslation(i) {
                e.setPostTranslationHandler(i)
            },
            get sync() {
                return e.inheritLocale
            },
            set sync(i) {
                e.inheritLocale = i
            },
            get warnHtmlInMessage() {
                return e.warnHtmlMessage ? "warn" : "off"
            },
            set warnHtmlInMessage(i) {
                e.warnHtmlMessage = i !== "off"
            },
            get escapeParameterHtml() {
                return e.escapeParameter
            },
            set escapeParameterHtml(i) {
                e.escapeParameter = i
            },
            get pluralizationRules() {
                return e.pluralRules || {}
            },
            __composer: e,
            t(...i) {
                return Reflect.apply(e.t, e, [...i])
            },
            rt(...i) {
                return Reflect.apply(e.rt, e, [...i])
            },
            te(i, s) {
                return e.te(i, s)
            },
            tm(i) {
                return e.tm(i)
            },
            getLocaleMessage(i) {
                return e.getLocaleMessage(i)
            },
            setLocaleMessage(i, s) {
                e.setLocaleMessage(i, s)
            },
            mergeLocaleMessage(i, s) {
                e.mergeLocaleMessage(i, s)
            },
            d(...i) {
                return Reflect.apply(e.d, e, [...i])
            },
            getDateTimeFormat(i) {
                return e.getDateTimeFormat(i)
            },
            setDateTimeFormat(i, s) {
                e.setDateTimeFormat(i, s)
            },
            mergeDateTimeFormat(i, s) {
                e.mergeDateTimeFormat(i, s)
            },
            n(...i) {
                return Reflect.apply(e.n, e, [...i])
            },
            getNumberFormat(i) {
                return e.getNumberFormat(i)
            },
            setNumberFormat(i, s) {
                e.setNumberFormat(i, s)
            },
            mergeNumberFormat(i, s) {
                e.mergeNumberFormat(i, s)
            }
        };
    return r.__extender = n, r.__enableEmitter = i => {
        const s = e;
        s[ta] && s[ta](i)
    }, r.__disableEmitter = () => {
        const i = e;
        i[Eu] && i[Eu]()
    }, r
}

function $Q(t, e, n) {
    return {
        beforeCreate() {
            const r = rt();
            if (!r) throw Tn(st.UNEXPECTED_ERROR);
            const i = this.$options;
            if (i.i18n) {
                const s = i.i18n;
                if (i.__i18n && (s.__i18n = i.__i18n), s.__root = e, this === this.$root) this.$i18n = b1(t, s);
                else {
                    s.__injectWithOption = !0, s.__extender = n.__vueI18nExtend, this.$i18n = Kv(s);
                    const o = this.$i18n;
                    o.__extender && (o.__disposer = o.__extender(this.$i18n))
                }
            } else if (i.__i18n)
                if (this === this.$root) this.$i18n = b1(t, i);
                else {
                    this.$i18n = Kv({
                        __i18n: i.__i18n,
                        __injectWithOption: !0,
                        __extender: n.__vueI18nExtend,
                        __root: e
                    });
                    const s = this.$i18n;
                    s.__extender && (s.__disposer = s.__extender(this.$i18n))
                }
            else this.$i18n = t;
            i.__i18nGlobal && UR(e, i, i), this.$t = (...s) => this.$i18n.t(...s), this.$rt = (...s) => this.$i18n.rt(...s), this.$te = (s, o) => this.$i18n.te(s, o), this.$d = (...s) => this.$i18n.d(...s), this.$n = (...s) => this.$i18n.n(...s), this.$tm = s => this.$i18n.tm(s), n.__setInstance(r, this.$i18n)
        },
        mounted() {
            if (this.$el && this.$i18n) {
                const r = this.$i18n;
                this.$el.__VUE_I18N__ = r.__composer;
                const i = this.__v_emitter = qb();
                r.__enableEmitter && r.__enableEmitter(i), i.on("*", Tu)
            }
        },
        unmounted() {
            const r = rt();
            if (!r) throw Tn(st.UNEXPECTED_ERROR);
            const i = this.$i18n;
            this.$el && this.$el.__VUE_I18N__ && (this.__v_emitter && (this.__v_emitter.off("*", Tu), delete this.__v_emitter), this.$i18n && (i.__disableEmitter && i.__disableEmitter(), delete this.$el.__VUE_I18N__)), delete this.$t, delete this.$rt, delete this.$te, delete this.$d, delete this.$n, delete this.$tm, i.__disposer && (i.__disposer(), delete i.__disposer, delete i.__extender), n.__deleteInstance(r), delete this.$i18n
        }
    }
}

function b1(t, e) {
    t.locale = e.locale || t.locale, t.fallbackLocale = e.fallbackLocale || t.fallbackLocale, t.missing = e.missing || t.missing, t.silentTranslationWarn = e.silentTranslationWarn || t.silentFallbackWarn, t.silentFallbackWarn = e.silentFallbackWarn || t.silentFallbackWarn, t.formatFallbackMessages = e.formatFallbackMessages || t.formatFallbackMessages, t.postTranslation = e.postTranslation || t.postTranslation, t.warnHtmlInMessage = e.warnHtmlInMessage || t.warnHtmlInMessage, t.escapeParameterHtml = e.escapeParameterHtml || t.escapeParameterHtml, t.sync = e.sync || t.sync, t.__composer[FR](e.pluralizationRules || t.pluralizationRules);
    const n = ex(t.locale, {
        messages: e.messages,
        __i18n: e.__i18n
    });
    return Object.keys(n).forEach(r => t.mergeLocaleMessage(r, n[r])), e.datetimeFormats && Object.keys(e.datetimeFormats).forEach(r => t.mergeDateTimeFormat(r, e.datetimeFormats[r])), e.numberFormats && Object.keys(e.numberFormats).forEach(r => t.mergeNumberFormat(r, e.numberFormats[r])), t
}
const rx = {
    tag: {
        type: [String, Object]
    },
    locale: {
        type: String
    },
    scope: {
        type: String,
        validator: t => t === "parent" || t === "global",
        default: "parent"
    },
    i18n: {
        type: Object
    }
};

function FQ({
    slots: t
}, e) {
    return e.length === 1 && e[0] === "default" ? (t.default ? t.default() : []).reduce((r, i) => [...r, ...i.type === mt ? i.children : [i]], []) : e.reduce((n, r) => {
        const i = t[r];
        return i && (n[r] = i()), n
    }, at())
}

function jR() {
    return mt
}
const LQ = ve({
        name: "i18n-t",
        props: Vt({
            keypath: {
                type: String,
                required: !0
            },
            plural: {
                type: [Number, String],
                validator: t => Lt(t) || !isNaN(t)
            }
        }, rx),
        setup(t, e) {
            const {
                slots: n,
                attrs: r
            } = e, i = t.i18n || ix({
                useScope: t.scope,
                __useComponent: !0
            });
            return () => {
                const s = Object.keys(n).filter(d => d[0] !== "_"),
                    o = at();
                t.locale && (o.locale = t.locale), t.plural !== void 0 && (o.plural = _e(t.plural) ? +t.plural : t.plural);
                const a = FQ(e, s),
                    l = i[Vv](t.keypath, a, o),
                    c = Vt(at(), r),
                    u = _e(t.tag) || qe(t.tag) ? t.tag : jR();
                return Jt(u, c, l)
            }
        }
    }),
    x1 = LQ;

function NQ(t) {
    return wt(t) && !_e(t[0])
}

function VR(t, e, n, r) {
    const {
        slots: i,
        attrs: s
    } = e;
    return () => {
        const o = {
            part: !0
        };
        let a = at();
        t.locale && (o.locale = t.locale), _e(t.format) ? o.key = t.format : qe(t.format) && (_e(t.format.key) && (o.key = t.format.key), a = Object.keys(t.format).reduce((f, h) => n.includes(h) ? Vt(at(), f, {
            [h]: t.format[h]
        }) : f, at()));
        const l = r(t.value, o, a);
        let c = [o.key];
        wt(l) ? c = l.map((f, h) => {
            const p = i[f.type],
                b = p ? p({
                    [f.type]: f.value,
                    index: h,
                    parts: l
                }) : [f.value];
            return NQ(b) && (b[0].key = `${f.type}-${h}`), b
        }) : _e(l) && (c = [l]);
        const u = Vt(at(), s),
            d = _e(t.tag) || qe(t.tag) ? t.tag : jR();
        return Jt(d, u, c)
    }
}
const UQ = ve({
        name: "i18n-n",
        props: Vt({
            value: {
                type: Number,
                required: !0
            },
            format: {
                type: [String, Object]
            }
        }, rx),
        setup(t, e) {
            const n = t.i18n || ix({
                useScope: t.scope,
                __useComponent: !0
            });
            return VR(t, e, BR, (...r) => n[Yv](...r))
        }
    }),
    w1 = UQ;

function GQ(t, e) {
    const n = t;
    if (t.mode === "composition") return n.__getInstance(e) || t.global; {
        const r = n.__getInstance(e);
        return r != null ? r.__composer : t.global.__composer
    }
}

function HQ(t) {
    const e = o => {
        Wb(cd(ti.DEPRECATE_TRANSLATE_CUSTOME_DIRECTIVE));
        const {
            instance: a,
            value: l
        } = o;
        if (!a || !a.$) throw Tn(st.UNEXPECTED_ERROR);
        const c = GQ(t, a.$),
            u = E1(l);
        return [Reflect.apply(c.t, c, [...S1(u)]), c]
    };
    return {
        created: (o, a) => {
            const [l, c] = e(a);
            $r && t.global === c && (o.__i18nWatcher = he(c.locale, () => {
                a.instance && a.instance.$forceUpdate()
            })), o.__composer = c, o.textContent = l
        },
        unmounted: o => {
            $r && o.__i18nWatcher && (o.__i18nWatcher(), o.__i18nWatcher = void 0, delete o.__i18nWatcher), o.__composer && (o.__composer = void 0, delete o.__composer)
        },
        beforeUpdate: (o, {
            value: a
        }) => {
            if (o.__composer) {
                const l = o.__composer,
                    c = E1(a);
                o.textContent = Reflect.apply(l.t, l, [...S1(c)])
            }
        },
        getSSRProps: o => {
            const [a] = e(o);
            return {
                textContent: a
            }
        }
    }
}

function E1(t) {
    if (_e(t)) return {
        path: t
    };
    if (He(t)) {
        if (!("path" in t)) throw Tn(st.REQUIRED_VALUE, "path");
        return t
    } else throw Tn(st.INVALID_VALUE)
}

function S1(t) {
    const {
        path: e,
        locale: n,
        args: r,
        choice: i,
        plural: s
    } = t, o = {}, a = r || {};
    return _e(n) && (o.locale = n), Lt(i) && (o.plural = i), Lt(s) && (o.plural = s), [e, a, o]
}

function zQ(t, e, ...n) {
    const r = He(n[0]) ? n[0] : {};
    (Ze(r.globalInstall) ? r.globalInstall : !0) && ([x1.name, "I18nT"].forEach(s => t.component(s, x1)), [w1.name, "I18nN"].forEach(s => t.component(s, w1)), [C1.name, "I18nD"].forEach(s => t.component(s, C1))), t.directive("t", HQ(e))
}
const jQ = mi("global-vue-i18n");

function Bxe(t = {}) {
    const e = __VUE_I18N_LEGACY_API__ && Ze(t.legacy) ? t.legacy : __VUE_I18N_LEGACY_API__;
    e && Wb(cd(ti.DEPRECATE_LEGACY_MODE));
    const n = Ze(t.globalInjection) ? t.globalInjection : !0,
        r = new Map,
        [i, s] = VQ(t, e),
        o = mi("vue-i18n");

    function a(d) {
        return r.get(d) || null
    }

    function l(d, f) {
        r.set(d, f)
    }

    function c(d) {
        r.delete(d)
    }
    const u = {
        get mode() {
            return __VUE_I18N_LEGACY_API__ && e ? "legacy" : "composition"
        },
        async install(d, ...f) {
            if (d.__VUE_I18N__ = u, d.__VUE_I18N_SYMBOL__ = o, d.provide(d.__VUE_I18N_SYMBOL__, u), He(f[0])) {
                const b = f[0];
                u.__composerExtend = b.__composerExtend, u.__vueI18nExtend = b.__vueI18nExtend
            }
            let h = null;
            !e && n && (h = QQ(d, u.global)), __VUE_I18N_FULL_INSTALL__ && zQ(d, u, ...f), __VUE_I18N_LEGACY_API__ && e && d.mixin($Q(s, s.__composer, u));
            const p = d.unmount;
            d.unmount = () => {
                h && h(), u.dispose(), p()
            }; {
                if (!await SQ(d, u)) throw Tn(st.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
                const y = qb();
                if (e) {
                    const m = s;
                    m.__enableEmitter && m.__enableEmitter(y)
                } else {
                    const m = s;
                    m[ta] && m[ta](y)
                }
                y.on("*", Tu)
            }
        },
        get global() {
            return s
        },
        dispose() {
            i.stop()
        },
        __instances: r,
        __getInstance: a,
        __setInstance: l,
        __deleteInstance: c
    };
    return u
}

function ix(t = {}) {
    const e = rt();
    if (e == null) throw Tn(st.MUST_BE_CALL_SETUP_TOP);
    if (!e.isCE && e.appContext.app != null && !e.appContext.app.__VUE_I18N_SYMBOL__) throw Tn(st.NOT_INSTALLED);
    const n = WQ(e),
        r = XQ(n),
        i = NR(e),
        s = YQ(t, i);
    if (s === "global") return UR(r, t, i), r;
    if (s === "parent") {
        let l = qQ(n, e, t.__useComponent);
        return l == null && (os(cd(ti.NOT_FOUND_PARENT_SCOPE)), l = r), l
    }
    const o = n;
    let a = o.__getInstance(e);
    if (a == null) {
        const l = Vt({}, t);
        "__i18n" in i && (l.__i18n = i.__i18n), r && (l.__root = r), a = tx(l), o.__composerExtend && (a[Xv] = o.__composerExtend(a)), JQ(o, e, a), o.__setInstance(e, a)
    } else if (s === "local") throw Tn(st.DUPLICATE_USE_I18N_CALLING);
    return a
}

function VQ(t, e) {
    const n = ju(),
        r = __VUE_I18N_LEGACY_API__ && e ? n.run(() => Kv(t)) : n.run(() => tx(t));
    if (r == null) throw Tn(st.UNEXPECTED_ERROR);
    return [n, r]
}

function WQ(t) {
    const e = Nt(t.isCE ? jQ : t.appContext.app.__VUE_I18N_SYMBOL__);
    if (!e) throw Tn(t.isCE ? st.NOT_INSTALLED_WITH_PROVIDE : st.UNEXPECTED_ERROR);
    return e
}

function YQ(t, e) {
    return Np(t) ? "__i18n" in e ? "local" : "global" : t.useScope ? t.useScope : "local"
}

function XQ(t) {
    return t.mode === "composition" ? t.global : t.global.__composer
}

function qQ(t, e, n = !1) {
    let r = null;
    const i = e.root;
    let s = KQ(e, n);
    for (; s != null;) {
        const o = t;
        if (t.mode === "composition") r = o.__getInstance(s);
        else if (__VUE_I18N_LEGACY_API__) {
            const a = o.__getInstance(s);
            a != null && (r = a.__composer, n && r && !r[LR] && (r = null))
        }
        if (r != null || i === s) break;
        s = s.parent
    }
    return r
}

function KQ(t, e = !1) {
    return t == null ? null : e && t.vnode.ctx || t.parent
}

function JQ(t, e, n) {
    let r = null;
    _t(() => {
        if (e.vnode.el) {
            e.vnode.el.__VUE_I18N__ = n, r = qb();
            const i = n;
            i[ta] && i[ta](r), r.on("*", Tu)
        }
    }, e), is(() => {
        const i = n;
        e.vnode.el && e.vnode.el.__VUE_I18N__ && (r && r.off("*", Tu), i[Eu] && i[Eu](), delete e.vnode.el.__VUE_I18N__), t.__deleteInstance(e);
        const s = i[Xv];
        s && (s(), delete i[Xv])
    }, e)
}
const ZQ = ["locale", "fallbackLocale", "availableLocales"],
    T1 = ["t", "rt", "d", "n", "tm", "te"];

function QQ(t, e) {
    const n = Object.create(null);
    return ZQ.forEach(i => {
        const s = Object.getOwnPropertyDescriptor(e, i);
        if (!s) throw Tn(st.UNEXPECTED_ERROR);
        const o = et(s.value) ? {
            get() {
                return s.value.value
            },
            set(a) {
                s.value.value = a
            }
        } : {
            get() {
                return s.get && s.get()
            }
        };
        Object.defineProperty(n, i, o)
    }), t.config.globalProperties.$i18n = n, T1.forEach(i => {
        const s = Object.getOwnPropertyDescriptor(e, i);
        if (!s || !s.value) throw Tn(st.UNEXPECTED_ERROR);
        Object.defineProperty(t.config.globalProperties, `$${i}`, s)
    }), () => {
        delete t.config.globalProperties.$i18n, T1.forEach(i => {
            delete t.config.globalProperties[`$${i}`]
        })
    }
}
const eee = ve({
        name: "i18n-d",
        props: Vt({
            value: {
                type: [Number, Date],
                required: !0
            },
            format: {
                type: [String, Object]
            }
        }, rx),
        setup(t, e) {
            const n = t.i18n || ix({
                useScope: t.scope,
                __useComponent: !0
            });
            return VR(t, e, kR, (...r) => n[Wv](...r))
        }
    }),
    C1 = eee;
yQ();
qZ(PZ);
KZ(jZ);
JZ(SR); {
    const t = Io();
    t.__INTLIFY__ = !0, AZ(t.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__)
}
var Dxe = {
        name: "Name",
        tel: "Phone",
        save: "Save",
        clear: "Clear",
        cancel: "Cancel",
        confirm: "Confirm",
        delete: "Delete",
        loading: "Loading...",
        noCoupon: "No coupons",
        nameEmpty: "Please fill in the name",
        addContact: "Add contact",
        telInvalid: "Malformed phone number",
        vanCalendar: {
            end: "End",
            start: "Start",
            title: "Calendar",
            weekdays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `Choose no more than ${t} days`
        },
        vanCascader: {
            select: "Select"
        },
        vanPagination: {
            prev: "Previous",
            next: "Next"
        },
        vanPullRefresh: {
            pulling: "Pull to refresh...",
            loosing: "Loose to refresh..."
        },
        vanSubmitBar: {
            label: "Total:"
        },
        vanCoupon: {
            unlimited: "Unlimited",
            discount: t => `${t*10}% off`,
            condition: t => `At least ${t}`
        },
        vanCouponCell: {
            title: "Coupon",
            count: t => `You have ${t} coupons`
        },
        vanCouponList: {
            exchange: "Exchange",
            close: "Close",
            enable: "Available",
            disabled: "Unavailable",
            placeholder: "Coupon code"
        },
        vanAddressEdit: {
            area: "Area",
            areaEmpty: "Please select a receiving area",
            addressEmpty: "Address can not be empty",
            addressDetail: "Address",
            defaultAddress: "Set as the default address"
        },
        vanAddressList: {
            add: "Add new address"
        }
    },
    $xe = {
        name: "",
        tel: "",
        save: "",
        clear: "",
        cancel: "",
        confirm: "",
        delete: "",
        loading: "...",
        noCoupon: " ",
        nameEmpty: "  ",
        addContact: " ",
        telInvalid: "  ",
        vanCalendar: {
            end: "",
            start: "",
            title: "",
            weekdays: ["", "", "", "", "", "", ""],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `  ${t} `
        },
        vanCascader: {
            select: ""
        },
        vanPagination: {
            prev: "",
            next: ""
        },
        vanPullRefresh: {
            pulling: "  ...",
            loosing: "  ..."
        },
        vanSubmitBar: {
            label: ":"
        },
        vanCoupon: {
            unlimited: "",
            discount: t => `${t*10}% `,
            condition: t => `  ${t}`
        },
        vanCouponCell: {
            title: "",
            count: t => `   ${t} `
        },
        vanCouponList: {
            exchange: "",
            close: "",
            enable: "",
            disabled: "",
            placeholder: " "
        },
        vanAddressEdit: {
            area: "",
            areaEmpty: "  ",
            addressEmpty: "    ",
            addressDetail: "",
            defaultAddress: "   "
        },
        vanAddressList: {
            add: " "
        }
    },
    Fxe = {
        name: "tn",
        tel: "in thoi",
        save: "Cu",
        clear: "Thng thong",
        cancel: "Hy b",
        confirm: "Xc nhn",
        delete: "Xa",
        loading: "ang ti ...",
        noCoupon: "Khng c phiu gim gi",
        nameEmpty: "Vui lng in vo tn",
        addContact: "Thm lin h",
        telInvalid: "S in thoi khng ng nh dng",
        vanCalendar: {
            end: "Kt thc",
            start: "Bt u",
            title: "Lch",
            weekdays: ["ch nht", "th hai", "th ba", "Th T", "Th nm", "Th su", "th by"],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `Chn khng qu ${t} ngy`
        },
        vanCascader: {
            select: "Chn"
        },
        vanPagination: {
            prev: "Trc ",
            next: "Tip theo"
        },
        vanPullRefresh: {
            pulling: "Ko  lm mi ...",
            loosing: "Loose  lm mi ..."
        },
        vanSubmitBar: {
            label: "Tng:"
        },
        vanCoupon: {
            unlimited: "Khng gii hn",
            discount: t => `Chit khu ${t*10}%`,
            condition: t => `t nht ${t}`
        },
        vanCouponCell: {
            title: "Phiu gim gi",
            count: t => `Bn c ${t} phiu gim gi`
        },
        vanCouponList: {
            exchange: "Trao i",
            close: "ng",
            enable: "C sn",
            disabled: "Khng kh dng",
            placeholder: "M phiu thng"
        },
        vanAddressEdit: {
            area: "Khu vc",
            areaEmpty: "Vui lng chn khu vc nhn hng",
            addressEmpty: "a ch khng c  trng",
            addressDetail: "a ch",
            defaultAddress: "t lm a ch mc nh"
        },
        vanAddressList: {
            add: "Thm a ch mi"
        }
    },
    Lxe = {
        name: "Nama",
        tel: "Telepon",
        save: "Simpan",
        clear: "Jernih",
        cancel: "Batal",
        confirm: "Konfirmasi",
        delete: "Hapus",
        loading: "Memuat...",
        noCoupon: "Tidak ada kupon",
        nameEmpty: "Silakan isi nama",
        addContact: "Tambahkan kontak",
        telInvalid: "Nomor telepon salah format",
        vanCalendar: {
            end: "Akhir",
            start: "Mulai",
            title: "Kalender",
            weekdays: ["minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `Pilih tidak lebih dari ${t} hari`
        },
        vanCascader: {
            select: "Pilih"
        },
        vanPagination: {
            prev: "Sebelumnya",
            next: "Selanjutnya"
        },
        vanPullRefresh: {
            pulling: "Tarik untuk menyegarkan...",
            loosing: "Loose untuk menyegarkan..."
        },
        vanSubmitBar: {
            label: "Jumlah:"
        },
        vanCoupon: {
            unlimited: "Tidak terbatas",
            discount: t => `${t*10}% off`,
            condition: t => `Setidaknya ${t}`
        },
        vanCouponCell: {
            title: "Kupon",
            count: t => `Anda memiliki kupon ${t}`
        },
        vanCouponList: {
            exchange: "Pertukaran",
            close: "Tutup",
            enable: "Tersedia",
            disabled: "Tidak tersedia",
            placeholder: "Kode kupon"
        },
        vanAddressEdit: {
            area: "Daerah",
            areaEmpty: "Silakan pilih area penerima",
            addressEmpty: "Alamat tidak boleh kosong",
            addressDetail: "Alamat",
            defaultAddress: "Tetapkan sebagai alamat default"
        },
        vanAddressList: {
            add: "Tambahkan alamat baru"
        }
    },
    Nxe = {
        name: "",
        tel: "",
        save: "",
        clear: "",
        cancel: " ",
        confirm: " ",
        delete: "",
        loading: "   ...",
        noCoupon: "  ",
        nameEmpty: "  ",
        addContact: " ",
        telInvalid: "  ",
        vanCalendar: {
            end: "",
            start: "",
            title: "",
            weekdays: ["", "", "", "", "", "", ""],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `${t}     `
        },
        vanCascader: {
            select: " "
        },
        vanPagination: {
            prev: " ",
            next: ""
        },
        vanPullRefresh: {
            pulling: "    ...",
            loosing: "    ..."
        },
        vanSubmitBar: {
            label: ":"
        },
        vanCoupon: {
            unlimited: "",
            discount: t => `${t*10}% `,
            condition: t => `   ${t}`
        },
        vanCouponCell: {
            title: "",
            count: t => `  ${t}  `
        },
        vanCouponList: {
            exchange: " ",
            close: " ",
            enable: "",
            disabled: "",
            placeholder: " "
        },
        vanAddressEdit: {
            area: "",
            areaEmpty: "   ",
            addressEmpty: "    ",
            addressDetail: "",
            defaultAddress: "      "
        },
        vanAddressList: {
            add: "  "
        }
    },
    Uxe = {
        name: "",
        tel: "",
        save: "",
        clear: "",
        cancel: "",
        confirm: "",
        delete: "",
        loading: "...",
        noCoupon: "",
        nameEmpty: "",
        addContact: "",
        telInvalid: "",
        vanCalendar: {
            end: "",
            start: "",
            title: "",
            weekdays: ["", "", "", "", "", "", ""],
            monthTitle: (t, e) => `${t}${e}`,
            rangePrompt: t => ` ${t} `
        },
        vanCascader: {
            select: ""
        },
        vanPagination: {
            prev: "",
            next: ""
        },
        vanPullRefresh: {
            pulling: "...",
            loosing: "..."
        },
        vanSubmitBar: {
            label: ":"
        },
        vanCoupon: {
            unlimited: " ",
            discount: t => `${t}`,
            condition: t => ` ${t} `
        },
        vanCouponCell: {
            title: "",
            count: t => ` ${t} `
        },
        vanCouponList: {
            exchange: "",
            close: "",
            enable: "",
            disabled: "",
            placeholder: ""
        },
        vanAddressEdit: {
            area: "",
            areaEmpty: "",
            addressEmpty: "",
            addressDetail: "",
            defaultAddress: ""
        },
        vanAddressList: {
            add: ""
        }
    },
    Gxe = {
        name: "Nome",
        tel: "Fone",
        save: "Salvar",
        clear: "Claro",
        cancel: "Cancelar",
        confirm: "Confirmar",
        delete: "Excluir",
        loading: "Carregando...",
        noCoupon: "Nenhum cupom",
        nameEmpty: "Por favor, preencha o nome",
        addContact: "Adicionar novo contato",
        telInvalid: "Telefone em formato invlido",
        vanCalendar: {
            end: "Fim",
            start: "Incio",
            title: "Calendrio",
            weekdays: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sb"],
            monthTitle: (t, e) => `${e}/${t}`,
            rangePrompt: t => `Escolha no mximo ${t} dias`
        },
        vanCascader: {
            select: "Selecione"
        },
        vanPagination: {
            prev: "Anterior",
            next: "Prximo"
        },
        vanPullRefresh: {
            pulling: "Puxe para atualizar...",
            loosing: "Solte para atualizar..."
        },
        vanSubmitBar: {
            label: "Total:"
        },
        vanCoupon: {
            unlimited: "Ilimitado",
            discount: t => `${t*10}% de desconto`,
            condition: t => `Pelo menos ${t}`
        },
        vanCouponCell: {
            title: "Cupom",
            count: t => `Voc possui ${t} cupom(ns)`
        },
        vanCouponList: {
            exchange: "Usar",
            close: "Fechar",
            enable: "Disponvel",
            disabled: "Indisponvel",
            placeholder: "Cdigo do cupom"
        },
        vanAddressEdit: {
            area: "rea",
            areaEmpty: "Por favor, selecione uma rea de recebimento",
            addressEmpty: "Endereo no pode ser vazio",
            addressDetail: "Endereo",
            defaultAddress: "Usar como endereo padro"
        },
        vanAddressList: {
            add: "Adicionar novo endereo"
        }
    },
    Hxe = {
        name: "",
        tel: "",
        save: " ",
        clear: "",
        cancel: "",
        confirm: " ",
        delete: "",
        loading: " ...",
        noCoupon: "  ",
        nameEmpty: "    ",
        addContact: "  ",
        telInvalid: "  ",
        vanCalendar: {
            end: "",
            start: "",
            title: "",
            weekdays: ["", "", "", "", "", "", ""],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `${t}     `
        },
        vanCascader: {
            select: ""
        },
        vanPagination: {
            prev: "",
            next: ""
        },
        vanPullRefresh: {
            pulling: "  ...",
            loosing: "  ..."
        },
        vanSubmitBar: {
            label: ":"
        },
        vanCoupon: {
            unlimited: "",
            discount: t => `${t*10}% `,
            condition: t => ` ${t}`
        },
        vanCouponCell: {
            title: "",
            count: t => ` ${t}  `
        },
        vanCouponList: {
            exchange: "",
            close: "",
            enable: "",
            disabled: "",
            placeholder: " "
        },
        vanAddressEdit: {
            area: "",
            areaEmpty: "      ",
            addressEmpty: "    ",
            addressDetail: "",
            defaultAddress: "    "
        },
        vanAddressList: {
            add: "   "
        }
    },
    zxe = {
        name: "",
        tel: "",
        save: "",
        clear: "",
        cancel: "",
        confirm: "",
        delete: "",
        loading: " ...",
        noCoupon: "  ",
        nameEmpty: "  ",
        addContact: "  ",
        telInvalid: "   ",
        vanCalendar: {
            end: "",
            start: "",
            title: "",
            weekdays: ["", "", "", "", "", "", ""],
            monthTitle: (t, e) => `${t}/${e}`,
            rangePrompt: t => `    ${t} `
        },
        vanCascader: {
            select: ""
        },
        vanPagination: {
            prev: "",
            next: ""
        },
        vanPullRefresh: {
            pulling: " ...",
            loosing: " ..."
        },
        vanSubmitBar: {
            label: ":"
        },
        vanCoupon: {
            unlimited: " ",
            discount: t => `${t*10}% `,
            condition: t => `  ${t}`
        },
        vanCouponCell: {
            title: "",
            count: t => ` ${t} `
        },
        vanCouponList: {
            exchange: "",
            close: "",
            enable: "",
            disabled: " ",
            placeholder: " "
        },
        vanAddressEdit: {
            area: "",
            areaEmpty: "   ",
            addressEmpty: "     ",
            addressDetail: "",
            defaultAddress: "  "
        },
        vanAddressList: {
            add: "  "
        }
    };

function Vs(t) {
    return Vu() ? (m_(t), !0) : !1
}

function jxe(t) {
    let e = !1,
        n;
    const r = ju(!0);
    return (...i) => (e || (n = r.run(() => t(...i)), e = !0), n)
}

function Cn(t) {
    return typeof t == "function" ? t() : En(t)
}
const Ws = typeof window < "u" && typeof document < "u",
    Vxe = typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope,
    tee = t => typeof t < "u",
    nee = t => t != null,
    ree = Object.prototype.toString,
    iee = t => ree.call(t) === "[object Object]",
    Kn = () => {},
    Jv = see();

function see() {
    var t, e;
    return Ws && ((t = window == null ? void 0 : window.navigator) == null ? void 0 : t.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent))
}

function sx(t, e) {
    function n(...r) {
        return new Promise((i, s) => {
            Promise.resolve(t(() => e.apply(this, r), {
                fn: e,
                thisArg: this,
                args: r
            })).then(i).catch(s)
        })
    }
    return n
}
const WR = t => t();

function YR(t, e = {}) {
    let n, r, i = Kn;
    const s = a => {
        clearTimeout(a), i(), i = Kn
    };
    return a => {
        const l = Cn(t),
            c = Cn(e.maxWait);
        return n && s(n), l <= 0 || c !== void 0 && c <= 0 ? (r && (s(r), r = null), Promise.resolve(a())) : new Promise((u, d) => {
            i = e.rejectOnCancel ? d : u, c && !r && (r = setTimeout(() => {
                n && s(n), r = null, u(a())
            }, c)), n = setTimeout(() => {
                r && s(r), r = null, u(a())
            }, l)
        })
    }
}

function oee(...t) {
    let e = 0,
        n, r = !0,
        i = Kn,
        s, o, a, l, c;
    !et(t[0]) && typeof t[0] == "object" ? {
        delay: o,
        trailing: a = !0,
        leading: l = !0,
        rejectOnCancel: c = !1
    } = t[0] : [o, a = !0, l = !0, c = !1] = t;
    const u = () => {
        n && (clearTimeout(n), n = void 0, i(), i = Kn)
    };
    return f => {
        const h = Cn(o),
            p = Date.now() - e,
            b = () => s = f();
        return u(), h <= 0 ? (e = Date.now(), b()) : (p > h && (l || !r) ? (e = Date.now(), b()) : a && (s = new Promise((y, m) => {
            i = c ? m : y, n = setTimeout(() => {
                e = Date.now(), r = !0, y(b()), u()
            }, Math.max(0, h - p))
        })), !l && !n && (n = setTimeout(() => r = !0, h)), r = !1, s)
    }
}

function aee(t = WR) {
    const e = q(!0);

    function n() {
        e.value = !1
    }

    function r() {
        e.value = !0
    }
    const i = (...s) => {
        e.value && t(...s)
    };
    return {
        isActive: pa(e),
        pause: n,
        resume: r,
        eventFilter: i
    }
}

function lee(t) {
    let e;

    function n() {
        return e || (e = t()), e
    }
    return n.reset = async () => {
        const r = e;
        e = void 0, r && await r
    }, n
}

function cee(t) {
    return t || rt()
}

function XR(...t) {
    if (t.length !== 1) return Rc(...t);
    const e = t[0];
    return typeof e == "function" ? pa(SA(() => ({
        get: e,
        set: Kn
    }))) : q(e)
}

function Wxe(t, e = 200, n = {}) {
    return sx(YR(e, n), t)
}

function Yxe(t, e = 200, n = !1, r = !0, i = !1) {
    return sx(oee(e, n, r, i), t)
}

function qR(t, e, n = {}) {
    const {
        eventFilter: r = WR,
        ...i
    } = n;
    return he(t, sx(r, e), i)
}

function KR(t, e, n = {}) {
    const {
        eventFilter: r,
        ...i
    } = n, {
        eventFilter: s,
        pause: o,
        resume: a,
        isActive: l
    } = aee(r);
    return {
        stop: qR(t, e, { ...i,
            eventFilter: s
        }),
        pause: o,
        resume: a,
        isActive: l
    }
}

function ox(t, e = !0, n) {
    cee() ? _t(t, n) : e ? t() : Ue(t)
}

function Xxe(t, e) {
    return te(() => Cn(t).map(n => Cn(n)).filter(e))
}

function qxe(t, e = 1e3, n = {}) {
    const {
        immediate: r = !0,
        immediateCallback: i = !1
    } = n;
    let s = null;
    const o = q(!1);

    function a() {
        s && (clearInterval(s), s = null)
    }

    function l() {
        o.value = !1, a()
    }

    function c() {
        const u = Cn(e);
        u <= 0 || (o.value = !0, i && t(), a(), s = setInterval(t, u))
    }
    if (r && Ws && c(), et(e) || typeof e == "function") {
        const u = he(e, () => {
            o.value && Ws && c()
        });
        Vs(u)
    }
    return Vs(l), {
        isActive: o,
        pause: l,
        resume: c
    }
}

function uee(t, e, n = {}) {
    const {
        immediate: r = !0
    } = n, i = q(!1);
    let s = null;

    function o() {
        s && (clearTimeout(s), s = null)
    }

    function a() {
        i.value = !1, o()
    }

    function l(...c) {
        o(), i.value = !0, s = setTimeout(() => {
            i.value = !1, s = null, t(...c)
        }, Cn(e))
    }
    return r && (i.value = !0, Ws && l()), Vs(a), {
        isPending: pa(i),
        start: l,
        stop: a
    }
}

function Kxe(t, e, n = {}) {
    const {
        debounce: r = 0,
        maxWait: i = void 0,
        ...s
    } = n;
    return qR(t, e, { ...s,
        eventFilter: YR(r, {
            maxWait: i
        })
    })
}

function ri(t) {
    var e;
    const n = Cn(t);
    return (e = n == null ? void 0 : n.$el) != null ? e : n
}
const fi = Ws ? window : void 0,
    JR = Ws ? window.document : void 0,
    ZR = Ws ? window.navigator : void 0;

function dn(...t) {
    let e, n, r, i;
    if (typeof t[0] == "string" || Array.isArray(t[0]) ? ([n, r, i] = t, e = fi) : [e, n, r, i] = t, !e) return Kn;
    Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);
    const s = [],
        o = () => {
            s.forEach(u => u()), s.length = 0
        },
        a = (u, d, f, h) => (u.addEventListener(d, f, h), () => u.removeEventListener(d, f, h)),
        l = he(() => [ri(e), Cn(i)], ([u, d]) => {
            if (o(), !u) return;
            const f = iee(d) ? { ...d
            } : d;
            s.push(...n.flatMap(h => r.map(p => a(u, h, p, f))))
        }, {
            immediate: !0,
            flush: "post"
        }),
        c = () => {
            l(), o()
        };
    return Vs(c), c
}
let P1 = !1;

function Jxe(t, e, n = {}) {
    const {
        window: r = fi,
        ignore: i = [],
        capture: s = !0,
        detectIframe: o = !1
    } = n;
    if (!r) return Kn;
    Jv && !P1 && (P1 = !0, Array.from(r.document.body.children).forEach(f => f.addEventListener("click", Kn)), r.document.documentElement.addEventListener("click", Kn));
    let a = !0;
    const l = f => i.some(h => {
            if (typeof h == "string") return Array.from(r.document.querySelectorAll(h)).some(p => p === f.target || f.composedPath().includes(p)); {
                const p = ri(h);
                return p && (f.target === p || f.composedPath().includes(p))
            }
        }),
        u = [dn(r, "click", f => {
            const h = ri(t);
            if (!(!h || h === f.target || f.composedPath().includes(h))) {
                if (f.detail === 0 && (a = !l(f)), !a) {
                    a = !0;
                    return
                }
                e(f)
            }
        }, {
            passive: !0,
            capture: s
        }), dn(r, "pointerdown", f => {
            const h = ri(t);
            a = !l(f) && !!(h && !f.composedPath().includes(h))
        }, {
            passive: !0
        }), o && dn(r, "blur", f => {
            setTimeout(() => {
                var h;
                const p = ri(t);
                ((h = r.document.activeElement) == null ? void 0 : h.tagName) === "IFRAME" && !(p != null && p.contains(r.document.activeElement)) && e(f)
            }, 0)
        })].filter(Boolean);
    return () => u.forEach(f => f())
}

function dee() {
    const t = q(!1),
        e = rt();
    return e && _t(() => {
        t.value = !0
    }, e), t
}

function Hp(t) {
    const e = dee();
    return te(() => (e.value, !!t()))
}

function fee(t, e, n = {}) {
    const {
        window: r = fi,
        ...i
    } = n;
    let s;
    const o = Hp(() => r && "MutationObserver" in r),
        a = () => {
            s && (s.disconnect(), s = void 0)
        },
        l = te(() => {
            const f = Cn(t),
                h = (Array.isArray(f) ? f : [f]).map(ri).filter(nee);
            return new Set(h)
        }),
        c = he(() => l.value, f => {
            a(), o.value && f.size && (s = new MutationObserver(e), f.forEach(h => s.observe(h, i)))
        }, {
            immediate: !0,
            flush: "post"
        }),
        u = () => s == null ? void 0 : s.takeRecords(),
        d = () => {
            a(), c()
        };
    return Vs(d), {
        isSupported: o,
        stop: d,
        takeRecords: u
    }
}

function Zxe(t, e) {
    const {
        interrupt: n = !0,
        onError: r = Kn,
        onFinished: i = Kn,
        signal: s
    } = e || {}, o = {
        aborted: "aborted",
        fulfilled: "fulfilled",
        pending: "pending",
        rejected: "rejected"
    }, a = Array.from(Array.from({
        length: t.length
    }), () => ({
        state: o.pending,
        data: null
    })), l = ft(a), c = q(-1);
    if (!t || t.length === 0) return i(), {
        activeIndex: c,
        result: l
    };

    function u(d, f) {
        c.value++, l[c.value].data = f, l[c.value].state = d
    }
    return t.reduce((d, f) => d.then(h => {
        var p;
        if (s != null && s.aborted) {
            u(o.aborted, new Error("aborted"));
            return
        }
        if (((p = l[c.value]) == null ? void 0 : p.state) === o.rejected && n) {
            i();
            return
        }
        const b = f(h).then(y => (u(o.fulfilled, y), c.value === t.length - 1 && i(), y));
        return s ? Promise.race([b, hee(s)]) : b
    }).catch(h => s != null && s.aborted ? (u(o.aborted, h), h) : (u(o.rejected, h), r(), h)), Promise.resolve()), {
        activeIndex: c,
        result: l
    }
}

function hee(t) {
    return new Promise((e, n) => {
        const r = new Error("aborted");
        t.aborted ? n(r) : t.addEventListener("abort", () => n(r), {
            once: !0
        })
    })
}

function A1(t, e = {}) {
    const {
        controls: n = !1,
        navigator: r = ZR
    } = e, i = Hp(() => r && "permissions" in r);
    let s;
    const o = typeof t == "string" ? {
            name: t
        } : t,
        a = q(),
        l = () => {
            s && (a.value = s.state)
        },
        c = lee(async () => {
            if (i.value) {
                if (!s) try {
                    s = await r.permissions.query(o), dn(s, "change", l), l()
                } catch {
                    a.value = "prompt"
                }
                return s
            }
        });
    return c(), n ? {
        state: a,
        isSupported: i,
        query: c
    } : a
}

function Qxe(t = {}) {
    const {
        navigator: e = ZR,
        read: n = !1,
        source: r,
        copiedDuring: i = 1500,
        legacy: s = !1
    } = t, o = Hp(() => e && "clipboard" in e), a = A1("clipboard-read"), l = A1("clipboard-write"), c = te(() => o.value || s), u = q(""), d = q(!1), f = uee(() => d.value = !1, i);

    function h() {
        o.value && m(a.value) ? e.clipboard.readText().then(g => {
            u.value = g
        }) : u.value = y()
    }
    c.value && n && dn(["copy", "cut"], h);
    async function p(g = Cn(r)) {
        c.value && g != null && (o.value && m(l.value) ? await e.clipboard.writeText(g) : b(g), u.value = g, d.value = !0, f.start())
    }

    function b(g) {
        const v = document.createElement("textarea");
        v.value = g ? ? "", v.style.position = "absolute", v.style.opacity = "0", document.body.appendChild(v), v.select(), document.execCommand("copy"), v.remove()
    }

    function y() {
        var g, v, _;
        return (_ = (v = (g = document == null ? void 0 : document.getSelection) == null ? void 0 : g.call(document)) == null ? void 0 : v.toString()) != null ? _ : ""
    }

    function m(g) {
        return g === "granted" || g === "prompt"
    }
    return {
        isSupported: c,
        text: u,
        copied: d,
        copy: p
    }
}

function pee(t) {
    return JSON.parse(JSON.stringify(t))
}
const ef = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
    tf = "__vueuse_ssr_handlers__",
    mee = gee();

function gee() {
    return tf in ef || (ef[tf] = ef[tf] || {}), ef[tf]
}

function yee(t, e) {
    return mee[t] || e
}

function vee(t) {
    return t == null ? "any" : t instanceof Set ? "set" : t instanceof Map ? "map" : t instanceof Date ? "date" : typeof t == "boolean" ? "boolean" : typeof t == "string" ? "string" : typeof t == "object" ? "object" : Number.isNaN(t) ? "any" : "number"
}
const _ee = {
        boolean: {
            read: t => t === "true",
            write: t => String(t)
        },
        object: {
            read: t => JSON.parse(t),
            write: t => JSON.stringify(t)
        },
        number: {
            read: t => Number.parseFloat(t),
            write: t => String(t)
        },
        any: {
            read: t => t,
            write: t => String(t)
        },
        string: {
            read: t => t,
            write: t => String(t)
        },
        map: {
            read: t => new Map(JSON.parse(t)),
            write: t => JSON.stringify(Array.from(t.entries()))
        },
        set: {
            read: t => new Set(JSON.parse(t)),
            write: t => JSON.stringify(Array.from(t))
        },
        date: {
            read: t => new Date(t),
            write: t => t.toISOString()
        }
    },
    O1 = "vueuse-storage";

function QR(t, e, n, r = {}) {
    var i;
    const {
        flush: s = "pre",
        deep: o = !0,
        listenToStorageChanges: a = !0,
        writeDefaults: l = !0,
        mergeDefaults: c = !1,
        shallow: u,
        window: d = fi,
        eventFilter: f,
        onError: h = T => {
            console.error(T)
        },
        initOnMounted: p
    } = r, b = (u ? np : q)(typeof e == "function" ? e() : e);
    if (!n) try {
        n = yee("getDefaultStorage", () => {
            var T;
            return (T = fi) == null ? void 0 : T.localStorage
        })()
    } catch (T) {
        h(T)
    }
    if (!n) return b;
    const y = Cn(e),
        m = vee(y),
        g = (i = r.serializer) != null ? i : _ee[m],
        {
            pause: v,
            resume: _
        } = KR(b, () => w(b.value), {
            flush: s,
            deep: o,
            eventFilter: f
        });
    d && a && ox(() => {
        dn(d, "storage", C), dn(d, O1, A), p && C()
    }), p || C();

    function x(T, S) {
        d && d.dispatchEvent(new CustomEvent(O1, {
            detail: {
                key: t,
                oldValue: T,
                newValue: S,
                storageArea: n
            }
        }))
    }

    function w(T) {
        try {
            const S = n.getItem(t);
            if (T == null) x(S, null), n.removeItem(t);
            else {
                const P = g.write(T);
                S !== P && (n.setItem(t, P), x(S, P))
            }
        } catch (S) {
            h(S)
        }
    }

    function E(T) {
        const S = T ? T.newValue : n.getItem(t);
        if (S == null) return l && y != null && n.setItem(t, g.write(y)), y;
        if (!T && c) {
            const P = g.read(S);
            return typeof c == "function" ? c(P, y) : m === "object" && !Array.isArray(P) ? { ...y,
                ...P
            } : P
        } else return typeof S != "string" ? S : g.read(S)
    }

    function C(T) {
        if (!(T && T.storageArea !== n)) {
            if (T && T.key == null) {
                b.value = y;
                return
            }
            if (!(T && T.key !== t)) {
                v();
                try {
                    (T == null ? void 0 : T.newValue) !== g.write(b.value) && (b.value = E(T))
                } catch (S) {
                    h(S)
                } finally {
                    T ? Ue(_) : _()
                }
            }
        }
    }

    function A(T) {
        C(T.detail)
    }
    return b
}

function ewe(t = {}) {
    const {
        document: e = JR
    } = t;
    if (!e) return q("visible");
    const n = q(e.visibilityState);
    return dn(e, "visibilitychange", () => {
        n.value = e.visibilityState
    }), n
}

function bee(t, e, n = {}) {
    const {
        window: r = fi,
        ...i
    } = n;
    let s;
    const o = Hp(() => r && "ResizeObserver" in r),
        a = () => {
            s && (s.disconnect(), s = void 0)
        },
        l = te(() => Array.isArray(t) ? t.map(d => ri(d)) : [ri(t)]),
        c = he(l, d => {
            if (a(), o.value && r) {
                s = new ResizeObserver(e);
                for (const f of d) f && s.observe(f, i)
            }
        }, {
            immediate: !0,
            flush: "post"
        }),
        u = () => {
            a(), c()
        };
    return Vs(u), {
        isSupported: o,
        stop: u
    }
}

function twe(t, e = {}) {
    const {
        reset: n = !0,
        windowResize: r = !0,
        windowScroll: i = !0,
        immediate: s = !0
    } = e, o = q(0), a = q(0), l = q(0), c = q(0), u = q(0), d = q(0), f = q(0), h = q(0);

    function p() {
        const b = ri(t);
        if (!b) {
            n && (o.value = 0, a.value = 0, l.value = 0, c.value = 0, u.value = 0, d.value = 0, f.value = 0, h.value = 0);
            return
        }
        const y = b.getBoundingClientRect();
        o.value = y.height, a.value = y.bottom, l.value = y.left, c.value = y.right, u.value = y.top, d.value = y.width, f.value = y.x, h.value = y.y
    }
    return bee(t, p), he(() => ri(t), b => !b && p()), fee(t, p, {
        attributeFilter: ["style", "class"]
    }), i && dn("scroll", p, {
        capture: !0,
        passive: !0
    }), r && dn("resize", p, {
        passive: !0
    }), ox(() => {
        s && p()
    }), {
        height: o,
        bottom: a,
        left: l,
        right: c,
        top: u,
        width: d,
        x: f,
        y: h,
        update: p
    }
}
const fc = new Map;

function nwe(t) {
    const e = Vu();

    function n(a) {
        var l;
        const c = fc.get(t) || new Set;
        c.add(a), fc.set(t, c);
        const u = () => i(a);
        return (l = e == null ? void 0 : e.cleanups) == null || l.push(u), u
    }

    function r(a) {
        function l(...c) {
            i(l), a(...c)
        }
        return n(l)
    }

    function i(a) {
        const l = fc.get(t);
        l && (l.delete(a), l.size || s())
    }

    function s() {
        fc.delete(t)
    }

    function o(a, l) {
        var c;
        (c = fc.get(t)) == null || c.forEach(u => u(a, l))
    }
    return {
        on: n,
        once: r,
        off: i,
        emit: o,
        reset: s
    }
}

function Qm(t) {
    return typeof Window < "u" && t instanceof Window ? t.document.documentElement : typeof Document < "u" && t instanceof Document ? t.documentElement : t
}

function rwe(t, e, n = {}) {
    const {
        window: r = fi
    } = n;
    return QR(t, e, r == null ? void 0 : r.localStorage, n)
}

function ek(t) {
    const e = window.getComputedStyle(t);
    if (e.overflowX === "scroll" || e.overflowY === "scroll" || e.overflowX === "auto" && t.clientWidth < t.scrollWidth || e.overflowY === "auto" && t.clientHeight < t.scrollHeight) return !0; {
        const n = t.parentNode;
        return !n || n.tagName === "BODY" ? !1 : ek(n)
    }
}

function xee(t) {
    const e = t || window.event,
        n = e.target;
    return ek(n) ? !1 : e.touches.length > 1 ? !0 : (e.preventDefault && e.preventDefault(), !1)
}
const eg = new WeakMap;

function iwe(t, e = !1) {
    const n = q(e);
    let r = null,
        i = "";
    he(XR(t), a => {
        const l = Qm(Cn(a));
        if (l) {
            const c = l;
            if (eg.get(c) || eg.set(c, c.style.overflow), c.style.overflow !== "hidden" && (i = c.style.overflow), c.style.overflow === "hidden") return n.value = !0;
            if (n.value) return c.style.overflow = "hidden"
        }
    }, {
        immediate: !0
    });
    const s = () => {
            const a = Qm(Cn(t));
            !a || n.value || (Jv && (r = dn(a, "touchmove", l => {
                xee(l)
            }, {
                passive: !1
            })), a.style.overflow = "hidden", n.value = !0)
        },
        o = () => {
            const a = Qm(Cn(t));
            !a || !n.value || (Jv && (r == null || r()), a.style.overflow = i, eg.delete(a), n.value = !1)
        };
    return Vs(o), te({
        get() {
            return n.value
        },
        set(a) {
            a ? s() : o()
        }
    })
}

function swe(t, e, n = {}) {
    const {
        window: r = fi
    } = n;
    return QR(t, e, r == null ? void 0 : r.sessionStorage, n)
}
let wee = 0;

function owe(t, e = {}) {
    const n = q(!1),
        {
            document: r = JR,
            immediate: i = !0,
            manual: s = !1,
            id: o = `vueuse_styletag_${++wee}`
        } = e,
        a = q(t);
    let l = () => {};
    const c = () => {
            if (!r) return;
            const d = r.getElementById(o) || r.createElement("style");
            d.isConnected || (d.id = o, e.media && (d.media = e.media), r.head.appendChild(d)), !n.value && (l = he(a, f => {
                d.textContent = f
            }, {
                immediate: !0
            }), n.value = !0)
        },
        u = () => {
            !r || !n.value || (l(), r.head.removeChild(r.getElementById(o)), n.value = !1)
        };
    return i && !s && ox(c), s || Vs(u), {
        id: o,
        css: a,
        unload: u,
        load: c,
        isLoaded: pa(n)
    }
}

function awe(t, e = {}) {
    const {
        threshold: n = 50,
        onSwipe: r,
        onSwipeEnd: i,
        onSwipeStart: s,
        passive: o = !0,
        window: a = fi
    } = e, l = ft({
        x: 0,
        y: 0
    }), c = ft({
        x: 0,
        y: 0
    }), u = te(() => l.x - c.x), d = te(() => l.y - c.y), {
        max: f,
        abs: h
    } = Math, p = te(() => f(h(u.value), h(d.value)) >= n), b = q(!1), y = te(() => p.value ? h(u.value) > h(d.value) ? u.value > 0 ? "left" : "right" : d.value > 0 ? "up" : "down" : "none"), m = A => [A.touches[0].clientX, A.touches[0].clientY], g = (A, T) => {
        l.x = A, l.y = T
    }, v = (A, T) => {
        c.x = A, c.y = T
    };
    let _;
    const x = Eee(a == null ? void 0 : a.document);
    o ? _ = x ? {
        passive: !0
    } : {
        capture: !1
    } : _ = x ? {
        passive: !1,
        capture: !0
    } : {
        capture: !0
    };
    const w = A => {
            b.value && (i == null || i(A, y.value)), b.value = !1
        },
        E = [dn(t, "touchstart", A => {
            if (A.touches.length !== 1) return;
            _.capture && !_.passive && A.preventDefault();
            const [T, S] = m(A);
            g(T, S), v(T, S), s == null || s(A)
        }, _), dn(t, "touchmove", A => {
            if (A.touches.length !== 1) return;
            const [T, S] = m(A);
            v(T, S), !b.value && p.value && (b.value = !0), b.value && (r == null || r(A))
        }, _), dn(t, ["touchend", "touchcancel"], w, _)];
    return {
        isPassiveEventSupported: x,
        isSwiping: b,
        direction: y,
        coordsStart: l,
        coordsEnd: c,
        lengthX: u,
        lengthY: d,
        stop: () => E.forEach(A => A())
    }
}

function Eee(t) {
    if (!t) return !1;
    let e = !1;
    const n = {
        get passive() {
            return e = !0, !1
        }
    };
    return t.addEventListener("x", Kn, n), t.removeEventListener("x", Kn), e
}

function lwe(t = "history", e = {}) {
    const {
        initialValue: n = {},
        removeNullishValues: r = !0,
        removeFalsyValues: i = !1,
        write: s = !0,
        window: o = fi
    } = e;
    if (!o) return ft(n);
    const a = ft({});

    function l() {
        if (t === "history") return o.location.search || "";
        if (t === "hash") {
            const m = o.location.hash || "",
                g = m.indexOf("?");
            return g > 0 ? m.slice(g) : ""
        } else return (o.location.hash || "").replace(/^#/, "")
    }

    function c(m) {
        const g = m.toString();
        if (t === "history") return `${g?`?${g}`:""}${o.location.hash||""}`;
        if (t === "hash-params") return `${o.location.search||""}${g?`#${g}`:""}`;
        const v = o.location.hash || "#",
            _ = v.indexOf("?");
        return _ > 0 ? `${v.slice(0,_)}${g?`?${g}`:""}` : `${v}${g?`?${g}`:""}`
    }

    function u() {
        return new URLSearchParams(l())
    }

    function d(m) {
        const g = new Set(Object.keys(a));
        for (const v of m.keys()) {
            const _ = m.getAll(v);
            a[v] = _.length > 1 ? _ : m.get(v) || "", g.delete(v)
        }
        Array.from(g).forEach(v => delete a[v])
    }
    const {
        pause: f,
        resume: h
    } = KR(a, () => {
        const m = new URLSearchParams("");
        Object.keys(a).forEach(g => {
            const v = a[g];
            Array.isArray(v) ? v.forEach(_ => m.append(g, _)) : r && v == null || i && !v ? m.delete(g) : m.set(g, v)
        }), p(m)
    }, {
        deep: !0
    });

    function p(m, g) {
        f(), g && d(m), o.history.replaceState(o.history.state, o.document.title, o.location.pathname + c(m)), h()
    }

    function b() {
        s && p(u(), !0)
    }
    dn(o, "popstate", b, !1), t !== "history" && dn(o, "hashchange", b, !1);
    const y = u();
    return y.keys().next().value ? d(y) : Object.assign(a, n), a
}

function See(t, e, n, r = {}) {
    var i, s, o;
    const {
        clone: a = !1,
        passive: l = !1,
        eventName: c,
        deep: u = !1,
        defaultValue: d,
        shouldEmit: f
    } = r, h = rt(), p = n || (h == null ? void 0 : h.emit) || ((i = h == null ? void 0 : h.$emit) == null ? void 0 : i.bind(h)) || ((o = (s = h == null ? void 0 : h.proxy) == null ? void 0 : s.$emit) == null ? void 0 : o.bind(h == null ? void 0 : h.proxy));
    let b = c;
    e || (e = "modelValue"), b = b || `update:${e.toString()}`;
    const y = v => a ? typeof a == "function" ? a(v) : pee(v) : v,
        m = () => tee(t[e]) ? y(t[e]) : d,
        g = v => {
            f ? f(v) && p(b, v) : p(b, v)
        };
    if (l) {
        const v = m(),
            _ = q(v);
        let x = !1;
        return he(() => t[e], w => {
            x || (x = !0, _.value = y(w), Ue(() => x = !1))
        }), he(_, w => {
            !x && (w !== t[e] || u) && g(w)
        }, {
            deep: u
        }), _
    } else return te({
        get() {
            return m()
        },
        set(v) {
            g(v)
        }
    })
}

function cwe(t, e, n = {}) {
    const r = {};
    for (const i in t) r[i] = See(t, i, e, n);
    return r
}
var tk = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r()
    })(Jo, function() {
        return function(n, r, i) {
            n = n || {};
            var s = r.prototype,
                o = {
                    future: "in %s",
                    past: "%s ago",
                    s: "a few seconds",
                    m: "a minute",
                    mm: "%d minutes",
                    h: "an hour",
                    hh: "%d hours",
                    d: "a day",
                    dd: "%d days",
                    M: "a month",
                    MM: "%d months",
                    y: "a year",
                    yy: "%d years"
                };

            function a(c, u, d, f) {
                return s.fromToBase(c, u, d, f)
            }
            i.en.relativeTime = o, s.fromToBase = function(c, u, d, f, h) {
                for (var p, b, y, m = d.$locale().relativeTime || o, g = n.thresholds || [{
                        l: "s",
                        r: 44,
                        d: "second"
                    }, {
                        l: "m",
                        r: 89
                    }, {
                        l: "mm",
                        r: 44,
                        d: "minute"
                    }, {
                        l: "h",
                        r: 89
                    }, {
                        l: "hh",
                        r: 21,
                        d: "hour"
                    }, {
                        l: "d",
                        r: 35
                    }, {
                        l: "dd",
                        r: 25,
                        d: "day"
                    }, {
                        l: "M",
                        r: 45
                    }, {
                        l: "MM",
                        r: 10,
                        d: "month"
                    }, {
                        l: "y",
                        r: 17
                    }, {
                        l: "yy",
                        d: "year"
                    }], v = g.length, _ = 0; _ < v; _ += 1) {
                    var x = g[_];
                    x.d && (p = f ? i(c).diff(d, x.d, !0) : d.diff(c, x.d, !0));
                    var w = (n.rounding || Math.round)(Math.abs(p));
                    if (y = p > 0, w <= x.r || !x.r) {
                        w <= 1 && _ > 0 && (x = g[_ - 1]);
                        var E = m[x.l];
                        h && (w = h("" + w)), b = typeof E == "string" ? E.replace("%d", w) : E(w, u, x.l, y);
                        break
                    }
                }
                if (u) return b;
                var C = y ? m.future : m.past;
                return typeof C == "function" ? C(b) : C.replace("%s", b)
            }, s.to = function(c, u) {
                return a(c, u, this, !0)
            }, s.from = function(c, u) {
                return a(c, u, this)
            };
            var l = function(c) {
                return c.$u ? i.utc() : i()
            };
            s.toNow = function(c) {
                return this.to(l(this), c)
            }, s.fromNow = function(c) {
                return this.from(l(this), c)
            }
        }
    })
})(tk);
var Tee = tk.exports;
const uwe = Hl(Tee);
var Cee = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r(Ob)
    })(Jo, function(n) {
        function r(o) {
            return o && typeof o == "object" && "default" in o ? o : {
                default: o
            }
        }
        var i = r(n),
            s = {
                name: "zh-cn",
                weekdays: "______".split("_"),
                weekdaysShort: "______".split("_"),
                weekdaysMin: "______".split("_"),
                months: "___________".split("_"),
                monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
                ordinal: function(o, a) {
                    return a === "W" ? o + "" : o + ""
                },
                weekStart: 1,
                yearStart: 4,
                formats: {
                    LT: "HH:mm",
                    LTS: "HH:mm:ss",
                    L: "YYYY/MM/DD",
                    LL: "YYYYMD",
                    LLL: "YYYYMDAhmm",
                    LLLL: "YYYYMDddddAhmm",
                    l: "YYYY/M/D",
                    ll: "YYYYMD",
                    lll: "YYYYMD HH:mm",
                    llll: "YYYYMDdddd HH:mm"
                },
                relativeTime: {
                    future: "%s",
                    past: "%s",
                    s: "",
                    m: "1 ",
                    mm: "%d ",
                    h: "1 ",
                    hh: "%d ",
                    d: "1 ",
                    dd: "%d ",
                    M: "1 ",
                    MM: "%d ",
                    y: "1 ",
                    yy: "%d "
                },
                meridiem: function(o, a) {
                    var l = 100 * o + a;
                    return l < 600 ? "" : l < 900 ? "" : l < 1100 ? "" : l < 1300 ? "" : l < 1800 ? "" : ""
                }
            };
        return i.default.locale(s, null, !0), s
    })
})(Cee);
var Pee = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r(Ob)
    })(Jo, function(n) {
        function r(o) {
            return o && typeof o == "object" && "default" in o ? o : {
                default: o
            }
        }
        var i = r(n),
            s = {
                name: "zh-tw",
                weekdays: "______".split("_"),
                weekdaysShort: "______".split("_"),
                weekdaysMin: "______".split("_"),
                months: "___________".split("_"),
                monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
                ordinal: function(o, a) {
                    return a === "W" ? o + "" : o + ""
                },
                formats: {
                    LT: "HH:mm",
                    LTS: "HH:mm:ss",
                    L: "YYYY/MM/DD",
                    LL: "YYYYMD",
                    LLL: "YYYYMD HH:mm",
                    LLLL: "YYYYMDdddd HH:mm",
                    l: "YYYY/M/D",
                    ll: "YYYYMD",
                    lll: "YYYYMD HH:mm",
                    llll: "YYYYMDdddd HH:mm"
                },
                relativeTime: {
                    future: "%s",
                    past: "%s",
                    s: "",
                    m: "1 ",
                    mm: "%d ",
                    h: "1 ",
                    hh: "%d ",
                    d: "1 ",
                    dd: "%d ",
                    M: "1 ",
                    MM: "%d ",
                    y: "1 ",
                    yy: "%d "
                },
                meridiem: function(o, a) {
                    var l = 100 * o + a;
                    return l < 600 ? "" : l < 900 ? "" : l < 1100 ? "" : l < 1300 ? "" : l < 1800 ? "" : ""
                }
            };
        return i.default.locale(s, null, !0), s
    })
})(Pee);
var Aee = {
    exports: {}
};
(function(t, e) {
    (function(n, r) {
        t.exports = r()
    })(Jo, function() {
        return {
            name: "en",
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            ordinal: function(n) {
                var r = ["th", "st", "nd", "rd"],
                    i = n % 100;
                return "[" + n + (r[(i - 20) % 10] || r[i] || r[0]) + "]"
            }
        }
    })
})(Aee);
/*!
 * vue-router v4.1.6
 * (c) 2022 Eduardo San Martin Morote
 * @license MIT
 */
const Mi = typeof window < "u";

function Oee(t) {
    return t.__esModule || t[Symbol.toStringTag] === "Module"
}
const nt = Object.assign;

function tg(t, e) {
    const n = {};
    for (const r in e) {
        const i = e[r];
        n[r] = Qn(i) ? i.map(t) : t(i)
    }
    return n
}
const jc = () => {},
    Qn = Array.isArray;

function je(t) {
    const e = Array.from(arguments).slice(1);
    console.warn.apply(console, ["[Vue Router warn]: " + t].concat(e))
}
const Iee = /\/$/,
    Mee = t => t.replace(Iee, "");

function ng(t, e, n = "/") {
    let r, i = {},
        s = "",
        o = "";
    const a = e.indexOf("#");
    let l = e.indexOf("?");
    return a < l && a >= 0 && (l = -1), l > -1 && (r = e.slice(0, l), s = e.slice(l + 1, a > -1 ? a : e.length), i = t(s)), a > -1 && (r = r || e.slice(0, a), o = e.slice(a, e.length)), r = Bee(r ? ? e, n), {
        fullPath: r + (s && "?") + s + o,
        path: r,
        query: i,
        hash: o
    }
}

function Ree(t, e) {
    const n = e.query ? t(e.query) : "";
    return e.path + (n && "?") + n + (e.hash || "")
}

function I1(t, e) {
    return !e || !t.toLowerCase().startsWith(e.toLowerCase()) ? t : t.slice(e.length) || "/"
}

function M1(t, e, n) {
    const r = e.matched.length - 1,
        i = n.matched.length - 1;
    return r > -1 && r === i && Ys(e.matched[r], n.matched[i]) && nk(e.params, n.params) && t(e.query) === t(n.query) && e.hash === n.hash
}

function Ys(t, e) {
    return (t.aliasOf || t) === (e.aliasOf || e)
}

function nk(t, e) {
    if (Object.keys(t).length !== Object.keys(e).length) return !1;
    for (const n in t)
        if (!kee(t[n], e[n])) return !1;
    return !0
}

function kee(t, e) {
    return Qn(t) ? R1(t, e) : Qn(e) ? R1(e, t) : t === e
}

function R1(t, e) {
    return Qn(e) ? t.length === e.length && t.every((n, r) => n === e[r]) : t.length === 1 && t[0] === e
}

function Bee(t, e) {
    if (t.startsWith("/")) return t;
    if (!e.startsWith("/")) return je(`Cannot resolve a relative location without an absolute path. Trying to resolve "${t}" from "${e}". It should look like "/${e}".`), t;
    if (!t) return e;
    const n = e.split("/"),
        r = t.split("/");
    let i = n.length - 1,
        s, o;
    for (s = 0; s < r.length; s++)
        if (o = r[s], o !== ".")
            if (o === "..") i > 1 && i--;
            else break;
    return n.slice(0, i).join("/") + "/" + r.slice(s - (s === r.length ? 1 : 0)).join("/")
}
var Cu;
(function(t) {
    t.pop = "pop", t.push = "push"
})(Cu || (Cu = {}));
var Vc;
(function(t) {
    t.back = "back", t.forward = "forward", t.unknown = ""
})(Vc || (Vc = {}));

function Dee(t) {
    if (!t)
        if (Mi) {
            const e = document.querySelector("base");
            t = e && e.getAttribute("href") || "/", t = t.replace(/^\w+:\/\/[^\/]+/, "")
        } else t = "/";
    return t[0] !== "/" && t[0] !== "#" && (t = "/" + t), Mee(t)
}
const $ee = /^[^#]+#/;

function Fee(t, e) {
    return t.replace($ee, "#") + e
}

function Lee(t, e) {
    const n = document.documentElement.getBoundingClientRect(),
        r = t.getBoundingClientRect();
    return {
        behavior: e.behavior,
        left: r.left - n.left - (e.left || 0),
        top: r.top - n.top - (e.top || 0)
    }
}
const zp = () => ({
    left: window.pageXOffset,
    top: window.pageYOffset
});

function Nee(t) {
    let e;
    if ("el" in t) {
        const n = t.el,
            r = typeof n == "string" && n.startsWith("#");
        if (typeof t.el == "string" && (!r || !document.getElementById(t.el.slice(1)))) try {
            const s = document.querySelector(t.el);
            if (r && s) {
                je(`The selector "${t.el}" should be passed as "el: document.querySelector('${t.el}')" because it starts with "#".`);
                return
            }
        } catch {
            je(`The selector "${t.el}" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);
            return
        }
        const i = typeof n == "string" ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
        if (!i) {
            je(`Couldn't find element using selector "${t.el}" returned by scrollBehavior.`);
            return
        }
        e = Lee(i, t)
    } else e = t;
    "scrollBehavior" in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.pageXOffset, e.top != null ? e.top : window.pageYOffset)
}

function k1(t, e) {
    return (history.state ? history.state.position - e : -1) + t
}
const Zv = new Map;

function Uee(t, e) {
    Zv.set(t, e)
}

function Gee(t) {
    const e = Zv.get(t);
    return Zv.delete(t), e
}
let Hee = () => location.protocol + "//" + location.host;

function rk(t, e) {
    const {
        pathname: n,
        search: r,
        hash: i
    } = e, s = t.indexOf("#");
    if (s > -1) {
        let a = i.includes(t.slice(s)) ? t.slice(s).length : 1,
            l = i.slice(a);
        return l[0] !== "/" && (l = "/" + l), I1(l, "")
    }
    return I1(n, t) + r + i
}

function zee(t, e, n, r) {
    let i = [],
        s = [],
        o = null;
    const a = ({
        state: f
    }) => {
        const h = rk(t, location),
            p = n.value,
            b = e.value;
        let y = 0;
        if (f) {
            if (n.value = h, e.value = f, o && o === p) {
                o = null;
                return
            }
            y = b ? f.position - b.position : 0
        } else r(h);
        i.forEach(m => {
            m(n.value, p, {
                delta: y,
                type: Cu.pop,
                direction: y ? y > 0 ? Vc.forward : Vc.back : Vc.unknown
            })
        })
    };

    function l() {
        o = n.value
    }

    function c(f) {
        i.push(f);
        const h = () => {
            const p = i.indexOf(f);
            p > -1 && i.splice(p, 1)
        };
        return s.push(h), h
    }

    function u() {
        const {
            history: f
        } = window;
        f.state && f.replaceState(nt({}, f.state, {
            scroll: zp()
        }), "")
    }

    function d() {
        for (const f of s) f();
        s = [], window.removeEventListener("popstate", a), window.removeEventListener("beforeunload", u)
    }
    return window.addEventListener("popstate", a), window.addEventListener("beforeunload", u), {
        pauseListeners: l,
        listen: c,
        destroy: d
    }
}

function B1(t, e, n, r = !1, i = !1) {
    return {
        back: t,
        current: e,
        forward: n,
        replaced: r,
        position: window.history.length,
        scroll: i ? zp() : null
    }
}

function jee(t) {
    const {
        history: e,
        location: n
    } = window, r = {
        value: rk(t, n)
    }, i = {
        value: e.state
    };
    i.value || s(r.value, {
        back: null,
        current: r.value,
        forward: null,
        position: e.length - 1,
        replaced: !0,
        scroll: null
    }, !0);

    function s(l, c, u) {
        const d = t.indexOf("#"),
            f = d > -1 ? (n.host && document.querySelector("base") ? t : t.slice(d)) + l : Hee() + t + l;
        try {
            e[u ? "replaceState" : "pushState"](c, "", f), i.value = c
        } catch (h) {
            je("Error with push/replace State", h), n[u ? "replace" : "assign"](f)
        }
    }

    function o(l, c) {
        const u = nt({}, e.state, B1(i.value.back, l, i.value.forward, !0), c, {
            position: i.value.position
        });
        s(l, u, !0), r.value = l
    }

    function a(l, c) {
        const u = nt({}, i.value, e.state, {
            forward: l,
            scroll: zp()
        });
        e.state || je(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:

history.replaceState(history.state, '', url)

You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`), s(u.current, u, !0);
        const d = nt({}, B1(r.value, l, null), {
            position: u.position + 1
        }, c);
        s(l, d, !1), r.value = l
    }
    return {
        location: r,
        state: i,
        push: a,
        replace: o
    }
}

function Vee(t) {
    t = Dee(t);
    const e = jee(t),
        n = zee(t, e.state, e.location, e.replace);

    function r(s, o = !0) {
        o || n.pauseListeners(), history.go(s)
    }
    const i = nt({
        location: "",
        base: t,
        go: r,
        createHref: Fee.bind(null, t)
    }, e, n);
    return Object.defineProperty(i, "location", {
        enumerable: !0,
        get: () => e.location.value
    }), Object.defineProperty(i, "state", {
        enumerable: !0,
        get: () => e.state.value
    }), i
}

function dwe(t) {
    return t = location.host ? t || location.pathname + location.search : "", t.includes("#") || (t += "#"), !t.endsWith("#/") && !t.endsWith("#") && je(`A hash base must end with a "#":
"${t}" should be "${t.replace(/#.*$/,"#")}".`), Vee(t)
}

function Wee(t) {
    return typeof t == "string" || t && typeof t == "object"
}

function ik(t) {
    return typeof t == "string" || typeof t == "symbol"
}
const ps = {
        path: "/",
        name: void 0,
        params: {},
        query: {},
        hash: "",
        fullPath: "/",
        matched: [],
        meta: {},
        redirectedFrom: void 0
    },
    sk = Symbol("navigation failure");
var D1;
(function(t) {
    t[t.aborted = 4] = "aborted", t[t.cancelled = 8] = "cancelled", t[t.duplicated = 16] = "duplicated"
})(D1 || (D1 = {}));
const Yee = {
    1({
        location: t,
        currentLocation: e
    }) {
        return `No match for
 ${JSON.stringify(t)}${e?`
while being at
`+JSON.stringify(e):""}`
    },
    2({
        from: t,
        to: e
    }) {
        return `Redirected from "${t.fullPath}" to "${qee(e)}" via a navigation guard.`
    },
    4({
        from: t,
        to: e
    }) {
        return `Navigation aborted from "${t.fullPath}" to "${e.fullPath}" via a navigation guard.`
    },
    8({
        from: t,
        to: e
    }) {
        return `Navigation cancelled from "${t.fullPath}" to "${e.fullPath}" with a new navigation.`
    },
    16({
        from: t,
        to: e
    }) {
        return `Avoided redundant navigation to current location: "${t.fullPath}".`
    }
};

function wl(t, e) {
    return nt(new Error(Yee[t](e)), {
        type: t,
        [sk]: !0
    }, e)
}

function xi(t, e) {
    return t instanceof Error && sk in t && (e == null || !!(t.type & e))
}
const Xee = ["params", "query", "hash"];

function qee(t) {
    if (typeof t == "string") return t;
    if ("path" in t) return t.path;
    const e = {};
    for (const n of Xee) n in t && (e[n] = t[n]);
    return JSON.stringify(e, null, 2)
}
const $1 = "[^/]+?",
    Kee = {
        sensitive: !1,
        strict: !1,
        start: !0,
        end: !0
    },
    Jee = /[.+*?^${}()[\]/\\]/g;

function Zee(t, e) {
    const n = nt({}, Kee, e),
        r = [];
    let i = n.start ? "^" : "";
    const s = [];
    for (const c of t) {
        const u = c.length ? [] : [90];
        n.strict && !c.length && (i += "/");
        for (let d = 0; d < c.length; d++) {
            const f = c[d];
            let h = 40 + (n.sensitive ? .25 : 0);
            if (f.type === 0) d || (i += "/"), i += f.value.replace(Jee, "\\$&"), h += 40;
            else if (f.type === 1) {
                const {
                    value: p,
                    repeatable: b,
                    optional: y,
                    regexp: m
                } = f;
                s.push({
                    name: p,
                    repeatable: b,
                    optional: y
                });
                const g = m || $1;
                if (g !== $1) {
                    h += 10;
                    try {
                        new RegExp(`(${g})`)
                    } catch (_) {
                        throw new Error(`Invalid custom RegExp for param "${p}" (${g}): ` + _.message)
                    }
                }
                let v = b ? `((?:${g})(?:/(?:${g}))*)` : `(${g})`;
                d || (v = y && c.length < 2 ? `(?:/${v})` : "/" + v), y && (v += "?"), i += v, h += 20, y && (h += -8), b && (h += -20), g === ".*" && (h += -50)
            }
            u.push(h)
        }
        r.push(u)
    }
    if (n.strict && n.end) {
        const c = r.length - 1;
        r[c][r[c].length - 1] += .7000000000000001
    }
    n.strict || (i += "/?"), n.end ? i += "$" : n.strict && (i += "(?:/|$)");
    const o = new RegExp(i, n.sensitive ? "" : "i");

    function a(c) {
        const u = c.match(o),
            d = {};
        if (!u) return null;
        for (let f = 1; f < u.length; f++) {
            const h = u[f] || "",
                p = s[f - 1];
            d[p.name] = h && p.repeatable ? h.split("/") : h
        }
        return d
    }

    function l(c) {
        let u = "",
            d = !1;
        for (const f of t) {
            (!d || !u.endsWith("/")) && (u += "/"), d = !1;
            for (const h of f)
                if (h.type === 0) u += h.value;
                else if (h.type === 1) {
                const {
                    value: p,
                    repeatable: b,
                    optional: y
                } = h, m = p in c ? c[p] : "";
                if (Qn(m) && !b) throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`);
                const g = Qn(m) ? m.join("/") : m;
                if (!g)
                    if (y) f.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : d = !0);
                    else throw new Error(`Missing required param "${p}"`);
                u += g
            }
        }
        return u || "/"
    }
    return {
        re: o,
        score: r,
        keys: s,
        parse: a,
        stringify: l
    }
}

function Qee(t, e) {
    let n = 0;
    for (; n < t.length && n < e.length;) {
        const r = e[n] - t[n];
        if (r) return r;
        n++
    }
    return t.length < e.length ? t.length === 1 && t[0] === 40 + 40 ? -1 : 1 : t.length > e.length ? e.length === 1 && e[0] === 40 + 40 ? 1 : -1 : 0
}

function ete(t, e) {
    let n = 0;
    const r = t.score,
        i = e.score;
    for (; n < r.length && n < i.length;) {
        const s = Qee(r[n], i[n]);
        if (s) return s;
        n++
    }
    if (Math.abs(i.length - r.length) === 1) {
        if (F1(r)) return 1;
        if (F1(i)) return -1
    }
    return i.length - r.length
}

function F1(t) {
    const e = t[t.length - 1];
    return t.length > 0 && e[e.length - 1] < 0
}
const tte = {
        type: 0,
        value: ""
    },
    nte = /[a-zA-Z0-9_]/;

function rte(t) {
    if (!t) return [
        []
    ];
    if (t === "/") return [
        [tte]
    ];
    if (!t.startsWith("/")) throw new Error(`Route paths should start with a "/": "${t}" should be "/${t}".`);

    function e(h) {
        throw new Error(`ERR (${n})/"${c}": ${h}`)
    }
    let n = 0,
        r = n;
    const i = [];
    let s;

    function o() {
        s && i.push(s), s = []
    }
    let a = 0,
        l, c = "",
        u = "";

    function d() {
        c && (n === 0 ? s.push({
            type: 0,
            value: c
        }) : n === 1 || n === 2 || n === 3 ? (s.length > 1 && (l === "*" || l === "+") && e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), s.push({
            type: 1,
            value: c,
            regexp: u,
            repeatable: l === "*" || l === "+",
            optional: l === "*" || l === "?"
        })) : e("Invalid state to consume buffer"), c = "")
    }

    function f() {
        c += l
    }
    for (; a < t.length;) {
        if (l = t[a++], l === "\\" && n !== 2) {
            r = n, n = 4;
            continue
        }
        switch (n) {
            case 0:
                l === "/" ? (c && d(), o()) : l === ":" ? (d(), n = 1) : f();
                break;
            case 4:
                f(), n = r;
                break;
            case 1:
                l === "(" ? n = 2 : nte.test(l) ? f() : (d(), n = 0, l !== "*" && l !== "?" && l !== "+" && a--);
                break;
            case 2:
                l === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + l : n = 3 : u += l;
                break;
            case 3:
                d(), n = 0, l !== "*" && l !== "?" && l !== "+" && a--, u = "";
                break;
            default:
                e("Unknown state");
                break
        }
    }
    return n === 2 && e(`Unfinished custom RegExp for param "${c}"`), d(), o(), i
}

function ite(t, e, n) {
    const r = Zee(rte(t.path), n); {
        const s = new Set;
        for (const o of r.keys) s.has(o.name) && je(`Found duplicated params with name "${o.name}" for path "${t.path}". Only the last one will be available on "$route.params".`), s.add(o.name)
    }
    const i = nt(r, {
        record: t,
        parent: e,
        children: [],
        alias: []
    });
    return e && !i.record.aliasOf == !e.record.aliasOf && e.children.push(i), i
}

function ste(t, e) {
    const n = [],
        r = new Map;
    e = U1({
        strict: !1,
        end: !0,
        sensitive: !1
    }, e);

    function i(u) {
        return r.get(u)
    }

    function s(u, d, f) {
        const h = !f,
            p = ote(u);
        ute(p, d), p.aliasOf = f && f.record;
        const b = U1(e, u),
            y = [p];
        if ("alias" in u) {
            const v = typeof u.alias == "string" ? [u.alias] : u.alias;
            for (const _ of v) y.push(nt({}, p, {
                components: f ? f.record.components : p.components,
                path: _,
                aliasOf: f ? f.record : p
            }))
        }
        let m, g;
        for (const v of y) {
            const {
                path: _
            } = v;
            if (d && _[0] !== "/") {
                const x = d.record.path,
                    w = x[x.length - 1] === "/" ? "" : "/";
                v.path = d.record.path + (_ && w + _)
            }
            if (v.path === "*") throw new Error(`Catch all routes ("*") must now be defined using a param with a custom regexp.
See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.`);
            if (m = ite(v, d, b), d && _[0] === "/" && dte(m, d), f ? (f.alias.push(m), cte(f, m)) : (g = g || m, g !== m && g.alias.push(m), h && u.name && !N1(m) && o(u.name)), p.children) {
                const x = p.children;
                for (let w = 0; w < x.length; w++) s(x[w], m, f && f.children[w])
            }
            f = f || m, (m.record.components && Object.keys(m.record.components).length || m.record.name || m.record.redirect) && l(m)
        }
        return g ? () => {
            o(g)
        } : jc
    }

    function o(u) {
        if (ik(u)) {
            const d = r.get(u);
            d && (r.delete(u), n.splice(n.indexOf(d), 1), d.children.forEach(o), d.alias.forEach(o))
        } else {
            const d = n.indexOf(u);
            d > -1 && (n.splice(d, 1), u.record.name && r.delete(u.record.name), u.children.forEach(o), u.alias.forEach(o))
        }
    }

    function a() {
        return n
    }

    function l(u) {
        let d = 0;
        for (; d < n.length && ete(u, n[d]) >= 0 && (u.record.path !== n[d].record.path || !ok(u, n[d]));) d++;
        n.splice(d, 0, u), u.record.name && !N1(u) && r.set(u.record.name, u)
    }

    function c(u, d) {
        let f, h = {},
            p, b;
        if ("name" in u && u.name) {
            if (f = r.get(u.name), !f) throw wl(1, {
                location: u
            }); {
                const g = Object.keys(u.params || {}).filter(v => !f.keys.find(_ => _.name === v));
                g.length && je(`Discarded invalid param(s) "${g.join('", "')}" when navigating. See https://github.com/vuejs/router/blob/main/packages/router/CHANGELOG.md#414-2022-08-22 for more details.`)
            }
            b = f.record.name, h = nt(L1(d.params, f.keys.filter(g => !g.optional).map(g => g.name)), u.params && L1(u.params, f.keys.map(g => g.name))), p = f.stringify(h)
        } else if ("path" in u) p = u.path, p.startsWith("/") || je(`The Matcher cannot resolve relative paths but received "${p}". Unless you directly called \`matcher.resolve("${p}")\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`), f = n.find(g => g.re.test(p)), f && (h = f.parse(p), b = f.record.name);
        else {
            if (f = d.name ? r.get(d.name) : n.find(g => g.re.test(d.path)), !f) throw wl(1, {
                location: u,
                currentLocation: d
            });
            b = f.record.name, h = nt({}, d.params, u.params), p = f.stringify(h)
        }
        const y = [];
        let m = f;
        for (; m;) y.unshift(m.record), m = m.parent;
        return {
            name: b,
            path: p,
            params: h,
            matched: y,
            meta: lte(y)
        }
    }
    return t.forEach(u => s(u)), {
        addRoute: s,
        resolve: c,
        removeRoute: o,
        getRoutes: a,
        getRecordMatcher: i
    }
}

function L1(t, e) {
    const n = {};
    for (const r of e) r in t && (n[r] = t[r]);
    return n
}

function ote(t) {
    return {
        path: t.path,
        redirect: t.redirect,
        name: t.name,
        meta: t.meta || {},
        aliasOf: void 0,
        beforeEnter: t.beforeEnter,
        props: ate(t),
        children: t.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components" in t ? t.components || null : t.component && {
            default: t.component
        }
    }
}

function ate(t) {
    const e = {},
        n = t.props || !1;
    if ("component" in t) e.default = n;
    else
        for (const r in t.components) e[r] = typeof n == "boolean" ? n : n[r];
    return e
}

function N1(t) {
    for (; t;) {
        if (t.record.aliasOf) return !0;
        t = t.parent
    }
    return !1
}

function lte(t) {
    return t.reduce((e, n) => nt(e, n.meta), {})
}

function U1(t, e) {
    const n = {};
    for (const r in t) n[r] = r in e ? e[r] : t[r];
    return n
}

function Qv(t, e) {
    return t.name === e.name && t.optional === e.optional && t.repeatable === e.repeatable
}

function cte(t, e) {
    for (const n of t.keys)
        if (!n.optional && !e.keys.find(Qv.bind(null, n))) return je(`Alias "${e.record.path}" and the original record: "${t.record.path}" must have the exact same param named "${n.name}"`);
    for (const n of e.keys)
        if (!n.optional && !t.keys.find(Qv.bind(null, n))) return je(`Alias "${e.record.path}" and the original record: "${t.record.path}" must have the exact same param named "${n.name}"`)
}

function ute(t, e) {
    e && e.record.name && !t.name && !t.path && je(`The route named "${String(e.record.name)}" has a child without a name and an empty path. Using that name won't render the empty path child so you probably want to move the name to the child instead. If this is intentional, add a name to the child route to remove the warning.`)
}

function dte(t, e) {
    for (const n of e.keys)
        if (!t.keys.find(Qv.bind(null, n))) return je(`Absolute path "${t.record.path}" must have the exact same param named "${n.name}" as its parent "${e.record.path}".`)
}

function ok(t, e) {
    return e.children.some(n => n === t || ok(t, n))
}
const ak = /#/g,
    fte = /&/g,
    hte = /\//g,
    pte = /=/g,
    mte = /\?/g,
    lk = /\+/g,
    gte = /%5B/g,
    yte = /%5D/g,
    ck = /%5E/g,
    vte = /%60/g,
    uk = /%7B/g,
    _te = /%7C/g,
    dk = /%7D/g,
    bte = /%20/g;

function ax(t) {
    return encodeURI("" + t).replace(_te, "|").replace(gte, "[").replace(yte, "]")
}

function xte(t) {
    return ax(t).replace(uk, "{").replace(dk, "}").replace(ck, "^")
}

function e0(t) {
    return ax(t).replace(lk, "%2B").replace(bte, "+").replace(ak, "%23").replace(fte, "%26").replace(vte, "`").replace(uk, "{").replace(dk, "}").replace(ck, "^")
}

function wte(t) {
    return e0(t).replace(pte, "%3D")
}

function Ete(t) {
    return ax(t).replace(ak, "%23").replace(mte, "%3F")
}

function Ste(t) {
    return t == null ? "" : Ete(t).replace(hte, "%2F")
}

function Pu(t) {
    try {
        return decodeURIComponent("" + t)
    } catch {
        je(`Error decoding "${t}". Using original value`)
    }
    return "" + t
}

function Tte(t) {
    const e = {};
    if (t === "" || t === "?") return e;
    const r = (t[0] === "?" ? t.slice(1) : t).split("&");
    for (let i = 0; i < r.length; ++i) {
        const s = r[i].replace(lk, " "),
            o = s.indexOf("="),
            a = Pu(o < 0 ? s : s.slice(0, o)),
            l = o < 0 ? null : Pu(s.slice(o + 1));
        if (a in e) {
            let c = e[a];
            Qn(c) || (c = e[a] = [c]), c.push(l)
        } else e[a] = l
    }
    return e
}

function G1(t) {
    let e = "";
    for (let n in t) {
        const r = t[n];
        if (n = wte(n), r == null) {
            r !== void 0 && (e += (e.length ? "&" : "") + n);
            continue
        }(Qn(r) ? r.map(s => s && e0(s)) : [r && e0(r)]).forEach(s => {
            s !== void 0 && (e += (e.length ? "&" : "") + n, s != null && (e += "=" + s))
        })
    }
    return e
}

function Cte(t) {
    const e = {};
    for (const n in t) {
        const r = t[n];
        r !== void 0 && (e[n] = Qn(r) ? r.map(i => i == null ? null : "" + i) : r == null ? r : "" + r)
    }
    return e
}
const fk = Symbol("router view location matched"),
    H1 = Symbol("router view depth"),
    jp = Symbol("router"),
    lx = Symbol("route location"),
    t0 = Symbol("router view location");

function hc() {
    let t = [];

    function e(r) {
        return t.push(r), () => {
            const i = t.indexOf(r);
            i > -1 && t.splice(i, 1)
        }
    }

    function n() {
        t = []
    }
    return {
        add: e,
        list: () => t,
        reset: n
    }
}

function Pte(t, e, n) {
    const r = () => {
        t[e].delete(n)
    };
    is(r), hi(r), ns(() => {
        t[e].add(n)
    }), t[e].add(n)
}

function fwe(t) {
    if (!rt()) {
        je("getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function");
        return
    }
    const e = Nt(fk, {}).value;
    if (!e) {
        je("No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside a component child of <router-view>. Maybe you called it inside of App.vue?");
        return
    }
    Pte(e, "leaveGuards", t)
}

function _s(t, e, n, r, i) {
    const s = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || []);
    return () => new Promise((o, a) => {
        const l = d => {
                d === !1 ? a(wl(4, {
                    from: n,
                    to: e
                })) : d instanceof Error ? a(d) : Wee(d) ? a(wl(2, {
                    from: e,
                    to: d
                })) : (s && r.enterCallbacks[i] === s && typeof d == "function" && s.push(d), o())
            },
            c = t.call(r && r.instances[i], e, n, Ate(l, e, n));
        let u = Promise.resolve(c);
        if (t.length < 3 && (u = u.then(l)), t.length > 2) {
            const d = `The "next" callback was never called inside of ${t.name?'"'+t.name+'"':""}:
${t.toString()}
. If you are returning a value instead of calling "next", make sure to remove the "next" parameter from your function.`;
            if (typeof c == "object" && "then" in c) u = u.then(f => l._called ? f : (je(d), Promise.reject(new Error("Invalid navigation guard"))));
            else if (c !== void 0 && !l._called) {
                je(d), a(new Error("Invalid navigation guard"));
                return
            }
        }
        u.catch(d => a(d))
    })
}

function Ate(t, e, n) {
    let r = 0;
    return function() {
        r++ === 1 && je(`The "next" callback was called more than once in one navigation guard when going from "${n.fullPath}" to "${e.fullPath}". It should be called exactly one time in each navigation guard. This will fail in production.`), t._called = !0, r === 1 && t.apply(null, arguments)
    }
}

function rg(t, e, n, r) {
    const i = [];
    for (const s of t) {
        !s.components && !s.children.length && je(`Record with path "${s.path}" is either missing a "component(s)" or "children" property.`);
        for (const o in s.components) {
            let a = s.components[o]; {
                if (!a || typeof a != "object" && typeof a != "function") throw je(`Component "${o}" in record with path "${s.path}" is not a valid component. Received "${String(a)}".`), new Error("Invalid route component");
                if ("then" in a) {
                    je(`Component "${o}" in record with path "${s.path}" is a Promise instead of a function that returns a Promise. Did you write "import('./MyPage.vue')" instead of "() => import('./MyPage.vue')" ? This will break in production if not fixed.`);
                    const l = a;
                    a = () => l
                } else a.__asyncLoader && !a.__warnedDefineAsync && (a.__warnedDefineAsync = !0, je(`Component "${o}" in record with path "${s.path}" is defined using "defineAsyncComponent()". Write "() => import('./MyPage.vue')" instead of "defineAsyncComponent(() => import('./MyPage.vue'))".`))
            }
            if (!(e !== "beforeRouteEnter" && !s.instances[o]))
                if (Ote(a)) {
                    const c = (a.__vccOpts || a)[e];
                    c && i.push(_s(c, n, r, s, o))
                } else {
                    let l = a();
                    "catch" in l || (je(`Component "${o}" in record with path "${s.path}" is a function that does not return a Promise. If you were passing a functional component, make sure to add a "displayName" to the component. This will break in production if not fixed.`), l = Promise.resolve(l)), i.push(() => l.then(c => {
                        if (!c) return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${s.path}"`));
                        const u = Oee(c) ? c.default : c;
                        s.components[o] = u;
                        const f = (u.__vccOpts || u)[e];
                        return f && _s(f, n, r, s, o)()
                    }))
                }
        }
    }
    return i
}

function Ote(t) {
    return typeof t == "object" || "displayName" in t || "props" in t || "__vccOpts" in t
}

function z1(t) {
    const e = Nt(jp),
        n = Nt(lx),
        r = te(() => e.resolve(En(t.to))),
        i = te(() => {
            const {
                matched: l
            } = r.value, {
                length: c
            } = l, u = l[c - 1], d = n.matched;
            if (!u || !d.length) return -1;
            const f = d.findIndex(Ys.bind(null, u));
            if (f > -1) return f;
            const h = j1(l[c - 2]);
            return c > 1 && j1(u) === h && d[d.length - 1].path !== h ? d.findIndex(Ys.bind(null, l[c - 2])) : f
        }),
        s = te(() => i.value > -1 && kte(n.params, r.value.params)),
        o = te(() => i.value > -1 && i.value === n.matched.length - 1 && nk(n.params, r.value.params));

    function a(l = {}) {
        return Rte(l) ? e[En(t.replace) ? "replace" : "push"](En(t.to)).catch(jc) : Promise.resolve()
    }
    if (Mi) {
        const l = rt();
        if (l) {
            const c = {
                route: r.value,
                isActive: s.value,
                isExactActive: o.value
            };
            l.__vrl_devtools = l.__vrl_devtools || [], l.__vrl_devtools.push(c), Ul(() => {
                c.route = r.value, c.isActive = s.value, c.isExactActive = o.value
            }, {
                flush: "post"
            })
        }
    }
    return {
        route: r,
        href: te(() => r.value.href),
        isActive: s,
        isExactActive: o,
        navigate: a
    }
}
const Ite = ve({
        name: "RouterLink",
        compatConfig: {
            MODE: 3
        },
        props: {
            to: {
                type: [String, Object],
                required: !0
            },
            replace: Boolean,
            activeClass: String,
            exactActiveClass: String,
            custom: Boolean,
            ariaCurrentValue: {
                type: String,
                default: "page"
            }
        },
        useLink: z1,
        setup(t, {
            slots: e
        }) {
            const n = ft(z1(t)),
                {
                    options: r
                } = Nt(jp),
                i = te(() => ({
                    [V1(t.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
                    [V1(t.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
                }));
            return () => {
                const s = e.default && e.default(n);
                return t.custom ? s : Jt("a", {
                    "aria-current": n.isExactActive ? t.ariaCurrentValue : null,
                    href: n.href,
                    onClick: n.navigate,
                    class: i.value
                }, s)
            }
        }
    }),
    Mte = Ite;

function Rte(t) {
    if (!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey) && !t.defaultPrevented && !(t.button !== void 0 && t.button !== 0)) {
        if (t.currentTarget && t.currentTarget.getAttribute) {
            const e = t.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(e)) return
        }
        return t.preventDefault && t.preventDefault(), !0
    }
}

function kte(t, e) {
    for (const n in e) {
        const r = e[n],
            i = t[n];
        if (typeof r == "string") {
            if (r !== i) return !1
        } else if (!Qn(i) || i.length !== r.length || r.some((s, o) => s !== i[o])) return !1
    }
    return !0
}

function j1(t) {
    return t ? t.aliasOf ? t.aliasOf.path : t.path : ""
}
const V1 = (t, e, n) => t ? ? e ? ? n,
    Bte = ve({
        name: "RouterView",
        inheritAttrs: !1,
        props: {
            name: {
                type: String,
                default: "default"
            },
            route: Object
        },
        compatConfig: {
            MODE: 3
        },
        setup(t, {
            attrs: e,
            slots: n
        }) {
            $te();
            const r = Nt(t0),
                i = te(() => t.route || r.value),
                s = Nt(H1, 0),
                o = te(() => {
                    let c = En(s);
                    const {
                        matched: u
                    } = i.value;
                    let d;
                    for (;
                        (d = u[c]) && !d.components;) c++;
                    return c
                }),
                a = te(() => i.value.matched[o.value]);
            gr(H1, te(() => o.value + 1)), gr(fk, a), gr(t0, i);
            const l = q();
            return he(() => [l.value, a.value, t.name], ([c, u, d], [f, h, p]) => {
                u && (u.instances[d] = c, h && h !== u && c && c === f && (u.leaveGuards.size || (u.leaveGuards = h.leaveGuards), u.updateGuards.size || (u.updateGuards = h.updateGuards))), c && u && (!h || !Ys(u, h) || !f) && (u.enterCallbacks[d] || []).forEach(b => b(c))
            }, {
                flush: "post"
            }), () => {
                const c = i.value,
                    u = t.name,
                    d = a.value,
                    f = d && d.components[u];
                if (!f) return W1(n.default, {
                    Component: f,
                    route: c
                });
                const h = d.props[u],
                    p = h ? h === !0 ? c.params : typeof h == "function" ? h(c) : h : null,
                    y = Jt(f, nt({}, p, e, {
                        onVnodeUnmounted: m => {
                            m.component.isUnmounted && (d.instances[u] = null)
                        },
                        ref: l
                    }));
                if (Mi && y.ref) {
                    const m = {
                        depth: o.value,
                        name: d.name,
                        path: d.path,
                        meta: d.meta
                    };
                    (Qn(y.ref) ? y.ref.map(v => v.i) : [y.ref.i]).forEach(v => {
                        v.__vrv_devtools = m
                    })
                }
                return W1(n.default, {
                    Component: y,
                    route: c
                }) || y
            }
        }
    });

function W1(t, e) {
    if (!t) return null;
    const n = t(e);
    return n.length === 1 ? n[0] : n
}
const Dte = Bte;

function $te() {
    const t = rt(),
        e = t.parent && t.parent.type.name;
    if (e && (e === "KeepAlive" || e.includes("Transition"))) {
        const n = e === "KeepAlive" ? "keep-alive" : "transition";
        je(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.
Use slot props instead:

<router-view v-slot="{ Component }">
  <${n}>
    <component :is="Component" />
  </${n}>
</router-view>`)
    }
}

function pc(t, e) {
    const n = nt({}, t, {
        matched: t.matched.map(r => Vte(r, ["instances", "children", "aliasOf"]))
    });
    return {
        _custom: {
            type: null,
            readOnly: !0,
            display: t.fullPath,
            tooltip: e,
            value: n
        }
    }
}

function nf(t) {
    return {
        _custom: {
            display: t
        }
    }
}
let Fte = 0;

function Lte(t, e, n) {
    if (e.__hasDevtools) return;
    e.__hasDevtools = !0;
    const r = Fte++;
    _p({
        id: "org.vuejs.router" + (r ? "." + r : ""),
        label: "Vue Router",
        packageName: "vue-router",
        homepage: "https://router.vuejs.org",
        logo: "https://router.vuejs.org/logo.png",
        componentStateTypes: ["Routing"],
        app: t
    }, i => {
        typeof i.now != "function" && console.warn("[Vue Router]: You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html."), i.on.inspectComponent((u, d) => {
            u.instanceData && u.instanceData.state.push({
                type: "Routing",
                key: "$route",
                editable: !1,
                value: pc(e.currentRoute.value, "Current Route")
            })
        }), i.on.visitComponentTree(({
            treeNode: u,
            componentInstance: d
        }) => {
            if (d.__vrv_devtools) {
                const f = d.__vrv_devtools;
                u.tags.push({
                    label: (f.name ? `${f.name.toString()}: ` : "") + f.path,
                    textColor: 0,
                    tooltip: "This component is rendered by &lt;router-view&gt;",
                    backgroundColor: hk
                })
            }
            Qn(d.__vrl_devtools) && (d.__devtoolsApi = i, d.__vrl_devtools.forEach(f => {
                let h = gk,
                    p = "";
                f.isExactActive ? (h = mk, p = "This is exactly active") : f.isActive && (h = pk, p = "This link is active"), u.tags.push({
                    label: f.route.path,
                    textColor: 0,
                    tooltip: p,
                    backgroundColor: h
                })
            }))
        }), he(e.currentRoute, () => {
            l(), i.notifyComponentUpdate(), i.sendInspectorTree(a), i.sendInspectorState(a)
        });
        const s = "router:navigations:" + r;
        i.addTimelineLayer({
            id: s,
            label: `Router${r?" "+r:""} Navigations`,
            color: 4237508
        }), e.onError((u, d) => {
            i.addTimelineEvent({
                layerId: s,
                event: {
                    title: "Error during Navigation",
                    subtitle: d.fullPath,
                    logType: "error",
                    time: i.now(),
                    data: {
                        error: u
                    },
                    groupId: d.meta.__navigationId
                }
            })
        });
        let o = 0;
        e.beforeEach((u, d) => {
            const f = {
                guard: nf("beforeEach"),
                from: pc(d, "Current Location during this navigation"),
                to: pc(u, "Target location")
            };
            Object.defineProperty(u.meta, "__navigationId", {
                value: o++
            }), i.addTimelineEvent({
                layerId: s,
                event: {
                    time: i.now(),
                    title: "Start of navigation",
                    subtitle: u.fullPath,
                    data: f,
                    groupId: u.meta.__navigationId
                }
            })
        }), e.afterEach((u, d, f) => {
            const h = {
                guard: nf("afterEach")
            };
            f ? (h.failure = {
                _custom: {
                    type: Error,
                    readOnly: !0,
                    display: f ? f.message : "",
                    tooltip: "Navigation Failure",
                    value: f
                }
            }, h.status = nf("")) : h.status = nf(""), h.from = pc(d, "Current Location during this navigation"), h.to = pc(u, "Target location"), i.addTimelineEvent({
                layerId: s,
                event: {
                    title: "End of navigation",
                    subtitle: u.fullPath,
                    time: i.now(),
                    data: h,
                    logType: f ? "warning" : "default",
                    groupId: u.meta.__navigationId
                }
            })
        });
        const a = "router-inspector:" + r;
        i.addInspector({
            id: a,
            label: "Routes" + (r ? " " + r : ""),
            icon: "book",
            treeFilterPlaceholder: "Search routes"
        });

        function l() {
            if (!c) return;
            const u = c;
            let d = n.getRoutes().filter(f => !f.parent);
            d.forEach(_k), u.filter && (d = d.filter(f => n0(f, u.filter.toLowerCase()))), d.forEach(f => vk(f, e.currentRoute.value)), u.rootNodes = d.map(yk)
        }
        let c;
        i.on.getInspectorTree(u => {
            c = u, u.app === t && u.inspectorId === a && l()
        }), i.on.getInspectorState(u => {
            if (u.app === t && u.inspectorId === a) {
                const f = n.getRoutes().find(h => h.record.__vd_id === u.nodeId);
                f && (u.state = {
                    options: Ute(f)
                })
            }
        }), i.sendInspectorTree(a), i.sendInspectorState(a)
    })
}

function Nte(t) {
    return t.optional ? t.repeatable ? "*" : "?" : t.repeatable ? "+" : ""
}

function Ute(t) {
    const {
        record: e
    } = t, n = [{
        editable: !1,
        key: "path",
        value: e.path
    }];
    return e.name != null && n.push({
        editable: !1,
        key: "name",
        value: e.name
    }), n.push({
        editable: !1,
        key: "regexp",
        value: t.re
    }), t.keys.length && n.push({
        editable: !1,
        key: "keys",
        value: {
            _custom: {
                type: null,
                readOnly: !0,
                display: t.keys.map(r => `${r.name}${Nte(r)}`).join(" "),
                tooltip: "Param keys",
                value: t.keys
            }
        }
    }), e.redirect != null && n.push({
        editable: !1,
        key: "redirect",
        value: e.redirect
    }), t.alias.length && n.push({
        editable: !1,
        key: "aliases",
        value: t.alias.map(r => r.record.path)
    }), Object.keys(t.record.meta).length && n.push({
        editable: !1,
        key: "meta",
        value: t.record.meta
    }), n.push({
        key: "score",
        editable: !1,
        value: {
            _custom: {
                type: null,
                readOnly: !0,
                display: t.score.map(r => r.join(", ")).join(" | "),
                tooltip: "Score used to sort routes",
                value: t.score
            }
        }
    }), n
}
const hk = 15485081,
    pk = 2450411,
    mk = 8702998,
    Gte = 2282478,
    gk = 16486972,
    Hte = 6710886;

function yk(t) {
    const e = [],
        {
            record: n
        } = t;
    n.name != null && e.push({
        label: String(n.name),
        textColor: 0,
        backgroundColor: Gte
    }), n.aliasOf && e.push({
        label: "alias",
        textColor: 0,
        backgroundColor: gk
    }), t.__vd_match && e.push({
        label: "matches",
        textColor: 0,
        backgroundColor: hk
    }), t.__vd_exactActive && e.push({
        label: "exact",
        textColor: 0,
        backgroundColor: mk
    }), t.__vd_active && e.push({
        label: "active",
        textColor: 0,
        backgroundColor: pk
    }), n.redirect && e.push({
        label: typeof n.redirect == "string" ? `redirect: ${n.redirect}` : "redirects",
        textColor: 16777215,
        backgroundColor: Hte
    });
    let r = n.__vd_id;
    return r == null && (r = String(zte++), n.__vd_id = r), {
        id: r,
        label: n.path,
        tags: e,
        children: t.children.map(yk)
    }
}
let zte = 0;
const jte = /^\/(.*)\/([a-z]*)$/;

function vk(t, e) {
    const n = e.matched.length && Ys(e.matched[e.matched.length - 1], t.record);
    t.__vd_exactActive = t.__vd_active = n, n || (t.__vd_active = e.matched.some(r => Ys(r, t.record))), t.children.forEach(r => vk(r, e))
}

function _k(t) {
    t.__vd_match = !1, t.children.forEach(_k)
}

function n0(t, e) {
    const n = String(t.re).match(jte);
    if (t.__vd_match = !1, !n || n.length < 3) return !1;
    if (new RegExp(n[1].replace(/\$$/, ""), n[2]).test(e)) return t.children.forEach(o => n0(o, e)), t.record.path !== "/" || e === "/" ? (t.__vd_match = t.re.test(e), !0) : !1;
    const i = t.record.path.toLowerCase(),
        s = Pu(i);
    return !e.startsWith("/") && (s.includes(e) || i.includes(e)) || s.startsWith(e) || i.startsWith(e) || t.record.name && String(t.record.name).includes(e) ? !0 : t.children.some(o => n0(o, e))
}

function Vte(t, e) {
    const n = {};
    for (const r in t) e.includes(r) || (n[r] = t[r]);
    return n
}

function hwe(t) {
    const e = ste(t.routes, t),
        n = t.parseQuery || Tte,
        r = t.stringifyQuery || G1,
        i = t.history;
    if (!i) throw new Error('Provide the "history" option when calling "createRouter()": https://next.router.vuejs.org/api/#history.');
    const s = hc(),
        o = hc(),
        a = hc(),
        l = np(ps);
    let c = ps;
    Mi && t.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
    const u = tg.bind(null, $ => "" + $),
        d = tg.bind(null, Ste),
        f = tg.bind(null, Pu);

    function h($, X) {
        let F, Z;
        return ik($) ? (F = e.getRecordMatcher($), Z = X) : Z = $, e.addRoute(Z, F)
    }

    function p($) {
        const X = e.getRecordMatcher($);
        X ? e.removeRoute(X) : je(`Cannot remove non-existent route "${String($)}"`)
    }

    function b() {
        return e.getRoutes().map($ => $.record)
    }

    function y($) {
        return !!e.getRecordMatcher($)
    }

    function m($, X) {
        if (X = nt({}, X || l.value), typeof $ == "string") {
            const ge = ng(n, $, X.path),
                O = e.resolve({
                    path: ge.path
                }, X),
                L = i.createHref(ge.fullPath);
            return L.startsWith("//") ? je(`Location "${$}" resolved to "${L}". A resolved location cannot start with multiple slashes.`) : O.matched.length || je(`No match found for location with path "${$}"`), nt(ge, O, {
                params: f(O.params),
                hash: Pu(ge.hash),
                redirectedFrom: void 0,
                href: L
            })
        }
        let F;
        if ("path" in $) "params" in $ && !("name" in $) && Object.keys($.params).length && je(`Path "${$.path}" was passed with params but they will be ignored. Use a named route alongside params instead.`), F = nt({}, $, {
            path: ng(n, $.path, X.path).path
        });
        else {
            const ge = nt({}, $.params);
            for (const O in ge) ge[O] == null && delete ge[O];
            F = nt({}, $, {
                params: d($.params)
            }), X.params = d(X.params)
        }
        const Z = e.resolve(F, X),
            K = $.hash || "";
        K && !K.startsWith("#") && je(`A \`hash\` should always start with the character "#". Replace "${K}" with "#${K}".`), Z.params = u(f(Z.params));
        const ce = Ree(r, nt({}, $, {
                hash: xte(K),
                path: Z.path
            })),
            de = i.createHref(ce);
        return de.startsWith("//") ? je(`Location "${$}" resolved to "${de}". A resolved location cannot start with multiple slashes.`) : Z.matched.length || je(`No match found for location with path "${"path"in $?$.path:$}"`), nt({
            fullPath: ce,
            hash: K,
            query: r === G1 ? Cte($.query) : $.query || {}
        }, Z, {
            redirectedFrom: void 0,
            href: de
        })
    }

    function g($) {
        return typeof $ == "string" ? ng(n, $, l.value.path) : nt({}, $)
    }

    function v($, X) {
        if (c !== $) return wl(8, {
            from: X,
            to: $
        })
    }

    function _($) {
        return E($)
    }

    function x($) {
        return _(nt(g($), {
            replace: !0
        }))
    }

    function w($) {
        const X = $.matched[$.matched.length - 1];
        if (X && X.redirect) {
            const {
                redirect: F
            } = X;
            let Z = typeof F == "function" ? F($) : F;
            if (typeof Z == "string" && (Z = Z.includes("?") || Z.includes("#") ? Z = g(Z) : {
                    path: Z
                }, Z.params = {}), !("path" in Z) && !("name" in Z)) throw je(`Invalid redirect found:
${JSON.stringify(Z,null,2)}
 when navigating to "${$.fullPath}". A redirect must contain a name or path. This will break in production.`), new Error("Invalid redirect");
            return nt({
                query: $.query,
                hash: $.hash,
                params: "path" in Z ? {} : $.params
            }, Z)
        }
    }

    function E($, X) {
        const F = c = m($),
            Z = l.value,
            K = $.state,
            ce = $.force,
            de = $.replace === !0,
            ge = w(F);
        if (ge) return E(nt(g(ge), {
            state: typeof ge == "object" ? nt({}, K, ge.state) : K,
            force: ce,
            replace: de
        }), X || F);
        const O = F;
        O.redirectedFrom = X;
        let L;
        return !ce && M1(r, Z, F) && (L = wl(16, {
            to: O,
            from: Z
        }), le(Z, Z, !0, !1)), (L ? Promise.resolve(L) : A(O, Z)).catch(j => xi(j) ? xi(j, 2) ? j : Y(j) : N(j, O, Z)).then(j => {
            if (j) {
                if (xi(j, 2)) return M1(r, m(j.to), O) && X && (X._count = X._count ? X._count + 1 : 1) > 10 ? (je(`Detected an infinite redirection in a navigation guard when going from "${Z.fullPath}" to "${O.fullPath}". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`), Promise.reject(new Error("Infinite redirect in navigation guard"))) : E(nt({
                    replace: de
                }, g(j.to), {
                    state: typeof j.to == "object" ? nt({}, K, j.to.state) : K,
                    force: ce
                }), X || O)
            } else j = S(O, Z, !0, de, K);
            return T(O, Z, j), j
        })
    }

    function C($, X) {
        const F = v($, X);
        return F ? Promise.reject(F) : Promise.resolve()
    }

    function A($, X) {
        let F;
        const [Z, K, ce] = Wte($, X);
        F = rg(Z.reverse(), "beforeRouteLeave", $, X);
        for (const ge of Z) ge.leaveGuards.forEach(O => {
            F.push(_s(O, $, X))
        });
        const de = C.bind(null, $, X);
        return F.push(de), Fa(F).then(() => {
            F = [];
            for (const ge of s.list()) F.push(_s(ge, $, X));
            return F.push(de), Fa(F)
        }).then(() => {
            F = rg(K, "beforeRouteUpdate", $, X);
            for (const ge of K) ge.updateGuards.forEach(O => {
                F.push(_s(O, $, X))
            });
            return F.push(de), Fa(F)
        }).then(() => {
            F = [];
            for (const ge of $.matched)
                if (ge.beforeEnter && !X.matched.includes(ge))
                    if (Qn(ge.beforeEnter))
                        for (const O of ge.beforeEnter) F.push(_s(O, $, X));
                    else F.push(_s(ge.beforeEnter, $, X));
            return F.push(de), Fa(F)
        }).then(() => ($.matched.forEach(ge => ge.enterCallbacks = {}), F = rg(ce, "beforeRouteEnter", $, X), F.push(de), Fa(F))).then(() => {
            F = [];
            for (const ge of o.list()) F.push(_s(ge, $, X));
            return F.push(de), Fa(F)
        }).catch(ge => xi(ge, 8) ? ge : Promise.reject(ge))
    }

    function T($, X, F) {
        for (const Z of a.list()) Z($, X, F)
    }

    function S($, X, F, Z, K) {
        const ce = v($, X);
        if (ce) return ce;
        const de = X === ps,
            ge = Mi ? history.state : {};
        F && (Z || de ? i.replace($.fullPath, nt({
            scroll: de && ge && ge.scroll
        }, K)) : i.push($.fullPath, K)), l.value = $, le($, X, F, de), Y()
    }
    let P;

    function R() {
        P || (P = i.listen(($, X, F) => {
            if (!fe.listening) return;
            const Z = m($),
                K = w(Z);
            if (K) {
                E(nt(K, {
                    replace: !0
                }), Z).catch(jc);
                return
            }
            c = Z;
            const ce = l.value;
            Mi && Uee(k1(ce.fullPath, F.delta), zp()), A(Z, ce).catch(de => xi(de, 12) ? de : xi(de, 2) ? (E(de.to, Z).then(ge => {
                xi(ge, 20) && !F.delta && F.type === Cu.pop && i.go(-1, !1)
            }).catch(jc), Promise.reject()) : (F.delta && i.go(-F.delta, !1), N(de, Z, ce))).then(de => {
                de = de || S(Z, ce, !1), de && (F.delta && !xi(de, 8) ? i.go(-F.delta, !1) : F.type === Cu.pop && xi(de, 20) && i.go(-1, !1)), T(Z, ce, de)
            }).catch(jc)
        }))
    }
    let D = hc(),
        H = hc(),
        B;

    function N($, X, F) {
        Y($);
        const Z = H.list();
        return Z.length ? Z.forEach(K => K($, X, F)) : (je("uncaught error during route navigation:"), console.error($)), Promise.reject($)
    }

    function V() {
        return B && l.value !== ps ? Promise.resolve() : new Promise(($, X) => {
            D.add([$, X])
        })
    }

    function Y($) {
        return B || (B = !$, R(), D.list().forEach(([X, F]) => $ ? F($) : X()), D.reset()), $
    }

    function le($, X, F, Z) {
        const {
            scrollBehavior: K
        } = t;
        if (!Mi || !K) return Promise.resolve();
        const ce = !F && Gee(k1($.fullPath, 0)) || (Z || !F) && history.state && history.state.scroll || null;
        return Ue().then(() => K($, X, ce)).then(de => de && Nee(de)).catch(de => N(de, $, X))
    }
    const ae = $ => i.go($);
    let W;
    const ne = new Set,
        fe = {
            currentRoute: l,
            listening: !0,
            addRoute: h,
            removeRoute: p,
            hasRoute: y,
            getRoutes: b,
            resolve: m,
            options: t,
            push: _,
            replace: x,
            go: ae,
            back: () => ae(-1),
            forward: () => ae(1),
            beforeEach: s.add,
            beforeResolve: o.add,
            afterEach: a.add,
            onError: H.add,
            isReady: V,
            install($) {
                const X = this;
                $.component("RouterLink", Mte), $.component("RouterView", Dte), $.config.globalProperties.$router = X, Object.defineProperty($.config.globalProperties, "$route", {
                    enumerable: !0,
                    get: () => En(l)
                }), Mi && !W && l.value === ps && (W = !0, _(i.location).catch(K => {
                    je("Unexpected error when starting the router:", K)
                }));
                const F = {};
                for (const K in ps) F[K] = te(() => l.value[K]);
                $.provide(jp, X), $.provide(lx, ft(F)), $.provide(t0, l);
                const Z = $.unmount;
                ne.add($), $.unmount = function() {
                    ne.delete($), ne.size < 1 && (c = ps, P && P(), P = null, l.value = ps, W = !1, B = !1), Z()
                }, Mi && Lte($, X, e)
            }
        };
    return fe
}

function Fa(t) {
    return t.reduce((e, n) => e.then(() => n()), Promise.resolve())
}

function Wte(t, e) {
    const n = [],
        r = [],
        i = [],
        s = Math.max(e.matched.length, t.matched.length);
    for (let o = 0; o < s; o++) {
        const a = e.matched[o];
        a && (t.matched.find(c => Ys(c, a)) ? r.push(a) : n.push(a));
        const l = t.matched[o];
        l && (e.matched.find(c => Ys(c, l)) || i.push(l))
    }
    return [n, r, i]
}

function pwe() {
    return Nt(jp)
}

function mwe() {
    return Nt(lx)
}

function bk(t, e) {
    return function() {
        return t.apply(e, arguments)
    }
}
const {
    toString: Yte
} = Object.prototype, {
    getPrototypeOf: cx
} = Object, {
    iterator: Vp,
    toStringTag: xk
} = Symbol, Wp = (t => e => {
    const n = Yte.call(e);
    return t[n] || (t[n] = n.slice(8, -1).toLowerCase())
})(Object.create(null)), Ur = t => (t = t.toLowerCase(), e => Wp(e) === t), Yp = t => e => typeof e === t, {
    isArray: Yl
} = Array, Au = Yp("undefined");

function Xte(t) {
    return t !== null && !Au(t) && t.constructor !== null && !Au(t.constructor) && Fn(t.constructor.isBuffer) && t.constructor.isBuffer(t)
}
const wk = Ur("ArrayBuffer");

function qte(t) {
    let e;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && wk(t.buffer), e
}
const Kte = Yp("string"),
    Fn = Yp("function"),
    Ek = Yp("number"),
    Xp = t => t !== null && typeof t == "object",
    Jte = t => t === !0 || t === !1,
    zf = t => {
        if (Wp(t) !== "object") return !1;
        const e = cx(t);
        return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(xk in t) && !(Vp in t)
    },
    Zte = Ur("Date"),
    Qte = Ur("File"),
    ene = Ur("Blob"),
    tne = Ur("FileList"),
    nne = t => Xp(t) && Fn(t.pipe),
    rne = t => {
        let e;
        return t && (typeof FormData == "function" && t instanceof FormData || Fn(t.append) && ((e = Wp(t)) === "formdata" || e === "object" && Fn(t.toString) && t.toString() === "[object FormData]"))
    },
    ine = Ur("URLSearchParams"),
    [sne, one, ane, lne] = ["ReadableStream", "Request", "Response", "Headers"].map(Ur),
    cne = t => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");

function ud(t, e, {
    allOwnKeys: n = !1
} = {}) {
    if (t === null || typeof t > "u") return;
    let r, i;
    if (typeof t != "object" && (t = [t]), Yl(t))
        for (r = 0, i = t.length; r < i; r++) e.call(null, t[r], r, t);
    else {
        const s = n ? Object.getOwnPropertyNames(t) : Object.keys(t),
            o = s.length;
        let a;
        for (r = 0; r < o; r++) a = s[r], e.call(null, t[a], a, t)
    }
}

function Sk(t, e) {
    e = e.toLowerCase();
    const n = Object.keys(t);
    let r = n.length,
        i;
    for (; r-- > 0;)
        if (i = n[r], e === i.toLowerCase()) return i;
    return null
}
const Mo = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(),
    Tk = t => !Au(t) && t !== Mo;

function r0() {
    const {
        caseless: t
    } = Tk(this) && this || {}, e = {}, n = (r, i) => {
        const s = t && Sk(e, i) || i;
        zf(e[s]) && zf(r) ? e[s] = r0(e[s], r) : zf(r) ? e[s] = r0({}, r) : Yl(r) ? e[s] = r.slice() : e[s] = r
    };
    for (let r = 0, i = arguments.length; r < i; r++) arguments[r] && ud(arguments[r], n);
    return e
}
const une = (t, e, n, {
        allOwnKeys: r
    } = {}) => (ud(e, (i, s) => {
        n && Fn(i) ? t[s] = bk(i, n) : t[s] = i
    }, {
        allOwnKeys: r
    }), t),
    dne = t => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t),
    fne = (t, e, n, r) => {
        t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, "super", {
            value: e.prototype
        }), n && Object.assign(t.prototype, n)
    },
    hne = (t, e, n, r) => {
        let i, s, o;
        const a = {};
        if (e = e || {}, t == null) return e;
        do {
            for (i = Object.getOwnPropertyNames(t), s = i.length; s-- > 0;) o = i[s], (!r || r(o, t, e)) && !a[o] && (e[o] = t[o], a[o] = !0);
            t = n !== !1 && cx(t)
        } while (t && (!n || n(t, e)) && t !== Object.prototype);
        return e
    },
    pne = (t, e, n) => {
        t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;
        const r = t.indexOf(e, n);
        return r !== -1 && r === n
    },
    mne = t => {
        if (!t) return null;
        if (Yl(t)) return t;
        let e = t.length;
        if (!Ek(e)) return null;
        const n = new Array(e);
        for (; e-- > 0;) n[e] = t[e];
        return n
    },
    gne = (t => e => t && e instanceof t)(typeof Uint8Array < "u" && cx(Uint8Array)),
    yne = (t, e) => {
        const r = (t && t[Vp]).call(t);
        let i;
        for (;
            (i = r.next()) && !i.done;) {
            const s = i.value;
            e.call(t, s[0], s[1])
        }
    },
    vne = (t, e) => {
        let n;
        const r = [];
        for (;
            (n = t.exec(e)) !== null;) r.push(n);
        return r
    },
    _ne = Ur("HTMLFormElement"),
    bne = t => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(n, r, i) {
        return r.toUpperCase() + i
    }),
    Y1 = (({
        hasOwnProperty: t
    }) => (e, n) => t.call(e, n))(Object.prototype),
    xne = Ur("RegExp"),
    Ck = (t, e) => {
        const n = Object.getOwnPropertyDescriptors(t),
            r = {};
        ud(n, (i, s) => {
            let o;
            (o = e(i, s, t)) !== !1 && (r[s] = o || i)
        }), Object.defineProperties(t, r)
    },
    wne = t => {
        Ck(t, (e, n) => {
            if (Fn(t) && ["arguments", "caller", "callee"].indexOf(n) !== -1) return !1;
            const r = t[n];
            if (Fn(r)) {
                if (e.enumerable = !1, "writable" in e) {
                    e.writable = !1;
                    return
                }
                e.set || (e.set = () => {
                    throw Error("Can not rewrite read-only method '" + n + "'")
                })
            }
        })
    },
    Ene = (t, e) => {
        const n = {},
            r = i => {
                i.forEach(s => {
                    n[s] = !0
                })
            };
        return Yl(t) ? r(t) : r(String(t).split(e)), n
    },
    Sne = () => {},
    Tne = (t, e) => t != null && Number.isFinite(t = +t) ? t : e;

function Cne(t) {
    return !!(t && Fn(t.append) && t[xk] === "FormData" && t[Vp])
}
const Pne = t => {
        const e = new Array(10),
            n = (r, i) => {
                if (Xp(r)) {
                    if (e.indexOf(r) >= 0) return;
                    if (!("toJSON" in r)) {
                        e[i] = r;
                        const s = Yl(r) ? [] : {};
                        return ud(r, (o, a) => {
                            const l = n(o, i + 1);
                            !Au(l) && (s[a] = l)
                        }), e[i] = void 0, s
                    }
                }
                return r
            };
        return n(t, 0)
    },
    Ane = Ur("AsyncFunction"),
    One = t => t && (Xp(t) || Fn(t)) && Fn(t.then) && Fn(t.catch),
    Pk = ((t, e) => t ? setImmediate : e ? ((n, r) => (Mo.addEventListener("message", ({
        source: i,
        data: s
    }) => {
        i === Mo && s === n && r.length && r.shift()()
    }, !1), i => {
        r.push(i), Mo.postMessage(n, "*")
    }))(`axios@${Math.random()}`, []) : n => setTimeout(n))(typeof setImmediate == "function", Fn(Mo.postMessage)),
    Ine = typeof queueMicrotask < "u" ? queueMicrotask.bind(Mo) : typeof process < "u" && process.nextTick || Pk,
    Mne = t => t != null && Fn(t[Vp]),
    Q = {
        isArray: Yl,
        isArrayBuffer: wk,
        isBuffer: Xte,
        isFormData: rne,
        isArrayBufferView: qte,
        isString: Kte,
        isNumber: Ek,
        isBoolean: Jte,
        isObject: Xp,
        isPlainObject: zf,
        isReadableStream: sne,
        isRequest: one,
        isResponse: ane,
        isHeaders: lne,
        isUndefined: Au,
        isDate: Zte,
        isFile: Qte,
        isBlob: ene,
        isRegExp: xne,
        isFunction: Fn,
        isStream: nne,
        isURLSearchParams: ine,
        isTypedArray: gne,
        isFileList: tne,
        forEach: ud,
        merge: r0,
        extend: une,
        trim: cne,
        stripBOM: dne,
        inherits: fne,
        toFlatObject: hne,
        kindOf: Wp,
        kindOfTest: Ur,
        endsWith: pne,
        toArray: mne,
        forEachEntry: yne,
        matchAll: vne,
        isHTMLForm: _ne,
        hasOwnProperty: Y1,
        hasOwnProp: Y1,
        reduceDescriptors: Ck,
        freezeMethods: wne,
        toObjectSet: Ene,
        toCamelCase: bne,
        noop: Sne,
        toFiniteNumber: Tne,
        findKey: Sk,
        global: Mo,
        isContextDefined: Tk,
        isSpecCompliantForm: Cne,
        toJSONObject: Pne,
        isAsyncFn: Ane,
        isThenable: One,
        setImmediate: Pk,
        asap: Ine,
        isIterable: Mne
    };

function Ne(t, e, n, r, i) {
    Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null)
}
Q.inherits(Ne, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: Q.toJSONObject(this.config),
            code: this.code,
            status: this.status
        }
    }
});
const Ak = Ne.prototype,
    Ok = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(t => {
    Ok[t] = {
        value: t
    }
});
Object.defineProperties(Ne, Ok);
Object.defineProperty(Ak, "isAxiosError", {
    value: !0
});
Ne.from = (t, e, n, r, i, s) => {
    const o = Object.create(Ak);
    return Q.toFlatObject(t, o, function(l) {
        return l !== Error.prototype
    }, a => a !== "isAxiosError"), Ne.call(o, t.message, e, n, r, i), o.cause = t, o.name = t.name, s && Object.assign(o, s), o
};
const Rne = null;

function i0(t) {
    return Q.isPlainObject(t) || Q.isArray(t)
}

function Ik(t) {
    return Q.endsWith(t, "[]") ? t.slice(0, -2) : t
}

function X1(t, e, n) {
    return t ? t.concat(e).map(function(i, s) {
        return i = Ik(i), !n && s ? "[" + i + "]" : i
    }).join(n ? "." : "") : e
}

function kne(t) {
    return Q.isArray(t) && !t.some(i0)
}
const Bne = Q.toFlatObject(Q, {}, null, function(e) {
    return /^is[A-Z]/.test(e)
});

function qp(t, e, n) {
    if (!Q.isObject(t)) throw new TypeError("target must be an object");
    e = e || new FormData, n = Q.toFlatObject(n, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(b, y) {
        return !Q.isUndefined(y[b])
    });
    const r = n.metaTokens,
        i = n.visitor || u,
        s = n.dots,
        o = n.indexes,
        l = (n.Blob || typeof Blob < "u" && Blob) && Q.isSpecCompliantForm(e);
    if (!Q.isFunction(i)) throw new TypeError("visitor must be a function");

    function c(p) {
        if (p === null) return "";
        if (Q.isDate(p)) return p.toISOString();
        if (Q.isBoolean(p)) return p.toString();
        if (!l && Q.isBlob(p)) throw new Ne("Blob is not supported. Use a Buffer instead.");
        return Q.isArrayBuffer(p) || Q.isTypedArray(p) ? l && typeof Blob == "function" ? new Blob([p]) : Buffer.from(p) : p
    }

    function u(p, b, y) {
        let m = p;
        if (p && !y && typeof p == "object") {
            if (Q.endsWith(b, "{}")) b = r ? b : b.slice(0, -2), p = JSON.stringify(p);
            else if (Q.isArray(p) && kne(p) || (Q.isFileList(p) || Q.endsWith(b, "[]")) && (m = Q.toArray(p))) return b = Ik(b), m.forEach(function(v, _) {
                !(Q.isUndefined(v) || v === null) && e.append(o === !0 ? X1([b], _, s) : o === null ? b : b + "[]", c(v))
            }), !1
        }
        return i0(p) ? !0 : (e.append(X1(y, b, s), c(p)), !1)
    }
    const d = [],
        f = Object.assign(Bne, {
            defaultVisitor: u,
            convertValue: c,
            isVisitable: i0
        });

    function h(p, b) {
        if (!Q.isUndefined(p)) {
            if (d.indexOf(p) !== -1) throw Error("Circular reference detected in " + b.join("."));
            d.push(p), Q.forEach(p, function(m, g) {
                (!(Q.isUndefined(m) || m === null) && i.call(e, m, Q.isString(g) ? g.trim() : g, b, f)) === !0 && h(m, b ? b.concat(g) : [g])
            }), d.pop()
        }
    }
    if (!Q.isObject(t)) throw new TypeError("data must be an object");
    return h(t), e
}

function q1(t) {
    const e = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {
        return e[r]
    })
}

function ux(t, e) {
    this._pairs = [], t && qp(t, this, e)
}
const Mk = ux.prototype;
Mk.append = function(e, n) {
    this._pairs.push([e, n])
};
Mk.toString = function(e) {
    const n = e ? function(r) {
        return e.call(this, r, q1)
    } : q1;
    return this._pairs.map(function(i) {
        return n(i[0]) + "=" + n(i[1])
    }, "").join("&")
};

function Dne(t) {
    return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}

function Rk(t, e, n) {
    if (!e) return t;
    const r = n && n.encode || Dne;
    Q.isFunction(n) && (n = {
        serialize: n
    });
    const i = n && n.serialize;
    let s;
    if (i ? s = i(e, n) : s = Q.isURLSearchParams(e) ? e.toString() : new ux(e, n).toString(r), s) {
        const o = t.indexOf("#");
        o !== -1 && (t = t.slice(0, o)), t += (t.indexOf("?") === -1 ? "?" : "&") + s
    }
    return t
}
class $ne {
    constructor() {
        this.handlers = []
    }
    use(e, n, r) {
        return this.handlers.push({
            fulfilled: e,
            rejected: n,
            synchronous: r ? r.synchronous : !1,
            runWhen: r ? r.runWhen : null
        }), this.handlers.length - 1
    }
    eject(e) {
        this.handlers[e] && (this.handlers[e] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach(e) {
        Q.forEach(this.handlers, function(r) {
            r !== null && e(r)
        })
    }
}
const K1 = $ne,
    kk = {
        silentJSONParsing: !0,
        forcedJSONParsing: !0,
        clarifyTimeoutError: !1
    },
    Fne = typeof URLSearchParams < "u" ? URLSearchParams : ux,
    Lne = typeof FormData < "u" ? FormData : null,
    Nne = typeof Blob < "u" ? Blob : null,
    Une = {
        isBrowser: !0,
        classes: {
            URLSearchParams: Fne,
            FormData: Lne,
            Blob: Nne
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
    },
    dx = typeof window < "u" && typeof document < "u",
    s0 = typeof navigator == "object" && navigator || void 0,
    Gne = dx && (!s0 || ["ReactNative", "NativeScript", "NS"].indexOf(s0.product) < 0),
    Hne = (() => typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(),
    zne = dx && window.location.href || "http://localhost",
    jne = Object.freeze(Object.defineProperty({
        __proto__: null,
        hasBrowserEnv: dx,
        hasStandardBrowserEnv: Gne,
        hasStandardBrowserWebWorkerEnv: Hne,
        navigator: s0,
        origin: zne
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    un = { ...jne,
        ...Une
    };

function Vne(t, e) {
    return qp(t, new un.classes.URLSearchParams, Object.assign({
        visitor: function(n, r, i, s) {
            return un.isNode && Q.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments)
        }
    }, e))
}

function Wne(t) {
    return Q.matchAll(/\w+|\[(\w*)]/g, t).map(e => e[0] === "[]" ? "" : e[1] || e[0])
}

function Yne(t) {
    const e = {},
        n = Object.keys(t);
    let r;
    const i = n.length;
    let s;
    for (r = 0; r < i; r++) s = n[r], e[s] = t[s];
    return e
}

function Bk(t) {
    function e(n, r, i, s) {
        let o = n[s++];
        if (o === "__proto__") return !0;
        const a = Number.isFinite(+o),
            l = s >= n.length;
        return o = !o && Q.isArray(i) ? i.length : o, l ? (Q.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !a) : ((!i[o] || !Q.isObject(i[o])) && (i[o] = []), e(n, r, i[o], s) && Q.isArray(i[o]) && (i[o] = Yne(i[o])), !a)
    }
    if (Q.isFormData(t) && Q.isFunction(t.entries)) {
        const n = {};
        return Q.forEachEntry(t, (r, i) => {
            e(Wne(r), i, n, 0)
        }), n
    }
    return null
}

function Xne(t, e, n) {
    if (Q.isString(t)) try {
        return (e || JSON.parse)(t), Q.trim(t)
    } catch (r) {
        if (r.name !== "SyntaxError") throw r
    }
    return (n || JSON.stringify)(t)
}
const fx = {
    transitional: kk,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function(e, n) {
        const r = n.getContentType() || "",
            i = r.indexOf("application/json") > -1,
            s = Q.isObject(e);
        if (s && Q.isHTMLForm(e) && (e = new FormData(e)), Q.isFormData(e)) return i ? JSON.stringify(Bk(e)) : e;
        if (Q.isArrayBuffer(e) || Q.isBuffer(e) || Q.isStream(e) || Q.isFile(e) || Q.isBlob(e) || Q.isReadableStream(e)) return e;
        if (Q.isArrayBufferView(e)) return e.buffer;
        if (Q.isURLSearchParams(e)) return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
        let a;
        if (s) {
            if (r.indexOf("application/x-www-form-urlencoded") > -1) return Vne(e, this.formSerializer).toString();
            if ((a = Q.isFileList(e)) || r.indexOf("multipart/form-data") > -1) {
                const l = this.env && this.env.FormData;
                return qp(a ? {
                    "files[]": e
                } : e, l && new l, this.formSerializer)
            }
        }
        return s || i ? (n.setContentType("application/json", !1), Xne(e)) : e
    }],
    transformResponse: [function(e) {
        const n = this.transitional || fx.transitional,
            r = n && n.forcedJSONParsing,
            i = this.responseType === "json";
        if (Q.isResponse(e) || Q.isReadableStream(e)) return e;
        if (e && Q.isString(e) && (r && !this.responseType || i)) {
            const o = !(n && n.silentJSONParsing) && i;
            try {
                return JSON.parse(e)
            } catch (a) {
                if (o) throw a.name === "SyntaxError" ? Ne.from(a, Ne.ERR_BAD_RESPONSE, this, null, this.response) : a
            }
        }
        return e
    }],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: un.classes.FormData,
        Blob: un.classes.Blob
    },
    validateStatus: function(e) {
        return e >= 200 && e < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
Q.forEach(["delete", "get", "head", "post", "put", "patch"], t => {
    fx.headers[t] = {}
});
const hx = fx,
    qne = Q.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
    Kne = t => {
        const e = {};
        let n, r, i;
        return t && t.split(`
`).forEach(function(o) {
            i = o.indexOf(":"), n = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!n || e[n] && qne[n]) && (n === "set-cookie" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + ", " + r : r)
        }), e
    },
    J1 = Symbol("internals");

function mc(t) {
    return t && String(t).trim().toLowerCase()
}

function jf(t) {
    return t === !1 || t == null ? t : Q.isArray(t) ? t.map(jf) : String(t)
}

function Jne(t) {
    const e = Object.create(null),
        n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let r;
    for (; r = n.exec(t);) e[r[1]] = r[2];
    return e
}
const Zne = t => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());

function ig(t, e, n, r, i) {
    if (Q.isFunction(r)) return r.call(this, e, n);
    if (i && (e = n), !!Q.isString(e)) {
        if (Q.isString(r)) return e.indexOf(r) !== -1;
        if (Q.isRegExp(r)) return r.test(e)
    }
}

function Qne(t) {
    return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, n, r) => n.toUpperCase() + r)
}

function ere(t, e) {
    const n = Q.toCamelCase(" " + e);
    ["get", "set", "has"].forEach(r => {
        Object.defineProperty(t, r + n, {
            value: function(i, s, o) {
                return this[r].call(this, e, i, s, o)
            },
            configurable: !0
        })
    })
}
class Kp {
    constructor(e) {
        e && this.set(e)
    }
    set(e, n, r) {
        const i = this;

        function s(a, l, c) {
            const u = mc(l);
            if (!u) throw new Error("header name must be a non-empty string");
            const d = Q.findKey(i, u);
            (!d || i[d] === void 0 || c === !0 || c === void 0 && i[d] !== !1) && (i[d || l] = jf(a))
        }
        const o = (a, l) => Q.forEach(a, (c, u) => s(c, u, l));
        if (Q.isPlainObject(e) || e instanceof this.constructor) o(e, n);
        else if (Q.isString(e) && (e = e.trim()) && !Zne(e)) o(Kne(e), n);
        else if (Q.isObject(e) && Q.isIterable(e)) {
            let a = {},
                l, c;
            for (const u of e) {
                if (!Q.isArray(u)) throw TypeError("Object iterator must return a key-value pair");
                a[c = u[0]] = (l = a[c]) ? Q.isArray(l) ? [...l, u[1]] : [l, u[1]] : u[1]
            }
            o(a, n)
        } else e != null && s(n, e, r);
        return this
    }
    get(e, n) {
        if (e = mc(e), e) {
            const r = Q.findKey(this, e);
            if (r) {
                const i = this[r];
                if (!n) return i;
                if (n === !0) return Jne(i);
                if (Q.isFunction(n)) return n.call(this, i, r);
                if (Q.isRegExp(n)) return n.exec(i);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has(e, n) {
        if (e = mc(e), e) {
            const r = Q.findKey(this, e);
            return !!(r && this[r] !== void 0 && (!n || ig(this, this[r], r, n)))
        }
        return !1
    }
    delete(e, n) {
        const r = this;
        let i = !1;

        function s(o) {
            if (o = mc(o), o) {
                const a = Q.findKey(r, o);
                a && (!n || ig(r, r[a], a, n)) && (delete r[a], i = !0)
            }
        }
        return Q.isArray(e) ? e.forEach(s) : s(e), i
    }
    clear(e) {
        const n = Object.keys(this);
        let r = n.length,
            i = !1;
        for (; r--;) {
            const s = n[r];
            (!e || ig(this, this[s], s, e, !0)) && (delete this[s], i = !0)
        }
        return i
    }
    normalize(e) {
        const n = this,
            r = {};
        return Q.forEach(this, (i, s) => {
            const o = Q.findKey(r, s);
            if (o) {
                n[o] = jf(i), delete n[s];
                return
            }
            const a = e ? Qne(s) : String(s).trim();
            a !== s && delete n[s], n[a] = jf(i), r[a] = !0
        }), this
    }
    concat(...e) {
        return this.constructor.concat(this, ...e)
    }
    toJSON(e) {
        const n = Object.create(null);
        return Q.forEach(this, (r, i) => {
            r != null && r !== !1 && (n[i] = e && Q.isArray(r) ? r.join(", ") : r)
        }), n
    }[Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map(([e, n]) => e + ": " + n).join(`
`)
    }
    getSetCookie() {
        return this.get("set-cookie") || []
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from(e) {
        return e instanceof this ? e : new this(e)
    }
    static concat(e, ...n) {
        const r = new this(e);
        return n.forEach(i => r.set(i)), r
    }
    static accessor(e) {
        const r = (this[J1] = this[J1] = {
                accessors: {}
            }).accessors,
            i = this.prototype;

        function s(o) {
            const a = mc(o);
            r[a] || (ere(i, o), r[a] = !0)
        }
        return Q.isArray(e) ? e.forEach(s) : s(e), this
    }
}
Kp.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Q.reduceDescriptors(Kp.prototype, ({
    value: t
}, e) => {
    let n = e[0].toUpperCase() + e.slice(1);
    return {
        get: () => t,
        set(r) {
            this[n] = r
        }
    }
});
Q.freezeMethods(Kp);
const Br = Kp;

function sg(t, e) {
    const n = this || hx,
        r = e || n,
        i = Br.from(r.headers);
    let s = r.data;
    return Q.forEach(t, function(a) {
        s = a.call(n, s, i.normalize(), e ? e.status : void 0)
    }), i.normalize(), s
}

function Dk(t) {
    return !!(t && t.__CANCEL__)
}

function Xl(t, e, n) {
    Ne.call(this, t ? ? "canceled", Ne.ERR_CANCELED, e, n), this.name = "CanceledError"
}
Q.inherits(Xl, Ne, {
    __CANCEL__: !0
});

function $k(t, e, n) {
    const r = n.config.validateStatus;
    !n.status || !r || r(n.status) ? t(n) : e(new Ne("Request failed with status code " + n.status, [Ne.ERR_BAD_REQUEST, Ne.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n))
}

function tre(t) {
    const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
    return e && e[1] || ""
}

function nre(t, e) {
    t = t || 10;
    const n = new Array(t),
        r = new Array(t);
    let i = 0,
        s = 0,
        o;
    return e = e !== void 0 ? e : 1e3,
        function(l) {
            const c = Date.now(),
                u = r[s];
            o || (o = c), n[i] = l, r[i] = c;
            let d = s,
                f = 0;
            for (; d !== i;) f += n[d++], d = d % t;
            if (i = (i + 1) % t, i === s && (s = (s + 1) % t), c - o < e) return;
            const h = u && c - u;
            return h ? Math.round(f * 1e3 / h) : void 0
        }
}

function rre(t, e) {
    let n = 0,
        r = 1e3 / e,
        i, s;
    const o = (c, u = Date.now()) => {
        n = u, i = null, s && (clearTimeout(s), s = null), t.apply(null, c)
    };
    return [(...c) => {
        const u = Date.now(),
            d = u - n;
        d >= r ? o(c, u) : (i = c, s || (s = setTimeout(() => {
            s = null, o(i)
        }, r - d)))
    }, () => i && o(i)]
}
const Sh = (t, e, n = 3) => {
        let r = 0;
        const i = nre(50, 250);
        return rre(s => {
            const o = s.loaded,
                a = s.lengthComputable ? s.total : void 0,
                l = o - r,
                c = i(l),
                u = o <= a;
            r = o;
            const d = {
                loaded: o,
                total: a,
                progress: a ? o / a : void 0,
                bytes: l,
                rate: c || void 0,
                estimated: c && a && u ? (a - o) / c : void 0,
                event: s,
                lengthComputable: a != null,
                [e ? "download" : "upload"]: !0
            };
            t(d)
        }, n)
    },
    Z1 = (t, e) => {
        const n = t != null;
        return [r => e[0]({
            lengthComputable: n,
            total: t,
            loaded: r
        }), e[1]]
    },
    Q1 = t => (...e) => Q.asap(() => t(...e)),
    ire = un.hasStandardBrowserEnv ? ((t, e) => n => (n = new URL(n, un.origin), t.protocol === n.protocol && t.host === n.host && (e || t.port === n.port)))(new URL(un.origin), un.navigator && /(msie|trident)/i.test(un.navigator.userAgent)) : () => !0,
    sre = un.hasStandardBrowserEnv ? {
        write(t, e, n, r, i, s) {
            const o = [t + "=" + encodeURIComponent(e)];
            Q.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), Q.isString(r) && o.push("path=" + r), Q.isString(i) && o.push("domain=" + i), s === !0 && o.push("secure"), document.cookie = o.join("; ")
        },
        read(t) {
            const e = document.cookie.match(new RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
            return e ? decodeURIComponent(e[3]) : null
        },
        remove(t) {
            this.write(t, "", Date.now() - 864e5)
        }
    } : {
        write() {},
        read() {
            return null
        },
        remove() {}
    };

function ore(t) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)
}

function are(t, e) {
    return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t
}

function Fk(t, e, n) {
    let r = !ore(e);
    return t && (r || n == !1) ? are(t, e) : e
}
const eT = t => t instanceof Br ? { ...t
} : t;

function na(t, e) {
    e = e || {};
    const n = {};

    function r(c, u, d, f) {
        return Q.isPlainObject(c) && Q.isPlainObject(u) ? Q.merge.call({
            caseless: f
        }, c, u) : Q.isPlainObject(u) ? Q.merge({}, u) : Q.isArray(u) ? u.slice() : u
    }

    function i(c, u, d, f) {
        if (Q.isUndefined(u)) {
            if (!Q.isUndefined(c)) return r(void 0, c, d, f)
        } else return r(c, u, d, f)
    }

    function s(c, u) {
        if (!Q.isUndefined(u)) return r(void 0, u)
    }

    function o(c, u) {
        if (Q.isUndefined(u)) {
            if (!Q.isUndefined(c)) return r(void 0, c)
        } else return r(void 0, u)
    }

    function a(c, u, d) {
        if (d in e) return r(c, u);
        if (d in t) return r(void 0, c)
    }
    const l = {
        url: s,
        method: s,
        data: s,
        baseURL: o,
        transformRequest: o,
        transformResponse: o,
        paramsSerializer: o,
        timeout: o,
        timeoutMessage: o,
        withCredentials: o,
        withXSRFToken: o,
        adapter: o,
        responseType: o,
        xsrfCookieName: o,
        xsrfHeaderName: o,
        onUploadProgress: o,
        onDownloadProgress: o,
        decompress: o,
        maxContentLength: o,
        maxBodyLength: o,
        beforeRedirect: o,
        transport: o,
        httpAgent: o,
        httpsAgent: o,
        cancelToken: o,
        socketPath: o,
        responseEncoding: o,
        validateStatus: a,
        headers: (c, u, d) => i(eT(c), eT(u), d, !0)
    };
    return Q.forEach(Object.keys(Object.assign({}, t, e)), function(u) {
        const d = l[u] || i,
            f = d(t[u], e[u], u);
        Q.isUndefined(f) && d !== a || (n[u] = f)
    }), n
}
const Lk = t => {
        const e = na({}, t);
        let {
            data: n,
            withXSRFToken: r,
            xsrfHeaderName: i,
            xsrfCookieName: s,
            headers: o,
            auth: a
        } = e;
        e.headers = o = Br.from(o), e.url = Rk(Fk(e.baseURL, e.url, e.allowAbsoluteUrls), t.params, t.paramsSerializer), a && o.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : "")));
        let l;
        if (Q.isFormData(n)) {
            if (un.hasStandardBrowserEnv || un.hasStandardBrowserWebWorkerEnv) o.setContentType(void 0);
            else if ((l = o.getContentType()) !== !1) {
                const [c, ...u] = l ? l.split(";").map(d => d.trim()).filter(Boolean) : [];
                o.setContentType([c || "multipart/form-data", ...u].join("; "))
            }
        }
        if (un.hasStandardBrowserEnv && (r && Q.isFunction(r) && (r = r(e)), r || r !== !1 && ire(e.url))) {
            const c = i && s && sre.read(s);
            c && o.set(i, c)
        }
        return e
    },
    lre = typeof XMLHttpRequest < "u",
    cre = lre && function(t) {
        return new Promise(function(n, r) {
            const i = Lk(t);
            let s = i.data;
            const o = Br.from(i.headers).normalize();
            let {
                responseType: a,
                onUploadProgress: l,
                onDownloadProgress: c
            } = i, u, d, f, h, p;

            function b() {
                h && h(), p && p(), i.cancelToken && i.cancelToken.unsubscribe(u), i.signal && i.signal.removeEventListener("abort", u)
            }
            let y = new XMLHttpRequest;
            y.open(i.method.toUpperCase(), i.url, !0), y.timeout = i.timeout;

            function m() {
                if (!y) return;
                const v = Br.from("getAllResponseHeaders" in y && y.getAllResponseHeaders()),
                    x = {
                        data: !a || a === "text" || a === "json" ? y.responseText : y.response,
                        status: y.status,
                        statusText: y.statusText,
                        headers: v,
                        config: t,
                        request: y
                    };
                $k(function(E) {
                    n(E), b()
                }, function(E) {
                    r(E), b()
                }, x), y = null
            }
            "onloadend" in y ? y.onloadend = m : y.onreadystatechange = function() {
                !y || y.readyState !== 4 || y.status === 0 && !(y.responseURL && y.responseURL.indexOf("file:") === 0) || setTimeout(m)
            }, y.onabort = function() {
                y && (r(new Ne("Request aborted", Ne.ECONNABORTED, t, y)), y = null)
            }, y.onerror = function() {
                r(new Ne("Network Error", Ne.ERR_NETWORK, t, y)), y = null
            }, y.ontimeout = function() {
                let _ = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
                const x = i.transitional || kk;
                i.timeoutErrorMessage && (_ = i.timeoutErrorMessage), r(new Ne(_, x.clarifyTimeoutError ? Ne.ETIMEDOUT : Ne.ECONNABORTED, t, y)), y = null
            }, s === void 0 && o.setContentType(null), "setRequestHeader" in y && Q.forEach(o.toJSON(), function(_, x) {
                y.setRequestHeader(x, _)
            }), Q.isUndefined(i.withCredentials) || (y.withCredentials = !!i.withCredentials), a && a !== "json" && (y.responseType = i.responseType), c && ([f, p] = Sh(c, !0), y.addEventListener("progress", f)), l && y.upload && ([d, h] = Sh(l), y.upload.addEventListener("progress", d), y.upload.addEventListener("loadend", h)), (i.cancelToken || i.signal) && (u = v => {
                y && (r(!v || v.type ? new Xl(null, t, y) : v), y.abort(), y = null)
            }, i.cancelToken && i.cancelToken.subscribe(u), i.signal && (i.signal.aborted ? u() : i.signal.addEventListener("abort", u)));
            const g = tre(i.url);
            if (g && un.protocols.indexOf(g) === -1) {
                r(new Ne("Unsupported protocol " + g + ":", Ne.ERR_BAD_REQUEST, t));
                return
            }
            y.send(s || null)
        })
    },
    ure = (t, e) => {
        const {
            length: n
        } = t = t ? t.filter(Boolean) : [];
        if (e || n) {
            let r = new AbortController,
                i;
            const s = function(c) {
                if (!i) {
                    i = !0, a();
                    const u = c instanceof Error ? c : this.reason;
                    r.abort(u instanceof Ne ? u : new Xl(u instanceof Error ? u.message : u))
                }
            };
            let o = e && setTimeout(() => {
                o = null, s(new Ne(`timeout ${e} of ms exceeded`, Ne.ETIMEDOUT))
            }, e);
            const a = () => {
                t && (o && clearTimeout(o), o = null, t.forEach(c => {
                    c.unsubscribe ? c.unsubscribe(s) : c.removeEventListener("abort", s)
                }), t = null)
            };
            t.forEach(c => c.addEventListener("abort", s));
            const {
                signal: l
            } = r;
            return l.unsubscribe = () => Q.asap(a), l
        }
    },
    dre = ure,
    fre = function*(t, e) {
        let n = t.byteLength;
        if (!e || n < e) {
            yield t;
            return
        }
        let r = 0,
            i;
        for (; r < n;) i = r + e, yield t.slice(r, i), r = i
    },
    hre = async function*(t, e) {
        for await (const n of pre(t)) yield* fre(n, e)
    },
    pre = async function*(t) {
        if (t[Symbol.asyncIterator]) {
            yield* t;
            return
        }
        const e = t.getReader();
        try {
            for (;;) {
                const {
                    done: n,
                    value: r
                } = await e.read();
                if (n) break;
                yield r
            }
        } finally {
            await e.cancel()
        }
    },
    tT = (t, e, n, r) => {
        const i = hre(t, e);
        let s = 0,
            o, a = l => {
                o || (o = !0, r && r(l))
            };
        return new ReadableStream({
            async pull(l) {
                try {
                    const {
                        done: c,
                        value: u
                    } = await i.next();
                    if (c) {
                        a(), l.close();
                        return
                    }
                    let d = u.byteLength;
                    if (n) {
                        let f = s += d;
                        n(f)
                    }
                    l.enqueue(new Uint8Array(u))
                } catch (c) {
                    throw a(c), c
                }
            },
            cancel(l) {
                return a(l), i.return()
            }
        }, {
            highWaterMark: 2
        })
    },
    Jp = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function",
    Nk = Jp && typeof ReadableStream == "function",
    mre = Jp && (typeof TextEncoder == "function" ? (t => e => t.encode(e))(new TextEncoder) : async t => new Uint8Array(await new Response(t).arrayBuffer())),
    Uk = (t, ...e) => {
        try {
            return !!t(...e)
        } catch {
            return !1
        }
    },
    gre = Nk && Uk(() => {
        let t = !1;
        const e = new Request(un.origin, {
            body: new ReadableStream,
            method: "POST",
            get duplex() {
                return t = !0, "half"
            }
        }).headers.has("Content-Type");
        return t && !e
    }),
    nT = 64 * 1024,
    o0 = Nk && Uk(() => Q.isReadableStream(new Response("").body)),
    Th = {
        stream: o0 && (t => t.body)
    };
Jp && (t => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => {
        !Th[e] && (Th[e] = Q.isFunction(t[e]) ? n => n[e]() : (n, r) => {
            throw new Ne(`Response type '${e}' is not supported`, Ne.ERR_NOT_SUPPORT, r)
        })
    })
})(new Response);
const yre = async t => {
        if (t == null) return 0;
        if (Q.isBlob(t)) return t.size;
        if (Q.isSpecCompliantForm(t)) return (await new Request(un.origin, {
            method: "POST",
            body: t
        }).arrayBuffer()).byteLength;
        if (Q.isArrayBufferView(t) || Q.isArrayBuffer(t)) return t.byteLength;
        if (Q.isURLSearchParams(t) && (t = t + ""), Q.isString(t)) return (await mre(t)).byteLength
    },
    vre = async (t, e) => {
        const n = Q.toFiniteNumber(t.getContentLength());
        return n ? ? yre(e)
    },
    _re = Jp && (async t => {
        let {
            url: e,
            method: n,
            data: r,
            signal: i,
            cancelToken: s,
            timeout: o,
            onDownloadProgress: a,
            onUploadProgress: l,
            responseType: c,
            headers: u,
            withCredentials: d = "same-origin",
            fetchOptions: f
        } = Lk(t);
        c = c ? (c + "").toLowerCase() : "text";
        let h = dre([i, s && s.toAbortSignal()], o),
            p;
        const b = h && h.unsubscribe && (() => {
            h.unsubscribe()
        });
        let y;
        try {
            if (l && gre && n !== "get" && n !== "head" && (y = await vre(u, r)) !== 0) {
                let x = new Request(e, {
                        method: "POST",
                        body: r,
                        duplex: "half"
                    }),
                    w;
                if (Q.isFormData(r) && (w = x.headers.get("content-type")) && u.setContentType(w), x.body) {
                    const [E, C] = Z1(y, Sh(Q1(l)));
                    r = tT(x.body, nT, E, C)
                }
            }
            Q.isString(d) || (d = d ? "include" : "omit");
            const m = "credentials" in Request.prototype;
            p = new Request(e, { ...f,
                signal: h,
                method: n.toUpperCase(),
                headers: u.normalize().toJSON(),
                body: r,
                duplex: "half",
                credentials: m ? d : void 0
            });
            let g = await fetch(p, f);
            const v = o0 && (c === "stream" || c === "response");
            if (o0 && (a || v && b)) {
                const x = {};
                ["status", "statusText", "headers"].forEach(A => {
                    x[A] = g[A]
                });
                const w = Q.toFiniteNumber(g.headers.get("content-length")),
                    [E, C] = a && Z1(w, Sh(Q1(a), !0)) || [];
                g = new Response(tT(g.body, nT, E, () => {
                    C && C(), b && b()
                }), x)
            }
            c = c || "text";
            let _ = await Th[Q.findKey(Th, c) || "text"](g, t);
            return !v && b && b(), await new Promise((x, w) => {
                $k(x, w, {
                    data: _,
                    headers: Br.from(g.headers),
                    status: g.status,
                    statusText: g.statusText,
                    config: t,
                    request: p
                })
            })
        } catch (m) {
            throw b && b(), m && m.name === "TypeError" && /Load failed|fetch/i.test(m.message) ? Object.assign(new Ne("Network Error", Ne.ERR_NETWORK, t, p), {
                cause: m.cause || m
            }) : Ne.from(m, m && m.code, t, p)
        }
    }),
    a0 = {
        http: Rne,
        xhr: cre,
        fetch: _re
    };
Q.forEach(a0, (t, e) => {
    if (t) {
        try {
            Object.defineProperty(t, "name", {
                value: e
            })
        } catch {}
        Object.defineProperty(t, "adapterName", {
            value: e
        })
    }
});
const rT = t => `- ${t}`,
    bre = t => Q.isFunction(t) || t === null || t === !1,
    Gk = {
        getAdapter: t => {
            t = Q.isArray(t) ? t : [t];
            const {
                length: e
            } = t;
            let n, r;
            const i = {};
            for (let s = 0; s < e; s++) {
                n = t[s];
                let o;
                if (r = n, !bre(n) && (r = a0[(o = String(n)).toLowerCase()], r === void 0)) throw new Ne(`Unknown adapter '${o}'`);
                if (r) break;
                i[o || "#" + s] = r
            }
            if (!r) {
                const s = Object.entries(i).map(([a, l]) => `adapter ${a} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build"));
                let o = e ? s.length > 1 ? `since :
` + s.map(rT).join(`
`) : " " + rT(s[0]) : "as no adapter specified";
                throw new Ne("There is no suitable adapter to dispatch the request " + o, "ERR_NOT_SUPPORT")
            }
            return r
        },
        adapters: a0
    };

function og(t) {
    if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new Xl(null, t)
}

function iT(t) {
    return og(t), t.headers = Br.from(t.headers), t.data = sg.call(t, t.transformRequest), ["post", "put", "patch"].indexOf(t.method) !== -1 && t.headers.setContentType("application/x-www-form-urlencoded", !1), Gk.getAdapter(t.adapter || hx.adapter)(t).then(function(r) {
        return og(t), r.data = sg.call(t, t.transformResponse, r), r.headers = Br.from(r.headers), r
    }, function(r) {
        return Dk(r) || (og(t), r && r.response && (r.response.data = sg.call(t, t.transformResponse, r.response), r.response.headers = Br.from(r.response.headers))), Promise.reject(r)
    })
}
const Hk = "1.10.0",
    Zp = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
    Zp[t] = function(r) {
        return typeof r === t || "a" + (e < 1 ? "n " : " ") + t
    }
});
const sT = {};
Zp.transitional = function(e, n, r) {
    function i(s, o) {
        return "[Axios v" + Hk + "] Transitional option '" + s + "'" + o + (r ? ". " + r : "")
    }
    return (s, o, a) => {
        if (e === !1) throw new Ne(i(o, " has been removed" + (n ? " in " + n : "")), Ne.ERR_DEPRECATED);
        return n && !sT[o] && (sT[o] = !0, console.warn(i(o, " has been deprecated since v" + n + " and will be removed in the near future"))), e ? e(s, o, a) : !0
    }
};
Zp.spelling = function(e) {
    return (n, r) => (console.warn(`${r} is likely a misspelling of ${e}`), !0)
};

function xre(t, e, n) {
    if (typeof t != "object") throw new Ne("options must be an object", Ne.ERR_BAD_OPTION_VALUE);
    const r = Object.keys(t);
    let i = r.length;
    for (; i-- > 0;) {
        const s = r[i],
            o = e[s];
        if (o) {
            const a = t[s],
                l = a === void 0 || o(a, s, t);
            if (l !== !0) throw new Ne("option " + s + " must be " + l, Ne.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (n !== !0) throw new Ne("Unknown option " + s, Ne.ERR_BAD_OPTION)
    }
}
const Vf = {
        assertOptions: xre,
        validators: Zp
    },
    jr = Vf.validators;
class Ch {
    constructor(e) {
        this.defaults = e || {}, this.interceptors = {
            request: new K1,
            response: new K1
        }
    }
    async request(e, n) {
        try {
            return await this._request(e, n)
        } catch (r) {
            if (r instanceof Error) {
                let i = {};
                Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error;
                const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
                try {
                    r.stack ? s && !String(r.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + s) : r.stack = s
                } catch {}
            }
            throw r
        }
    }
    _request(e, n) {
        typeof e == "string" ? (n = n || {}, n.url = e) : n = e || {}, n = na(this.defaults, n);
        const {
            transitional: r,
            paramsSerializer: i,
            headers: s
        } = n;
        r !== void 0 && Vf.assertOptions(r, {
            silentJSONParsing: jr.transitional(jr.boolean),
            forcedJSONParsing: jr.transitional(jr.boolean),
            clarifyTimeoutError: jr.transitional(jr.boolean)
        }, !1), i != null && (Q.isFunction(i) ? n.paramsSerializer = {
            serialize: i
        } : Vf.assertOptions(i, {
            encode: jr.function,
            serialize: jr.function
        }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), Vf.assertOptions(n, {
            baseUrl: jr.spelling("baseURL"),
            withXsrfToken: jr.spelling("withXSRFToken")
        }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
        let o = s && Q.merge(s.common, s[n.method]);
        s && Q.forEach(["delete", "get", "head", "post", "put", "patch", "common"], p => {
            delete s[p]
        }), n.headers = Br.concat(o, s);
        const a = [];
        let l = !0;
        this.interceptors.request.forEach(function(b) {
            typeof b.runWhen == "function" && b.runWhen(n) === !1 || (l = l && b.synchronous, a.unshift(b.fulfilled, b.rejected))
        });
        const c = [];
        this.interceptors.response.forEach(function(b) {
            c.push(b.fulfilled, b.rejected)
        });
        let u, d = 0,
            f;
        if (!l) {
            const p = [iT.bind(this), void 0];
            for (p.unshift.apply(p, a), p.push.apply(p, c), f = p.length, u = Promise.resolve(n); d < f;) u = u.then(p[d++], p[d++]);
            return u
        }
        f = a.length;
        let h = n;
        for (d = 0; d < f;) {
            const p = a[d++],
                b = a[d++];
            try {
                h = p(h)
            } catch (y) {
                b.call(this, y);
                break
            }
        }
        try {
            u = iT.call(this, h)
        } catch (p) {
            return Promise.reject(p)
        }
        for (d = 0, f = c.length; d < f;) u = u.then(c[d++], c[d++]);
        return u
    }
    getUri(e) {
        e = na(this.defaults, e);
        const n = Fk(e.baseURL, e.url, e.allowAbsoluteUrls);
        return Rk(n, e.params, e.paramsSerializer)
    }
}
Q.forEach(["delete", "get", "head", "options"], function(e) {
    Ch.prototype[e] = function(n, r) {
        return this.request(na(r || {}, {
            method: e,
            url: n,
            data: (r || {}).data
        }))
    }
});
Q.forEach(["post", "put", "patch"], function(e) {
    function n(r) {
        return function(s, o, a) {
            return this.request(na(a || {}, {
                method: e,
                headers: r ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: s,
                data: o
            }))
        }
    }
    Ch.prototype[e] = n(), Ch.prototype[e + "Form"] = n(!0)
});
const Wf = Ch;
class px {
    constructor(e) {
        if (typeof e != "function") throw new TypeError("executor must be a function.");
        let n;
        this.promise = new Promise(function(s) {
            n = s
        });
        const r = this;
        this.promise.then(i => {
            if (!r._listeners) return;
            let s = r._listeners.length;
            for (; s-- > 0;) r._listeners[s](i);
            r._listeners = null
        }), this.promise.then = i => {
            let s;
            const o = new Promise(a => {
                r.subscribe(a), s = a
            }).then(i);
            return o.cancel = function() {
                r.unsubscribe(s)
            }, o
        }, e(function(s, o, a) {
            r.reason || (r.reason = new Xl(s, o, a), n(r.reason))
        })
    }
    throwIfRequested() {
        if (this.reason) throw this.reason
    }
    subscribe(e) {
        if (this.reason) {
            e(this.reason);
            return
        }
        this._listeners ? this._listeners.push(e) : this._listeners = [e]
    }
    unsubscribe(e) {
        if (!this._listeners) return;
        const n = this._listeners.indexOf(e);
        n !== -1 && this._listeners.splice(n, 1)
    }
    toAbortSignal() {
        const e = new AbortController,
            n = r => {
                e.abort(r)
            };
        return this.subscribe(n), e.signal.unsubscribe = () => this.unsubscribe(n), e.signal
    }
    static source() {
        let e;
        return {
            token: new px(function(i) {
                e = i
            }),
            cancel: e
        }
    }
}
const wre = px;

function Ere(t) {
    return function(n) {
        return t.apply(null, n)
    }
}

function Sre(t) {
    return Q.isObject(t) && t.isAxiosError === !0
}
const l0 = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(l0).forEach(([t, e]) => {
    l0[e] = t
});
const Tre = l0;

function zk(t) {
    const e = new Wf(t),
        n = bk(Wf.prototype.request, e);
    return Q.extend(n, Wf.prototype, e, {
        allOwnKeys: !0
    }), Q.extend(n, e, null, {
        allOwnKeys: !0
    }), n.create = function(i) {
        return zk(na(t, i))
    }, n
}
const Gt = zk(hx);
Gt.Axios = Wf;
Gt.CanceledError = Xl;
Gt.CancelToken = wre;
Gt.isCancel = Dk;
Gt.VERSION = Hk;
Gt.toFormData = qp;
Gt.AxiosError = Ne;
Gt.Cancel = Gt.CanceledError;
Gt.all = function(e) {
    return Promise.all(e)
};
Gt.spread = Ere;
Gt.isAxiosError = Sre;
Gt.mergeConfig = na;
Gt.AxiosHeaders = Br;
Gt.formToJSON = t => Bk(Q.isHTMLForm(t) ? new FormData(t) : t);
Gt.getAdapter = Gk.getAdapter;
Gt.HttpStatusCode = Tre;
Gt.default = Gt;
const gwe = Gt;
var G = (t => (t.Application = "application", t.WebGLPipes = "webgl-pipes", t.WebGLPipesAdaptor = "webgl-pipes-adaptor", t.WebGLSystem = "webgl-system", t.WebGPUPipes = "webgpu-pipes", t.WebGPUPipesAdaptor = "webgpu-pipes-adaptor", t.WebGPUSystem = "webgpu-system", t.CanvasSystem = "canvas-system", t.CanvasPipesAdaptor = "canvas-pipes-adaptor", t.CanvasPipes = "canvas-pipes", t.Asset = "asset", t.LoadParser = "load-parser", t.ResolveParser = "resolve-parser", t.CacheParser = "cache-parser", t.DetectionParser = "detection-parser", t.MaskEffect = "mask-effect", t.BlendMode = "blend-mode", t.TextureSource = "texture-source", t.Environment = "environment", t.ShapeBuilder = "shape-builder", t.Batcher = "batcher", t))(G || {});
const c0 = t => {
        if (typeof t == "function" || typeof t == "object" && t.extension) {
            if (!t.extension) throw new Error("Extension class must have an extension object");
            t = { ...typeof t.extension != "object" ? {
                    type: t.extension
                } : t.extension,
                ref: t
            }
        }
        if (typeof t == "object") t = { ...t
        };
        else throw new Error("Invalid extension type");
        return typeof t.type == "string" && (t.type = [t.type]), t
    },
    rf = (t, e) => c0(t).priority ? ? e,
    Re = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...t) {
            return t.map(c0).forEach(e => {
                e.type.forEach(n => {
                    var r, i;
                    return (i = (r = this._removeHandlers)[n]) == null ? void 0 : i.call(r, e)
                })
            }), this
        },
        add(...t) {
            return t.map(c0).forEach(e => {
                e.type.forEach(n => {
                    var s, o;
                    const r = this._addHandlers,
                        i = this._queue;
                    r[n] ? (o = r[n]) == null || o.call(r, e) : (i[n] = i[n] || [], (s = i[n]) == null || s.push(e))
                })
            }), this
        },
        handle(t, e, n) {
            var o;
            const r = this._addHandlers,
                i = this._removeHandlers;
            if (r[t] || i[t]) throw new Error(`Extension type ${t} already has a handler`);
            r[t] = e, i[t] = n;
            const s = this._queue;
            return s[t] && ((o = s[t]) == null || o.forEach(a => e(a)), delete s[t]), this
        },
        handleByMap(t, e) {
            return this.handle(t, n => {
                n.name && (e[n.name] = n.ref)
            }, n => {
                n.name && delete e[n.name]
            })
        },
        handleByNamedList(t, e, n = -1) {
            return this.handle(t, r => {
                e.findIndex(s => s.name === r.name) >= 0 || (e.push({
                    name: r.name,
                    value: r.ref
                }), e.sort((s, o) => rf(o.value, n) - rf(s.value, n)))
            }, r => {
                const i = e.findIndex(s => s.name === r.name);
                i !== -1 && e.splice(i, 1)
            })
        },
        handleByList(t, e, n = -1) {
            return this.handle(t, r => {
                e.includes(r.ref) || (e.push(r.ref), e.sort((i, s) => rf(s, n) - rf(i, n)))
            }, r => {
                const i = e.indexOf(r.ref);
                i !== -1 && e.splice(i, 1)
            })
        },
        mixin(t, ...e) {
            for (const n of e) Object.defineProperties(t.prototype, Object.getOwnPropertyDescriptors(n))
        }
    },
    Cre = {
        extension: {
            type: G.Environment,
            name: "browser",
            priority: -1
        },
        test: () => !0,
        load: async () => {
            await nh(() => Promise.resolve().then(() => G_e), void 0)
        }
    },
    Pre = {
        extension: {
            type: G.Environment,
            name: "webworker",
            priority: 0
        },
        test: () => typeof self < "u" && self.WorkerGlobalScope !== void 0,
        load: async () => {
            await nh(() => Promise.resolve().then(() => H_e), void 0)
        }
    };
class At {
    constructor(e, n, r) {
        this._x = n || 0, this._y = r || 0, this._observer = e
    }
    clone(e) {
        return new At(e ? ? this._observer, this._x, this._y)
    }
    set(e = 0, n = e) {
        return (this._x !== e || this._y !== n) && (this._x = e, this._y = n, this._observer._onUpdate(this)), this
    }
    copyFrom(e) {
        return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this._observer._onUpdate(this)), this
    }
    copyTo(e) {
        return e.set(this._x, this._y), e
    }
    equals(e) {
        return e.x === this._x && e.y === this._y
    }
    toString() {
        return `[pixi.js/math:ObservablePoint x=${this._x} y=${this._y} scope=${this._observer}]`
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x !== e && (this._x = e, this._observer._onUpdate(this))
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y !== e && (this._y = e, this._observer._onUpdate(this))
    }
}
var jk = {
    exports: {}
};
(function(t) {
    var e = Object.prototype.hasOwnProperty,
        n = "~";

    function r() {}
    Object.create && (r.prototype = Object.create(null), new r().__proto__ || (n = !1));

    function i(l, c, u) {
        this.fn = l, this.context = c, this.once = u || !1
    }

    function s(l, c, u, d, f) {
        if (typeof u != "function") throw new TypeError("The listener must be a function");
        var h = new i(u, d || l, f),
            p = n ? n + c : c;
        return l._events[p] ? l._events[p].fn ? l._events[p] = [l._events[p], h] : l._events[p].push(h) : (l._events[p] = h, l._eventsCount++), l
    }

    function o(l, c) {
        --l._eventsCount === 0 ? l._events = new r : delete l._events[c]
    }

    function a() {
        this._events = new r, this._eventsCount = 0
    }
    a.prototype.eventNames = function() {
        var c = [],
            u, d;
        if (this._eventsCount === 0) return c;
        for (d in u = this._events) e.call(u, d) && c.push(n ? d.slice(1) : d);
        return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c
    }, a.prototype.listeners = function(c) {
        var u = n ? n + c : c,
            d = this._events[u];
        if (!d) return [];
        if (d.fn) return [d.fn];
        for (var f = 0, h = d.length, p = new Array(h); f < h; f++) p[f] = d[f].fn;
        return p
    }, a.prototype.listenerCount = function(c) {
        var u = n ? n + c : c,
            d = this._events[u];
        return d ? d.fn ? 1 : d.length : 0
    }, a.prototype.emit = function(c, u, d, f, h, p) {
        var b = n ? n + c : c;
        if (!this._events[b]) return !1;
        var y = this._events[b],
            m = arguments.length,
            g, v;
        if (y.fn) {
            switch (y.once && this.removeListener(c, y.fn, void 0, !0), m) {
                case 1:
                    return y.fn.call(y.context), !0;
                case 2:
                    return y.fn.call(y.context, u), !0;
                case 3:
                    return y.fn.call(y.context, u, d), !0;
                case 4:
                    return y.fn.call(y.context, u, d, f), !0;
                case 5:
                    return y.fn.call(y.context, u, d, f, h), !0;
                case 6:
                    return y.fn.call(y.context, u, d, f, h, p), !0
            }
            for (v = 1, g = new Array(m - 1); v < m; v++) g[v - 1] = arguments[v];
            y.fn.apply(y.context, g)
        } else {
            var _ = y.length,
                x;
            for (v = 0; v < _; v++) switch (y[v].once && this.removeListener(c, y[v].fn, void 0, !0), m) {
                case 1:
                    y[v].fn.call(y[v].context);
                    break;
                case 2:
                    y[v].fn.call(y[v].context, u);
                    break;
                case 3:
                    y[v].fn.call(y[v].context, u, d);
                    break;
                case 4:
                    y[v].fn.call(y[v].context, u, d, f);
                    break;
                default:
                    if (!g)
                        for (x = 1, g = new Array(m - 1); x < m; x++) g[x - 1] = arguments[x];
                    y[v].fn.apply(y[v].context, g)
            }
        }
        return !0
    }, a.prototype.on = function(c, u, d) {
        return s(this, c, u, d, !1)
    }, a.prototype.once = function(c, u, d) {
        return s(this, c, u, d, !0)
    }, a.prototype.removeListener = function(c, u, d, f) {
        var h = n ? n + c : c;
        if (!this._events[h]) return this;
        if (!u) return o(this, h), this;
        var p = this._events[h];
        if (p.fn) p.fn === u && (!f || p.once) && (!d || p.context === d) && o(this, h);
        else {
            for (var b = 0, y = [], m = p.length; b < m; b++)(p[b].fn !== u || f && !p[b].once || d && p[b].context !== d) && y.push(p[b]);
            y.length ? this._events[h] = y.length === 1 ? y[0] : y : o(this, h)
        }
        return this
    }, a.prototype.removeAllListeners = function(c) {
        var u;
        return c ? (u = n ? n + c : c, this._events[u] && o(this, u)) : (this._events = new r, this._eventsCount = 0), this
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = n, a.EventEmitter = a, t.exports = a
})(jk);
var Are = jk.exports;
const ir = Hl(Are),
    Ore = Math.PI * 2,
    Ire = 180 / Math.PI,
    Mre = Math.PI / 180;
class dt {
    constructor(e = 0, n = 0) {
        this.x = 0, this.y = 0, this.x = e, this.y = n
    }
    clone() {
        return new dt(this.x, this.y)
    }
    copyFrom(e) {
        return this.set(e.x, e.y), this
    }
    copyTo(e) {
        return e.set(this.x, this.y), e
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    set(e = 0, n = e) {
        return this.x = e, this.y = n, this
    }
    toString() {
        return `[pixi.js/math:Point x=${this.x} y=${this.y}]`
    }
    static get shared() {
        return ag.x = 0, ag.y = 0, ag
    }
}
const ag = new dt;
class Te {
    constructor(e = 1, n = 0, r = 0, i = 1, s = 0, o = 0) {
        this.array = null, this.a = e, this.b = n, this.c = r, this.d = i, this.tx = s, this.ty = o
    }
    fromArray(e) {
        this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5]
    }
    set(e, n, r, i, s, o) {
        return this.a = e, this.b = n, this.c = r, this.d = i, this.tx = s, this.ty = o, this
    }
    toArray(e, n) {
        this.array || (this.array = new Float32Array(9));
        const r = n || this.array;
        return e ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r
    }
    apply(e, n) {
        n = n || new dt;
        const r = e.x,
            i = e.y;
        return n.x = this.a * r + this.c * i + this.tx, n.y = this.b * r + this.d * i + this.ty, n
    }
    applyInverse(e, n) {
        n = n || new dt;
        const r = this.a,
            i = this.b,
            s = this.c,
            o = this.d,
            a = this.tx,
            l = this.ty,
            c = 1 / (r * o + s * -i),
            u = e.x,
            d = e.y;
        return n.x = o * c * u + -s * c * d + (l * s - a * o) * c, n.y = r * c * d + -i * c * u + (-l * r + a * i) * c, n
    }
    translate(e, n) {
        return this.tx += e, this.ty += n, this
    }
    scale(e, n) {
        return this.a *= e, this.d *= n, this.c *= e, this.b *= n, this.tx *= e, this.ty *= n, this
    }
    rotate(e) {
        const n = Math.cos(e),
            r = Math.sin(e),
            i = this.a,
            s = this.c,
            o = this.tx;
        return this.a = i * n - this.b * r, this.b = i * r + this.b * n, this.c = s * n - this.d * r, this.d = s * r + this.d * n, this.tx = o * n - this.ty * r, this.ty = o * r + this.ty * n, this
    }
    append(e) {
        const n = this.a,
            r = this.b,
            i = this.c,
            s = this.d;
        return this.a = e.a * n + e.b * i, this.b = e.a * r + e.b * s, this.c = e.c * n + e.d * i, this.d = e.c * r + e.d * s, this.tx = e.tx * n + e.ty * i + this.tx, this.ty = e.tx * r + e.ty * s + this.ty, this
    }
    appendFrom(e, n) {
        const r = e.a,
            i = e.b,
            s = e.c,
            o = e.d,
            a = e.tx,
            l = e.ty,
            c = n.a,
            u = n.b,
            d = n.c,
            f = n.d;
        return this.a = r * c + i * d, this.b = r * u + i * f, this.c = s * c + o * d, this.d = s * u + o * f, this.tx = a * c + l * d + n.tx, this.ty = a * u + l * f + n.ty, this
    }
    setTransform(e, n, r, i, s, o, a, l, c) {
        return this.a = Math.cos(a + c) * s, this.b = Math.sin(a + c) * s, this.c = -Math.sin(a - l) * o, this.d = Math.cos(a - l) * o, this.tx = e - (r * this.a + i * this.c), this.ty = n - (r * this.b + i * this.d), this
    }
    prepend(e) {
        const n = this.tx;
        if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
            const r = this.a,
                i = this.c;
            this.a = r * e.a + this.b * e.c, this.b = r * e.b + this.b * e.d, this.c = i * e.a + this.d * e.c, this.d = i * e.b + this.d * e.d
        }
        return this.tx = n * e.a + this.ty * e.c + e.tx, this.ty = n * e.b + this.ty * e.d + e.ty, this
    }
    decompose(e) {
        const n = this.a,
            r = this.b,
            i = this.c,
            s = this.d,
            o = e.pivot,
            a = -Math.atan2(-i, s),
            l = Math.atan2(r, n),
            c = Math.abs(a + l);
        return c < 1e-5 || Math.abs(Ore - c) < 1e-5 ? (e.rotation = l, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = a, e.skew.y = l), e.scale.x = Math.sqrt(n * n + r * r), e.scale.y = Math.sqrt(i * i + s * s), e.position.x = this.tx + (o.x * n + o.y * i), e.position.y = this.ty + (o.x * r + o.y * s), e
    }
    invert() {
        const e = this.a,
            n = this.b,
            r = this.c,
            i = this.d,
            s = this.tx,
            o = e * i - n * r;
        return this.a = i / o, this.b = -n / o, this.c = -r / o, this.d = e / o, this.tx = (r * this.ty - i * s) / o, this.ty = -(e * this.ty - n * s) / o, this
    }
    isIdentity() {
        return this.a === 1 && this.b === 0 && this.c === 0 && this.d === 1 && this.tx === 0 && this.ty === 0
    }
    identity() {
        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
    }
    clone() {
        const e = new Te;
        return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e
    }
    copyTo(e) {
        return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e
    }
    copyFrom(e) {
        return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this
    }
    equals(e) {
        return e.a === this.a && e.b === this.b && e.c === this.c && e.d === this.d && e.tx === this.tx && e.ty === this.ty
    }
    toString() {
        return `[pixi.js:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
    }
    static get IDENTITY() {
        return kre.identity()
    }
    static get shared() {
        return Rre.identity()
    }
}
const Rre = new Te,
    kre = new Te,
    vo = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
    _o = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
    bo = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
    xo = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
    u0 = [],
    Vk = [],
    sf = Math.sign;

function Bre() {
    for (let t = 0; t < 16; t++) {
        const e = [];
        u0.push(e);
        for (let n = 0; n < 16; n++) {
            const r = sf(vo[t] * vo[n] + bo[t] * _o[n]),
                i = sf(_o[t] * vo[n] + xo[t] * _o[n]),
                s = sf(vo[t] * bo[n] + bo[t] * xo[n]),
                o = sf(_o[t] * bo[n] + xo[t] * xo[n]);
            for (let a = 0; a < 16; a++)
                if (vo[a] === r && _o[a] === i && bo[a] === s && xo[a] === o) {
                    e.push(a);
                    break
                }
        }
    }
    for (let t = 0; t < 16; t++) {
        const e = new Te;
        e.set(vo[t], _o[t], bo[t], xo[t], 0, 0), Vk.push(e)
    }
}
Bre();
const xt = {
        E: 0,
        SE: 1,
        S: 2,
        SW: 3,
        W: 4,
        NW: 5,
        N: 6,
        NE: 7,
        MIRROR_VERTICAL: 8,
        MAIN_DIAGONAL: 10,
        MIRROR_HORIZONTAL: 12,
        REVERSE_DIAGONAL: 14,
        uX: t => vo[t],
        uY: t => _o[t],
        vX: t => bo[t],
        vY: t => xo[t],
        inv: t => t & 8 ? t & 15 : -t & 7,
        add: (t, e) => u0[t][e],
        sub: (t, e) => u0[t][xt.inv(e)],
        rotate180: t => t ^ 4,
        isVertical: t => (t & 3) === 2,
        byDirection: (t, e) => Math.abs(t) * 2 <= Math.abs(e) ? e >= 0 ? xt.S : xt.N : Math.abs(e) * 2 <= Math.abs(t) ? t > 0 ? xt.E : xt.W : e > 0 ? t > 0 ? xt.SE : xt.SW : t > 0 ? xt.NE : xt.NW,
        matrixAppendRotationInv: (t, e, n = 0, r = 0) => {
            const i = Vk[xt.inv(e)];
            i.tx = n, i.ty = r, t.append(i)
        }
    },
    of = [new dt, new dt, new dt, new dt];
class it {
    constructor(e = 0, n = 0, r = 0, i = 0) {
        this.type = "rectangle", this.x = Number(e), this.y = Number(n), this.width = Number(r), this.height = Number(i)
    }
    get left() {
        return this.x
    }
    get right() {
        return this.x + this.width
    }
    get top() {
        return this.y
    }
    get bottom() {
        return this.y + this.height
    }
    isEmpty() {
        return this.left === this.right || this.top === this.bottom
    }
    static get EMPTY() {
        return new it(0, 0, 0, 0)
    }
    clone() {
        return new it(this.x, this.y, this.width, this.height)
    }
    copyFromBounds(e) {
        return this.x = e.minX, this.y = e.minY, this.width = e.maxX - e.minX, this.height = e.maxY - e.minY, this
    }
    copyFrom(e) {
        return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this
    }
    copyTo(e) {
        return e.copyFrom(this), e
    }
    contains(e, n) {
        return this.width <= 0 || this.height <= 0 ? !1 : e >= this.x && e < this.x + this.width && n >= this.y && n < this.y + this.height
    }
    strokeContains(e, n, r, i = .5) {
        const {
            width: s,
            height: o
        } = this;
        if (s <= 0 || o <= 0) return !1;
        const a = this.x,
            l = this.y,
            c = r * (1 - i),
            u = r - c,
            d = a - c,
            f = a + s + c,
            h = l - c,
            p = l + o + c,
            b = a + u,
            y = a + s - u,
            m = l + u,
            g = l + o - u;
        return e >= d && e <= f && n >= h && n <= p && !(e > b && e < y && n > m && n < g)
    }
    intersects(e, n) {
        if (!n) {
            const C = this.x < e.x ? e.x : this.x;
            if ((this.right > e.right ? e.right : this.right) <= C) return !1;
            const T = this.y < e.y ? e.y : this.y;
            return (this.bottom > e.bottom ? e.bottom : this.bottom) > T
        }
        const r = this.left,
            i = this.right,
            s = this.top,
            o = this.bottom;
        if (i <= r || o <= s) return !1;
        const a = of [0].set(e.left, e.top),
            l = of [1].set(e.left, e.bottom),
            c = of [2].set(e.right, e.top),
            u = of [3].set(e.right, e.bottom);
        if (c.x <= a.x || l.y <= a.y) return !1;
        const d = Math.sign(n.a * n.d - n.b * n.c);
        if (d === 0 || (n.apply(a, a), n.apply(l, l), n.apply(c, c), n.apply(u, u), Math.max(a.x, l.x, c.x, u.x) <= r || Math.min(a.x, l.x, c.x, u.x) >= i || Math.max(a.y, l.y, c.y, u.y) <= s || Math.min(a.y, l.y, c.y, u.y) >= o)) return !1;
        const f = d * (l.y - a.y),
            h = d * (a.x - l.x),
            p = f * r + h * s,
            b = f * i + h * s,
            y = f * r + h * o,
            m = f * i + h * o;
        if (Math.max(p, b, y, m) <= f * a.x + h * a.y || Math.min(p, b, y, m) >= f * u.x + h * u.y) return !1;
        const g = d * (a.y - c.y),
            v = d * (c.x - a.x),
            _ = g * r + v * s,
            x = g * i + v * s,
            w = g * r + v * o,
            E = g * i + v * o;
        return !(Math.max(_, x, w, E) <= g * a.x + v * a.y || Math.min(_, x, w, E) >= g * u.x + v * u.y)
    }
    pad(e = 0, n = e) {
        return this.x -= e, this.y -= n, this.width += e * 2, this.height += n * 2, this
    }
    fit(e) {
        const n = Math.max(this.x, e.x),
            r = Math.min(this.x + this.width, e.x + e.width),
            i = Math.max(this.y, e.y),
            s = Math.min(this.y + this.height, e.y + e.height);
        return this.x = n, this.width = Math.max(r - n, 0), this.y = i, this.height = Math.max(s - i, 0), this
    }
    ceil(e = 1, n = .001) {
        const r = Math.ceil((this.x + this.width - n) * e) / e,
            i = Math.ceil((this.y + this.height - n) * e) / e;
        return this.x = Math.floor((this.x + n) * e) / e, this.y = Math.floor((this.y + n) * e) / e, this.width = r - this.x, this.height = i - this.y, this
    }
    enlarge(e) {
        const n = Math.min(this.x, e.x),
            r = Math.max(this.x + this.width, e.x + e.width),
            i = Math.min(this.y, e.y),
            s = Math.max(this.y + this.height, e.y + e.height);
        return this.x = n, this.width = r - n, this.y = i, this.height = s - i, this
    }
    getBounds(e) {
        return e || (e = new it), e.copyFrom(this), e
    }
    containsRect(e) {
        if (this.width <= 0 || this.height <= 0) return !1;
        const n = e.x,
            r = e.y,
            i = e.x + e.width,
            s = e.y + e.height;
        return n >= this.x && n < this.x + this.width && r >= this.y && r < this.y + this.height && i >= this.x && i < this.x + this.width && s >= this.y && s < this.y + this.height
    }
    set(e, n, r, i) {
        return this.x = e, this.y = n, this.width = r, this.height = i, this
    }
    toString() {
        return `[pixi.js/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
    }
}
const lg = {
    default: -1
};

function vt(t = "default") {
    return lg[t] === void 0 && (lg[t] = -1), ++lg[t]
}
const oT = {},
    Ye = "8.0.0",
    Dre = "8.3.4";

function Ie(t, e, n = 3) {
    if (oT[e]) return;
    let r = new Error().stack;
    typeof r > "u" ? console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${t}`) : (r = r.split(`
`).splice(n).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${e}
Deprecated since v${t}`), console.warn(r), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${e}
Deprecated since v${t}`), console.warn(r))), oT[e] = !0
}
const Wk = () => {};

function El(t) {
    return t += t === 0 ? 1 : 0, --t, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t + 1
}

function aT(t) {
    return !(t & t - 1) && !!t
}

function Yk(t) {
    const e = {};
    for (const n in t) t[n] !== void 0 && (e[n] = t[n]);
    return e
}
const lT = Object.create(null);

function $re(t) {
    const e = lT[t];
    return e === void 0 && (lT[t] = vt("resource")), e
}
const Xk = class qk extends ir {
    constructor(e = {}) {
        super(), this._resourceType = "textureSampler", this._touched = 0, this._maxAnisotropy = 1, this.destroyed = !1, e = { ...qk.defaultOptions,
            ...e
        }, this.addressMode = e.addressMode, this.addressModeU = e.addressModeU ? ? this.addressModeU, this.addressModeV = e.addressModeV ? ? this.addressModeV, this.addressModeW = e.addressModeW ? ? this.addressModeW, this.scaleMode = e.scaleMode, this.magFilter = e.magFilter ? ? this.magFilter, this.minFilter = e.minFilter ? ? this.minFilter, this.mipmapFilter = e.mipmapFilter ? ? this.mipmapFilter, this.lodMinClamp = e.lodMinClamp, this.lodMaxClamp = e.lodMaxClamp, this.compare = e.compare, this.maxAnisotropy = e.maxAnisotropy ? ? 1
    }
    set addressMode(e) {
        this.addressModeU = e, this.addressModeV = e, this.addressModeW = e
    }
    get addressMode() {
        return this.addressModeU
    }
    set wrapMode(e) {
        Ie(Ye, "TextureStyle.wrapMode is now TextureStyle.addressMode"), this.addressMode = e
    }
    get wrapMode() {
        return this.addressMode
    }
    set scaleMode(e) {
        this.magFilter = e, this.minFilter = e, this.mipmapFilter = e
    }
    get scaleMode() {
        return this.magFilter
    }
    set maxAnisotropy(e) {
        this._maxAnisotropy = Math.min(e, 16), this._maxAnisotropy > 1 && (this.scaleMode = "linear")
    }
    get maxAnisotropy() {
        return this._maxAnisotropy
    }
    get _resourceId() {
        return this._sharedResourceId || this._generateResourceId()
    }
    update() {
        this.emit("change", this), this._sharedResourceId = null
    }
    _generateResourceId() {
        const e = `${this.addressModeU}-${this.addressModeV}-${this.addressModeW}-${this.magFilter}-${this.minFilter}-${this.mipmapFilter}-${this.lodMinClamp}-${this.lodMaxClamp}-${this.compare}-${this._maxAnisotropy}`;
        return this._sharedResourceId = $re(e), this._resourceId
    }
    destroy() {
        this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this.removeAllListeners()
    }
};
Xk.defaultOptions = {
    addressMode: "clamp-to-edge",
    scaleMode: "linear"
};
let Zi = Xk;
const Kk = class Jk extends ir {
    constructor(e = {}) {
        super(), this.options = e, this.uid = vt("textureSource"), this._resourceType = "textureSource", this._resourceId = vt("resource"), this.uploadMethodId = "unknown", this._resolution = 1, this.pixelWidth = 1, this.pixelHeight = 1, this.width = 1, this.height = 1, this.sampleCount = 1, this.mipLevelCount = 1, this.autoGenerateMipmaps = !1, this.format = "rgba8unorm", this.dimension = "2d", this.antialias = !1, this._touched = 0, this._batchTick = -1, this._textureBindLocation = -1, e = { ...Jk.defaultOptions,
            ...e
        }, this.label = e.label ? ? "", this.resource = e.resource, this.autoGarbageCollect = e.autoGarbageCollect, this._resolution = e.resolution, e.width ? this.pixelWidth = e.width * this._resolution : this.pixelWidth = this.resource ? this.resourceWidth ? ? 1 : 1, e.height ? this.pixelHeight = e.height * this._resolution : this.pixelHeight = this.resource ? this.resourceHeight ? ? 1 : 1, this.width = this.pixelWidth / this._resolution, this.height = this.pixelHeight / this._resolution, this.format = e.format, this.dimension = e.dimensions, this.mipLevelCount = e.mipLevelCount, this.autoGenerateMipmaps = e.autoGenerateMipmaps, this.sampleCount = e.sampleCount, this.antialias = e.antialias, this.alphaMode = e.alphaMode, this.style = new Zi(Yk(e)), this.destroyed = !1, this._refreshPOT()
    }
    get source() {
        return this
    }
    get style() {
        return this._style
    }
    set style(e) {
        var n, r;
        this.style !== e && ((n = this._style) == null || n.off("change", this._onStyleChange, this), this._style = e, (r = this._style) == null || r.on("change", this._onStyleChange, this), this._onStyleChange())
    }
    get addressMode() {
        return this._style.addressMode
    }
    set addressMode(e) {
        this._style.addressMode = e
    }
    get repeatMode() {
        return this._style.addressMode
    }
    set repeatMode(e) {
        this._style.addressMode = e
    }
    get magFilter() {
        return this._style.magFilter
    }
    set magFilter(e) {
        this._style.magFilter = e
    }
    get minFilter() {
        return this._style.minFilter
    }
    set minFilter(e) {
        this._style.minFilter = e
    }
    get mipmapFilter() {
        return this._style.mipmapFilter
    }
    set mipmapFilter(e) {
        this._style.mipmapFilter = e
    }
    get lodMinClamp() {
        return this._style.lodMinClamp
    }
    set lodMinClamp(e) {
        this._style.lodMinClamp = e
    }
    get lodMaxClamp() {
        return this._style.lodMaxClamp
    }
    set lodMaxClamp(e) {
        this._style.lodMaxClamp = e
    }
    _onStyleChange() {
        this.emit("styleChange", this)
    }
    update() {
        if (this.resource) {
            const e = this._resolution;
            if (this.resize(this.resourceWidth / e, this.resourceHeight / e)) return
        }
        this.emit("update", this)
    }
    destroy() {
        this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._style && (this._style.destroy(), this._style = null), this.uploadMethodId = null, this.resource = null, this.removeAllListeners()
    }
    unload() {
        this._resourceId = vt("resource"), this.emit("change", this), this.emit("unload", this)
    }
    get resourceWidth() {
        const {
            resource: e
        } = this;
        return e.naturalWidth || e.videoWidth || e.displayWidth || e.width
    }
    get resourceHeight() {
        const {
            resource: e
        } = this;
        return e.naturalHeight || e.videoHeight || e.displayHeight || e.height
    }
    get resolution() {
        return this._resolution
    }
    set resolution(e) {
        this._resolution !== e && (this._resolution = e, this.width = this.pixelWidth / e, this.height = this.pixelHeight / e)
    }
    resize(e, n, r) {
        r || (r = this._resolution), e || (e = this.width), n || (n = this.height);
        const i = Math.round(e * r),
            s = Math.round(n * r);
        return this.width = i / r, this.height = s / r, this._resolution = r, this.pixelWidth === i && this.pixelHeight === s ? !1 : (this._refreshPOT(), this.pixelWidth = i, this.pixelHeight = s, this.emit("resize", this), this._resourceId = vt("resource"), this.emit("change", this), !0)
    }
    updateMipmaps() {
        this.autoGenerateMipmaps && this.mipLevelCount > 1 && this.emit("updateMipmaps", this)
    }
    set wrapMode(e) {
        this._style.wrapMode = e
    }
    get wrapMode() {
        return this._style.wrapMode
    }
    set scaleMode(e) {
        this._style.scaleMode = e
    }
    get scaleMode() {
        return this._style.scaleMode
    }
    _refreshPOT() {
        this.isPowerOfTwo = aT(this.pixelWidth) && aT(this.pixelHeight)
    }
    static test(e) {
        throw new Error("Unimplemented")
    }
};
Kk.defaultOptions = {
    resolution: 1,
    format: "bgra8unorm",
    alphaMode: "premultiply-alpha-on-upload",
    dimensions: "2d",
    mipLevelCount: 1,
    autoGenerateMipmaps: !1,
    sampleCount: 1,
    antialias: !1,
    autoGarbageCollect: !1
};
let Wt = Kk;
class mx extends Wt {
    constructor(e) {
        const n = e.resource || new Float32Array(e.width * e.height * 4);
        let r = e.format;
        r || (n instanceof Float32Array ? r = "rgba32float" : n instanceof Int32Array || n instanceof Uint32Array ? r = "rgba32uint" : n instanceof Int16Array || n instanceof Uint16Array ? r = "rgba16uint" : (n instanceof Int8Array, r = "bgra8unorm")), super({ ...e,
            resource: n,
            format: r
        }), this.uploadMethodId = "buffer"
    }
    static test(e) {
        return e instanceof Int8Array || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Int16Array || e instanceof Uint16Array || e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array
    }
}
mx.extension = G.TextureSource;
const cT = new Te;
class Zk {
    constructor(e, n) {
        this.mapCoord = new Te, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, typeof n > "u" ? this.clampMargin = e.width < 10 ? 0 : .5 : this.clampMargin = n, this.isSimple = !1, this.texture = e
    }
    get texture() {
        return this._texture
    }
    set texture(e) {
        var n;
        this.texture !== e && ((n = this._texture) == null || n.removeListener("update", this.update, this), this._texture = e, this._texture.addListener("update", this.update, this), this.update())
    }
    multiplyUvs(e, n) {
        n === void 0 && (n = e);
        const r = this.mapCoord;
        for (let i = 0; i < e.length; i += 2) {
            const s = e[i],
                o = e[i + 1];
            n[i] = s * r.a + o * r.c + r.tx, n[i + 1] = s * r.b + o * r.d + r.ty
        }
        return n
    }
    update() {
        const e = this._texture;
        this._updateID++;
        const n = e.uvs;
        this.mapCoord.set(n.x1 - n.x0, n.y1 - n.y0, n.x3 - n.x0, n.y3 - n.y0, n.x0, n.y0);
        const r = e.orig,
            i = e.trim;
        i && (cT.set(r.width / i.width, 0, 0, r.height / i.height, -i.x / i.width, -i.y / i.height), this.mapCoord.append(cT));
        const s = e.source,
            o = this.uClampFrame,
            a = this.clampMargin / s._resolution,
            l = this.clampOffset / s._resolution;
        return o[0] = (e.frame.x + a + l) / s.width, o[1] = (e.frame.y + a + l) / s.height, o[2] = (e.frame.x + e.frame.width - a + l) / s.width, o[3] = (e.frame.y + e.frame.height - a + l) / s.height, this.uClampOffset[0] = this.clampOffset / s.pixelWidth, this.uClampOffset[1] = this.clampOffset / s.pixelHeight, this.isSimple = e.frame.width === s.width && e.frame.height === s.height && e.rotate === 0, !0
    }
}
class we extends ir {
    constructor({
        source: e,
        label: n,
        frame: r,
        orig: i,
        trim: s,
        defaultAnchor: o,
        defaultBorders: a,
        rotate: l,
        dynamic: c
    } = {}) {
        if (super(), this.uid = vt("texture"), this.uvs = {
                x0: 0,
                y0: 0,
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                x3: 0,
                y3: 0
            }, this.frame = new it, this.noFrame = !1, this.dynamic = !1, this.isTexture = !0, this.label = n, this.source = (e == null ? void 0 : e.source) ? ? new Wt, this.noFrame = !r, r) this.frame.copyFrom(r);
        else {
            const {
                width: u,
                height: d
            } = this._source;
            this.frame.width = u, this.frame.height = d
        }
        this.orig = i || this.frame, this.trim = s, this.rotate = l ? ? 0, this.defaultAnchor = o, this.defaultBorders = a, this.destroyed = !1, this.dynamic = c || !1, this.updateUvs()
    }
    set source(e) {
        this._source && this._source.off("resize", this.update, this), this._source = e, e.on("resize", this.update, this), this.emit("update", this)
    }
    get source() {
        return this._source
    }
    get textureMatrix() {
        return this._textureMatrix || (this._textureMatrix = new Zk(this)), this._textureMatrix
    }
    get width() {
        return this.orig.width
    }
    get height() {
        return this.orig.height
    }
    updateUvs() {
        const {
            uvs: e,
            frame: n
        } = this, {
            width: r,
            height: i
        } = this._source, s = n.x / r, o = n.y / i, a = n.width / r, l = n.height / i;
        let c = this.rotate;
        if (c) {
            const u = a / 2,
                d = l / 2,
                f = s + u,
                h = o + d;
            c = xt.add(c, xt.NW), e.x0 = f + u * xt.uX(c), e.y0 = h + d * xt.uY(c), c = xt.add(c, 2), e.x1 = f + u * xt.uX(c), e.y1 = h + d * xt.uY(c), c = xt.add(c, 2), e.x2 = f + u * xt.uX(c), e.y2 = h + d * xt.uY(c), c = xt.add(c, 2), e.x3 = f + u * xt.uX(c), e.y3 = h + d * xt.uY(c)
        } else e.x0 = s, e.y0 = o, e.x1 = s + a, e.y1 = o, e.x2 = s + a, e.y2 = o + l, e.x3 = s, e.y3 = o + l
    }
    destroy(e = !1) {
        this._source && e && (this._source.destroy(), this._source = null), this._textureMatrix = null, this.destroyed = !0, this.emit("destroy", this), this.removeAllListeners()
    }
    update() {
        this.noFrame && (this.frame.width = this._source.width, this.frame.height = this._source.height), this.updateUvs(), this.emit("update", this)
    }
    get baseTexture() {
        return Ie(Ye, "Texture.baseTexture is now Texture.source"), this._source
    }
}
we.EMPTY = new we({
    label: "EMPTY",
    source: new Wt({
        label: "EMPTY"
    })
});
we.EMPTY.destroy = Wk;
we.WHITE = new we({
    source: new mx({
        resource: new Uint8Array([255, 255, 255, 255]),
        width: 1,
        height: 1,
        alphaMode: "premultiply-alpha-on-upload",
        label: "WHITE"
    }),
    label: "WHITE"
});
we.WHITE.destroy = Wk;

function Qk(t, e, n) {
    const {
        width: r,
        height: i
    } = n.orig, s = n.trim;
    if (s) {
        const o = s.width,
            a = s.height;
        t.minX = s.x - e._x * r, t.maxX = t.minX + o, t.minY = s.y - e._y * i, t.maxY = t.minY + a
    } else t.minX = -e._x * r, t.maxX = t.minX + r, t.minY = -e._y * i, t.maxY = t.minY + i
}
const uT = new Te;
class rn {
    constructor(e = 1 / 0, n = 1 / 0, r = -1 / 0, i = -1 / 0) {
        this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = uT, this.minX = e, this.minY = n, this.maxX = r, this.maxY = i
    }
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY
    }
    get rectangle() {
        this._rectangle || (this._rectangle = new it);
        const e = this._rectangle;
        return this.minX > this.maxX || this.minY > this.maxY ? (e.x = 0, e.y = 0, e.width = 0, e.height = 0) : e.copyFromBounds(this), e
    }
    clear() {
        return this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.matrix = uT, this
    }
    set(e, n, r, i) {
        this.minX = e, this.minY = n, this.maxX = r, this.maxY = i
    }
    addFrame(e, n, r, i, s) {
        s || (s = this.matrix);
        const o = s.a,
            a = s.b,
            l = s.c,
            c = s.d,
            u = s.tx,
            d = s.ty;
        let f = this.minX,
            h = this.minY,
            p = this.maxX,
            b = this.maxY,
            y = o * e + l * n + u,
            m = a * e + c * n + d;
        y < f && (f = y), m < h && (h = m), y > p && (p = y), m > b && (b = m), y = o * r + l * n + u, m = a * r + c * n + d, y < f && (f = y), m < h && (h = m), y > p && (p = y), m > b && (b = m), y = o * e + l * i + u, m = a * e + c * i + d, y < f && (f = y), m < h && (h = m), y > p && (p = y), m > b && (b = m), y = o * r + l * i + u, m = a * r + c * i + d, y < f && (f = y), m < h && (h = m), y > p && (p = y), m > b && (b = m), this.minX = f, this.minY = h, this.maxX = p, this.maxY = b
    }
    addRect(e, n) {
        this.addFrame(e.x, e.y, e.x + e.width, e.y + e.height, n)
    }
    addBounds(e, n) {
        this.addFrame(e.minX, e.minY, e.maxX, e.maxY, n)
    }
    addBoundsMask(e) {
        this.minX = this.minX > e.minX ? this.minX : e.minX, this.minY = this.minY > e.minY ? this.minY : e.minY, this.maxX = this.maxX < e.maxX ? this.maxX : e.maxX, this.maxY = this.maxY < e.maxY ? this.maxY : e.maxY
    }
    applyMatrix(e) {
        const n = this.minX,
            r = this.minY,
            i = this.maxX,
            s = this.maxY,
            {
                a: o,
                b: a,
                c: l,
                d: c,
                tx: u,
                ty: d
            } = e;
        let f = o * n + l * r + u,
            h = a * n + c * r + d;
        this.minX = f, this.minY = h, this.maxX = f, this.maxY = h, f = o * i + l * r + u, h = a * i + c * r + d, this.minX = f < this.minX ? f : this.minX, this.minY = h < this.minY ? h : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = h > this.maxY ? h : this.maxY, f = o * n + l * s + u, h = a * n + c * s + d, this.minX = f < this.minX ? f : this.minX, this.minY = h < this.minY ? h : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = h > this.maxY ? h : this.maxY, f = o * i + l * s + u, h = a * i + c * s + d, this.minX = f < this.minX ? f : this.minX, this.minY = h < this.minY ? h : this.minY, this.maxX = f > this.maxX ? f : this.maxX, this.maxY = h > this.maxY ? h : this.maxY
    }
    fit(e) {
        return this.minX < e.left && (this.minX = e.left), this.maxX > e.right && (this.maxX = e.right), this.minY < e.top && (this.minY = e.top), this.maxY > e.bottom && (this.maxY = e.bottom), this
    }
    fitBounds(e, n, r, i) {
        return this.minX < e && (this.minX = e), this.maxX > n && (this.maxX = n), this.minY < r && (this.minY = r), this.maxY > i && (this.maxY = i), this
    }
    pad(e, n = e) {
        return this.minX -= e, this.maxX += e, this.minY -= n, this.maxY += n, this
    }
    ceil() {
        return this.minX = Math.floor(this.minX), this.minY = Math.floor(this.minY), this.maxX = Math.ceil(this.maxX), this.maxY = Math.ceil(this.maxY), this
    }
    clone() {
        return new rn(this.minX, this.minY, this.maxX, this.maxY)
    }
    scale(e, n = e) {
        return this.minX *= e, this.minY *= n, this.maxX *= e, this.maxY *= n, this
    }
    get x() {
        return this.minX
    }
    set x(e) {
        const n = this.maxX - this.minX;
        this.minX = e, this.maxX = e + n
    }
    get y() {
        return this.minY
    }
    set y(e) {
        const n = this.maxY - this.minY;
        this.minY = e, this.maxY = e + n
    }
    get width() {
        return this.maxX - this.minX
    }
    set width(e) {
        this.maxX = this.minX + e
    }
    get height() {
        return this.maxY - this.minY
    }
    set height(e) {
        this.maxY = this.minY + e
    }
    get left() {
        return this.minX
    }
    get right() {
        return this.maxX
    }
    get top() {
        return this.minY
    }
    get bottom() {
        return this.maxY
    }
    get isPositive() {
        return this.maxX - this.minX > 0 && this.maxY - this.minY > 0
    }
    get isValid() {
        return this.minX + this.minY !== 1 / 0
    }
    addVertexData(e, n, r, i) {
        let s = this.minX,
            o = this.minY,
            a = this.maxX,
            l = this.maxY;
        i || (i = this.matrix);
        const c = i.a,
            u = i.b,
            d = i.c,
            f = i.d,
            h = i.tx,
            p = i.ty;
        for (let b = n; b < r; b += 2) {
            const y = e[b],
                m = e[b + 1],
                g = c * y + d * m + h,
                v = u * y + f * m + p;
            s = g < s ? g : s, o = v < o ? v : o, a = g > a ? g : a, l = v > l ? v : l
        }
        this.minX = s, this.minY = o, this.maxX = a, this.maxY = l
    }
    containsPoint(e, n) {
        return this.minX <= e && this.minY <= n && this.maxX >= e && this.maxY >= n
    }
    toString() {
        return `[pixi.js:Bounds minX=${this.minX} minY=${this.minY} maxX=${this.maxX} maxY=${this.maxY} width=${this.width} height=${this.height}]`
    }
    copyFrom(e) {
        return this.minX = e.minX, this.minY = e.minY, this.maxX = e.maxX, this.maxY = e.maxY, this
    }
}
var Fre = {
        grad: .9,
        turn: 360,
        rad: 360 / (2 * Math.PI)
    },
    wi = function(t) {
        return typeof t == "string" ? t.length > 0 : typeof t == "number"
    },
    qt = function(t, e, n) {
        return e === void 0 && (e = 0), n === void 0 && (n = Math.pow(10, e)), Math.round(n * t) / n + 0
    },
    pr = function(t, e, n) {
        return e === void 0 && (e = 0), n === void 0 && (n = 1), t > n ? n : t > e ? t : e
    },
    eB = function(t) {
        return (t = isFinite(t) ? t % 360 : 0) > 0 ? t : t + 360
    },
    dT = function(t) {
        return {
            r: pr(t.r, 0, 255),
            g: pr(t.g, 0, 255),
            b: pr(t.b, 0, 255),
            a: pr(t.a)
        }
    },
    cg = function(t) {
        return {
            r: qt(t.r),
            g: qt(t.g),
            b: qt(t.b),
            a: qt(t.a, 3)
        }
    },
    Lre = /^#([0-9a-f]{3,8})$/i,
    af = function(t) {
        var e = t.toString(16);
        return e.length < 2 ? "0" + e : e
    },
    tB = function(t) {
        var e = t.r,
            n = t.g,
            r = t.b,
            i = t.a,
            s = Math.max(e, n, r),
            o = s - Math.min(e, n, r),
            a = o ? s === e ? (n - r) / o : s === n ? 2 + (r - e) / o : 4 + (e - n) / o : 0;
        return {
            h: 60 * (a < 0 ? a + 6 : a),
            s: s ? o / s * 100 : 0,
            v: s / 255 * 100,
            a: i
        }
    },
    nB = function(t) {
        var e = t.h,
            n = t.s,
            r = t.v,
            i = t.a;
        e = e / 360 * 6, n /= 100, r /= 100;
        var s = Math.floor(e),
            o = r * (1 - n),
            a = r * (1 - (e - s) * n),
            l = r * (1 - (1 - e + s) * n),
            c = s % 6;
        return {
            r: 255 * [r, a, o, o, l, r][c],
            g: 255 * [l, r, r, a, o, o][c],
            b: 255 * [o, o, l, r, r, a][c],
            a: i
        }
    },
    fT = function(t) {
        return {
            h: eB(t.h),
            s: pr(t.s, 0, 100),
            l: pr(t.l, 0, 100),
            a: pr(t.a)
        }
    },
    hT = function(t) {
        return {
            h: qt(t.h),
            s: qt(t.s),
            l: qt(t.l),
            a: qt(t.a, 3)
        }
    },
    pT = function(t) {
        return nB((n = (e = t).s, {
            h: e.h,
            s: (n *= ((r = e.l) < 50 ? r : 100 - r) / 100) > 0 ? 2 * n / (r + n) * 100 : 0,
            v: r + n,
            a: e.a
        }));
        var e, n, r
    },
    Wc = function(t) {
        return {
            h: (e = tB(t)).h,
            s: (i = (200 - (n = e.s)) * (r = e.v) / 100) > 0 && i < 200 ? n * r / 100 / (i <= 100 ? i : 200 - i) * 100 : 0,
            l: i / 2,
            a: e.a
        };
        var e, n, r, i
    },
    Nre = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    Ure = /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    Gre = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    Hre = /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    d0 = {
        string: [
            [function(t) {
                var e = Lre.exec(t);
                return e ? (t = e[1]).length <= 4 ? {
                    r: parseInt(t[0] + t[0], 16),
                    g: parseInt(t[1] + t[1], 16),
                    b: parseInt(t[2] + t[2], 16),
                    a: t.length === 4 ? qt(parseInt(t[3] + t[3], 16) / 255, 2) : 1
                } : t.length === 6 || t.length === 8 ? {
                    r: parseInt(t.substr(0, 2), 16),
                    g: parseInt(t.substr(2, 2), 16),
                    b: parseInt(t.substr(4, 2), 16),
                    a: t.length === 8 ? qt(parseInt(t.substr(6, 2), 16) / 255, 2) : 1
                } : null : null
            }, "hex"],
            [function(t) {
                var e = Gre.exec(t) || Hre.exec(t);
                return e ? e[2] !== e[4] || e[4] !== e[6] ? null : dT({
                    r: Number(e[1]) / (e[2] ? 100 / 255 : 1),
                    g: Number(e[3]) / (e[4] ? 100 / 255 : 1),
                    b: Number(e[5]) / (e[6] ? 100 / 255 : 1),
                    a: e[7] === void 0 ? 1 : Number(e[7]) / (e[8] ? 100 : 1)
                }) : null
            }, "rgb"],
            [function(t) {
                var e = Nre.exec(t) || Ure.exec(t);
                if (!e) return null;
                var n, r, i = fT({
                    h: (n = e[1], r = e[2], r === void 0 && (r = "deg"), Number(n) * (Fre[r] || 1)),
                    s: Number(e[3]),
                    l: Number(e[4]),
                    a: e[5] === void 0 ? 1 : Number(e[5]) / (e[6] ? 100 : 1)
                });
                return pT(i)
            }, "hsl"]
        ],
        object: [
            [function(t) {
                var e = t.r,
                    n = t.g,
                    r = t.b,
                    i = t.a,
                    s = i === void 0 ? 1 : i;
                return wi(e) && wi(n) && wi(r) ? dT({
                    r: Number(e),
                    g: Number(n),
                    b: Number(r),
                    a: Number(s)
                }) : null
            }, "rgb"],
            [function(t) {
                var e = t.h,
                    n = t.s,
                    r = t.l,
                    i = t.a,
                    s = i === void 0 ? 1 : i;
                if (!wi(e) || !wi(n) || !wi(r)) return null;
                var o = fT({
                    h: Number(e),
                    s: Number(n),
                    l: Number(r),
                    a: Number(s)
                });
                return pT(o)
            }, "hsl"],
            [function(t) {
                var e = t.h,
                    n = t.s,
                    r = t.v,
                    i = t.a,
                    s = i === void 0 ? 1 : i;
                if (!wi(e) || !wi(n) || !wi(r)) return null;
                var o = function(a) {
                    return {
                        h: eB(a.h),
                        s: pr(a.s, 0, 100),
                        v: pr(a.v, 0, 100),
                        a: pr(a.a)
                    }
                }({
                    h: Number(e),
                    s: Number(n),
                    v: Number(r),
                    a: Number(s)
                });
                return nB(o)
            }, "hsv"]
        ]
    },
    mT = function(t, e) {
        for (var n = 0; n < e.length; n++) {
            var r = e[n][0](t);
            if (r) return [r, e[n][1]]
        }
        return [null, void 0]
    },
    zre = function(t) {
        return typeof t == "string" ? mT(t.trim(), d0.string) : typeof t == "object" && t !== null ? mT(t, d0.object) : [null, void 0]
    },
    ug = function(t, e) {
        var n = Wc(t);
        return {
            h: n.h,
            s: pr(n.s + 100 * e, 0, 100),
            l: n.l,
            a: n.a
        }
    },
    dg = function(t) {
        return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3 / 255
    },
    gT = function(t, e) {
        var n = Wc(t);
        return {
            h: n.h,
            s: n.s,
            l: pr(n.l + 100 * e, 0, 100),
            a: n.a
        }
    },
    f0 = function() {
        function t(e) {
            this.parsed = zre(e)[0], this.rgba = this.parsed || {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            }
        }
        return t.prototype.isValid = function() {
            return this.parsed !== null
        }, t.prototype.brightness = function() {
            return qt(dg(this.rgba), 2)
        }, t.prototype.isDark = function() {
            return dg(this.rgba) < .5
        }, t.prototype.isLight = function() {
            return dg(this.rgba) >= .5
        }, t.prototype.toHex = function() {
            return e = cg(this.rgba), n = e.r, r = e.g, i = e.b, o = (s = e.a) < 1 ? af(qt(255 * s)) : "", "#" + af(n) + af(r) + af(i) + o;
            var e, n, r, i, s, o
        }, t.prototype.toRgb = function() {
            return cg(this.rgba)
        }, t.prototype.toRgbString = function() {
            return e = cg(this.rgba), n = e.r, r = e.g, i = e.b, (s = e.a) < 1 ? "rgba(" + n + ", " + r + ", " + i + ", " + s + ")" : "rgb(" + n + ", " + r + ", " + i + ")";
            var e, n, r, i, s
        }, t.prototype.toHsl = function() {
            return hT(Wc(this.rgba))
        }, t.prototype.toHslString = function() {
            return e = hT(Wc(this.rgba)), n = e.h, r = e.s, i = e.l, (s = e.a) < 1 ? "hsla(" + n + ", " + r + "%, " + i + "%, " + s + ")" : "hsl(" + n + ", " + r + "%, " + i + "%)";
            var e, n, r, i, s
        }, t.prototype.toHsv = function() {
            return e = tB(this.rgba), {
                h: qt(e.h),
                s: qt(e.s),
                v: qt(e.v),
                a: qt(e.a, 3)
            };
            var e
        }, t.prototype.invert = function() {
            return Wr({
                r: 255 - (e = this.rgba).r,
                g: 255 - e.g,
                b: 255 - e.b,
                a: e.a
            });
            var e
        }, t.prototype.saturate = function(e) {
            return e === void 0 && (e = .1), Wr(ug(this.rgba, e))
        }, t.prototype.desaturate = function(e) {
            return e === void 0 && (e = .1), Wr(ug(this.rgba, -e))
        }, t.prototype.grayscale = function() {
            return Wr(ug(this.rgba, -1))
        }, t.prototype.lighten = function(e) {
            return e === void 0 && (e = .1), Wr(gT(this.rgba, e))
        }, t.prototype.darken = function(e) {
            return e === void 0 && (e = .1), Wr(gT(this.rgba, -e))
        }, t.prototype.rotate = function(e) {
            return e === void 0 && (e = 15), this.hue(this.hue() + e)
        }, t.prototype.alpha = function(e) {
            return typeof e == "number" ? Wr({
                r: (n = this.rgba).r,
                g: n.g,
                b: n.b,
                a: e
            }) : qt(this.rgba.a, 3);
            var n
        }, t.prototype.hue = function(e) {
            var n = Wc(this.rgba);
            return typeof e == "number" ? Wr({
                h: e,
                s: n.s,
                l: n.l,
                a: n.a
            }) : qt(n.h)
        }, t.prototype.isEqual = function(e) {
            return this.toHex() === Wr(e).toHex()
        }, t
    }(),
    Wr = function(t) {
        return t instanceof f0 ? t : new f0(t)
    },
    yT = [],
    jre = function(t) {
        t.forEach(function(e) {
            yT.indexOf(e) < 0 && (e(f0, d0), yT.push(e))
        })
    };

function Vre(t, e) {
    var n = {
            white: "#ffffff",
            bisque: "#ffe4c4",
            blue: "#0000ff",
            cadetblue: "#5f9ea0",
            chartreuse: "#7fff00",
            chocolate: "#d2691e",
            coral: "#ff7f50",
            antiquewhite: "#faebd7",
            aqua: "#00ffff",
            azure: "#f0ffff",
            whitesmoke: "#f5f5f5",
            papayawhip: "#ffefd5",
            plum: "#dda0dd",
            blanchedalmond: "#ffebcd",
            black: "#000000",
            gold: "#ffd700",
            goldenrod: "#daa520",
            gainsboro: "#dcdcdc",
            cornsilk: "#fff8dc",
            cornflowerblue: "#6495ed",
            burlywood: "#deb887",
            aquamarine: "#7fffd4",
            beige: "#f5f5dc",
            crimson: "#dc143c",
            cyan: "#00ffff",
            darkblue: "#00008b",
            darkcyan: "#008b8b",
            darkgoldenrod: "#b8860b",
            darkkhaki: "#bdb76b",
            darkgray: "#a9a9a9",
            darkgreen: "#006400",
            darkgrey: "#a9a9a9",
            peachpuff: "#ffdab9",
            darkmagenta: "#8b008b",
            darkred: "#8b0000",
            darkorchid: "#9932cc",
            darkorange: "#ff8c00",
            darkslateblue: "#483d8b",
            gray: "#808080",
            darkslategray: "#2f4f4f",
            darkslategrey: "#2f4f4f",
            deeppink: "#ff1493",
            deepskyblue: "#00bfff",
            wheat: "#f5deb3",
            firebrick: "#b22222",
            floralwhite: "#fffaf0",
            ghostwhite: "#f8f8ff",
            darkviolet: "#9400d3",
            magenta: "#ff00ff",
            green: "#008000",
            dodgerblue: "#1e90ff",
            grey: "#808080",
            honeydew: "#f0fff0",
            hotpink: "#ff69b4",
            blueviolet: "#8a2be2",
            forestgreen: "#228b22",
            lawngreen: "#7cfc00",
            indianred: "#cd5c5c",
            indigo: "#4b0082",
            fuchsia: "#ff00ff",
            brown: "#a52a2a",
            maroon: "#800000",
            mediumblue: "#0000cd",
            lightcoral: "#f08080",
            darkturquoise: "#00ced1",
            lightcyan: "#e0ffff",
            ivory: "#fffff0",
            lightyellow: "#ffffe0",
            lightsalmon: "#ffa07a",
            lightseagreen: "#20b2aa",
            linen: "#faf0e6",
            mediumaquamarine: "#66cdaa",
            lemonchiffon: "#fffacd",
            lime: "#00ff00",
            khaki: "#f0e68c",
            mediumseagreen: "#3cb371",
            limegreen: "#32cd32",
            mediumspringgreen: "#00fa9a",
            lightskyblue: "#87cefa",
            lightblue: "#add8e6",
            midnightblue: "#191970",
            lightpink: "#ffb6c1",
            mistyrose: "#ffe4e1",
            moccasin: "#ffe4b5",
            mintcream: "#f5fffa",
            lightslategray: "#778899",
            lightslategrey: "#778899",
            navajowhite: "#ffdead",
            navy: "#000080",
            mediumvioletred: "#c71585",
            powderblue: "#b0e0e6",
            palegoldenrod: "#eee8aa",
            oldlace: "#fdf5e6",
            paleturquoise: "#afeeee",
            mediumturquoise: "#48d1cc",
            mediumorchid: "#ba55d3",
            rebeccapurple: "#663399",
            lightsteelblue: "#b0c4de",
            mediumslateblue: "#7b68ee",
            thistle: "#d8bfd8",
            tan: "#d2b48c",
            orchid: "#da70d6",
            mediumpurple: "#9370db",
            purple: "#800080",
            pink: "#ffc0cb",
            skyblue: "#87ceeb",
            springgreen: "#00ff7f",
            palegreen: "#98fb98",
            red: "#ff0000",
            yellow: "#ffff00",
            slateblue: "#6a5acd",
            lavenderblush: "#fff0f5",
            peru: "#cd853f",
            palevioletred: "#db7093",
            violet: "#ee82ee",
            teal: "#008080",
            slategray: "#708090",
            slategrey: "#708090",
            aliceblue: "#f0f8ff",
            darkseagreen: "#8fbc8f",
            darkolivegreen: "#556b2f",
            greenyellow: "#adff2f",
            seagreen: "#2e8b57",
            seashell: "#fff5ee",
            tomato: "#ff6347",
            silver: "#c0c0c0",
            sienna: "#a0522d",
            lavender: "#e6e6fa",
            lightgreen: "#90ee90",
            orange: "#ffa500",
            orangered: "#ff4500",
            steelblue: "#4682b4",
            royalblue: "#4169e1",
            turquoise: "#40e0d0",
            yellowgreen: "#9acd32",
            salmon: "#fa8072",
            saddlebrown: "#8b4513",
            sandybrown: "#f4a460",
            rosybrown: "#bc8f8f",
            darksalmon: "#e9967a",
            lightgoldenrodyellow: "#fafad2",
            snow: "#fffafa",
            lightgrey: "#d3d3d3",
            lightgray: "#d3d3d3",
            dimgray: "#696969",
            dimgrey: "#696969",
            olivedrab: "#6b8e23",
            olive: "#808000"
        },
        r = {};
    for (var i in n) r[n[i]] = i;
    var s = {};
    t.prototype.toName = function(o) {
        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b)) return "transparent";
        var a, l, c = r[this.toHex()];
        if (c) return c;
        if (o != null && o.closest) {
            var u = this.toRgb(),
                d = 1 / 0,
                f = "black";
            if (!s.length)
                for (var h in n) s[h] = new t(n[h]).toRgb();
            for (var p in n) {
                var b = (a = u, l = s[p], Math.pow(a.r - l.r, 2) + Math.pow(a.g - l.g, 2) + Math.pow(a.b - l.b, 2));
                b < d && (d = b, f = p)
            }
            return f
        }
    }, e.string.push([function(o) {
        var a = o.toLowerCase(),
            l = a === "transparent" ? "#0000" : n[a];
        return l ? new t(l).toRgb() : null
    }, "name"])
}
jre([Vre]);
const Sl = class Pc {
    constructor(e = 16777215) {
        this._value = null, this._components = new Float32Array(4), this._components.fill(1), this._int = 16777215, this.value = e
    }
    get red() {
        return this._components[0]
    }
    get green() {
        return this._components[1]
    }
    get blue() {
        return this._components[2]
    }
    get alpha() {
        return this._components[3]
    }
    setValue(e) {
        return this.value = e, this
    }
    set value(e) {
        if (e instanceof Pc) this._value = this._cloneSource(e._value), this._int = e._int, this._components.set(e._components);
        else {
            if (e === null) throw new Error("Cannot set Color#value to null");
            (this._value === null || !this._isSourceEqual(this._value, e)) && (this._value = this._cloneSource(e), this._normalize(this._value))
        }
    }
    get value() {
        return this._value
    }
    _cloneSource(e) {
        return typeof e == "string" || typeof e == "number" || e instanceof Number || e === null ? e : Array.isArray(e) || ArrayBuffer.isView(e) ? e.slice(0) : typeof e == "object" && e !== null ? { ...e
        } : e
    }
    _isSourceEqual(e, n) {
        const r = typeof e;
        if (r !== typeof n) return !1;
        if (r === "number" || r === "string" || e instanceof Number) return e === n;
        if (Array.isArray(e) && Array.isArray(n) || ArrayBuffer.isView(e) && ArrayBuffer.isView(n)) return e.length !== n.length ? !1 : e.every((s, o) => s === n[o]);
        if (e !== null && n !== null) {
            const s = Object.keys(e),
                o = Object.keys(n);
            return s.length !== o.length ? !1 : s.every(a => e[a] === n[a])
        }
        return e === n
    }
    toRgba() {
        const [e, n, r, i] = this._components;
        return {
            r: e,
            g: n,
            b: r,
            a: i
        }
    }
    toRgb() {
        const [e, n, r] = this._components;
        return {
            r: e,
            g: n,
            b: r
        }
    }
    toRgbaString() {
        const [e, n, r] = this.toUint8RgbArray();
        return `rgba(${e},${n},${r},${this.alpha})`
    }
    toUint8RgbArray(e) {
        const [n, r, i] = this._components;
        return this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb), e[0] = Math.round(n * 255), e[1] = Math.round(r * 255), e[2] = Math.round(i * 255), e
    }
    toArray(e) {
        this._arrayRgba || (this._arrayRgba = []), e || (e = this._arrayRgba);
        const [n, r, i, s] = this._components;
        return e[0] = n, e[1] = r, e[2] = i, e[3] = s, e
    }
    toRgbArray(e) {
        this._arrayRgb || (this._arrayRgb = []), e || (e = this._arrayRgb);
        const [n, r, i] = this._components;
        return e[0] = n, e[1] = r, e[2] = i, e
    }
    toNumber() {
        return this._int
    }
    toBgrNumber() {
        const [e, n, r] = this.toUint8RgbArray();
        return (r << 16) + (n << 8) + e
    }
    toLittleEndianNumber() {
        const e = this._int;
        return (e >> 16) + (e & 65280) + ((e & 255) << 16)
    }
    multiply(e) {
        const [n, r, i, s] = Pc._temp.setValue(e)._components;
        return this._components[0] *= n, this._components[1] *= r, this._components[2] *= i, this._components[3] *= s, this._refreshInt(), this._value = null, this
    }
    premultiply(e, n = !0) {
        return n && (this._components[0] *= e, this._components[1] *= e, this._components[2] *= e), this._components[3] = e, this._refreshInt(), this._value = null, this
    }
    toPremultiplied(e, n = !0) {
        if (e === 1) return (255 << 24) + this._int;
        if (e === 0) return n ? 0 : this._int;
        let r = this._int >> 16 & 255,
            i = this._int >> 8 & 255,
            s = this._int & 255;
        return n && (r = r * e + .5 | 0, i = i * e + .5 | 0, s = s * e + .5 | 0), (e * 255 << 24) + (r << 16) + (i << 8) + s
    }
    toHex() {
        const e = this._int.toString(16);
        return `#${"000000".substring(0,6-e.length)+e}`
    }
    toHexa() {
        const n = Math.round(this._components[3] * 255).toString(16);
        return this.toHex() + "00".substring(0, 2 - n.length) + n
    }
    setAlpha(e) {
        return this._components[3] = this._clamp(e), this
    }
    _normalize(e) {
        let n, r, i, s;
        if ((typeof e == "number" || e instanceof Number) && e >= 0 && e <= 16777215) {
            const o = e;
            n = (o >> 16 & 255) / 255, r = (o >> 8 & 255) / 255, i = (o & 255) / 255, s = 1
        } else if ((Array.isArray(e) || e instanceof Float32Array) && e.length >= 3 && e.length <= 4) e = this._clamp(e), [n, r, i, s = 1] = e;
        else if ((e instanceof Uint8Array || e instanceof Uint8ClampedArray) && e.length >= 3 && e.length <= 4) e = this._clamp(e, 0, 255), [n, r, i, s = 255] = e, n /= 255, r /= 255, i /= 255, s /= 255;
        else if (typeof e == "string" || typeof e == "object") {
            if (typeof e == "string") {
                const a = Pc.HEX_PATTERN.exec(e);
                a && (e = `#${a[2]}`)
            }
            const o = Wr(e);
            o.isValid() && ({
                r: n,
                g: r,
                b: i,
                a: s
            } = o.rgba, n /= 255, r /= 255, i /= 255)
        }
        if (n !== void 0) this._components[0] = n, this._components[1] = r, this._components[2] = i, this._components[3] = s, this._refreshInt();
        else throw new Error(`Unable to convert color ${e}`)
    }
    _refreshInt() {
        this._clamp(this._components);
        const [e, n, r] = this._components;
        this._int = (e * 255 << 16) + (n * 255 << 8) + (r * 255 | 0)
    }
    _clamp(e, n = 0, r = 1) {
        return typeof e == "number" ? Math.min(Math.max(e, n), r) : (e.forEach((i, s) => {
            e[s] = Math.min(Math.max(i, n), r)
        }), e)
    }
    static isColorLike(e) {
        return typeof e == "number" || typeof e == "string" || e instanceof Number || e instanceof Pc || Array.isArray(e) || e instanceof Uint8Array || e instanceof Uint8ClampedArray || e instanceof Float32Array || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 || e.r !== void 0 && e.g !== void 0 && e.b !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 || e.h !== void 0 && e.s !== void 0 && e.l !== void 0 && e.a !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 || e.h !== void 0 && e.s !== void 0 && e.v !== void 0 && e.a !== void 0
    }
};
Sl.shared = new Sl;
Sl._temp = new Sl;
Sl.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i;
let tt = Sl;
const Wre = {
    cullArea: null,
    cullable: !1,
    cullableChildren: !0
};
let fg = 0;
const vT = 500;

function Oe(...t) {
    fg !== vT && (fg++, fg === vT ? console.warn("PixiJS Warning: too many warnings, no more warnings will be reported to the console by PixiJS.") : console.warn("PixiJS Warning: ", ...t))
}
class gx {
    constructor(e, n) {
        this._pool = [], this._count = 0, this._index = 0, this._classType = e, n && this.prepopulate(n)
    }
    prepopulate(e) {
        for (let n = 0; n < e; n++) this._pool[this._index++] = new this._classType;
        this._count += e
    }
    get(e) {
        var r;
        let n;
        return this._index > 0 ? n = this._pool[--this._index] : n = new this._classType, (r = n.init) == null || r.call(n, e), n
    }
    return (e) {
        var n;
        (n = e.reset) == null || n.call(e), this._pool[this._index++] = e
    }
    get totalSize() {
        return this._count
    }
    get totalFree() {
        return this._index
    }
    get totalUsed() {
        return this._count - this._index
    }
    clear() {
        this._pool.length = 0, this._index = 0
    }
}
class Yre {
    constructor() {
        this._poolsByClass = new Map
    }
    prepopulate(e, n) {
        this.getPool(e).prepopulate(n)
    }
    get(e, n) {
        return this.getPool(e).get(n)
    }
    return (e) {
        this.getPool(e.constructor).return(e)
    }
    getPool(e) {
        return this._poolsByClass.has(e) || this._poolsByClass.set(e, new gx(e)), this._poolsByClass.get(e)
    }
    stats() {
        const e = {};
        return this._poolsByClass.forEach(n => {
            const r = e[n._classType.name] ? n._classType.name + n._classType.ID : n._classType.name;
            e[r] = {
                free: n.totalFree,
                used: n.totalUsed,
                size: n.totalSize
            }
        }), e
    }
}
const nn = new Yre,
    Xre = {
        get isCachedAsTexture() {
            var t;
            return !!((t = this.renderGroup) != null && t.isCachedAsTexture)
        },
        cacheAsTexture(t) {
            typeof t == "boolean" && t === !1 ? this.disableRenderGroup() : (this.enableRenderGroup(), this.renderGroup.enableCacheAsTexture(t === !0 ? {} : t))
        },
        updateCacheTexture() {
            var t;
            (t = this.renderGroup) == null || t.updateCacheTexture()
        },
        get cacheAsBitmap() {
            return this.isCachedAsTexture
        },
        set cacheAsBitmap(t) {
            Ie("v8.6.0", "cacheAsBitmap is deprecated, use cacheAsTexture instead."), this.cacheAsTexture(t)
        }
    };

function rB(t, e, n) {
    const r = t.length;
    let i;
    if (e >= r || n === 0) return;
    n = e + n > r ? r - e : n;
    const s = r - n;
    for (i = e; i < s; ++i) t[i] = t[i + n];
    t.length = s
}
const qre = {
        allowChildren: !0,
        removeChildren(t = 0, e) {
            var s;
            const n = e ? ? this.children.length,
                r = n - t,
                i = [];
            if (r > 0 && r <= n) {
                for (let a = n - 1; a >= t; a--) {
                    const l = this.children[a];
                    l && (i.push(l), l.parent = null)
                }
                rB(this.children, t, n);
                const o = this.renderGroup || this.parentRenderGroup;
                o && o.removeChildren(i);
                for (let a = 0; a < i.length; ++a) {
                    const l = i[a];
                    (s = l.parentRenderLayer) == null || s.detach(l), this.emit("childRemoved", l, this, a), i[a].emit("removed", this)
                }
                return i.length > 0 && this._didViewChangeTick++, i
            } else if (r === 0 && this.children.length === 0) return i;
            throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
        },
        removeChildAt(t) {
            const e = this.getChildAt(t);
            return this.removeChild(e)
        },
        getChildAt(t) {
            if (t < 0 || t >= this.children.length) throw new Error(`getChildAt: Index (${t}) does not exist.`);
            return this.children[t]
        },
        setChildIndex(t, e) {
            if (e < 0 || e >= this.children.length) throw new Error(`The index ${e} supplied is out of bounds ${this.children.length}`);
            this.getChildIndex(t), this.addChildAt(t, e)
        },
        getChildIndex(t) {
            const e = this.children.indexOf(t);
            if (e === -1) throw new Error("The supplied Container must be a child of the caller");
            return e
        },
        addChildAt(t, e) {
            this.allowChildren || Ie(Ye, "addChildAt: Only Containers will be allowed to add children in v8.0.0");
            const {
                children: n
            } = this;
            if (e < 0 || e > n.length) throw new Error(`${t}addChildAt: The index ${e} supplied is out of bounds ${n.length}`);
            if (t.parent) {
                const i = t.parent.children.indexOf(t);
                if (t.parent === this && i === e) return t;
                i !== -1 && t.parent.children.splice(i, 1)
            }
            e === n.length ? n.push(t) : n.splice(e, 0, t), t.parent = this, t.didChange = !0, t._updateFlags = 15;
            const r = this.renderGroup || this.parentRenderGroup;
            return r && r.addChild(t), this.sortableChildren && (this.sortDirty = !0), this.emit("childAdded", t, this, e), t.emit("added", this), t
        },
        swapChildren(t, e) {
            if (t === e) return;
            const n = this.getChildIndex(t),
                r = this.getChildIndex(e);
            this.children[n] = e, this.children[r] = t;
            const i = this.renderGroup || this.parentRenderGroup;
            i && (i.structureDidChange = !0), this._didContainerChangeTick++
        },
        removeFromParent() {
            var t;
            (t = this.parent) == null || t.removeChild(this)
        },
        reparentChild(...t) {
            return t.length === 1 ? this.reparentChildAt(t[0], this.children.length) : (t.forEach(e => this.reparentChildAt(e, this.children.length)), t[0])
        },
        reparentChildAt(t, e) {
            if (t.parent === this) return this.setChildIndex(t, e), t;
            const n = t.worldTransform.clone();
            t.removeFromParent(), this.addChildAt(t, e);
            const r = this.worldTransform.clone();
            return r.invert(), n.prepend(r), t.setFromMatrix(n), t
        },
        replaceChild(t, e) {
            t.updateLocalTransform(), this.addChildAt(e, this.getChildIndex(t)), e.setFromMatrix(t.localTransform), e.updateLocalTransform(), this.removeChild(t)
        }
    },
    Kre = {
        collectRenderables(t, e, n) {
            this.parentRenderLayer && this.parentRenderLayer !== n || this.globalDisplayStatus < 7 || !this.includeInBuild || (this.sortableChildren && this.sortChildren(), this.isSimple ? this.collectRenderablesSimple(t, e, n) : this.renderGroup ? e.renderPipes.renderGroup.addRenderGroup(this.renderGroup, t) : this.collectRenderablesWithEffects(t, e, n))
        },
        collectRenderablesSimple(t, e, n) {
            const r = this.children,
                i = r.length;
            for (let s = 0; s < i; s++) r[s].collectRenderables(t, e, n)
        },
        collectRenderablesWithEffects(t, e, n) {
            const {
                renderPipes: r
            } = e;
            for (let i = 0; i < this.effects.length; i++) {
                const s = this.effects[i];
                r[s.pipe].push(s, this, t)
            }
            this.collectRenderablesSimple(t, e, n);
            for (let i = this.effects.length - 1; i >= 0; i--) {
                const s = this.effects[i];
                r[s.pipe].pop(s, this, t)
            }
        }
    };
class Ph {
    constructor() {
        this.pipe = "filter", this.priority = 1
    }
    destroy() {
        for (let e = 0; e < this.filters.length; e++) this.filters[e].destroy();
        this.filters = null, this.filterArea = null
    }
}
class Jre {
    constructor() {
        this._effectClasses = [], this._tests = [], this._initialized = !1
    }
    init() {
        this._initialized || (this._initialized = !0, this._effectClasses.forEach(e => {
            this.add({
                test: e.test,
                maskClass: e
            })
        }))
    }
    add(e) {
        this._tests.push(e)
    }
    getMaskEffect(e) {
        this._initialized || this.init();
        for (let n = 0; n < this._tests.length; n++) {
            const r = this._tests[n];
            if (r.test(e)) return nn.get(r.maskClass, e)
        }
        return e
    }
    returnMaskEffect(e) {
        nn.return(e)
    }
}
const h0 = new Jre;
Re.handleByList(G.MaskEffect, h0._effectClasses);
const Zre = {
        _maskEffect: null,
        _maskOptions: {
            inverse: !1
        },
        _filterEffect: null,
        effects: [],
        _markStructureAsChanged() {
            const t = this.renderGroup || this.parentRenderGroup;
            t && (t.structureDidChange = !0)
        },
        addEffect(t) {
            this.effects.indexOf(t) === -1 && (this.effects.push(t), this.effects.sort((n, r) => n.priority - r.priority), this._markStructureAsChanged(), this._updateIsSimple())
        },
        removeEffect(t) {
            const e = this.effects.indexOf(t);
            e !== -1 && (this.effects.splice(e, 1), this._markStructureAsChanged(), this._updateIsSimple())
        },
        set mask(t) {
            const e = this._maskEffect;
            (e == null ? void 0 : e.mask) !== t && (e && (this.removeEffect(e), h0.returnMaskEffect(e), this._maskEffect = null), t != null && (this._maskEffect = h0.getMaskEffect(t), this.addEffect(this._maskEffect)))
        },
        get mask() {
            var t;
            return (t = this._maskEffect) == null ? void 0 : t.mask
        },
        setMask(t) {
            this._maskOptions = { ...this._maskOptions,
                ...t
            }, t.mask && (this.mask = t.mask), this._markStructureAsChanged()
        },
        set filters(t) {
            var s;
            !Array.isArray(t) && t && (t = [t]);
            const e = this._filterEffect || (this._filterEffect = new Ph);
            t = t;
            const n = (t == null ? void 0 : t.length) > 0,
                r = ((s = e.filters) == null ? void 0 : s.length) > 0,
                i = n !== r;
            t = Array.isArray(t) ? t.slice(0) : t, e.filters = Object.freeze(t), i && (n ? this.addEffect(e) : (this.removeEffect(e), e.filters = t ? ? null))
        },
        get filters() {
            var t;
            return (t = this._filterEffect) == null ? void 0 : t.filters
        },
        set filterArea(t) {
            this._filterEffect || (this._filterEffect = new Ph), this._filterEffect.filterArea = t
        },
        get filterArea() {
            var t;
            return (t = this._filterEffect) == null ? void 0 : t.filterArea
        }
    },
    Qre = {
        label: null,
        get name() {
            return Ie(Ye, "Container.name property has been removed, use Container.label instead"), this.label
        },
        set name(t) {
            Ie(Ye, "Container.name property has been removed, use Container.label instead"), this.label = t
        },
        getChildByName(t, e = !1) {
            return this.getChildByLabel(t, e)
        },
        getChildByLabel(t, e = !1) {
            const n = this.children;
            for (let r = 0; r < n.length; r++) {
                const i = n[r];
                if (i.label === t || t instanceof RegExp && t.test(i.label)) return i
            }
            if (e)
                for (let r = 0; r < n.length; r++) {
                    const s = n[r].getChildByLabel(t, !0);
                    if (s) return s
                }
            return null
        },
        getChildrenByLabel(t, e = !1, n = []) {
            const r = this.children;
            for (let i = 0; i < r.length; i++) {
                const s = r[i];
                (s.label === t || t instanceof RegExp && t.test(s.label)) && n.push(s)
            }
            if (e)
                for (let i = 0; i < r.length; i++) r[i].getChildrenByLabel(t, !0, n);
            return n
        }
    },
    wn = new gx(Te),
    Ui = new gx(rn),
    eie = new Te,
    tie = {
        getFastGlobalBounds(t, e) {
            e || (e = new rn), e.clear(), this._getGlobalBoundsRecursive(!!t, e, this.parentRenderLayer), e.isValid || e.set(0, 0, 0, 0);
            const n = this.renderGroup || this.parentRenderGroup;
            return e.applyMatrix(n.worldTransform), e
        },
        _getGlobalBoundsRecursive(t, e, n) {
            let r = e;
            if (t && this.parentRenderLayer && this.parentRenderLayer !== n || this.localDisplayStatus !== 7 || !this.measurable) return;
            const i = !!this.effects.length;
            if ((this.renderGroup || i) && (r = Ui.get().clear()), this.boundsArea) e.addRect(this.boundsArea, this.worldTransform);
            else {
                if (this.renderPipeId) {
                    const o = this.bounds;
                    r.addFrame(o.minX, o.minY, o.maxX, o.maxY, this.groupTransform)
                }
                const s = this.children;
                for (let o = 0; o < s.length; o++) s[o]._getGlobalBoundsRecursive(t, r, n)
            }
            if (i) {
                let s = !1;
                const o = this.renderGroup || this.parentRenderGroup;
                for (let a = 0; a < this.effects.length; a++) this.effects[a].addBounds && (s || (s = !0, r.applyMatrix(o.worldTransform)), this.effects[a].addBounds(r, !0));
                s && (r.applyMatrix(o.worldTransform.copyTo(eie).invert()), e.addBounds(r, this.relativeGroupTransform)), e.addBounds(r), Ui.return(r)
            } else this.renderGroup && (e.addBounds(r, this.relativeGroupTransform), Ui.return(r))
        }
    };

function yx(t, e, n) {
    n.clear();
    let r, i;
    return t.parent ? e ? r = t.parent.worldTransform : (i = wn.get().identity(), r = vx(t, i)) : r = Te.IDENTITY, iB(t, n, r, e), i && wn.return(i), n.isValid || n.set(0, 0, 0, 0), n
}

function iB(t, e, n, r) {
    var a, l;
    if (!t.visible || !t.measurable) return;
    let i;
    r ? i = t.worldTransform : (t.updateLocalTransform(), i = wn.get(), i.appendFrom(t.localTransform, n));
    const s = e,
        o = !!t.effects.length;
    if (o && (e = Ui.get().clear()), t.boundsArea) e.addRect(t.boundsArea, i);
    else {
        t.bounds && (e.matrix = i, e.addBounds(t.bounds));
        for (let c = 0; c < t.children.length; c++) iB(t.children[c], e, i, r)
    }
    if (o) {
        for (let c = 0; c < t.effects.length; c++)(l = (a = t.effects[c]).addBounds) == null || l.call(a, e);
        s.addBounds(e, Te.IDENTITY), Ui.return(e)
    }
    r || wn.return(i)
}

function vx(t, e) {
    const n = t.parent;
    return n && (vx(n, e), n.updateLocalTransform(), e.append(n.localTransform)), e
}

function sB(t, e) {
    if (t === 16777215 || !e) return e;
    if (e === 16777215 || !t) return t;
    const n = t >> 16 & 255,
        r = t >> 8 & 255,
        i = t & 255,
        s = e >> 16 & 255,
        o = e >> 8 & 255,
        a = e & 255,
        l = n * s / 255 | 0,
        c = r * o / 255 | 0,
        u = i * a / 255 | 0;
    return (l << 16) + (c << 8) + u
}
const _T = 16777215;

function Ah(t, e) {
    return t === _T ? e : e === _T ? t : sB(t, e)
}

function Yc(t) {
    return ((t & 255) << 16) + (t & 65280) + (t >> 16 & 255)
}
const nie = {
    getGlobalAlpha(t) {
        if (t) return this.renderGroup ? this.renderGroup.worldAlpha : this.parentRenderGroup ? this.parentRenderGroup.worldAlpha * this.alpha : this.alpha;
        let e = this.alpha,
            n = this.parent;
        for (; n;) e *= n.alpha, n = n.parent;
        return e
    },
    getGlobalTransform(t, e) {
        if (e) return t.copyFrom(this.worldTransform);
        this.updateLocalTransform();
        const n = vx(this, wn.get().identity());
        return t.appendFrom(this.localTransform, n), wn.return(n), t
    },
    getGlobalTint(t) {
        if (t) return this.renderGroup ? Yc(this.renderGroup.worldColor) : this.parentRenderGroup ? Yc(Ah(this.localColor, this.parentRenderGroup.worldColor)) : this.tint;
        let e = this.localColor,
            n = this.parent;
        for (; n;) e = Ah(e, n.localColor), n = n.parent;
        return Yc(e)
    }
};

function _x(t, e, n) {
    return e.clear(), n || (n = Te.IDENTITY), oB(t, e, n, t, !0), e.isValid || e.set(0, 0, 0, 0), e
}

function oB(t, e, n, r, i) {
    var l, c;
    let s;
    if (i) s = wn.get(), s = n.copyTo(s);
    else {
        if (!t.visible || !t.measurable) return;
        t.updateLocalTransform();
        const u = t.localTransform;
        s = wn.get(), s.appendFrom(u, n)
    }
    const o = e,
        a = !!t.effects.length;
    if (a && (e = Ui.get().clear()), t.boundsArea) e.addRect(t.boundsArea, s);
    else {
        t.renderPipeId && (e.matrix = s, e.addBounds(t.bounds));
        const u = t.children;
        for (let d = 0; d < u.length; d++) oB(u[d], e, s, r, !1)
    }
    if (a) {
        for (let u = 0; u < t.effects.length; u++)(c = (l = t.effects[u]).addLocalBounds) == null || c.call(l, e, r);
        o.addBounds(e, Te.IDENTITY), Ui.return(e)
    }
    wn.return(s)
}

function aB(t, e) {
    const n = t.children;
    for (let r = 0; r < n.length; r++) {
        const i = n[r],
            s = i.uid,
            o = (i._didViewChangeTick & 65535) << 16 | i._didContainerChangeTick & 65535,
            a = e.index;
        (e.data[a] !== s || e.data[a + 1] !== o) && (e.data[e.index] = s, e.data[e.index + 1] = o, e.didChange = !0), e.index = a + 2, i.children.length && aB(i, e)
    }
    return e.didChange
}
const rie = new Te,
    iie = {
        _localBoundsCacheId: -1,
        _localBoundsCacheData: null,
        _setWidth(t, e) {
            const n = Math.sign(this.scale.x) || 1;
            e !== 0 ? this.scale.x = t / e * n : this.scale.x = n
        },
        _setHeight(t, e) {
            const n = Math.sign(this.scale.y) || 1;
            e !== 0 ? this.scale.y = t / e * n : this.scale.y = n
        },
        getLocalBounds() {
            this._localBoundsCacheData || (this._localBoundsCacheData = {
                data: [],
                index: 1,
                didChange: !1,
                localBounds: new rn
            });
            const t = this._localBoundsCacheData;
            return t.index = 1, t.didChange = !1, t.data[0] !== this._didViewChangeTick && (t.didChange = !0, t.data[0] = this._didViewChangeTick), aB(this, t), t.didChange && _x(this, t.localBounds, rie), t.localBounds
        },
        getBounds(t, e) {
            return yx(this, t, e || new rn)
        }
    },
    sie = {
        _onRender: null,
        set onRender(t) {
            const e = this.renderGroup || this.parentRenderGroup;
            if (!t) {
                this._onRender && (e == null || e.removeOnRender(this)), this._onRender = null;
                return
            }
            this._onRender || e == null || e.addOnRender(this), this._onRender = t
        },
        get onRender() {
            return this._onRender
        }
    },
    oie = {
        _zIndex: 0,
        sortDirty: !1,
        sortableChildren: !1,
        get zIndex() {
            return this._zIndex
        },
        set zIndex(t) {
            this._zIndex !== t && (this._zIndex = t, this.depthOfChildModified())
        },
        depthOfChildModified() {
            this.parent && (this.parent.sortableChildren = !0, this.parent.sortDirty = !0), this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0)
        },
        sortChildren() {
            this.sortDirty && (this.sortDirty = !1, this.children.sort(aie))
        }
    };

function aie(t, e) {
    return t._zIndex - e._zIndex
}
const lie = {
    getGlobalPosition(t = new dt, e = !1) {
        return this.parent ? this.parent.toGlobal(this._position, t, e) : (t.x = this._position.x, t.y = this._position.y), t
    },
    toGlobal(t, e, n = !1) {
        const r = this.getGlobalTransform(wn.get(), n);
        return e = r.apply(t, e), wn.return(r), e
    },
    toLocal(t, e, n, r) {
        e && (t = e.toGlobal(t, n, r));
        const i = this.getGlobalTransform(wn.get(), r);
        return n = i.applyInverse(t, n), wn.return(i), n
    }
};
class lB {
    constructor() {
        this.uid = vt("instructionSet"), this.instructions = [], this.instructionSize = 0, this.renderables = [], this.gcTick = 0
    }
    reset() {
        this.instructionSize = 0
    }
    add(e) {
        this.instructions[this.instructionSize++] = e
    }
    log() {
        this.instructions.length = this.instructionSize, console.table(this.instructions, ["type", "action"])
    }
}
let cie = 0;
class uie {
    constructor(e) {
        this._poolKeyHash = Object.create(null), this._texturePool = {}, this.textureOptions = e || {}, this.enableFullScreen = !1, this.textureStyle = new Zi(this.textureOptions)
    }
    createTexture(e, n, r) {
        const i = new Wt({ ...this.textureOptions,
            width: e,
            height: n,
            resolution: 1,
            antialias: r,
            autoGarbageCollect: !1
        });
        return new we({
            source: i,
            label: `texturePool_${cie++}`
        })
    }
    getOptimalTexture(e, n, r = 1, i) {
        let s = Math.ceil(e * r - 1e-6),
            o = Math.ceil(n * r - 1e-6);
        s = El(s), o = El(o);
        const a = (s << 17) + (o << 1) + (i ? 1 : 0);
        this._texturePool[a] || (this._texturePool[a] = []);
        let l = this._texturePool[a].pop();
        return l || (l = this.createTexture(s, o, i)), l.source._resolution = r, l.source.width = s / r, l.source.height = o / r, l.source.pixelWidth = s, l.source.pixelHeight = o, l.frame.x = 0, l.frame.y = 0, l.frame.width = e, l.frame.height = n, l.updateUvs(), this._poolKeyHash[l.uid] = a, l
    }
    getSameSizeTexture(e, n = !1) {
        const r = e.source;
        return this.getOptimalTexture(e.width, e.height, r._resolution, n)
    }
    returnTexture(e, n = !1) {
        const r = this._poolKeyHash[e.uid];
        n && (e.source.style = this.textureStyle), this._texturePool[r].push(e)
    }
    clear(e) {
        if (e = e !== !1, e)
            for (const n in this._texturePool) {
                const r = this._texturePool[n];
                if (r)
                    for (let i = 0; i < r.length; i++) r[i].destroy(!0)
            }
        this._texturePool = {}
    }
}
const Ft = new uie;
class die {
    constructor() {
        this.renderPipeId = "renderGroup", this.root = null, this.canBundle = !1, this.renderGroupParent = null, this.renderGroupChildren = [], this.worldTransform = new Te, this.worldColorAlpha = 4294967295, this.worldColor = 16777215, this.worldAlpha = 1, this.childrenToUpdate = Object.create(null), this.updateTick = 0, this.gcTick = 0, this.childrenRenderablesToUpdate = {
            list: [],
            index: 0
        }, this.structureDidChange = !0, this.instructionSet = new lB, this._onRenderContainers = [], this.textureNeedsUpdate = !0, this.isCachedAsTexture = !1, this._matrixDirty = 7
    }
    init(e) {
        this.root = e, e._onRender && this.addOnRender(e), e.didChange = !0;
        const n = e.children;
        for (let r = 0; r < n.length; r++) {
            const i = n[r];
            i._updateFlags = 15, this.addChild(i)
        }
    }
    enableCacheAsTexture(e = {}) {
        this.textureOptions = e, this.isCachedAsTexture = !0, this.textureNeedsUpdate = !0
    }
    disableCacheAsTexture() {
        this.isCachedAsTexture = !1, this.texture && (Ft.returnTexture(this.texture), this.texture = null)
    }
    updateCacheTexture() {
        this.textureNeedsUpdate = !0
    }
    reset() {
        this.renderGroupChildren.length = 0;
        for (const e in this.childrenToUpdate) {
            const n = this.childrenToUpdate[e];
            n.list.fill(null), n.index = 0
        }
        this.childrenRenderablesToUpdate.index = 0, this.childrenRenderablesToUpdate.list.fill(null), this.root = null, this.updateTick = 0, this.structureDidChange = !0, this._onRenderContainers.length = 0, this.renderGroupParent = null, this.disableCacheAsTexture()
    }
    get localTransform() {
        return this.root.localTransform
    }
    addRenderGroupChild(e) {
        e.renderGroupParent && e.renderGroupParent._removeRenderGroupChild(e), e.renderGroupParent = this, this.renderGroupChildren.push(e)
    }
    _removeRenderGroupChild(e) {
        const n = this.renderGroupChildren.indexOf(e);
        n > -1 && this.renderGroupChildren.splice(n, 1), e.renderGroupParent = null
    }
    addChild(e) {
        if (this.structureDidChange = !0, e.parentRenderGroup = this, e.updateTick = -1, e.parent === this.root ? e.relativeRenderGroupDepth = 1 : e.relativeRenderGroupDepth = e.parent.relativeRenderGroupDepth + 1, e.didChange = !0, this.onChildUpdate(e), e.renderGroup) {
            this.addRenderGroupChild(e.renderGroup);
            return
        }
        e._onRender && this.addOnRender(e);
        const n = e.children;
        for (let r = 0; r < n.length; r++) this.addChild(n[r])
    }
    removeChild(e) {
        if (this.structureDidChange = !0, e._onRender && (e.renderGroup || this.removeOnRender(e)), e.parentRenderGroup = null, e.renderGroup) {
            this._removeRenderGroupChild(e.renderGroup);
            return
        }
        const n = e.children;
        for (let r = 0; r < n.length; r++) this.removeChild(n[r])
    }
    removeChildren(e) {
        for (let n = 0; n < e.length; n++) this.removeChild(e[n])
    }
    onChildUpdate(e) {
        let n = this.childrenToUpdate[e.relativeRenderGroupDepth];
        n || (n = this.childrenToUpdate[e.relativeRenderGroupDepth] = {
            index: 0,
            list: []
        }), n.list[n.index++] = e
    }
    updateRenderable(e) {
        e.globalDisplayStatus < 7 || (this.instructionSet.renderPipes[e.renderPipeId].updateRenderable(e), e.didViewUpdate = !1)
    }
    onChildViewUpdate(e) {
        this.childrenRenderablesToUpdate.list[this.childrenRenderablesToUpdate.index++] = e
    }
    get isRenderable() {
        return this.root.localDisplayStatus === 7 && this.worldAlpha > 0
    }
    addOnRender(e) {
        this._onRenderContainers.push(e)
    }
    removeOnRender(e) {
        this._onRenderContainers.splice(this._onRenderContainers.indexOf(e), 1)
    }
    runOnRender(e) {
        for (let n = 0; n < this._onRenderContainers.length; n++) this._onRenderContainers[n]._onRender(e)
    }
    destroy() {
        this.disableCacheAsTexture(), this.renderGroupParent = null, this.root = null, this.childrenRenderablesToUpdate = null, this.childrenToUpdate = null, this.renderGroupChildren = null, this._onRenderContainers = null, this.instructionSet = null
    }
    getChildren(e = []) {
        const n = this.root.children;
        for (let r = 0; r < n.length; r++) this._getChildren(n[r], e);
        return e
    }
    _getChildren(e, n = []) {
        if (n.push(e), e.renderGroup) return n;
        const r = e.children;
        for (let i = 0; i < r.length; i++) this._getChildren(r[i], n);
        return n
    }
    invalidateMatrices() {
        this._matrixDirty = 7
    }
    get inverseWorldTransform() {
        return this._matrixDirty & 1 ? (this._matrixDirty &= -2, this._inverseWorldTransform || (this._inverseWorldTransform = new Te), this._inverseWorldTransform.copyFrom(this.worldTransform).invert()) : this._inverseWorldTransform
    }
    get textureOffsetInverseTransform() {
        return this._matrixDirty & 2 ? (this._matrixDirty &= -3, this._textureOffsetInverseTransform || (this._textureOffsetInverseTransform = new Te), this._textureOffsetInverseTransform.copyFrom(this.inverseWorldTransform).translate(-this._textureBounds.x, -this._textureBounds.y)) : this._textureOffsetInverseTransform
    }
    get inverseParentTextureTransform() {
        if (!(this._matrixDirty & 4)) return this._inverseParentTextureTransform;
        this._matrixDirty &= -5;
        const e = this._parentCacheAsTextureRenderGroup;
        return e ? (this._inverseParentTextureTransform || (this._inverseParentTextureTransform = new Te), this._inverseParentTextureTransform.copyFrom(this.worldTransform).prepend(e.inverseWorldTransform).translate(-e._textureBounds.x, -e._textureBounds.y)) : this.worldTransform
    }
    get cacheToLocalTransform() {
        return this._parentCacheAsTextureRenderGroup ? this._parentCacheAsTextureRenderGroup.textureOffsetInverseTransform : null
    }
}

function p0(t, e, n = {}) {
    for (const r in e) !n[r] && e[r] !== void 0 && (t[r] = e[r])
}
const hg = new At(null),
    lf = new At(null),
    pg = new At(null, 1, 1),
    cf = new At(null),
    Oh = 1,
    bx = 2,
    Xc = 4;
class er extends ir {
    constructor(e = {}) {
        var n, r;
        super(), this.uid = vt("renderable"), this._updateFlags = 15, this.renderGroup = null, this.parentRenderGroup = null, this.parentRenderGroupIndex = 0, this.didChange = !1, this.didViewUpdate = !1, this.relativeRenderGroupDepth = 0, this.children = [], this.parent = null, this.includeInBuild = !0, this.measurable = !0, this.isSimple = !0, this.updateTick = -1, this.localTransform = new Te, this.relativeGroupTransform = new Te, this.groupTransform = this.relativeGroupTransform, this.destroyed = !1, this._position = new At(this, 0, 0), this._scale = pg, this._pivot = lf, this._origin = cf, this._skew = hg, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._rotation = 0, this.localColor = 16777215, this.localAlpha = 1, this.groupAlpha = 1, this.groupColor = 16777215, this.groupColorAlpha = 4294967295, this.localBlendMode = "inherit", this.groupBlendMode = "normal", this.localDisplayStatus = 7, this.globalDisplayStatus = 7, this._didContainerChangeTick = 0, this._didViewChangeTick = 0, this._didLocalTransformChangeId = -1, this.effects = [], p0(this, e, {
            children: !0,
            parent: !0,
            effects: !0
        }), (n = e.children) == null || n.forEach(i => this.addChild(i)), (r = e.parent) == null || r.addChild(this)
    }
    static mixin(e) {
        Ie("8.8.0", "Container.mixin is deprecated, please use extensions.mixin instead."), Re.mixin(er, e)
    }
    set _didChangeId(e) {
        this._didViewChangeTick = e >> 12 & 4095, this._didContainerChangeTick = e & 4095
    }
    get _didChangeId() {
        return this._didContainerChangeTick & 4095 | (this._didViewChangeTick & 4095) << 12
    }
    addChild(...e) {
        if (this.allowChildren || Ie(Ye, "addChild: Only Containers will be allowed to add children in v8.0.0"), e.length > 1) {
            for (let i = 0; i < e.length; i++) this.addChild(e[i]);
            return e[0]
        }
        const n = e[0],
            r = this.renderGroup || this.parentRenderGroup;
        return n.parent === this ? (this.children.splice(this.children.indexOf(n), 1), this.children.push(n), r && (r.structureDidChange = !0), n) : (n.parent && n.parent.removeChild(n), this.children.push(n), this.sortableChildren && (this.sortDirty = !0), n.parent = this, n.didChange = !0, n._updateFlags = 15, r && r.addChild(n), this.emit("childAdded", n, this, this.children.length - 1), n.emit("added", this), this._didViewChangeTick++, n._zIndex !== 0 && n.depthOfChildModified(), n)
    }
    removeChild(...e) {
        if (e.length > 1) {
            for (let i = 0; i < e.length; i++) this.removeChild(e[i]);
            return e[0]
        }
        const n = e[0],
            r = this.children.indexOf(n);
        return r > -1 && (this._didViewChangeTick++, this.children.splice(r, 1), this.renderGroup ? this.renderGroup.removeChild(n) : this.parentRenderGroup && this.parentRenderGroup.removeChild(n), n.parentRenderLayer && n.parentRenderLayer.detach(n), n.parent = null, this.emit("childRemoved", n, this, r), n.emit("removed", this)), n
    }
    _onUpdate(e) {
        e && e === this._skew && this._updateSkew(), this._didContainerChangeTick++, !this.didChange && (this.didChange = !0, this.parentRenderGroup && this.parentRenderGroup.onChildUpdate(this))
    }
    set isRenderGroup(e) {
        !!this.renderGroup !== e && (e ? this.enableRenderGroup() : this.disableRenderGroup())
    }
    get isRenderGroup() {
        return !!this.renderGroup
    }
    enableRenderGroup() {
        if (this.renderGroup) return;
        const e = this.parentRenderGroup;
        e == null || e.removeChild(this), this.renderGroup = nn.get(die, this), this.groupTransform = Te.IDENTITY, e == null || e.addChild(this), this._updateIsSimple()
    }
    disableRenderGroup() {
        if (!this.renderGroup) return;
        const e = this.parentRenderGroup;
        e == null || e.removeChild(this), nn.return(this.renderGroup), this.renderGroup = null, this.groupTransform = this.relativeGroupTransform, e == null || e.addChild(this), this._updateIsSimple()
    }
    _updateIsSimple() {
        this.isSimple = !this.renderGroup && this.effects.length === 0
    }
    get worldTransform() {
        return this._worldTransform || (this._worldTransform = new Te), this.renderGroup ? this._worldTransform.copyFrom(this.renderGroup.worldTransform) : this.parentRenderGroup && this._worldTransform.appendFrom(this.relativeGroupTransform, this.parentRenderGroup.worldTransform), this._worldTransform
    }
    get x() {
        return this._position.x
    }
    set x(e) {
        this._position.x = e
    }
    get y() {
        return this._position.y
    }
    set y(e) {
        this._position.y = e
    }
    get position() {
        return this._position
    }
    set position(e) {
        this._position.copyFrom(e)
    }
    get rotation() {
        return this._rotation
    }
    set rotation(e) {
        this._rotation !== e && (this._rotation = e, this._onUpdate(this._skew))
    }
    get angle() {
        return this.rotation * Ire
    }
    set angle(e) {
        this.rotation = e * Mre
    }
    get pivot() {
        return this._pivot === lf && (this._pivot = new At(this, 0, 0)), this._pivot
    }
    set pivot(e) {
        this._pivot === lf && (this._pivot = new At(this, 0, 0), this._origin !== cf && Oe("Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.")), typeof e == "number" ? this._pivot.set(e) : this._pivot.copyFrom(e)
    }
    get skew() {
        return this._skew === hg && (this._skew = new At(this, 0, 0)), this._skew
    }
    set skew(e) {
        this._skew === hg && (this._skew = new At(this, 0, 0)), this._skew.copyFrom(e)
    }
    get scale() {
        return this._scale === pg && (this._scale = new At(this, 1, 1)), this._scale
    }
    set scale(e) {
        this._scale === pg && (this._scale = new At(this, 0, 0)), typeof e == "string" && (e = parseFloat(e)), typeof e == "number" ? this._scale.set(e) : this._scale.copyFrom(e)
    }
    get origin() {
        return this._origin === cf && (this._origin = new At(this, 0, 0)), this._origin
    }
    set origin(e) {
        this._origin === cf && (this._origin = new At(this, 0, 0), this._pivot !== lf && Oe("Setting both a pivot and origin on a Container is not recommended. This can lead to unexpected behavior if not handled carefully.")), typeof e == "number" ? this._origin.set(e) : this._origin.copyFrom(e)
    }
    get width() {
        return Math.abs(this.scale.x * this.getLocalBounds().width)
    }
    set width(e) {
        const n = this.getLocalBounds().width;
        this._setWidth(e, n)
    }
    get height() {
        return Math.abs(this.scale.y * this.getLocalBounds().height)
    }
    set height(e) {
        const n = this.getLocalBounds().height;
        this._setHeight(e, n)
    }
    getSize(e) {
        e || (e = {});
        const n = this.getLocalBounds();
        return e.width = Math.abs(this.scale.x * n.width), e.height = Math.abs(this.scale.y * n.height), e
    }
    setSize(e, n) {
        const r = this.getLocalBounds();
        typeof e == "object" ? (n = e.height ? ? e.width, e = e.width) : n ? ? (n = e), e !== void 0 && this._setWidth(e, r.width), n !== void 0 && this._setHeight(n, r.height)
    }
    _updateSkew() {
        const e = this._rotation,
            n = this._skew;
        this._cx = Math.cos(e + n._y), this._sx = Math.sin(e + n._y), this._cy = -Math.sin(e - n._x), this._sy = Math.cos(e - n._x)
    }
    updateTransform(e) {
        return this.position.set(typeof e.x == "number" ? e.x : this.position.x, typeof e.y == "number" ? e.y : this.position.y), this.scale.set(typeof e.scaleX == "number" ? e.scaleX || 1 : this.scale.x, typeof e.scaleY == "number" ? e.scaleY || 1 : this.scale.y), this.rotation = typeof e.rotation == "number" ? e.rotation : this.rotation, this.skew.set(typeof e.skewX == "number" ? e.skewX : this.skew.x, typeof e.skewY == "number" ? e.skewY : this.skew.y), this.pivot.set(typeof e.pivotX == "number" ? e.pivotX : this.pivot.x, typeof e.pivotY == "number" ? e.pivotY : this.pivot.y), this.origin.set(typeof e.originX == "number" ? e.originX : this.origin.x, typeof e.originY == "number" ? e.originY : this.origin.y), this
    }
    setFromMatrix(e) {
        e.decompose(this)
    }
    updateLocalTransform() {
        const e = this._didContainerChangeTick;
        if (this._didLocalTransformChangeId === e) return;
        this._didLocalTransformChangeId = e;
        const n = this.localTransform,
            r = this._scale,
            i = this._pivot,
            s = this._origin,
            o = this._position,
            a = r._x,
            l = r._y,
            c = i._x,
            u = i._y,
            d = -s._x,
            f = -s._y;
        n.a = this._cx * a, n.b = this._sx * a, n.c = this._cy * l, n.d = this._sy * l, n.tx = o._x - (c * n.a + u * n.c) + (d * n.a + f * n.c) - d * a, n.ty = o._y - (c * n.b + u * n.d) + (d * n.b + f * n.d) - f * l
    }
    set alpha(e) {
        e !== this.localAlpha && (this.localAlpha = e, this._updateFlags |= Oh, this._onUpdate())
    }
    get alpha() {
        return this.localAlpha
    }
    set tint(e) {
        const r = tt.shared.setValue(e ? ? 16777215).toBgrNumber();
        r !== this.localColor && (this.localColor = r, this._updateFlags |= Oh, this._onUpdate())
    }
    get tint() {
        return Yc(this.localColor)
    }
    set blendMode(e) {
        this.localBlendMode !== e && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= bx, this.localBlendMode = e, this._onUpdate())
    }
    get blendMode() {
        return this.localBlendMode
    }
    get visible() {
        return !!(this.localDisplayStatus & 2)
    }
    set visible(e) {
        const n = e ? 2 : 0;
        (this.localDisplayStatus & 2) !== n && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Xc, this.localDisplayStatus ^= 2, this._onUpdate())
    }
    get culled() {
        return !(this.localDisplayStatus & 4)
    }
    set culled(e) {
        const n = e ? 0 : 4;
        (this.localDisplayStatus & 4) !== n && (this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._updateFlags |= Xc, this.localDisplayStatus ^= 4, this._onUpdate())
    }
    get renderable() {
        return !!(this.localDisplayStatus & 1)
    }
    set renderable(e) {
        const n = e ? 1 : 0;
        (this.localDisplayStatus & 1) !== n && (this._updateFlags |= Xc, this.localDisplayStatus ^= 1, this.parentRenderGroup && (this.parentRenderGroup.structureDidChange = !0), this._onUpdate())
    }
    get isRenderable() {
        return this.localDisplayStatus === 7 && this.groupAlpha > 0
    }
    destroy(e = !1) {
        var i;
        if (this.destroyed) return;
        this.destroyed = !0;
        let n;
        if (this.children.length && (n = this.removeChildren(0, this.children.length)), this.removeFromParent(), this.parent = null, this._maskEffect = null, this._filterEffect = null, this.effects = null, this._position = null, this._scale = null, this._pivot = null, this._origin = null, this._skew = null, this.emit("destroyed", this), this.removeAllListeners(), (typeof e == "boolean" ? e : e == null ? void 0 : e.children) && n)
            for (let s = 0; s < n.length; ++s) n[s].destroy(e);
        (i = this.renderGroup) == null || i.destroy(), this.renderGroup = null
    }
}
Re.mixin(er, qre, tie, lie, sie, iie, Zre, Qre, oie, Wre, Xre, nie, Kre);
class dd extends er {
    constructor(e) {
        super(e), this.canBundle = !0, this.allowChildren = !1, this._roundPixels = 0, this._lastUsed = -1, this._gpuData = Object.create(null), this._bounds = new rn(0, 1, 0, 0), this._boundsDirty = !0
    }
    get bounds() {
        return this._boundsDirty ? (this.updateBounds(), this._boundsDirty = !1, this._bounds) : this._bounds
    }
    get roundPixels() {
        return !!this._roundPixels
    }
    set roundPixels(e) {
        this._roundPixels = e ? 1 : 0
    }
    containsPoint(e) {
        const n = this.bounds,
            {
                x: r,
                y: i
            } = e;
        return r >= n.minX && r <= n.maxX && i >= n.minY && i <= n.maxY
    }
    onViewUpdate() {
        if (this._didViewChangeTick++, this._boundsDirty = !0, this.didViewUpdate) return;
        this.didViewUpdate = !0;
        const e = this.renderGroup || this.parentRenderGroup;
        e && e.onChildViewUpdate(this)
    }
    destroy(e) {
        var n, r;
        super.destroy(e), this._bounds = null;
        for (const i in this._gpuData)(r = (n = this._gpuData[i]).destroy) == null || r.call(n);
        this._gpuData = null
    }
    collectRenderablesSimple(e, n, r) {
        const {
            renderPipes: i
        } = n;
        i.blendMode.setBlendMode(this, this.groupBlendMode, e), i[this.renderPipeId].addRenderable(this, e), this.didViewUpdate = !1;
        const o = this.children,
            a = o.length;
        for (let l = 0; l < a; l++) o[l].collectRenderables(e, n, r)
    }
}
class ra extends dd {
    constructor(e = we.EMPTY) {
        e instanceof we && (e = {
            texture: e
        });
        const {
            texture: n = we.EMPTY,
            anchor: r,
            roundPixels: i,
            width: s,
            height: o,
            ...a
        } = e;
        super({
            label: "Sprite",
            ...a
        }), this.renderPipeId = "sprite", this.batched = !0, this._visualBounds = {
            minX: 0,
            maxX: 1,
            minY: 0,
            maxY: 0
        }, this._anchor = new At({
            _onUpdate: () => {
                this.onViewUpdate()
            }
        }), r ? this.anchor = r : n.defaultAnchor && (this.anchor = n.defaultAnchor), this.texture = n, this.allowChildren = !1, this.roundPixels = i ? ? !1, s !== void 0 && (this.width = s), o !== void 0 && (this.height = o)
    }
    static from(e, n = !1) {
        return e instanceof we ? new ra(e) : new ra(we.from(e, n))
    }
    set texture(e) {
        e || (e = we.EMPTY);
        const n = this._texture;
        n !== e && (n && n.dynamic && n.off("update", this.onViewUpdate, this), e.dynamic && e.on("update", this.onViewUpdate, this), this._texture = e, this._width && this._setWidth(this._width, this._texture.orig.width), this._height && this._setHeight(this._height, this._texture.orig.height), this.onViewUpdate())
    }
    get texture() {
        return this._texture
    }
    get visualBounds() {
        return Qk(this._visualBounds, this._anchor, this._texture), this._visualBounds
    }
    get sourceBounds() {
        return Ie("8.6.1", "Sprite.sourceBounds is deprecated, use visualBounds instead."), this.visualBounds
    }
    updateBounds() {
        const e = this._anchor,
            n = this._texture,
            r = this._bounds,
            {
                width: i,
                height: s
            } = n.orig;
        r.minX = -e._x * i, r.maxX = r.minX + i, r.minY = -e._y * s, r.maxY = r.minY + s
    }
    destroy(e = !1) {
        if (super.destroy(e), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
            const r = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
            this._texture.destroy(r)
        }
        this._texture = null, this._visualBounds = null, this._bounds = null, this._anchor = null, this._gpuData = null
    }
    get anchor() {
        return this._anchor
    }
    set anchor(e) {
        typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
    }
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(e) {
        this._setWidth(e, this._texture.orig.width), this._width = e
    }
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(e) {
        this._setHeight(e, this._texture.orig.height), this._height = e
    }
    getSize(e) {
        return e || (e = {}), e.width = Math.abs(this.scale.x) * this._texture.orig.width, e.height = Math.abs(this.scale.y) * this._texture.orig.height, e
    }
    setSize(e, n) {
        typeof e == "object" ? (n = e.height ? ? e.width, e = e.width) : n ? ? (n = e), e !== void 0 && this._setWidth(e, this._texture.orig.width), n !== void 0 && this._setHeight(n, this._texture.orig.height)
    }
}
const fie = new rn;

function cB(t, e, n) {
    const r = fie;
    t.measurable = !0, yx(t, n, r), e.addBoundsMask(r), t.measurable = !1
}

function uB(t, e, n) {
    const r = Ui.get();
    t.measurable = !0;
    const i = wn.get().identity(),
        s = dB(t, n, i);
    _x(t, r, s), t.measurable = !1, e.addBoundsMask(r), wn.return(i), Ui.return(r)
}

function dB(t, e, n) {
    return t ? (t !== e && (dB(t.parent, e, n), t.updateLocalTransform(), n.append(t.localTransform)), n) : (Oe("Mask bounds, renderable is not inside the root container"), n)
}
class fB {
    constructor(e) {
        this.priority = 0, this.inverse = !1, this.pipe = "alphaMask", e != null && e.mask && this.init(e.mask)
    }
    init(e) {
        this.mask = e, this.renderMaskToTexture = !(e instanceof ra), this.mask.renderable = this.renderMaskToTexture, this.mask.includeInBuild = !this.renderMaskToTexture, this.mask.measurable = !1
    }
    reset() {
        this.mask.measurable = !0, this.mask = null
    }
    addBounds(e, n) {
        this.inverse || cB(this.mask, e, n)
    }
    addLocalBounds(e, n) {
        uB(this.mask, e, n)
    }
    containsPoint(e, n) {
        const r = this.mask;
        return n(r, e)
    }
    destroy() {
        this.reset()
    }
    static test(e) {
        return e instanceof ra
    }
}
fB.extension = G.MaskEffect;
class hB {
    constructor(e) {
        this.priority = 0, this.pipe = "colorMask", e != null && e.mask && this.init(e.mask)
    }
    init(e) {
        this.mask = e
    }
    destroy() {}
    static test(e) {
        return typeof e == "number"
    }
}
hB.extension = G.MaskEffect;
class pB {
    constructor(e) {
        this.priority = 0, this.pipe = "stencilMask", e != null && e.mask && this.init(e.mask)
    }
    init(e) {
        this.mask = e, this.mask.includeInBuild = !1, this.mask.measurable = !1
    }
    reset() {
        this.mask.measurable = !0, this.mask.includeInBuild = !0, this.mask = null
    }
    addBounds(e, n) {
        cB(this.mask, e, n)
    }
    addLocalBounds(e, n) {
        uB(this.mask, e, n)
    }
    containsPoint(e, n) {
        const r = this.mask;
        return n(r, e)
    }
    destroy() {
        this.reset()
    }
    static test(e) {
        return e instanceof er
    }
}
pB.extension = G.MaskEffect;
const hie = {
    createCanvas: (t, e) => {
        const n = document.createElement("canvas");
        return n.width = t, n.height = e, n
    },
    getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
    getWebGLRenderingContext: () => WebGLRenderingContext,
    getNavigator: () => navigator,
    getBaseUrl: () => document.baseURI ? ? window.location.href,
    getFontFaceSet: () => document.fonts,
    fetch: (t, e) => fetch(t, e),
    parseXML: t => new DOMParser().parseFromString(t, "text/xml")
};
let bT = hie;
const Ge = {
    get() {
        return bT
    },
    set(t) {
        bT = t
    }
};
class oi extends Wt {
    constructor(e) {
        e.resource || (e.resource = Ge.get().createCanvas()), e.width || (e.width = e.resource.width, e.autoDensity || (e.width /= e.resolution)), e.height || (e.height = e.resource.height, e.autoDensity || (e.height /= e.resolution)), super(e), this.uploadMethodId = "image", this.autoDensity = e.autoDensity, this.resizeCanvas(), this.transparent = !!e.transparent
    }
    resizeCanvas() {
        this.autoDensity && "style" in this.resource && (this.resource.style.width = `${this.width}px`, this.resource.style.height = `${this.height}px`), (this.resource.width !== this.pixelWidth || this.resource.height !== this.pixelHeight) && (this.resource.width = this.pixelWidth, this.resource.height = this.pixelHeight)
    }
    resize(e = this.width, n = this.height, r = this._resolution) {
        const i = super.resize(e, n, r);
        return i && this.resizeCanvas(), i
    }
    static test(e) {
        return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement || globalThis.OffscreenCanvas && e instanceof OffscreenCanvas
    }
    get context2D() {
        return this._context2D || (this._context2D = this.resource.getContext("2d"))
    }
}
oi.extension = G.TextureSource;
class ia extends Wt {
    constructor(e) {
        super(e), this.uploadMethodId = "image", this.autoGarbageCollect = !0
    }
    static test(e) {
        return globalThis.HTMLImageElement && e instanceof HTMLImageElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap || globalThis.VideoFrame && e instanceof VideoFrame
    }
}
ia.extension = G.TextureSource;
var Tl = (t => (t[t.INTERACTION = 50] = "INTERACTION", t[t.HIGH = 25] = "HIGH", t[t.NORMAL = 0] = "NORMAL", t[t.LOW = -25] = "LOW", t[t.UTILITY = -50] = "UTILITY", t))(Tl || {});
class mg {
    constructor(e, n = null, r = 0, i = !1) {
        this.next = null, this.previous = null, this._destroyed = !1, this._fn = e, this._context = n, this.priority = r, this._once = i
    }
    match(e, n = null) {
        return this._fn === e && this._context === n
    }
    emit(e) {
        this._fn && (this._context ? this._fn.call(this._context, e) : this._fn(e));
        const n = this.next;
        return this._once && this.destroy(!0), this._destroyed && (this.next = null), n
    }
    connect(e) {
        this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this
    }
    destroy(e = !1) {
        this._destroyed = !0, this._fn = null, this._context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
        const n = this.next;
        return this.next = e ? null : n, this.previous = null, n
    }
}
const mB = class zn {
    constructor() {
        this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new mg(null, null, 1 / 0), this.deltaMS = 1 / zn.targetFPMS, this.elapsedMS = 1 / zn.targetFPMS, this._tick = e => {
            this._requestId = null, this.started && (this.update(e), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
        }
    }
    _requestIfNeeded() {
        this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick))
    }
    _cancelIfNeeded() {
        this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null)
    }
    _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start()
    }
    add(e, n, r = Tl.NORMAL) {
        return this._addListener(new mg(e, n, r))
    }
    addOnce(e, n, r = Tl.NORMAL) {
        return this._addListener(new mg(e, n, r, !0))
    }
    _addListener(e) {
        let n = this._head.next,
            r = this._head;
        if (!n) e.connect(r);
        else {
            for (; n;) {
                if (e.priority > n.priority) {
                    e.connect(r);
                    break
                }
                r = n, n = n.next
            }
            e.previous || e.connect(r)
        }
        return this._startIfPossible(), this
    }
    remove(e, n) {
        let r = this._head.next;
        for (; r;) r.match(e, n) ? r = r.destroy() : r = r.next;
        return this._head.next || this._cancelIfNeeded(), this
    }
    get count() {
        if (!this._head) return 0;
        let e = 0,
            n = this._head;
        for (; n = n.next;) e++;
        return e
    }
    start() {
        this.started || (this.started = !0, this._requestIfNeeded())
    }
    stop() {
        this.started && (this.started = !1, this._cancelIfNeeded())
    }
    destroy() {
        if (!this._protected) {
            this.stop();
            let e = this._head.next;
            for (; e;) e = e.destroy(!0);
            this._head.destroy(), this._head = null
        }
    }
    update(e = performance.now()) {
        let n;
        if (e > this.lastTime) {
            if (n = this.elapsedMS = e - this.lastTime, n > this._maxElapsedMS && (n = this._maxElapsedMS), n *= this.speed, this._minElapsedMS) {
                const s = e - this._lastFrame | 0;
                if (s < this._minElapsedMS) return;
                this._lastFrame = e - s % this._minElapsedMS
            }
            this.deltaMS = n, this.deltaTime = this.deltaMS * zn.targetFPMS;
            const r = this._head;
            let i = r.next;
            for (; i;) i = i.emit(this);
            r.next || this._cancelIfNeeded()
        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = e
    }
    get FPS() {
        return 1e3 / this.elapsedMS
    }
    get minFPS() {
        return 1e3 / this._maxElapsedMS
    }
    set minFPS(e) {
        const n = Math.min(this.maxFPS, e),
            r = Math.min(Math.max(0, n) / 1e3, zn.targetFPMS);
        this._maxElapsedMS = 1 / r
    }
    get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
    }
    set maxFPS(e) {
        if (e === 0) this._minElapsedMS = 0;
        else {
            const n = Math.max(this.minFPS, e);
            this._minElapsedMS = 1 / (n / 1e3)
        }
    }
    static get shared() {
        if (!zn._shared) {
            const e = zn._shared = new zn;
            e.autoStart = !0, e._protected = !0
        }
        return zn._shared
    }
    static get system() {
        if (!zn._system) {
            const e = zn._system = new zn;
            e.autoStart = !0, e._protected = !0
        }
        return zn._system
    }
};
mB.targetFPMS = .06;
let bn = mB,
    gg;
async function gB() {
    return gg ? ? (gg = (async () => {
        var o;
        const e = document.createElement("canvas").getContext("webgl");
        if (!e) return "premultiply-alpha-on-upload";
        const n = await new Promise(a => {
            const l = document.createElement("video");
            l.onloadeddata = () => a(l), l.onerror = () => a(null), l.autoplay = !1, l.crossOrigin = "anonymous", l.preload = "auto", l.src = "data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM=", l.load()
        });
        if (!n) return "premultiply-alpha-on-upload";
        const r = e.createTexture();
        e.bindTexture(e.TEXTURE_2D, r);
        const i = e.createFramebuffer();
        e.bindFramebuffer(e.FRAMEBUFFER, i), e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, r, 0), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, n);
        const s = new Uint8Array(4);
        return e.readPixels(0, 0, 1, 1, e.RGBA, e.UNSIGNED_BYTE, s), e.deleteFramebuffer(i), e.deleteTexture(r), (o = e.getExtension("WEBGL_lose_context")) == null || o.loseContext(), s[0] <= s[3] ? "premultiplied-alpha" : "premultiply-alpha-on-upload"
    })()), gg
}
const Qp = class yB extends Wt {
    constructor(e) {
        super(e), this.isReady = !1, this.uploadMethodId = "video", e = { ...yB.defaultOptions,
            ...e
        }, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = e.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = e.autoPlay !== !1, this.alphaMode = e.alphaMode ? ? "premultiply-alpha-on-upload", this._videoFrameRequestCallback = this._videoFrameRequestCallback.bind(this), this._videoFrameRequestCallbackHandle = null, this._load = null, this._resolve = null, this._reject = null, this._onCanPlay = this._onCanPlay.bind(this), this._onCanPlayThrough = this._onCanPlayThrough.bind(this), this._onError = this._onError.bind(this), this._onPlayStart = this._onPlayStart.bind(this), this._onPlayStop = this._onPlayStop.bind(this), this._onSeeked = this._onSeeked.bind(this), e.autoLoad !== !1 && this.load()
    }
    updateFrame() {
        if (!this.destroyed) {
            if (this._updateFPS) {
                const e = bn.shared.elapsedMS * this.resource.playbackRate;
                this._msToNextUpdate = Math.floor(this._msToNextUpdate - e)
            }(!this._updateFPS || this._msToNextUpdate <= 0) && (this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0), this.isValid && this.update()
        }
    }
    _videoFrameRequestCallback() {
        this.updateFrame(), this.destroyed ? this._videoFrameRequestCallbackHandle = null : this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback)
    }
    get isValid() {
        return !!this.resource.videoWidth && !!this.resource.videoHeight
    }
    async load() {
        if (this._load) return this._load;
        const e = this.resource,
            n = this.options;
        return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart), e.addEventListener("pause", this._onPlayStop), e.addEventListener("seeked", this._onSeeked), this._isSourceReady() ? this._mediaReady() : (n.preload || e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlayThrough), e.addEventListener("error", this._onError, !0)), this.alphaMode = await gB(), this._load = new Promise((r, i) => {
            this.isValid ? r(this) : (this._resolve = r, this._reject = i, n.preloadTimeoutMs !== void 0 && (this._preloadTimeout = setTimeout(() => {
                this._onError(new ErrorEvent(`Preload exceeded timeout of ${n.preloadTimeoutMs}ms`))
            })), e.load())
        }), this._load
    }
    _onError(e) {
        this.resource.removeEventListener("error", this._onError, !0), this.emit("error", e), this._reject && (this._reject(e), this._reject = null, this._resolve = null)
    }
    _isSourcePlaying() {
        const e = this.resource;
        return !e.paused && !e.ended
    }
    _isSourceReady() {
        return this.resource.readyState > 2
    }
    _onPlayStart() {
        this.isValid || this._mediaReady(), this._configureAutoUpdate()
    }
    _onPlayStop() {
        this._configureAutoUpdate()
    }
    _onSeeked() {
        this._autoUpdate && !this._isSourcePlaying() && (this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0)
    }
    _onCanPlay() {
        this.resource.removeEventListener("canplay", this._onCanPlay), this._mediaReady()
    }
    _onCanPlayThrough() {
        this.resource.removeEventListener("canplaythrough", this._onCanPlay), this._preloadTimeout && (clearTimeout(this._preloadTimeout), this._preloadTimeout = void 0), this._mediaReady()
    }
    _mediaReady() {
        const e = this.resource;
        this.isValid && (this.isReady = !0, this.resize(e.videoWidth, e.videoHeight)), this._msToNextUpdate = 0, this.updateFrame(), this._msToNextUpdate = 0, this._resolve && (this._resolve(this), this._resolve = null, this._reject = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && this.resource.play()
    }
    destroy() {
        this._configureAutoUpdate();
        const e = this.resource;
        e && (e.removeEventListener("play", this._onPlayStart), e.removeEventListener("pause", this._onPlayStop), e.removeEventListener("seeked", this._onSeeked), e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlayThrough), e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), super.destroy()
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(e) {
        e !== this._autoUpdate && (this._autoUpdate = e, this._configureAutoUpdate())
    }
    get updateFPS() {
        return this._updateFPS
    }
    set updateFPS(e) {
        e !== this._updateFPS && (this._updateFPS = e, this._configureAutoUpdate())
    }
    _configureAutoUpdate() {
        this._autoUpdate && this._isSourcePlaying() ? !this._updateFPS && this.resource.requestVideoFrameCallback ? (this._isConnectedToTicker && (bn.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0), this._videoFrameRequestCallbackHandle === null && (this._videoFrameRequestCallbackHandle = this.resource.requestVideoFrameCallback(this._videoFrameRequestCallback))) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker || (bn.shared.add(this.updateFrame, this), this._isConnectedToTicker = !0, this._msToNextUpdate = 0)) : (this._videoFrameRequestCallbackHandle !== null && (this.resource.cancelVideoFrameCallback(this._videoFrameRequestCallbackHandle), this._videoFrameRequestCallbackHandle = null), this._isConnectedToTicker && (bn.shared.remove(this.updateFrame, this), this._isConnectedToTicker = !1, this._msToNextUpdate = 0))
    }
    static test(e) {
        return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement
    }
};
Qp.extension = G.TextureSource;
Qp.defaultOptions = { ...Wt.defaultOptions,
    autoLoad: !0,
    autoPlay: !0,
    updateFPS: 0,
    crossorigin: !0,
    loop: !1,
    muted: !0,
    playsinline: !0,
    preload: !1
};
Qp.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
};
let Yf = Qp;
const Or = (t, e, n = !1) => (Array.isArray(t) || (t = [t]), e ? t.map(r => typeof r == "string" || n ? e(r) : r) : t);
class pie {
    constructor() {
        this._parsers = [], this._cache = new Map, this._cacheMap = new Map
    }
    reset() {
        this._cacheMap.clear(), this._cache.clear()
    }
    has(e) {
        return this._cache.has(e)
    }
    get(e) {
        const n = this._cache.get(e);
        return n || Oe(`[Assets] Asset id ${e} was not found in the Cache`), n
    }
    set(e, n) {
        const r = Or(e);
        let i;
        for (let l = 0; l < this.parsers.length; l++) {
            const c = this.parsers[l];
            if (c.test(n)) {
                i = c.getCacheableAssets(r, n);
                break
            }
        }
        const s = new Map(Object.entries(i || {}));
        i || r.forEach(l => {
            s.set(l, n)
        });
        const o = [...s.keys()],
            a = {
                cacheKeys: o,
                keys: r
            };
        r.forEach(l => {
            this._cacheMap.set(l, a)
        }), o.forEach(l => {
            const c = i ? i[l] : n;
            this._cache.has(l) && this._cache.get(l) !== c && Oe("[Cache] already has key:", l), this._cache.set(l, s.get(l))
        })
    }
    remove(e) {
        if (!this._cacheMap.has(e)) {
            Oe(`[Assets] Asset id ${e} was not found in the Cache`);
            return
        }
        const n = this._cacheMap.get(e);
        n.cacheKeys.forEach(i => {
            this._cache.delete(i)
        }), n.keys.forEach(i => {
            this._cacheMap.delete(i)
        })
    }
    get parsers() {
        return this._parsers
    }
}
const ut = new pie,
    m0 = [];
Re.handleByList(G.TextureSource, m0);

function vB(t = {}) {
    const e = t && t.resource,
        n = e ? t.resource : t,
        r = e ? t : {
            resource: t
        };
    for (let i = 0; i < m0.length; i++) {
        const s = m0[i];
        if (s.test(n)) return new s(r)
    }
    throw new Error(`Could not find a source type for resource: ${r.resource}`)
}

function mie(t = {}, e = !1) {
    const n = t && t.resource,
        r = n ? t.resource : t,
        i = n ? t : {
            resource: t
        };
    if (!e && ut.has(r)) return ut.get(r);
    const s = new we({
        source: vB(i)
    });
    return s.on("destroy", () => {
        ut.has(r) && ut.remove(r)
    }), e || ut.set(r, s), s
}

function gie(t, e = !1) {
    return typeof t == "string" ? ut.get(t) : t instanceof Wt ? new we({
        source: t
    }) : mie(t, e)
}
we.from = gie;
Wt.from = vB;
Re.add(fB, hB, pB, Yf, ia, oi, mx);
var ro = (t => (t[t.Low = 0] = "Low", t[t.Normal = 1] = "Normal", t[t.High = 2] = "High", t))(ro || {});

function Er(t) {
    if (typeof t != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(t)}`)
}

function gc(t) {
    return t.split("?")[0].split("#")[0]
}

function yie(t) {
    return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
}

function vie(t, e, n) {
    return t.replace(new RegExp(yie(e), "g"), n)
}

function _ie(t, e) {
    let n = "",
        r = 0,
        i = -1,
        s = 0,
        o = -1;
    for (let a = 0; a <= t.length; ++a) {
        if (a < t.length) o = t.charCodeAt(a);
        else {
            if (o === 47) break;
            o = 47
        }
        if (o === 47) {
            if (!(i === a - 1 || s === 1))
                if (i !== a - 1 && s === 2) {
                    if (n.length < 2 || r !== 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
                        if (n.length > 2) {
                            const l = n.lastIndexOf("/");
                            if (l !== n.length - 1) {
                                l === -1 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), i = a, s = 0;
                                continue
                            }
                        } else if (n.length === 2 || n.length === 1) {
                            n = "", r = 0, i = a, s = 0;
                            continue
                        }
                    }
                    e && (n.length > 0 ? n += "/.." : n = "..", r = 2)
                } else n.length > 0 ? n += `/${t.slice(i+1,a)}` : n = t.slice(i + 1, a), r = a - i - 1;
            i = a, s = 0
        } else o === 46 && s !== -1 ? ++s : s = -1
    }
    return n
}
const Ln = {
    toPosix(t) {
        return vie(t, "\\", "/")
    },
    isUrl(t) {
        return /^https?:/.test(this.toPosix(t))
    },
    isDataUrl(t) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(t)
    },
    isBlobUrl(t) {
        return t.startsWith("blob:")
    },
    hasProtocol(t) {
        return /^[^/:]+:/.test(this.toPosix(t))
    },
    getProtocol(t) {
        Er(t), t = this.toPosix(t);
        const e = /^file:\/\/\//.exec(t);
        if (e) return e[0];
        const n = /^[^/:]+:\/{0,2}/.exec(t);
        return n ? n[0] : ""
    },
    toAbsolute(t, e, n) {
        if (Er(t), this.isDataUrl(t) || this.isBlobUrl(t)) return t;
        const r = gc(this.toPosix(e ? ? Ge.get().getBaseUrl())),
            i = gc(this.toPosix(n ? ? this.rootname(r)));
        return t = this.toPosix(t), t.startsWith("/") ? Ln.join(i, t.slice(1)) : this.isAbsolute(t) ? t : this.join(r, t)
    },
    normalize(t) {
        if (Er(t), t.length === 0) return ".";
        if (this.isDataUrl(t) || this.isBlobUrl(t)) return t;
        t = this.toPosix(t);
        let e = "";
        const n = t.startsWith("/");
        this.hasProtocol(t) && (e = this.rootname(t), t = t.slice(e.length));
        const r = t.endsWith("/");
        return t = _ie(t, !1), t.length > 0 && r && (t += "/"), n ? `/${t}` : e + t
    },
    isAbsolute(t) {
        return Er(t), t = this.toPosix(t), this.hasProtocol(t) ? !0 : t.startsWith("/")
    },
    join(...t) {
        if (t.length === 0) return ".";
        let e;
        for (let n = 0; n < t.length; ++n) {
            const r = t[n];
            if (Er(r), r.length > 0)
                if (e === void 0) e = r;
                else {
                    const i = t[n - 1] ? ? "";
                    this.joinExtensions.includes(this.extname(i).toLowerCase()) ? e += `/../${r}` : e += `/${r}`
                }
        }
        return e === void 0 ? "." : this.normalize(e)
    },
    dirname(t) {
        if (Er(t), t.length === 0) return ".";
        t = this.toPosix(t);
        let e = t.charCodeAt(0);
        const n = e === 47;
        let r = -1,
            i = !0;
        const s = this.getProtocol(t),
            o = t;
        t = t.slice(s.length);
        for (let a = t.length - 1; a >= 1; --a)
            if (e = t.charCodeAt(a), e === 47) {
                if (!i) {
                    r = a;
                    break
                }
            } else i = !1;
        return r === -1 ? n ? "/" : this.isUrl(o) ? s + t : s : n && r === 1 ? "//" : s + t.slice(0, r)
    },
    rootname(t) {
        Er(t), t = this.toPosix(t);
        let e = "";
        if (t.startsWith("/") ? e = "/" : e = this.getProtocol(t), this.isUrl(t)) {
            const n = t.indexOf("/", e.length);
            n !== -1 ? e = t.slice(0, n) : e = t, e.endsWith("/") || (e += "/")
        }
        return e
    },
    basename(t, e) {
        Er(t), e && Er(e), t = gc(this.toPosix(t));
        let n = 0,
            r = -1,
            i = !0,
            s;
        if (e !== void 0 && e.length > 0 && e.length <= t.length) {
            if (e.length === t.length && e === t) return "";
            let o = e.length - 1,
                a = -1;
            for (s = t.length - 1; s >= 0; --s) {
                const l = t.charCodeAt(s);
                if (l === 47) {
                    if (!i) {
                        n = s + 1;
                        break
                    }
                } else a === -1 && (i = !1, a = s + 1), o >= 0 && (l === e.charCodeAt(o) ? --o === -1 && (r = s) : (o = -1, r = a))
            }
            return n === r ? r = a : r === -1 && (r = t.length), t.slice(n, r)
        }
        for (s = t.length - 1; s >= 0; --s)
            if (t.charCodeAt(s) === 47) {
                if (!i) {
                    n = s + 1;
                    break
                }
            } else r === -1 && (i = !1, r = s + 1);
        return r === -1 ? "" : t.slice(n, r)
    },
    extname(t) {
        Er(t), t = gc(this.toPosix(t));
        let e = -1,
            n = 0,
            r = -1,
            i = !0,
            s = 0;
        for (let o = t.length - 1; o >= 0; --o) {
            const a = t.charCodeAt(o);
            if (a === 47) {
                if (!i) {
                    n = o + 1;
                    break
                }
                continue
            }
            r === -1 && (i = !1, r = o + 1), a === 46 ? e === -1 ? e = o : s !== 1 && (s = 1) : e !== -1 && (s = -1)
        }
        return e === -1 || r === -1 || s === 0 || s === 1 && e === r - 1 && e === n + 1 ? "" : t.slice(e, r)
    },
    parse(t) {
        Er(t);
        const e = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (t.length === 0) return e;
        t = gc(this.toPosix(t));
        let n = t.charCodeAt(0);
        const r = this.isAbsolute(t);
        let i;
        e.root = this.rootname(t), r || this.hasProtocol(t) ? i = 1 : i = 0;
        let s = -1,
            o = 0,
            a = -1,
            l = !0,
            c = t.length - 1,
            u = 0;
        for (; c >= i; --c) {
            if (n = t.charCodeAt(c), n === 47) {
                if (!l) {
                    o = c + 1;
                    break
                }
                continue
            }
            a === -1 && (l = !1, a = c + 1), n === 46 ? s === -1 ? s = c : u !== 1 && (u = 1) : s !== -1 && (u = -1)
        }
        return s === -1 || a === -1 || u === 0 || u === 1 && s === a - 1 && s === o + 1 ? a !== -1 && (o === 0 && r ? e.base = e.name = t.slice(1, a) : e.base = e.name = t.slice(o, a)) : (o === 0 && r ? (e.name = t.slice(1, s), e.base = t.slice(1, a)) : (e.name = t.slice(o, s), e.base = t.slice(o, a)), e.ext = t.slice(s, a)), e.dir = this.dirname(t), e
    },
    sep: "/",
    delimiter: ":",
    joinExtensions: [".html"]
};

function _B(t, e, n, r, i) {
    const s = e[n];
    for (let o = 0; o < s.length; o++) {
        const a = s[o];
        n < e.length - 1 ? _B(t.replace(r[n], a), e, n + 1, r, i) : i.push(t.replace(r[n], a))
    }
}

function bie(t) {
    const e = /\{(.*?)\}/g,
        n = t.match(e),
        r = [];
    if (n) {
        const i = [];
        n.forEach(s => {
            const o = s.substring(1, s.length - 1).split(",");
            i.push(o)
        }), _B(t, i, 0, n, r)
    } else r.push(t);
    return r
}
const Ih = t => !Array.isArray(t);
class ql {
    constructor() {
        this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (e, n) => `${e}${this._bundleIdConnector}${n}`,
            extractAssetIdFromBundle: (e, n) => n.replace(`${e}${this._bundleIdConnector}`, "")
        }, this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector, this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId, this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle, this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {}
    }
    setBundleIdentifier(e) {
        if (this._bundleIdConnector = e.connector ? ? this._bundleIdConnector, this._createBundleAssetId = e.createBundleAssetId ? ? this._createBundleAssetId, this._extractAssetIdFromBundle = e.extractAssetIdFromBundle ? ? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
    }
    prefer(...e) {
        e.forEach(n => {
            this._preferredOrder.push(n), n.priority || (n.priority = Object.keys(n.params))
        }), this._resolverHash = {}
    }
    set basePath(e) {
        this._basePath = e
    }
    get basePath() {
        return this._basePath
    }
    set rootPath(e) {
        this._rootPath = e
    }
    get rootPath() {
        return this._rootPath
    }
    get parsers() {
        return this._parsers
    }
    reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions), this._assetMap = {}, this._preferredOrder = [], this._resolverHash = {}, this._rootPath = null, this._basePath = null, this._manifest = null, this._bundles = {}, this._defaultSearchParams = null
    }
    setDefaultSearchParams(e) {
        if (typeof e == "string") this._defaultSearchParams = e;
        else {
            const n = e;
            this._defaultSearchParams = Object.keys(n).map(r => `${encodeURIComponent(r)}=${encodeURIComponent(n[r])}`).join("&")
        }
    }
    getAlias(e) {
        const {
            alias: n,
            src: r
        } = e;
        return Or(n || r, s => typeof s == "string" ? s : Array.isArray(s) ? s.map(o => (o == null ? void 0 : o.src) ? ? o) : s != null && s.src ? s.src : s, !0)
    }
    addManifest(e) {
        this._manifest && Oe("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = e, e.bundles.forEach(n => {
            this.addBundle(n.name, n.assets)
        })
    }
    addBundle(e, n) {
        const r = [];
        let i = n;
        Array.isArray(n) || (i = Object.entries(n).map(([s, o]) => typeof o == "string" || Array.isArray(o) ? {
            alias: s,
            src: o
        } : {
            alias: s,
            ...o
        })), i.forEach(s => {
            const o = s.src,
                a = s.alias;
            let l;
            if (typeof a == "string") {
                const c = this._createBundleAssetId(e, a);
                r.push(c), l = [a, c]
            } else {
                const c = a.map(u => this._createBundleAssetId(e, u));
                r.push(...c), l = [...a, ...c]
            }
            this.add({ ...s,
                alias: l,
                src: o
            })
        }), this._bundles[e] = r
    }
    add(e) {
        const n = [];
        Array.isArray(e) ? n.push(...e) : n.push(e);
        let r;
        r = s => {
            this.hasKey(s) && Oe(`[Resolver] already has key: ${s} overwriting`)
        }, Or(n).forEach(s => {
            const {
                src: o
            } = s;
            let {
                data: a,
                format: l,
                loadParser: c
            } = s;
            const u = Or(o).map(h => typeof h == "string" ? bie(h) : Array.isArray(h) ? h : [h]),
                d = this.getAlias(s);
            Array.isArray(d) ? d.forEach(r) : r(d);
            const f = [];
            u.forEach(h => {
                h.forEach(p => {
                    let b = {};
                    if (typeof p != "object") {
                        b.src = p;
                        for (let y = 0; y < this._parsers.length; y++) {
                            const m = this._parsers[y];
                            if (m.test(p)) {
                                b = m.parse(p);
                                break
                            }
                        }
                    } else a = p.data ? ? a, l = p.format ? ? l, c = p.loadParser ? ? c, b = { ...b,
                        ...p
                    };
                    if (!d) throw new Error(`[Resolver] alias is undefined for this asset: ${b.src}`);
                    b = this._buildResolvedAsset(b, {
                        aliases: d,
                        data: a,
                        format: l,
                        loadParser: c
                    }), f.push(b)
                })
            }), d.forEach(h => {
                this._assetMap[h] = f
            })
        })
    }
    resolveBundle(e) {
        const n = Ih(e);
        e = Or(e);
        const r = {};
        return e.forEach(i => {
            const s = this._bundles[i];
            if (s) {
                const o = this.resolve(s),
                    a = {};
                for (const l in o) {
                    const c = o[l];
                    a[this._extractAssetIdFromBundle(i, l)] = c
                }
                r[i] = a
            }
        }), n ? r[e[0]] : r
    }
    resolveUrl(e) {
        const n = this.resolve(e);
        if (typeof e != "string") {
            const r = {};
            for (const i in n) r[i] = n[i].src;
            return r
        }
        return n.src
    }
    resolve(e) {
        const n = Ih(e);
        e = Or(e);
        const r = {};
        return e.forEach(i => {
            if (!this._resolverHash[i])
                if (this._assetMap[i]) {
                    let s = this._assetMap[i];
                    const o = this._getPreferredOrder(s);
                    o == null || o.priority.forEach(a => {
                        o.params[a].forEach(l => {
                            const c = s.filter(u => u[a] ? u[a] === l : !1);
                            c.length && (s = c)
                        })
                    }), this._resolverHash[i] = s[0]
                } else this._resolverHash[i] = this._buildResolvedAsset({
                    alias: [i],
                    src: i
                }, {});
            r[i] = this._resolverHash[i]
        }), n ? r[e[0]] : r
    }
    hasKey(e) {
        return !!this._assetMap[e]
    }
    hasBundle(e) {
        return !!this._bundles[e]
    }
    _getPreferredOrder(e) {
        for (let n = 0; n < e.length; n++) {
            const r = e[n],
                i = this._preferredOrder.find(s => s.params.format.includes(r.format));
            if (i) return i
        }
        return this._preferredOrder[0]
    }
    _appendDefaultSearchParams(e) {
        if (!this._defaultSearchParams) return e;
        const n = /\?/.test(e) ? "&" : "?";
        return `${e}${n}${this._defaultSearchParams}`
    }
    _buildResolvedAsset(e, n) {
        const {
            aliases: r,
            data: i,
            loadParser: s,
            format: o
        } = n;
        return (this._basePath || this._rootPath) && (e.src = Ln.toAbsolute(e.src, this._basePath, this._rootPath)), e.alias = r ? ? e.alias ? ? [e.src], e.src = this._appendDefaultSearchParams(e.src), e.data = { ...i || {},
            ...e.data
        }, e.loadParser = s ? ? e.loadParser, e.format = o ? ? e.format ? ? xie(e.src), e
    }
}
ql.RETINA_PREFIX = /@([0-9\.]+)x/;

function xie(t) {
    return t.split(".").pop().split("?").shift().split("#").shift()
}
const g0 = (t, e) => {
        const n = e.split("?")[1];
        return n && (t += `?${n}`), t
    },
    bB = class Ac {
        constructor(e, n) {
            this.linkedSheets = [];
            let r = e;
            (e == null ? void 0 : e.source) instanceof Wt && (r = {
                texture: e,
                data: n
            });
            const {
                texture: i,
                data: s,
                cachePrefix: o = ""
            } = r;
            this.cachePrefix = o, this._texture = i instanceof we ? i : null, this.textureSource = i.source, this.textures = {}, this.animations = {}, this.data = s;
            const a = parseFloat(s.meta.scale);
            a ? (this.resolution = a, i.source.resolution = this.resolution) : this.resolution = i.source._resolution, this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null
        }
        parse() {
            return new Promise(e => {
                this._callback = e, this._batchIndex = 0, this._frameKeys.length <= Ac.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch()
            })
        }
        _processFrames(e) {
            let n = e;
            const r = Ac.BATCH_SIZE;
            for (; n - e < r && n < this._frameKeys.length;) {
                const i = this._frameKeys[n],
                    s = this._frames[i],
                    o = s.frame;
                if (o) {
                    let a = null,
                        l = null;
                    const c = s.trimmed !== !1 && s.sourceSize ? s.sourceSize : s.frame,
                        u = new it(0, 0, Math.floor(c.w) / this.resolution, Math.floor(c.h) / this.resolution);
                    s.rotated ? a = new it(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.h) / this.resolution, Math.floor(o.w) / this.resolution) : a = new it(Math.floor(o.x) / this.resolution, Math.floor(o.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution), s.trimmed !== !1 && s.spriteSourceSize && (l = new it(Math.floor(s.spriteSourceSize.x) / this.resolution, Math.floor(s.spriteSourceSize.y) / this.resolution, Math.floor(o.w) / this.resolution, Math.floor(o.h) / this.resolution)), this.textures[i] = new we({
                        source: this.textureSource,
                        frame: a,
                        orig: u,
                        trim: l,
                        rotate: s.rotated ? 2 : 0,
                        defaultAnchor: s.anchor,
                        defaultBorders: s.borders,
                        label: i.toString()
                    })
                }
                n++
            }
        }
        _processAnimations() {
            const e = this.data.animations || {};
            for (const n in e) {
                this.animations[n] = [];
                for (let r = 0; r < e[n].length; r++) {
                    const i = e[n][r];
                    this.animations[n].push(this.textures[i])
                }
            }
        }
        _parseComplete() {
            const e = this._callback;
            this._callback = null, this._batchIndex = 0, e.call(this, this.textures)
        }
        _nextBatch() {
            this._processFrames(this._batchIndex * Ac.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
                this._batchIndex * Ac.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete())
            }, 0)
        }
        destroy(e = !1) {
            var n;
            for (const r in this.textures) this.textures[r].destroy();
            this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && ((n = this._texture) == null || n.destroy(), this.textureSource.destroy()), this._texture = null, this.textureSource = null, this.linkedSheets = []
        }
    };
bB.BATCH_SIZE = 1e3;
let xT = bB;
const wie = ["jpg", "png", "jpeg", "avif", "webp", "basis", "etc2", "bc7", "bc6h", "bc5", "bc4", "bc3", "bc2", "bc1", "eac", "astc"];

function xB(t, e, n) {
    const r = {};
    if (t.forEach(i => {
            r[i] = e
        }), Object.keys(e.textures).forEach(i => {
            r[`${e.cachePrefix}${i}`] = e.textures[i]
        }), !n) {
        const i = Ln.dirname(t[0]);
        e.linkedSheets.forEach((s, o) => {
            const a = xB([`${i}/${e.data.meta.related_multi_packs[o]}`], s, !0);
            Object.assign(r, a)
        })
    }
    return r
}
const Eie = {
    extension: G.Asset,
    cache: {
        test: t => t instanceof xT,
        getCacheableAssets: (t, e) => xB(t, e, !1)
    },
    resolver: {
        extension: {
            type: G.ResolveParser,
            name: "resolveSpritesheet"
        },
        test: t => {
            const n = t.split("?")[0].split("."),
                r = n.pop(),
                i = n.pop();
            return r === "json" && wie.includes(i)
        },
        parse: t => {
            var n;
            const e = t.split(".");
            return {
                resolution: parseFloat(((n = ql.RETINA_PREFIX.exec(t)) == null ? void 0 : n[1]) ? ? "1"),
                format: e[e.length - 2],
                src: t
            }
        }
    },
    loader: {
        name: "spritesheetLoader",
        extension: {
            type: G.LoadParser,
            priority: ro.Normal,
            name: "spritesheetLoader"
        },
        async testParse(t, e) {
            return Ln.extname(e.src).toLowerCase() === ".json" && !!t.frames
        },
        async parse(t, e, n) {
            var d, f;
            const {
                texture: r,
                imageFilename: i,
                textureOptions: s,
                cachePrefix: o
            } = (e == null ? void 0 : e.data) ? ? {};
            let a = Ln.dirname(e.src);
            a && a.lastIndexOf("/") !== a.length - 1 && (a += "/");
            let l;
            if (r instanceof we) l = r;
            else {
                const h = g0(a + (i ? ? t.meta.image), e.src);
                l = (await n.load([{
                    src: h,
                    data: s
                }]))[h]
            }
            const c = new xT({
                texture: l.source,
                data: t,
                cachePrefix: o
            });
            await c.parse();
            const u = (d = t == null ? void 0 : t.meta) == null ? void 0 : d.related_multi_packs;
            if (Array.isArray(u)) {
                const h = [];
                for (const b of u) {
                    if (typeof b != "string") continue;
                    let y = a + b;
                    (f = e.data) != null && f.ignoreMultiPack || (y = g0(y, e.src), h.push(n.load({
                        src: y,
                        data: {
                            textureOptions: s,
                            ignoreMultiPack: !0
                        }
                    })))
                }
                const p = await Promise.all(h);
                c.linkedSheets = p, p.forEach(b => {
                    b.linkedSheets = [c].concat(c.linkedSheets.filter(y => y !== b))
                })
            }
            return c
        },
        async unload(t, e, n) {
            await n.unload(t.textureSource._sourceOrigin), t.destroy(!1)
        }
    }
};
Re.add(Eie);
class fd {
    constructor(e) {
        this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = fd.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new dt, this.page = new dt, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = e
    }
    get layerX() {
        return this.layer.x
    }
    get layerY() {
        return this.layer.y
    }
    get pageX() {
        return this.page.x
    }
    get pageY() {
        return this.page.y
    }
    get data() {
        return this
    }
    composedPath() {
        return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path
    }
    initEvent(e, n, r) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    initUIEvent(e, n, r, i, s) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0
    }
    stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0
    }
    stopPropagation() {
        this.propagationStopped = !0
    }
}
var yg = /iPhone/i,
    wT = /iPod/i,
    ET = /iPad/i,
    ST = /\biOS-universal(?:.+)Mac\b/i,
    vg = /\bAndroid(?:.+)Mobile\b/i,
    TT = /Android/i,
    La = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
    uf = /Silk/i,
    Ei = /Windows Phone/i,
    CT = /\bWindows(?:.+)ARM\b/i,
    PT = /BlackBerry/i,
    AT = /BB10/i,
    OT = /Opera Mini/i,
    IT = /\b(CriOS|Chrome)(?:.+)Mobile/i,
    MT = /Mobile(?:.+)Firefox\b/i,
    RT = function(t) {
        return typeof t < "u" && t.platform === "MacIntel" && typeof t.maxTouchPoints == "number" && t.maxTouchPoints > 1 && typeof MSStream > "u"
    };

function Sie(t) {
    return function(e) {
        return e.test(t)
    }
}

function kT(t) {
    var e = {
        userAgent: "",
        platform: "",
        maxTouchPoints: 0
    };
    !t && typeof navigator < "u" ? e = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
    } : typeof t == "string" ? e.userAgent = t : t && t.userAgent && (e = {
        userAgent: t.userAgent,
        platform: t.platform,
        maxTouchPoints: t.maxTouchPoints || 0
    });
    var n = e.userAgent,
        r = n.split("[FBAN");
    typeof r[1] < "u" && (n = r[0]), r = n.split("Twitter"), typeof r[1] < "u" && (n = r[0]);
    var i = Sie(n),
        s = {
            apple: {
                phone: i(yg) && !i(Ei),
                ipod: i(wT),
                tablet: !i(yg) && (i(ET) || RT(e)) && !i(Ei),
                universal: i(ST),
                device: (i(yg) || i(wT) || i(ET) || i(ST) || RT(e)) && !i(Ei)
            },
            amazon: {
                phone: i(La),
                tablet: !i(La) && i(uf),
                device: i(La) || i(uf)
            },
            android: {
                phone: !i(Ei) && i(La) || !i(Ei) && i(vg),
                tablet: !i(Ei) && !i(La) && !i(vg) && (i(uf) || i(TT)),
                device: !i(Ei) && (i(La) || i(uf) || i(vg) || i(TT)) || i(/\bokhttp\b/i)
            },
            windows: {
                phone: i(Ei),
                tablet: i(CT),
                device: i(Ei) || i(CT)
            },
            other: {
                blackberry: i(PT),
                blackberry10: i(AT),
                opera: i(OT),
                firefox: i(MT),
                chrome: i(IT),
                device: i(PT) || i(AT) || i(OT) || i(MT) || i(IT)
            },
            any: !1,
            phone: !1,
            tablet: !1
        };
    return s.any = s.apple.device || s.android.device || s.windows.device || s.other.device, s.phone = s.apple.phone || s.android.phone || s.windows.phone, s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet, s
}
const Tie = kT.default ? ? kT,
    Cie = Tie(globalThis.navigator),
    Pie = 9,
    df = 100,
    Aie = 0,
    Oie = 0,
    BT = 2,
    DT = 1,
    Iie = -1e3,
    Mie = -1e3,
    Rie = 2,
    xx = class wB {
        constructor(e, n = Cie) {
            this._mobileInfo = n, this.debug = !1, this._activateOnTab = !0, this._deactivateOnMouseMove = !0, this._isActive = !1, this._isMobileAccessibility = !1, this._div = null, this._pool = [], this._renderId = 0, this._children = [], this._androidUpdateCount = 0, this._androidUpdateFrequency = 500, this._hookDiv = null, (n.tablet || n.phone) && this._createTouchHook(), this._renderer = e
        }
        get isActive() {
            return this._isActive
        }
        get isMobileAccessibility() {
            return this._isMobileAccessibility
        }
        get hookDiv() {
            return this._hookDiv
        }
        _createTouchHook() {
            const e = document.createElement("button");
            e.style.width = `${DT}px`, e.style.height = `${DT}px`, e.style.position = "absolute", e.style.top = `${Iie}px`, e.style.left = `${Mie}px`, e.style.zIndex = Rie.toString(), e.style.backgroundColor = "#FF0000", e.title = "select to enable accessibility for this content", e.addEventListener("focus", () => {
                this._isMobileAccessibility = !0, this._activate(), this._destroyTouchHook()
            }), document.body.appendChild(e), this._hookDiv = e
        }
        _destroyTouchHook() {
            this._hookDiv && (document.body.removeChild(this._hookDiv), this._hookDiv = null)
        }
        _activate() {
            if (this._isActive) return;
            this._isActive = !0, this._div || (this._div = document.createElement("div"), this._div.style.width = `${df}px`, this._div.style.height = `${df}px`, this._div.style.position = "absolute", this._div.style.top = `${Aie}px`, this._div.style.left = `${Oie}px`, this._div.style.zIndex = BT.toString(), this._div.style.pointerEvents = "none"), this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)), this._deactivateOnMouseMove && (this._onMouseMove = this._onMouseMove.bind(this), globalThis.document.addEventListener("mousemove", this._onMouseMove, !0));
            const e = this._renderer.view.canvas;
            if (e.parentNode) e.parentNode.appendChild(this._div), this._initAccessibilitySetup();
            else {
                const n = new MutationObserver(() => {
                    e.parentNode && (e.parentNode.appendChild(this._div), n.disconnect(), this._initAccessibilitySetup())
                });
                n.observe(document.body, {
                    childList: !0,
                    subtree: !0
                })
            }
        }
        _initAccessibilitySetup() {
            this._renderer.runners.postrender.add(this), this._renderer.lastObjectRendered && this._updateAccessibleObjects(this._renderer.lastObjectRendered)
        }
        _deactivate() {
            if (!(!this._isActive || this._isMobileAccessibility)) {
                this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), this._activateOnTab && globalThis.addEventListener("keydown", this._onKeyDown, !1), this._renderer.runners.postrender.remove(this);
                for (const e of this._children) e._accessibleDiv && e._accessibleDiv.parentNode && (e._accessibleDiv.parentNode.removeChild(e._accessibleDiv), e._accessibleDiv = null), e._accessibleActive = !1;
                this._pool.forEach(e => {
                    e.parentNode && e.parentNode.removeChild(e)
                }), this._div && this._div.parentNode && this._div.parentNode.removeChild(this._div), this._pool = [], this._children = []
            }
        }
        _updateAccessibleObjects(e) {
            if (!e.visible || !e.accessibleChildren) return;
            e.accessible && (e._accessibleActive || this._addChild(e), e._renderId = this._renderId);
            const n = e.children;
            if (n)
                for (let r = 0; r < n.length; r++) this._updateAccessibleObjects(n[r])
        }
        init(e) {
            const r = {
                accessibilityOptions: { ...wB.defaultOptions,
                    ...(e == null ? void 0 : e.accessibilityOptions) || {}
                }
            };
            this.debug = r.accessibilityOptions.debug, this._activateOnTab = r.accessibilityOptions.activateOnTab, this._deactivateOnMouseMove = r.accessibilityOptions.deactivateOnMouseMove, r.accessibilityOptions.enabledByDefault ? this._activate() : this._activateOnTab && (this._onKeyDown = this._onKeyDown.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)), this._renderer.runners.postrender.remove(this)
        }
        postrender() {
            const e = performance.now();
            if (this._mobileInfo.android.device && e < this._androidUpdateCount || (this._androidUpdateCount = e + this._androidUpdateFrequency, !this._renderer.renderingToScreen || !this._renderer.view.canvas)) return;
            const n = new Set;
            if (this._renderer.lastObjectRendered) {
                this._updateAccessibleObjects(this._renderer.lastObjectRendered);
                for (const r of this._children) r._renderId === this._renderId && n.add(this._children.indexOf(r))
            }
            for (let r = this._children.length - 1; r >= 0; r--) {
                const i = this._children[r];
                n.has(r) || (i._accessibleDiv && i._accessibleDiv.parentNode && (i._accessibleDiv.parentNode.removeChild(i._accessibleDiv), this._pool.push(i._accessibleDiv), i._accessibleDiv = null), i._accessibleActive = !1, rB(this._children, r, 1))
            }
            if (this._renderer.renderingToScreen) {
                const {
                    x: r,
                    y: i,
                    width: s,
                    height: o
                } = this._renderer.screen, a = this._div;
                a.style.left = `${r}px`, a.style.top = `${i}px`, a.style.width = `${s}px`, a.style.height = `${o}px`
            }
            for (let r = 0; r < this._children.length; r++) {
                const i = this._children[r];
                if (!i._accessibleActive || !i._accessibleDiv) continue;
                const s = i._accessibleDiv,
                    o = i.hitArea || i.getBounds().rectangle;
                if (i.hitArea) {
                    const a = i.worldTransform,
                        l = this._renderer.resolution,
                        c = this._renderer.resolution;
                    s.style.left = `${(a.tx+o.x*a.a)*l}px`, s.style.top = `${(a.ty+o.y*a.d)*c}px`, s.style.width = `${o.width*a.a*l}px`, s.style.height = `${o.height*a.d*c}px`
                } else {
                    this._capHitArea(o);
                    const a = this._renderer.resolution,
                        l = this._renderer.resolution;
                    s.style.left = `${o.x*a}px`, s.style.top = `${o.y*l}px`, s.style.width = `${o.width*a}px`, s.style.height = `${o.height*l}px`
                }
            }
            this._renderId++
        }
        _updateDebugHTML(e) {
            e.innerHTML = `type: ${e.type}</br> title : ${e.title}</br> tabIndex: ${e.tabIndex}`
        }
        _capHitArea(e) {
            e.x < 0 && (e.width += e.x, e.x = 0), e.y < 0 && (e.height += e.y, e.y = 0);
            const {
                width: n,
                height: r
            } = this._renderer;
            e.x + e.width > n && (e.width = n - e.x), e.y + e.height > r && (e.height = r - e.y)
        }
        _addChild(e) {
            let n = this._pool.pop();
            n || (e.accessibleType === "button" ? n = document.createElement("button") : (n = document.createElement(e.accessibleType), n.style.cssText = `
                        color: transparent;
                        pointer-events: none;
                        padding: 0;
                        margin: 0;
                        border: 0;
                        outline: 0;
                        background: transparent;
                        box-sizing: border-box;
                        user-select: none;
                        -webkit-user-select: none;
                        -moz-user-select: none;
                        -ms-user-select: none;
                    `, e.accessibleText && (n.innerText = e.accessibleText)), n.style.width = `${df}px`, n.style.height = `${df}px`, n.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", n.style.position = "absolute", n.style.zIndex = BT.toString(), n.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? n.setAttribute("aria-live", "off") : n.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? n.setAttribute("aria-relevant", "additions") : n.setAttribute("aria-relevant", "text"), n.addEventListener("click", this._onClick.bind(this)), n.addEventListener("focus", this._onFocus.bind(this)), n.addEventListener("focusout", this._onFocusOut.bind(this))), n.style.pointerEvents = e.accessiblePointerEvents, n.type = e.accessibleType, e.accessibleTitle && e.accessibleTitle !== null ? n.title = e.accessibleTitle : (!e.accessibleHint || e.accessibleHint === null) && (n.title = `container ${e.tabIndex}`), e.accessibleHint && e.accessibleHint !== null && n.setAttribute("aria-label", e.accessibleHint), this.debug && this._updateDebugHTML(n), e._accessibleActive = !0, e._accessibleDiv = n, n.container = e, this._children.push(e), this._div.appendChild(e._accessibleDiv), e.interactive && (e._accessibleDiv.tabIndex = e.tabIndex)
        }
        _dispatchEvent(e, n) {
            const {
                container: r
            } = e.target, i = this._renderer.events.rootBoundary, s = Object.assign(new fd(i), {
                target: r
            });
            i.rootTarget = this._renderer.lastObjectRendered, n.forEach(o => i.dispatchEvent(s, o))
        }
        _onClick(e) {
            this._dispatchEvent(e, ["click", "pointertap", "tap"])
        }
        _onFocus(e) {
            e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(e, ["mouseover"])
        }
        _onFocusOut(e) {
            e.target.getAttribute("aria-live") || e.target.setAttribute("aria-live", "polite"), this._dispatchEvent(e, ["mouseout"])
        }
        _onKeyDown(e) {
            e.keyCode !== Pie || !this._activateOnTab || this._activate()
        }
        _onMouseMove(e) {
            e.movementX === 0 && e.movementY === 0 || this._deactivate()
        }
        destroy() {
            this._deactivate(), this._destroyTouchHook(), this._div = null, this._pool = null, this._children = null, this._renderer = null, this._activateOnTab && globalThis.removeEventListener("keydown", this._onKeyDown)
        }
        setAccessibilityEnabled(e) {
            e ? this._activate() : this._deactivate()
        }
    };
xx.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "accessibility"
};
xx.defaultOptions = {
    enabledByDefault: !1,
    debug: !1,
    activateOnTab: !0,
    deactivateOnMouseMove: !0
};
let kie = xx;
const Bie = {
        accessible: !1,
        accessibleTitle: null,
        accessibleHint: null,
        tabIndex: 0,
        accessibleType: "button",
        accessibleText: null,
        accessiblePointerEvents: "auto",
        accessibleChildren: !0,
        _accessibleActive: !1,
        _accessibleDiv: null,
        _renderId: -1
    },
    _g = Object.create(null),
    $T = Object.create(null);

function Ou(t, e) {
    let n = $T[t];
    return n === void 0 && (_g[e] === void 0 && (_g[e] = 1), $T[t] = n = _g[e]++), n
}
let Na;

function EB() {
    return (!Na || Na != null && Na.isContextLost()) && (Na = Ge.get().createCanvas().getContext("webgl", {})), Na
}
let ff;

function Die() {
    if (!ff) {
        ff = "mediump";
        const t = EB();
        t && t.getShaderPrecisionFormat && (ff = t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision ? "highp" : "mediump")
    }
    return ff
}

function $ie(t, e, n) {
    return e ? t : n ? (t = t.replace("out vec4 finalColor;", ""), `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in varying
        #define finalColor gl_FragColor
        #define texture texture2D
        #endif
        ${t}
        `) : `

        #ifdef GL_ES // This checks if it is WebGL1
        #define in attribute
        #define out varying
        #endif
        ${t}
        `
}

function Fie(t, e, n) {
    const r = n ? e.maxSupportedFragmentPrecision : e.maxSupportedVertexPrecision;
    if (t.substring(0, 9) !== "precision") {
        let i = n ? e.requestedFragmentPrecision : e.requestedVertexPrecision;
        return i === "highp" && r !== "highp" && (i = "mediump"), `precision ${i} float;
${t}`
    } else if (r !== "highp" && t.substring(0, 15) === "precision highp") return t.replace("precision highp", "precision mediump");
    return t
}

function Lie(t, e) {
    return e ? `#version 300 es
${t}` : t
}
const Nie = {},
    Uie = {};

function Gie(t, {
    name: e = "pixi-program"
}, n = !0) {
    e = e.replace(/\s+/g, "-"), e += n ? "-fragment" : "-vertex";
    const r = n ? Nie : Uie;
    return r[e] ? (r[e]++, e += `-${r[e]}`) : r[e] = 1, t.indexOf("#define SHADER_NAME") !== -1 ? t : `${`#define SHADER_NAME ${e}`}
${t}`
}

function Hie(t, e) {
    return e ? t.replace("#version 300 es", "") : t
}
const bg = {
        stripVersion: Hie,
        ensurePrecision: Fie,
        addProgramDefines: $ie,
        setProgramName: Gie,
        insertVersion: Lie
    },
    xg = Object.create(null),
    SB = class y0 {
        constructor(e) {
            e = { ...y0.defaultOptions,
                ...e
            };
            const n = e.fragment.indexOf("#version 300 es") !== -1,
                r = {
                    stripVersion: n,
                    ensurePrecision: {
                        requestedFragmentPrecision: e.preferredFragmentPrecision,
                        requestedVertexPrecision: e.preferredVertexPrecision,
                        maxSupportedVertexPrecision: "highp",
                        maxSupportedFragmentPrecision: Die()
                    },
                    setProgramName: {
                        name: e.name
                    },
                    addProgramDefines: n,
                    insertVersion: n
                };
            let i = e.fragment,
                s = e.vertex;
            Object.keys(bg).forEach(o => {
                const a = r[o];
                i = bg[o](i, a, !0), s = bg[o](s, a, !1)
            }), this.fragment = i, this.vertex = s, this.transformFeedbackVaryings = e.transformFeedbackVaryings, this._key = Ou(`${this.vertex}:${this.fragment}`, "gl-program")
        }
        destroy() {
            this.fragment = null, this.vertex = null, this._attributeData = null, this._uniformData = null, this._uniformBlockData = null, this.transformFeedbackVaryings = null
        }
        static from(e) {
            const n = `${e.vertex}:${e.fragment}`;
            return xg[n] || (xg[n] = new y0(e)), xg[n]
        }
    };
SB.defaultOptions = {
    preferredVertexPrecision: "highp",
    preferredFragmentPrecision: "mediump"
};
let wa = SB;
const FT = {
    uint8x2: {
        size: 2,
        stride: 2,
        normalised: !1
    },
    uint8x4: {
        size: 4,
        stride: 4,
        normalised: !1
    },
    sint8x2: {
        size: 2,
        stride: 2,
        normalised: !1
    },
    sint8x4: {
        size: 4,
        stride: 4,
        normalised: !1
    },
    unorm8x2: {
        size: 2,
        stride: 2,
        normalised: !0
    },
    unorm8x4: {
        size: 4,
        stride: 4,
        normalised: !0
    },
    snorm8x2: {
        size: 2,
        stride: 2,
        normalised: !0
    },
    snorm8x4: {
        size: 4,
        stride: 4,
        normalised: !0
    },
    uint16x2: {
        size: 2,
        stride: 4,
        normalised: !1
    },
    uint16x4: {
        size: 4,
        stride: 8,
        normalised: !1
    },
    sint16x2: {
        size: 2,
        stride: 4,
        normalised: !1
    },
    sint16x4: {
        size: 4,
        stride: 8,
        normalised: !1
    },
    unorm16x2: {
        size: 2,
        stride: 4,
        normalised: !0
    },
    unorm16x4: {
        size: 4,
        stride: 8,
        normalised: !0
    },
    snorm16x2: {
        size: 2,
        stride: 4,
        normalised: !0
    },
    snorm16x4: {
        size: 4,
        stride: 8,
        normalised: !0
    },
    float16x2: {
        size: 2,
        stride: 4,
        normalised: !1
    },
    float16x4: {
        size: 4,
        stride: 8,
        normalised: !1
    },
    float32: {
        size: 1,
        stride: 4,
        normalised: !1
    },
    float32x2: {
        size: 2,
        stride: 8,
        normalised: !1
    },
    float32x3: {
        size: 3,
        stride: 12,
        normalised: !1
    },
    float32x4: {
        size: 4,
        stride: 16,
        normalised: !1
    },
    uint32: {
        size: 1,
        stride: 4,
        normalised: !1
    },
    uint32x2: {
        size: 2,
        stride: 8,
        normalised: !1
    },
    uint32x3: {
        size: 3,
        stride: 12,
        normalised: !1
    },
    uint32x4: {
        size: 4,
        stride: 16,
        normalised: !1
    },
    sint32: {
        size: 1,
        stride: 4,
        normalised: !1
    },
    sint32x2: {
        size: 2,
        stride: 8,
        normalised: !1
    },
    sint32x3: {
        size: 3,
        stride: 12,
        normalised: !1
    },
    sint32x4: {
        size: 4,
        stride: 16,
        normalised: !1
    }
};

function Xs(t) {
    return FT[t] ? ? FT.float32
}
const zie = {
    f32: "float32",
    "vec2<f32>": "float32x2",
    "vec3<f32>": "float32x3",
    "vec4<f32>": "float32x4",
    vec2f: "float32x2",
    vec3f: "float32x3",
    vec4f: "float32x4",
    i32: "sint32",
    "vec2<i32>": "sint32x2",
    "vec3<i32>": "sint32x3",
    "vec4<i32>": "sint32x4",
    u32: "uint32",
    "vec2<u32>": "uint32x2",
    "vec3<u32>": "uint32x3",
    "vec4<u32>": "uint32x4",
    bool: "uint32",
    "vec2<bool>": "uint32x2",
    "vec3<bool>": "uint32x3",
    "vec4<bool>": "uint32x4"
};

function jie({
    source: t,
    entryPoint: e
}) {
    const n = {},
        r = t.indexOf(`fn ${e}`);
    if (r !== -1) {
        const i = t.indexOf("->", r);
        if (i !== -1) {
            const s = t.substring(r, i),
                o = /@location\((\d+)\)\s+([a-zA-Z0-9_]+)\s*:\s*([a-zA-Z0-9_<>]+)(?:,|\s|$)/g;
            let a;
            for (;
                (a = o.exec(s)) !== null;) {
                const l = zie[a[3]] ? ? "float32";
                n[a[2]] = {
                    location: parseInt(a[1], 10),
                    format: l,
                    stride: Xs(l).stride,
                    offset: 0,
                    instance: !1,
                    start: 0
                }
            }
        }
    }
    return n
}

function wg(t) {
    var d, f;
    const e = /(^|[^/])@(group|binding)\(\d+\)[^;]+;/g,
        n = /@group\((\d+)\)/,
        r = /@binding\((\d+)\)/,
        i = /var(<[^>]+>)? (\w+)/,
        s = /:\s*(\w+)/,
        o = /struct\s+(\w+)\s*{([^}]+)}/g,
        a = /(\w+)\s*:\s*([\w\<\>]+)/g,
        l = /struct\s+(\w+)/,
        c = (d = t.match(e)) == null ? void 0 : d.map(h => ({
            group: parseInt(h.match(n)[1], 10),
            binding: parseInt(h.match(r)[1], 10),
            name: h.match(i)[2],
            isUniform: h.match(i)[1] === "<uniform>",
            type: h.match(s)[1]
        }));
    if (!c) return {
        groups: [],
        structs: []
    };
    const u = ((f = t.match(o)) == null ? void 0 : f.map(h => {
        const p = h.match(l)[1],
            b = h.match(a).reduce((y, m) => {
                const [g, v] = m.split(":");
                return y[g.trim()] = v.trim(), y
            }, {});
        return b ? {
            name: p,
            members: b
        } : null
    }).filter(({
        name: h
    }) => c.some(p => p.type === h))) ? ? [];
    return {
        groups: c,
        structs: u
    }
}
var Oc = (t => (t[t.VERTEX = 1] = "VERTEX", t[t.FRAGMENT = 2] = "FRAGMENT", t[t.COMPUTE = 4] = "COMPUTE", t))(Oc || {});

function Vie({
    groups: t
}) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        e[r.group] || (e[r.group] = []), r.isUniform ? e[r.group].push({
            binding: r.binding,
            visibility: Oc.VERTEX | Oc.FRAGMENT,
            buffer: {
                type: "uniform"
            }
        }) : r.type === "sampler" ? e[r.group].push({
            binding: r.binding,
            visibility: Oc.FRAGMENT,
            sampler: {
                type: "filtering"
            }
        }) : r.type === "texture_2d" && e[r.group].push({
            binding: r.binding,
            visibility: Oc.FRAGMENT,
            texture: {
                sampleType: "float",
                viewDimension: "2d",
                multisampled: !1
            }
        })
    }
    return e
}

function Wie({
    groups: t
}) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
        const r = t[n];
        e[r.group] || (e[r.group] = {}), e[r.group][r.name] = r.binding
    }
    return e
}

function Yie(t, e) {
    const n = new Set,
        r = new Set,
        i = [...t.structs, ...e.structs].filter(o => n.has(o.name) ? !1 : (n.add(o.name), !0)),
        s = [...t.groups, ...e.groups].filter(o => {
            const a = `${o.name}-${o.binding}`;
            return r.has(a) ? !1 : (r.add(a), !0)
        });
    return {
        structs: i,
        groups: s
    }
}
const Eg = Object.create(null);
class io {
    constructor(e) {
        var a, l;
        this._layoutKey = 0, this._attributeLocationsKey = 0;
        const {
            fragment: n,
            vertex: r,
            layout: i,
            gpuLayout: s,
            name: o
        } = e;
        if (this.name = o, this.fragment = n, this.vertex = r, n.source === r.source) {
            const c = wg(n.source);
            this.structsAndGroups = c
        } else {
            const c = wg(r.source),
                u = wg(n.source);
            this.structsAndGroups = Yie(c, u)
        }
        this.layout = i ? ? Wie(this.structsAndGroups), this.gpuLayout = s ? ? Vie(this.structsAndGroups), this.autoAssignGlobalUniforms = ((a = this.layout[0]) == null ? void 0 : a.globalUniforms) !== void 0, this.autoAssignLocalUniforms = ((l = this.layout[1]) == null ? void 0 : l.localUniforms) !== void 0, this._generateProgramKey()
    }
    _generateProgramKey() {
        const {
            vertex: e,
            fragment: n
        } = this, r = e.source + n.source + e.entryPoint + n.entryPoint;
        this._layoutKey = Ou(r, "program")
    }
    get attributeData() {
        return this._attributeData ? ? (this._attributeData = jie(this.vertex)), this._attributeData
    }
    destroy() {
        this.gpuLayout = null, this.layout = null, this.structsAndGroups = null, this.fragment = null, this.vertex = null
    }
    static from(e) {
        const n = `${e.vertex.source}:${e.fragment.source}:${e.fragment.entryPoint}:${e.vertex.entryPoint}`;
        return Eg[n] || (Eg[n] = new io(e)), Eg[n]
    }
}
const TB = ["f32", "i32", "vec2<f32>", "vec3<f32>", "vec4<f32>", "mat2x2<f32>", "mat3x3<f32>", "mat4x4<f32>", "mat3x2<f32>", "mat4x2<f32>", "mat2x3<f32>", "mat4x3<f32>", "mat2x4<f32>", "mat3x4<f32>", "vec2<i32>", "vec3<i32>", "vec4<i32>"],
    Xie = TB.reduce((t, e) => (t[e] = !0, t), {});

function qie(t, e) {
    switch (t) {
        case "f32":
            return 0;
        case "vec2<f32>":
            return new Float32Array(2 * e);
        case "vec3<f32>":
            return new Float32Array(3 * e);
        case "vec4<f32>":
            return new Float32Array(4 * e);
        case "mat2x2<f32>":
            return new Float32Array([1, 0, 0, 1]);
        case "mat3x3<f32>":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case "mat4x4<f32>":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
}
const CB = class PB {
    constructor(e, n) {
        this._touched = 0, this.uid = vt("uniform"), this._resourceType = "uniformGroup", this._resourceId = vt("resource"), this.isUniformGroup = !0, this._dirtyId = 0, this.destroyed = !1, n = { ...PB.defaultOptions,
            ...n
        }, this.uniformStructures = e;
        const r = {};
        for (const i in e) {
            const s = e[i];
            if (s.name = i, s.size = s.size ? ? 1, !Xie[s.type]) throw new Error(`Uniform type ${s.type} is not supported. Supported uniform types are: ${TB.join(", ")}`);
            s.value ? ? (s.value = qie(s.type, s.size)), r[i] = s.value
        }
        this.uniforms = r, this._dirtyId = 1, this.ubo = n.ubo, this.isStatic = n.isStatic, this._signature = Ou(Object.keys(r).map(i => `${i}-${e[i].type}`).join("-"), "uniform-group")
    }
    update() {
        this._dirtyId++
    }
};
CB.defaultOptions = {
    ubo: !1,
    isStatic: !1
};
let Pn = CB;
class Gi {
    constructor(e) {
        this.resources = Object.create(null), this._dirty = !0;
        let n = 0;
        for (const r in e) {
            const i = e[r];
            this.setResource(i, n++)
        }
        this._updateKey()
    }
    _updateKey() {
        if (!this._dirty) return;
        this._dirty = !1;
        const e = [];
        let n = 0;
        for (const r in this.resources) e[n++] = this.resources[r]._resourceId;
        this._key = e.join("|")
    }
    setResource(e, n) {
        var i, s;
        const r = this.resources[n];
        e !== r && (r && ((i = e.off) == null || i.call(e, "change", this.onResourceChange, this)), (s = e.on) == null || s.call(e, "change", this.onResourceChange, this), this.resources[n] = e, this._dirty = !0)
    }
    getResource(e) {
        return this.resources[e]
    }
    _touch(e) {
        const n = this.resources;
        for (const r in n) n[r]._touched = e
    }
    destroy() {
        var n;
        const e = this.resources;
        for (const r in e) {
            const i = e[r];
            (n = i.off) == null || n.call(i, "change", this.onResourceChange, this)
        }
        this.resources = null
    }
    onResourceChange(e) {
        if (this._dirty = !0, e.destroyed) {
            const n = this.resources;
            for (const r in n) n[r] === e && (n[r] = null)
        } else this._updateKey()
    }
}
var tr = (t => (t[t.WEBGL = 1] = "WEBGL", t[t.WEBGPU = 2] = "WEBGPU", t[t.BOTH = 3] = "BOTH", t))(tr || {});
class br extends ir {
    constructor(e) {
        super(), this.uid = vt("shader"), this._uniformBindMap = Object.create(null), this._ownedBindGroups = [];
        let {
            gpuProgram: n,
            glProgram: r,
            groups: i,
            resources: s,
            compatibleRenderers: o,
            groupMap: a
        } = e;
        this.gpuProgram = n, this.glProgram = r, o === void 0 && (o = 0, n && (o |= tr.WEBGPU), r && (o |= tr.WEBGL)), this.compatibleRenderers = o;
        const l = {};
        if (!s && !i && (s = {}), s && i) throw new Error("[Shader] Cannot have both resources and groups");
        if (!n && i && !a) throw new Error("[Shader] No group map or WebGPU shader provided - consider using resources instead.");
        if (!n && i && a)
            for (const c in a)
                for (const u in a[c]) {
                    const d = a[c][u];
                    l[d] = {
                        group: c,
                        binding: u,
                        name: d
                    }
                } else if (n && i && !a) {
                    const c = n.structsAndGroups.groups;
                    a = {}, c.forEach(u => {
                        a[u.group] = a[u.group] || {}, a[u.group][u.binding] = u.name, l[u.name] = u
                    })
                } else if (s) {
            i = {}, a = {}, n && n.structsAndGroups.groups.forEach(d => {
                a[d.group] = a[d.group] || {}, a[d.group][d.binding] = d.name, l[d.name] = d
            });
            let c = 0;
            for (const u in s) l[u] || (i[99] || (i[99] = new Gi, this._ownedBindGroups.push(i[99])), l[u] = {
                group: 99,
                binding: c,
                name: u
            }, a[99] = a[99] || {}, a[99][c] = u, c++);
            for (const u in s) {
                const d = u;
                let f = s[u];
                !f.source && !f._resourceType && (f = new Pn(f));
                const h = l[d];
                h && (i[h.group] || (i[h.group] = new Gi, this._ownedBindGroups.push(i[h.group])), i[h.group].setResource(f, h.binding))
            }
        }
        this.groups = i, this._uniformBindMap = a, this.resources = this._buildResourceAccessor(i, l)
    }
    addResource(e, n, r) {
        var i, s;
        (i = this._uniformBindMap)[n] || (i[n] = {}), (s = this._uniformBindMap[n])[r] || (s[r] = e), this.groups[n] || (this.groups[n] = new Gi, this._ownedBindGroups.push(this.groups[n]))
    }
    _buildResourceAccessor(e, n) {
        const r = {};
        for (const i in n) {
            const s = n[i];
            Object.defineProperty(r, s.name, {
                get() {
                    return e[s.group].getResource(s.binding)
                },
                set(o) {
                    e[s.group].setResource(o, s.binding)
                }
            })
        }
        return r
    }
    destroy(e = !1) {
        var n, r;
        this.emit("destroy", this), e && ((n = this.gpuProgram) == null || n.destroy(), (r = this.glProgram) == null || r.destroy()), this.gpuProgram = null, this.glProgram = null, this.removeAllListeners(), this._uniformBindMap = null, this._ownedBindGroups.forEach(i => {
            i.destroy()
        }), this._ownedBindGroups = null, this.resources = null, this.groups = null
    }
    static from(e) {
        const {
            gpu: n,
            gl: r,
            ...i
        } = e;
        let s, o;
        return n && (s = io.from(n)), r && (o = wa.from(r)), new br({
            gpuProgram: s,
            glProgram: o,
            ...i
        })
    }
}
const Kie = {
        normal: 0,
        add: 1,
        multiply: 2,
        screen: 3,
        overlay: 4,
        erase: 5,
        "normal-npm": 6,
        "add-npm": 7,
        "screen-npm": 8,
        min: 9,
        max: 10
    },
    Sg = 0,
    Tg = 1,
    Cg = 2,
    Pg = 3,
    Ag = 4,
    Og = 5,
    v0 = class AB {
        constructor() {
            this.data = 0, this.blendMode = "normal", this.polygonOffset = 0, this.blend = !0, this.depthMask = !0
        }
        get blend() {
            return !!(this.data & 1 << Sg)
        }
        set blend(e) {
            !!(this.data & 1 << Sg) !== e && (this.data ^= 1 << Sg)
        }
        get offsets() {
            return !!(this.data & 1 << Tg)
        }
        set offsets(e) {
            !!(this.data & 1 << Tg) !== e && (this.data ^= 1 << Tg)
        }
        set cullMode(e) {
            if (e === "none") {
                this.culling = !1;
                return
            }
            this.culling = !0, this.clockwiseFrontFace = e === "front"
        }
        get cullMode() {
            return this.culling ? this.clockwiseFrontFace ? "front" : "back" : "none"
        }
        get culling() {
            return !!(this.data & 1 << Cg)
        }
        set culling(e) {
            !!(this.data & 1 << Cg) !== e && (this.data ^= 1 << Cg)
        }
        get depthTest() {
            return !!(this.data & 1 << Pg)
        }
        set depthTest(e) {
            !!(this.data & 1 << Pg) !== e && (this.data ^= 1 << Pg)
        }
        get depthMask() {
            return !!(this.data & 1 << Og)
        }
        set depthMask(e) {
            !!(this.data & 1 << Og) !== e && (this.data ^= 1 << Og)
        }
        get clockwiseFrontFace() {
            return !!(this.data & 1 << Ag)
        }
        set clockwiseFrontFace(e) {
            !!(this.data & 1 << Ag) !== e && (this.data ^= 1 << Ag)
        }
        get blendMode() {
            return this._blendMode
        }
        set blendMode(e) {
            this.blend = e !== "none", this._blendMode = e, this._blendModeId = Kie[e] || 0
        }
        get polygonOffset() {
            return this._polygonOffset
        }
        set polygonOffset(e) {
            this.offsets = !!e, this._polygonOffset = e
        }
        toString() {
            return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
        }
        static for2d() {
            const e = new AB;
            return e.depthTest = !1, e.blend = !0, e
        }
    };
v0.default2d = v0.for2d();
let Fr = v0;
const OB = class _0 extends br {
    constructor(e) {
        e = { ..._0.defaultOptions,
            ...e
        }, super(e), this.enabled = !0, this._state = Fr.for2d(), this.blendMode = e.blendMode, this.padding = e.padding, typeof e.antialias == "boolean" ? this.antialias = e.antialias ? "on" : "off" : this.antialias = e.antialias, this.resolution = e.resolution, this.blendRequired = e.blendRequired, this.clipToViewport = e.clipToViewport, this.addResource("uTexture", 0, 1)
    }
    apply(e, n, r, i) {
        e.applyFilter(this, n, r, i)
    }
    get blendMode() {
        return this._state.blendMode
    }
    set blendMode(e) {
        this._state.blendMode = e
    }
    static from(e) {
        const {
            gpu: n,
            gl: r,
            ...i
        } = e;
        let s, o;
        return n && (s = io.from(n)), r && (o = wa.from(r)), new _0({
            gpuProgram: s,
            glProgram: o,
            ...i
        })
    }
};
OB.defaultOptions = {
    blendMode: "normal",
    resolution: 1,
    padding: 0,
    antialias: "off",
    blendRequired: !1,
    clipToViewport: !0
};
let wx = OB;
const b0 = [];
Re.handleByNamedList(G.Environment, b0);
async function Jie(t) {
    if (!t)
        for (let e = 0; e < b0.length; e++) {
            const n = b0[e];
            if (n.value.test()) {
                await n.value.load();
                return
            }
        }
}
let yc;

function IB() {
    if (typeof yc == "boolean") return yc;
    try {
        yc = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
            a: "b"
        }, "a", "b") === !0
    } catch {
        yc = !1
    }
    return yc
}

function LT(t, e, n = 2) {
    const r = e && e.length,
        i = r ? e[0] * n : t.length;
    let s = MB(t, 0, i, n, !0);
    const o = [];
    if (!s || s.next === s.prev) return o;
    let a, l, c;
    if (r && (s = nse(t, e, s, n)), t.length > 80 * n) {
        a = t[0], l = t[1];
        let u = a,
            d = l;
        for (let f = n; f < i; f += n) {
            const h = t[f],
                p = t[f + 1];
            h < a && (a = h), p < l && (l = p), h > u && (u = h), p > d && (d = p)
        }
        c = Math.max(u - a, d - l), c = c !== 0 ? 32767 / c : 0
    }
    return Iu(s, o, n, a, l, c, 0), o
}

function MB(t, e, n, r, i) {
    let s;
    if (i === hse(t, e, n, r) > 0)
        for (let o = e; o < n; o += r) s = NT(o / r | 0, t[o], t[o + 1], s);
    else
        for (let o = n - r; o >= e; o -= r) s = NT(o / r | 0, t[o], t[o + 1], s);
    return s && Cl(s, s.next) && (Ru(s), s = s.next), s
}

function sa(t, e) {
    if (!t) return t;
    e || (e = t);
    let n = t,
        r;
    do
        if (r = !1, !n.steiner && (Cl(n, n.next) || Et(n.prev, n, n.next) === 0)) {
            if (Ru(n), n = e = n.prev, n === n.next) break;
            r = !0
        } else n = n.next; while (r || n !== e);
    return e
}

function Iu(t, e, n, r, i, s, o) {
    if (!t) return;
    !o && s && ase(t, r, i, s);
    let a = t;
    for (; t.prev !== t.next;) {
        const l = t.prev,
            c = t.next;
        if (s ? Qie(t, r, i, s) : Zie(t)) {
            e.push(l.i, t.i, c.i), Ru(t), t = c.next, a = c.next;
            continue
        }
        if (t = c, t === a) {
            o ? o === 1 ? (t = ese(sa(t), e), Iu(t, e, n, r, i, s, 2)) : o === 2 && tse(t, e, n, r, i, s) : Iu(sa(t), e, n, r, i, s, 1);
            break
        }
    }
}

function Zie(t) {
    const e = t.prev,
        n = t,
        r = t.next;
    if (Et(e, n, r) >= 0) return !1;
    const i = e.x,
        s = n.x,
        o = r.x,
        a = e.y,
        l = n.y,
        c = r.y,
        u = Math.min(i, s, o),
        d = Math.min(a, l, c),
        f = Math.max(i, s, o),
        h = Math.max(a, l, c);
    let p = r.next;
    for (; p !== e;) {
        if (p.x >= u && p.x <= f && p.y >= d && p.y <= h && Ic(i, a, s, l, o, c, p.x, p.y) && Et(p.prev, p, p.next) >= 0) return !1;
        p = p.next
    }
    return !0
}

function Qie(t, e, n, r) {
    const i = t.prev,
        s = t,
        o = t.next;
    if (Et(i, s, o) >= 0) return !1;
    const a = i.x,
        l = s.x,
        c = o.x,
        u = i.y,
        d = s.y,
        f = o.y,
        h = Math.min(a, l, c),
        p = Math.min(u, d, f),
        b = Math.max(a, l, c),
        y = Math.max(u, d, f),
        m = x0(h, p, e, n, r),
        g = x0(b, y, e, n, r);
    let v = t.prevZ,
        _ = t.nextZ;
    for (; v && v.z >= m && _ && _.z <= g;) {
        if (v.x >= h && v.x <= b && v.y >= p && v.y <= y && v !== i && v !== o && Ic(a, u, l, d, c, f, v.x, v.y) && Et(v.prev, v, v.next) >= 0 || (v = v.prevZ, _.x >= h && _.x <= b && _.y >= p && _.y <= y && _ !== i && _ !== o && Ic(a, u, l, d, c, f, _.x, _.y) && Et(_.prev, _, _.next) >= 0)) return !1;
        _ = _.nextZ
    }
    for (; v && v.z >= m;) {
        if (v.x >= h && v.x <= b && v.y >= p && v.y <= y && v !== i && v !== o && Ic(a, u, l, d, c, f, v.x, v.y) && Et(v.prev, v, v.next) >= 0) return !1;
        v = v.prevZ
    }
    for (; _ && _.z <= g;) {
        if (_.x >= h && _.x <= b && _.y >= p && _.y <= y && _ !== i && _ !== o && Ic(a, u, l, d, c, f, _.x, _.y) && Et(_.prev, _, _.next) >= 0) return !1;
        _ = _.nextZ
    }
    return !0
}

function ese(t, e) {
    let n = t;
    do {
        const r = n.prev,
            i = n.next.next;
        !Cl(r, i) && kB(r, n, n.next, i) && Mu(r, i) && Mu(i, r) && (e.push(r.i, n.i, i.i), Ru(n), Ru(n.next), n = t = i), n = n.next
    } while (n !== t);
    return sa(n)
}

function tse(t, e, n, r, i, s) {
    let o = t;
    do {
        let a = o.next.next;
        for (; a !== o.prev;) {
            if (o.i !== a.i && use(o, a)) {
                let l = BB(o, a);
                o = sa(o, o.next), l = sa(l, l.next), Iu(o, e, n, r, i, s, 0), Iu(l, e, n, r, i, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== t)
}

function nse(t, e, n, r) {
    const i = [];
    for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s] * r,
            l = s < o - 1 ? e[s + 1] * r : t.length,
            c = MB(t, a, l, r, !1);
        c === c.next && (c.steiner = !0), i.push(cse(c))
    }
    i.sort(rse);
    for (let s = 0; s < i.length; s++) n = ise(i[s], n);
    return n
}

function rse(t, e) {
    let n = t.x - e.x;
    if (n === 0 && (n = t.y - e.y, n === 0)) {
        const r = (t.next.y - t.y) / (t.next.x - t.x),
            i = (e.next.y - e.y) / (e.next.x - e.x);
        n = r - i
    }
    return n
}

function ise(t, e) {
    const n = sse(t, e);
    if (!n) return e;
    const r = BB(n, t);
    return sa(r, r.next), sa(n, n.next)
}

function sse(t, e) {
    let n = e;
    const r = t.x,
        i = t.y;
    let s = -1 / 0,
        o;
    if (Cl(t, n)) return n;
    do {
        if (Cl(t, n.next)) return n.next;
        if (i <= n.y && i >= n.next.y && n.next.y !== n.y) {
            const d = n.x + (i - n.y) * (n.next.x - n.x) / (n.next.y - n.y);
            if (d <= r && d > s && (s = d, o = n.x < n.next.x ? n : n.next, d === r)) return o
        }
        n = n.next
    } while (n !== e);
    if (!o) return null;
    const a = o,
        l = o.x,
        c = o.y;
    let u = 1 / 0;
    n = o;
    do {
        if (r >= n.x && n.x >= l && r !== n.x && RB(i < c ? r : s, i, l, c, i < c ? s : r, i, n.x, n.y)) {
            const d = Math.abs(i - n.y) / (r - n.x);
            Mu(n, t) && (d < u || d === u && (n.x > o.x || n.x === o.x && ose(o, n))) && (o = n, u = d)
        }
        n = n.next
    } while (n !== a);
    return o
}

function ose(t, e) {
    return Et(t.prev, t, e.prev) < 0 && Et(e.next, t, t.next) < 0
}

function ase(t, e, n, r) {
    let i = t;
    do i.z === 0 && (i.z = x0(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== t);
    i.prevZ.nextZ = null, i.prevZ = null, lse(i)
}

function lse(t) {
    let e, n = 1;
    do {
        let r = t,
            i;
        t = null;
        let s = null;
        for (e = 0; r;) {
            e++;
            let o = r,
                a = 0;
            for (let c = 0; c < n && (a++, o = o.nextZ, !!o); c++);
            let l = n;
            for (; a > 0 || l > 0 && o;) a !== 0 && (l === 0 || !o || r.z <= o.z) ? (i = r, r = r.nextZ, a--) : (i = o, o = o.nextZ, l--), s ? s.nextZ = i : t = i, i.prevZ = s, s = i;
            r = o
        }
        s.nextZ = null, n *= 2
    } while (e > 1);
    return t
}

function x0(t, e, n, r, i) {
    return t = (t - n) * i | 0, e = (e - r) * i | 0, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t | e << 1
}

function cse(t) {
    let e = t,
        n = t;
    do(e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next; while (e !== t);
    return n
}

function RB(t, e, n, r, i, s, o, a) {
    return (i - o) * (e - a) >= (t - o) * (s - a) && (t - o) * (r - a) >= (n - o) * (e - a) && (n - o) * (s - a) >= (i - o) * (r - a)
}

function Ic(t, e, n, r, i, s, o, a) {
    return !(t === o && e === a) && RB(t, e, n, r, i, s, o, a)
}

function use(t, e) {
    return t.next.i !== e.i && t.prev.i !== e.i && !dse(t, e) && (Mu(t, e) && Mu(e, t) && fse(t, e) && (Et(t.prev, t, e.prev) || Et(t, e.prev, e)) || Cl(t, e) && Et(t.prev, t, t.next) > 0 && Et(e.prev, e, e.next) > 0)
}

function Et(t, e, n) {
    return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
}

function Cl(t, e) {
    return t.x === e.x && t.y === e.y
}

function kB(t, e, n, r) {
    const i = pf(Et(t, e, n)),
        s = pf(Et(t, e, r)),
        o = pf(Et(n, r, t)),
        a = pf(Et(n, r, e));
    return !!(i !== s && o !== a || i === 0 && hf(t, n, e) || s === 0 && hf(t, r, e) || o === 0 && hf(n, t, r) || a === 0 && hf(n, e, r))
}

function hf(t, e, n) {
    return e.x <= Math.max(t.x, n.x) && e.x >= Math.min(t.x, n.x) && e.y <= Math.max(t.y, n.y) && e.y >= Math.min(t.y, n.y)
}

function pf(t) {
    return t > 0 ? 1 : t < 0 ? -1 : 0
}

function dse(t, e) {
    let n = t;
    do {
        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && kB(n, n.next, t, e)) return !0;
        n = n.next
    } while (n !== t);
    return !1
}

function Mu(t, e) {
    return Et(t.prev, t, t.next) < 0 ? Et(t, e, t.next) >= 0 && Et(t, t.prev, e) >= 0 : Et(t, e, t.prev) < 0 || Et(t, t.next, e) < 0
}

function fse(t, e) {
    let n = t,
        r = !1;
    const i = (t.x + e.x) / 2,
        s = (t.y + e.y) / 2;
    do n.y > s != n.next.y > s && n.next.y !== n.y && i < (n.next.x - n.x) * (s - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next; while (n !== t);
    return r
}

function BB(t, e) {
    const n = w0(t.i, t.x, t.y),
        r = w0(e.i, e.x, e.y),
        i = t.next,
        s = e.prev;
    return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, s.next = r, r.prev = s, r
}

function NT(t, e, n, r) {
    const i = w0(t, e, n);
    return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
}

function Ru(t) {
    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
}

function w0(t, e, n) {
    return {
        i: t,
        x: e,
        y: n,
        prev: null,
        next: null,
        z: 0,
        prevZ: null,
        nextZ: null,
        steiner: !1
    }
}

function hse(t, e, n, r) {
    let i = 0;
    for (let s = e, o = n - r; s < n; s += r) i += (t[o] - t[s]) * (t[s + 1] + t[o + 1]), o = s;
    return i
}
const pse = LT.default || LT;
var Yn = (t => (t[t.NONE = 0] = "NONE", t[t.COLOR = 16384] = "COLOR", t[t.STENCIL = 1024] = "STENCIL", t[t.DEPTH = 256] = "DEPTH", t[t.COLOR_DEPTH = 16640] = "COLOR_DEPTH", t[t.COLOR_STENCIL = 17408] = "COLOR_STENCIL", t[t.DEPTH_STENCIL = 1280] = "DEPTH_STENCIL", t[t.ALL = 17664] = "ALL", t))(Yn || {});
class DB {
    constructor(e) {
        this.items = [], this._name = e
    }
    emit(e, n, r, i, s, o, a, l) {
        const {
            name: c,
            items: u
        } = this;
        for (let d = 0, f = u.length; d < f; d++) u[d][c](e, n, r, i, s, o, a, l);
        return this
    }
    add(e) {
        return e[this._name] && (this.remove(e), this.items.push(e)), this
    }
    remove(e) {
        const n = this.items.indexOf(e);
        return n !== -1 && this.items.splice(n, 1), this
    }
    contains(e) {
        return this.items.indexOf(e) !== -1
    }
    removeAll() {
        return this.items.length = 0, this
    }
    destroy() {
        this.removeAll(), this.items = null, this._name = null
    }
    get empty() {
        return this.items.length === 0
    }
    get name() {
        return this._name
    }
}
const mse = ["init", "destroy", "contextChange", "resolutionChange", "resetState", "renderEnd", "renderStart", "render", "update", "postrender", "prerender"],
    $B = class FB extends ir {
        constructor(e) {
            super(), this.uid = vt("renderer"), this.runners = Object.create(null), this.renderPipes = Object.create(null), this._initOptions = {}, this._systemsHash = Object.create(null), this.type = e.type, this.name = e.name, this.config = e;
            const n = [...mse, ...this.config.runners ? ? []];
            this._addRunners(...n), this._unsafeEvalCheck()
        }
        async init(e = {}) {
            const n = e.skipExtensionImports === !0 ? !0 : e.manageImports === !1;
            await Jie(n), this._addSystems(this.config.systems), this._addPipes(this.config.renderPipes, this.config.renderPipeAdaptors);
            for (const r in this._systemsHash) e = { ...this._systemsHash[r].constructor.defaultOptions,
                ...e
            };
            e = { ...FB.defaultOptions,
                ...e
            }, this._roundPixels = e.roundPixels ? 1 : 0;
            for (let r = 0; r < this.runners.init.items.length; r++) await this.runners.init.items[r].init(e);
            this._initOptions = e
        }
        render(e, n) {
            let r = e;
            if (r instanceof er && (r = {
                    container: r
                }, n && (Ie(Ye, "passing a second argument is deprecated, please use render options instead"), r.target = n.renderTexture)), r.target || (r.target = this.view.renderTarget), r.target === this.view.renderTarget && (this._lastObjectRendered = r.container, r.clearColor ? ? (r.clearColor = this.background.colorRgba), r.clear ? ? (r.clear = this.background.clearBeforeRender)), r.clearColor) {
                const i = Array.isArray(r.clearColor) && r.clearColor.length === 4;
                r.clearColor = i ? r.clearColor : tt.shared.setValue(r.clearColor).toArray()
            }
            r.transform || (r.container.updateLocalTransform(), r.transform = r.container.localTransform), r.container.enableRenderGroup(), this.runners.prerender.emit(r), this.runners.renderStart.emit(r), this.runners.render.emit(r), this.runners.renderEnd.emit(r), this.runners.postrender.emit(r)
        }
        resize(e, n, r) {
            const i = this.view.resolution;
            this.view.resize(e, n, r), this.emit("resize", this.view.screen.width, this.view.screen.height, this.view.resolution), r !== void 0 && r !== i && this.runners.resolutionChange.emit(r)
        }
        clear(e = {}) {
            const n = this;
            e.target || (e.target = n.renderTarget.renderTarget), e.clearColor || (e.clearColor = this.background.colorRgba), e.clear ? ? (e.clear = Yn.ALL);
            const {
                clear: r,
                clearColor: i,
                target: s
            } = e;
            tt.shared.setValue(i ? ? this.background.colorRgba), n.renderTarget.clear(s, r, tt.shared.toArray())
        }
        get resolution() {
            return this.view.resolution
        }
        set resolution(e) {
            this.view.resolution = e, this.runners.resolutionChange.emit(e)
        }
        get width() {
            return this.view.texture.frame.width
        }
        get height() {
            return this.view.texture.frame.height
        }
        get canvas() {
            return this.view.canvas
        }
        get lastObjectRendered() {
            return this._lastObjectRendered
        }
        get renderingToScreen() {
            return this.renderTarget.renderingToScreen
        }
        get screen() {
            return this.view.screen
        }
        _addRunners(...e) {
            e.forEach(n => {
                this.runners[n] = new DB(n)
            })
        }
        _addSystems(e) {
            let n;
            for (n in e) {
                const r = e[n];
                this._addSystem(r.value, r.name)
            }
        }
        _addSystem(e, n) {
            const r = new e(this);
            if (this[n]) throw new Error(`Whoops! The name "${n}" is already in use`);
            this[n] = r, this._systemsHash[n] = r;
            for (const i in this.runners) this.runners[i].add(r);
            return this
        }
        _addPipes(e, n) {
            const r = n.reduce((i, s) => (i[s.name] = s.value, i), {});
            e.forEach(i => {
                const s = i.value,
                    o = i.name,
                    a = r[o];
                this.renderPipes[o] = new s(this, a ? new a : null)
            })
        }
        destroy(e = !1) {
            this.runners.destroy.items.reverse(), this.runners.destroy.emit(e), Object.values(this.runners).forEach(n => {
                n.destroy()
            }), this._systemsHash = null, this.renderPipes = null
        }
        generateTexture(e) {
            return this.textureGenerator.generateTexture(e)
        }
        get roundPixels() {
            return !!this._roundPixels
        }
        _unsafeEvalCheck() {
            if (!IB()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")
        }
        resetState() {
            this.runners.resetState.emit()
        }
    };
$B.defaultOptions = {
    resolution: 1,
    failIfMajorPerformanceCaveat: !1,
    roundPixels: !1
};
let em = $B,
    mf;

function gse(t) {
    return mf !== void 0 || (mf = (() => {
        var n;
        const e = {
            stencil: !0,
            failIfMajorPerformanceCaveat: t ? ? em.defaultOptions.failIfMajorPerformanceCaveat
        };
        try {
            if (!Ge.get().getWebGLRenderingContext()) return !1;
            let i = Ge.get().createCanvas().getContext("webgl", e);
            const s = !!((n = i == null ? void 0 : i.getContextAttributes()) != null && n.stencil);
            if (i) {
                const o = i.getExtension("WEBGL_lose_context");
                o && o.loseContext()
            }
            return i = null, s
        } catch {
            return !1
        }
    })()), mf
}
let gf;
async function yse(t = {}) {
    return gf !== void 0 || (gf = await (async () => {
        const e = Ge.get().getNavigator().gpu;
        if (!e) return !1;
        try {
            return await (await e.requestAdapter(t)).requestDevice(), !0
        } catch {
            return !1
        }
    })()), gf
}
const UT = ["webgl", "webgpu", "canvas"];
async function vse(t) {
    let e = [];
    t.preference ? (e.push(t.preference), UT.forEach(s => {
        s !== t.preference && e.push(s)
    })) : e = UT.slice();
    let n, r = {};
    for (let s = 0; s < e.length; s++) {
        const o = e[s];
        if (o === "webgpu" && await yse()) {
            const {
                WebGPURenderer: a
            } = await nh(() => Promise.resolve().then(() => _ue), void 0);
            n = a, r = { ...t,
                ...t.webgpu
            };
            break
        } else if (o === "webgl" && gse(t.failIfMajorPerformanceCaveat ? ? em.defaultOptions.failIfMajorPerformanceCaveat)) {
            const {
                WebGLRenderer: a
            } = await nh(() => Promise.resolve().then(() => eue), void 0);
            n = a, r = { ...t,
                ...t.webgl
            };
            break
        } else if (o === "canvas") throw r = { ...t
        }, new Error("CanvasRenderer is not yet implemented")
    }
    if (delete r.webgpu, delete r.webgl, !n) throw new Error("No available renderer for the current environment");
    const i = new n;
    return await i.init(r), i
}
const Mh = "8.11.0";
class LB {
    static init() {
        var e;
        (e = globalThis.__PIXI_APP_INIT__) == null || e.call(globalThis, this, Mh)
    }
    static destroy() {}
}
LB.extension = G.Application;
class NB {
    constructor(e) {
        this._renderer = e
    }
    init() {
        var e;
        (e = globalThis.__PIXI_RENDERER_INIT__) == null || e.call(globalThis, this._renderer, Mh)
    }
    destroy() {
        this._renderer = null
    }
}
NB.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "initHook",
    priority: -10
};
const UB = class E0 {
    constructor(...e) {
        this.stage = new er, e[0] !== void 0 && Ie(Ye, "Application constructor options are deprecated, please use Application.init() instead.")
    }
    async init(e) {
        e = { ...e
        }, this.renderer = await vse(e), E0._plugins.forEach(n => {
            n.init.call(this, e)
        })
    }
    render() {
        this.renderer.render({
            container: this.stage
        })
    }
    get canvas() {
        return this.renderer.canvas
    }
    get view() {
        return Ie(Ye, "Application.view is deprecated, please use Application.canvas instead."), this.renderer.canvas
    }
    get screen() {
        return this.renderer.screen
    }
    destroy(e = !1, n = !1) {
        const r = E0._plugins.slice(0);
        r.reverse(), r.forEach(i => {
            i.destroy.call(this)
        }), this.stage.destroy(n), this.stage = null, this.renderer.destroy(e), this.renderer = null
    }
};
UB._plugins = [];
let _se = UB;
Re.handleByList(G.Application, _se._plugins);
Re.add(LB);
class GB {
    static init(e) {
        Object.defineProperty(this, "resizeTo", {
            set(n) {
                globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = n, n && (globalThis.addEventListener("resize", this.queueResize), this.resize())
            },
            get() {
                return this._resizeTo
            }
        }), this.queueResize = () => {
            this._resizeTo && (this._cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()))
        }, this._cancelResize = () => {
            this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null)
        }, this.resize = () => {
            if (!this._resizeTo) return;
            this._cancelResize();
            let n, r;
            if (this._resizeTo === globalThis.window) n = globalThis.innerWidth, r = globalThis.innerHeight;
            else {
                const {
                    clientWidth: i,
                    clientHeight: s
                } = this._resizeTo;
                n = i, r = s
            }
            this.renderer.resize(n, r), this.render()
        }, this._resizeId = null, this._resizeTo = null, this.resizeTo = e.resizeTo || null
    }
    static destroy() {
        globalThis.removeEventListener("resize", this.queueResize), this._cancelResize(), this._cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null
    }
}
GB.extension = G.Application;
class HB {
    static init(e) {
        e = Object.assign({
            autoStart: !0,
            sharedTicker: !1
        }, e), Object.defineProperty(this, "ticker", {
            set(n) {
                this._ticker && this._ticker.remove(this.render, this), this._ticker = n, n && n.add(this.render, this, Tl.LOW)
            },
            get() {
                return this._ticker
            }
        }), this.stop = () => {
            this._ticker.stop()
        }, this.start = () => {
            this._ticker.start()
        }, this._ticker = null, this.ticker = e.sharedTicker ? bn.shared : new bn, e.autoStart && this.start()
    }
    static destroy() {
        if (this._ticker) {
            const e = this._ticker;
            this.ticker = null, e.destroy()
        }
    }
}
HB.extension = G.Application;
class zB extends ir {
    constructor() {
        super(...arguments), this.chars = Object.create(null), this.lineHeight = 0, this.fontFamily = "", this.fontMetrics = {
            fontSize: 0,
            ascent: 0,
            descent: 0
        }, this.baseLineOffset = 0, this.distanceField = {
            type: "none",
            range: 0
        }, this.pages = [], this.applyFillAsTint = !0, this.baseMeasurementFontSize = 100, this.baseRenderedFontSize = 100
    }
    get font() {
        return Ie(Ye, "BitmapFont.font is deprecated, please use BitmapFont.fontFamily instead."), this.fontFamily
    }
    get pageTextures() {
        return Ie(Ye, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages
    }
    get size() {
        return Ie(Ye, "BitmapFont.size is deprecated, please use BitmapFont.fontMetrics.fontSize instead."), this.fontMetrics.fontSize
    }
    get distanceFieldRange() {
        return Ie(Ye, "BitmapFont.distanceFieldRange is deprecated, please use BitmapFont.distanceField.range instead."), this.distanceField.range
    }
    get distanceFieldType() {
        return Ie(Ye, "BitmapFont.distanceFieldType is deprecated, please use BitmapFont.distanceField.type instead."), this.distanceField.type
    }
    destroy(e = !1) {
        var n;
        this.emit("destroy", this), this.removeAllListeners();
        for (const r in this.chars)(n = this.chars[r].texture) == null || n.destroy();
        this.chars = null, e && (this.pages.forEach(r => r.texture.destroy(!0)), this.pages = null)
    }
}
const bse = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];

function Rh(t) {
    const e = typeof t.fontSize == "number" ? `${t.fontSize}px` : t.fontSize;
    let n = t.fontFamily;
    Array.isArray(t.fontFamily) || (n = t.fontFamily.split(","));
    for (let r = n.length - 1; r >= 0; r--) {
        let i = n[r].trim();
        !/([\"\'])[^\'\"]+\1/.test(i) && !bse.includes(i) && (i = `"${i}"`), n[r] = i
    }
    return `${t.fontStyle} ${t.fontVariant} ${t.fontWeight} ${e} ${n.join(",")}`
}
const Ig = {
        willReadFrequently: !0
    },
    gi = class Ce {
        static get experimentalLetterSpacingSupported() {
            let e = Ce._experimentalLetterSpacingSupported;
            if (e === void 0) {
                const n = Ge.get().getCanvasRenderingContext2D().prototype;
                e = Ce._experimentalLetterSpacingSupported = "letterSpacing" in n || "textLetterSpacing" in n
            }
            return e
        }
        constructor(e, n, r, i, s, o, a, l, c) {
            this.text = e, this.style = n, this.width = r, this.height = i, this.lines = s, this.lineWidths = o, this.lineHeight = a, this.maxLineWidth = l, this.fontProperties = c
        }
        static measureText(e = " ", n, r = Ce._canvas, i = n.wordWrap) {
            var m;
            const s = Rh(n),
                o = Ce.measureFont(s);
            o.fontSize === 0 && (o.fontSize = n.fontSize, o.ascent = n.fontSize);
            const a = Ce.__context;
            a.font = s;
            const c = (i ? Ce._wordWrap(e, n, r) : e).split(/(?:\r\n|\r|\n)/),
                u = new Array(c.length);
            let d = 0;
            for (let g = 0; g < c.length; g++) {
                const v = Ce._measureText(c[g], n.letterSpacing, a);
                u[g] = v, d = Math.max(d, v)
            }
            const f = ((m = n._stroke) == null ? void 0 : m.width) || 0;
            let h = d + f;
            n.dropShadow && (h += n.dropShadow.distance);
            const p = n.lineHeight || o.fontSize;
            let b = Math.max(p, o.fontSize + f) + (c.length - 1) * (p + n.leading);
            return n.dropShadow && (b += n.dropShadow.distance), new Ce(e, n, h, b, c, u, p + n.leading, d, o)
        }
        static _measureText(e, n, r) {
            let i = !1;
            Ce.experimentalLetterSpacingSupported && (Ce.experimentalLetterSpacing ? (r.letterSpacing = `${n}px`, r.textLetterSpacing = `${n}px`, i = !0) : (r.letterSpacing = "0px", r.textLetterSpacing = "0px"));
            const s = r.measureText(e);
            let o = s.width;
            const a = -s.actualBoundingBoxLeft;
            let c = s.actualBoundingBoxRight - a;
            if (o > 0)
                if (i) o -= n, c -= n;
                else {
                    const u = (Ce.graphemeSegmenter(e).length - 1) * n;
                    o += u, c += u
                }
            return Math.max(o, c)
        }
        static _wordWrap(e, n, r = Ce._canvas) {
            const i = r.getContext("2d", Ig);
            let s = 0,
                o = "",
                a = "";
            const l = Object.create(null),
                {
                    letterSpacing: c,
                    whiteSpace: u
                } = n,
                d = Ce._collapseSpaces(u),
                f = Ce._collapseNewlines(u);
            let h = !d;
            const p = n.wordWrapWidth + c,
                b = Ce._tokenize(e);
            for (let y = 0; y < b.length; y++) {
                let m = b[y];
                if (Ce._isNewline(m)) {
                    if (!f) {
                        a += Ce._addLine(o), h = !d, o = "", s = 0;
                        continue
                    }
                    m = " "
                }
                if (d) {
                    const v = Ce.isBreakingSpace(m),
                        _ = Ce.isBreakingSpace(o[o.length - 1]);
                    if (v && _) continue
                }
                const g = Ce._getFromCache(m, c, l, i);
                if (g > p)
                    if (o !== "" && (a += Ce._addLine(o), o = "", s = 0), Ce.canBreakWords(m, n.breakWords)) {
                        const v = Ce.wordWrapSplit(m);
                        for (let _ = 0; _ < v.length; _++) {
                            let x = v[_],
                                w = x,
                                E = 1;
                            for (; v[_ + E];) {
                                const A = v[_ + E];
                                if (!Ce.canBreakChars(w, A, m, _, n.breakWords)) x += A;
                                else break;
                                w = A, E++
                            }
                            _ += E - 1;
                            const C = Ce._getFromCache(x, c, l, i);
                            C + s > p && (a += Ce._addLine(o), h = !1, o = "", s = 0), o += x, s += C
                        }
                    } else {
                        o.length > 0 && (a += Ce._addLine(o), o = "", s = 0);
                        const v = y === b.length - 1;
                        a += Ce._addLine(m, !v), h = !1, o = "", s = 0
                    }
                else g + s > p && (h = !1, a += Ce._addLine(o), o = "", s = 0), (o.length > 0 || !Ce.isBreakingSpace(m) || h) && (o += m, s += g)
            }
            return a += Ce._addLine(o, !1), a
        }
        static _addLine(e, n = !0) {
            return e = Ce._trimRight(e), e = n ? `${e}
` : e, e
        }
        static _getFromCache(e, n, r, i) {
            let s = r[e];
            return typeof s != "number" && (s = Ce._measureText(e, n, i) + n, r[e] = s), s
        }
        static _collapseSpaces(e) {
            return e === "normal" || e === "pre-line"
        }
        static _collapseNewlines(e) {
            return e === "normal"
        }
        static _trimRight(e) {
            if (typeof e != "string") return "";
            for (let n = e.length - 1; n >= 0; n--) {
                const r = e[n];
                if (!Ce.isBreakingSpace(r)) break;
                e = e.slice(0, -1)
            }
            return e
        }
        static _isNewline(e) {
            return typeof e != "string" ? !1 : Ce._newlines.includes(e.charCodeAt(0))
        }
        static isBreakingSpace(e, n) {
            return typeof e != "string" ? !1 : Ce._breakingSpaces.includes(e.charCodeAt(0))
        }
        static _tokenize(e) {
            const n = [];
            let r = "";
            if (typeof e != "string") return n;
            for (let i = 0; i < e.length; i++) {
                const s = e[i],
                    o = e[i + 1];
                if (Ce.isBreakingSpace(s, o) || Ce._isNewline(s)) {
                    r !== "" && (n.push(r), r = ""), s === "\r" && o === `
` ? (n.push(`\r
`), i++) : n.push(s);
                    continue
                }
                r += s
            }
            return r !== "" && n.push(r), n
        }
        static canBreakWords(e, n) {
            return n
        }
        static canBreakChars(e, n, r, i, s) {
            return !0
        }
        static wordWrapSplit(e) {
            return Ce.graphemeSegmenter(e)
        }
        static measureFont(e) {
            if (Ce._fonts[e]) return Ce._fonts[e];
            const n = Ce._context;
            n.font = e;
            const r = n.measureText(Ce.METRICS_STRING + Ce.BASELINE_SYMBOL),
                i = {
                    ascent: r.actualBoundingBoxAscent,
                    descent: r.actualBoundingBoxDescent,
                    fontSize: r.actualBoundingBoxAscent + r.actualBoundingBoxDescent
                };
            return Ce._fonts[e] = i, i
        }
        static clearMetrics(e = "") {
            e ? delete Ce._fonts[e] : Ce._fonts = {}
        }
        static get _canvas() {
            if (!Ce.__canvas) {
                let e;
                try {
                    const n = new OffscreenCanvas(0, 0),
                        r = n.getContext("2d", Ig);
                    if (r != null && r.measureText) return Ce.__canvas = n, n;
                    e = Ge.get().createCanvas()
                } catch {
                    e = Ge.get().createCanvas()
                }
                e.width = e.height = 10, Ce.__canvas = e
            }
            return Ce.__canvas
        }
        static get _context() {
            return Ce.__context || (Ce.__context = Ce._canvas.getContext("2d", Ig)), Ce.__context
        }
    };
gi.METRICS_STRING = "|q";
gi.BASELINE_SYMBOL = "M";
gi.BASELINE_MULTIPLIER = 1.4;
gi.HEIGHT_MULTIPLIER = 2;
gi.graphemeSegmenter = (() => {
    if (typeof(Intl == null ? void 0 : Intl.Segmenter) == "function") {
        const t = new Intl.Segmenter;
        return e => {
            const n = t.segment(e),
                r = [];
            let i = 0;
            for (const s of n) r[i++] = s.segment;
            return r
        }
    }
    return t => [...t]
})();
gi.experimentalLetterSpacing = !1;
gi._fonts = {};
gi._newlines = [10, 13];
gi._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
let Ir = gi;
const GT = [{
        offset: 0,
        color: "white"
    }, {
        offset: 1,
        color: "black"
    }],
    Ex = class S0 {
        constructor(...e) {
            this.uid = vt("fillGradient"), this.type = "linear", this.colorStops = [];
            let n = xse(e);
            n = { ...n.type === "radial" ? S0.defaultRadialOptions : S0.defaultLinearOptions,
                ...Yk(n)
            }, this._textureSize = n.textureSize, this._wrapMode = n.wrapMode, n.type === "radial" ? (this.center = n.center, this.outerCenter = n.outerCenter ? ? this.center, this.innerRadius = n.innerRadius, this.outerRadius = n.outerRadius, this.scale = n.scale, this.rotation = n.rotation) : (this.start = n.start, this.end = n.end), this.textureSpace = n.textureSpace, this.type = n.type, n.colorStops.forEach(i => {
                this.addColorStop(i.offset, i.color)
            })
        }
        addColorStop(e, n) {
            return this.colorStops.push({
                offset: e,
                color: tt.shared.setValue(n).toHexa()
            }), this
        }
        buildLinearGradient() {
            if (this.texture) return;
            let {
                x: e,
                y: n
            } = this.start, {
                x: r,
                y: i
            } = this.end, s = r - e, o = i - n;
            const a = s < 0 || o < 0;
            if (this._wrapMode === "clamp-to-edge") {
                if (s < 0) {
                    const y = e;
                    e = r, r = y, s *= -1
                }
                if (o < 0) {
                    const y = n;
                    n = i, i = y, o *= -1
                }
            }
            const l = this.colorStops.length ? this.colorStops : GT,
                c = this._textureSize,
                {
                    canvas: u,
                    context: d
                } = zT(c, 1),
                f = a ? d.createLinearGradient(this._textureSize, 0, 0, 0) : d.createLinearGradient(0, 0, this._textureSize, 0);
            HT(f, l), d.fillStyle = f, d.fillRect(0, 0, c, 1), this.texture = new we({
                source: new ia({
                    resource: u,
                    addressMode: this._wrapMode
                })
            });
            const h = Math.sqrt(s * s + o * o),
                p = Math.atan2(o, s),
                b = new Te;
            b.scale(h / c, 1), b.rotate(p), b.translate(e, n), this.textureSpace === "local" && b.scale(c, c), this.transform = b
        }
        buildGradient() {
            this.type === "linear" ? this.buildLinearGradient() : this.buildRadialGradient()
        }
        buildRadialGradient() {
            if (this.texture) return;
            const e = this.colorStops.length ? this.colorStops : GT,
                n = this._textureSize,
                {
                    canvas: r,
                    context: i
                } = zT(n, n),
                {
                    x: s,
                    y: o
                } = this.center,
                {
                    x: a,
                    y: l
                } = this.outerCenter,
                c = this.innerRadius,
                u = this.outerRadius,
                d = a - u,
                f = l - u,
                h = n / (u * 2),
                p = (s - d) * h,
                b = (o - f) * h,
                y = i.createRadialGradient(p, b, c * h, (a - d) * h, (l - f) * h, u * h);
            HT(y, e), i.fillStyle = e[e.length - 1].color, i.fillRect(0, 0, n, n), i.fillStyle = y, i.translate(p, b), i.rotate(this.rotation), i.scale(1, this.scale), i.translate(-p, -b), i.fillRect(0, 0, n, n), this.texture = new we({
                source: new ia({
                    resource: r,
                    addressMode: this._wrapMode
                })
            });
            const m = new Te;
            m.scale(1 / h, 1 / h), m.translate(d, f), this.textureSpace === "local" && m.scale(n, n), this.transform = m
        }
        get styleKey() {
            return this.uid
        }
        destroy() {
            var e;
            (e = this.texture) == null || e.destroy(!0), this.texture = null
        }
    };
Ex.defaultLinearOptions = {
    start: {
        x: 0,
        y: 0
    },
    end: {
        x: 0,
        y: 1
    },
    colorStops: [],
    textureSpace: "local",
    type: "linear",
    textureSize: 256,
    wrapMode: "clamp-to-edge"
};
Ex.defaultRadialOptions = {
    center: {
        x: .5,
        y: .5
    },
    innerRadius: 0,
    outerRadius: .5,
    colorStops: [],
    scale: 1,
    textureSpace: "local",
    type: "radial",
    textureSize: 256,
    wrapMode: "clamp-to-edge"
};
let Qi = Ex;

function HT(t, e) {
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        t.addColorStop(r.offset, r.color)
    }
}

function zT(t, e) {
    const n = Ge.get().createCanvas(t, e),
        r = n.getContext("2d");
    return {
        canvas: n,
        context: r
    }
}

function xse(t) {
    let e = t[0] ? ? {};
    return (typeof e == "number" || t[1]) && (Ie("8.5.2", "use options object instead"), e = {
        type: "linear",
        start: {
            x: t[0],
            y: t[1]
        },
        end: {
            x: t[2],
            y: t[3]
        },
        textureSpace: t[4],
        textureSize: t[5] ? ? Qi.defaultLinearOptions.textureSize
    }), e
}
const jT = {
    repeat: {
        addressModeU: "repeat",
        addressModeV: "repeat"
    },
    "repeat-x": {
        addressModeU: "repeat",
        addressModeV: "clamp-to-edge"
    },
    "repeat-y": {
        addressModeU: "clamp-to-edge",
        addressModeV: "repeat"
    },
    "no-repeat": {
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
    }
};
class tm {
    constructor(e, n) {
        this.uid = vt("fillPattern"), this.transform = new Te, this._styleKey = null, this.texture = e, this.transform.scale(1 / e.frame.width, 1 / e.frame.height), n && (e.source.style.addressModeU = jT[n].addressModeU, e.source.style.addressModeV = jT[n].addressModeV)
    }
    setTransform(e) {
        const n = this.texture;
        this.transform.copyFrom(e), this.transform.invert(), this.transform.scale(1 / n.frame.width, 1 / n.frame.height), this._styleKey = null
    }
    get styleKey() {
        return this._styleKey ? this._styleKey : (this._styleKey = `fill-pattern-${this.uid}-${this.texture.uid}-${this.transform.toArray().join("-")}`, this._styleKey)
    }
}
var wse = Sse,
    Mg = {
        a: 7,
        c: 6,
        h: 1,
        l: 2,
        m: 2,
        q: 4,
        s: 4,
        t: 2,
        v: 1,
        z: 0
    },
    Ese = /([astvzqmhlc])([^astvzqmhlc]*)/ig;

function Sse(t) {
    var e = [];
    return t.replace(Ese, function(n, r, i) {
        var s = r.toLowerCase();
        for (i = Cse(i), s == "m" && i.length > 2 && (e.push([r].concat(i.splice(0, 2))), s = "l", r = r == "m" ? "l" : "L");;) {
            if (i.length == Mg[s]) return i.unshift(r), e.push(i);
            if (i.length < Mg[s]) throw new Error("malformed path data");
            e.push([r].concat(i.splice(0, Mg[s])))
        }
    }), e
}
var Tse = /-?[0-9]*\.?[0-9]+(?:e[-+]?\d+)?/ig;

function Cse(t) {
    var e = t.match(Tse);
    return e ? e.map(Number) : []
}
const Pse = Hl(wse);

function Ase(t, e) {
    const n = Pse(t),
        r = [];
    let i = null,
        s = 0,
        o = 0;
    for (let a = 0; a < n.length; a++) {
        const l = n[a],
            c = l[0],
            u = l;
        switch (c) {
            case "M":
                s = u[1], o = u[2], e.moveTo(s, o);
                break;
            case "m":
                s += u[1], o += u[2], e.moveTo(s, o);
                break;
            case "H":
                s = u[1], e.lineTo(s, o);
                break;
            case "h":
                s += u[1], e.lineTo(s, o);
                break;
            case "V":
                o = u[1], e.lineTo(s, o);
                break;
            case "v":
                o += u[1], e.lineTo(s, o);
                break;
            case "L":
                s = u[1], o = u[2], e.lineTo(s, o);
                break;
            case "l":
                s += u[1], o += u[2], e.lineTo(s, o);
                break;
            case "C":
                s = u[5], o = u[6], e.bezierCurveTo(u[1], u[2], u[3], u[4], s, o);
                break;
            case "c":
                e.bezierCurveTo(s + u[1], o + u[2], s + u[3], o + u[4], s + u[5], o + u[6]), s += u[5], o += u[6];
                break;
            case "S":
                s = u[3], o = u[4], e.bezierCurveToShort(u[1], u[2], s, o);
                break;
            case "s":
                e.bezierCurveToShort(s + u[1], o + u[2], s + u[3], o + u[4]), s += u[3], o += u[4];
                break;
            case "Q":
                s = u[3], o = u[4], e.quadraticCurveTo(u[1], u[2], s, o);
                break;
            case "q":
                e.quadraticCurveTo(s + u[1], o + u[2], s + u[3], o + u[4]), s += u[3], o += u[4];
                break;
            case "T":
                s = u[1], o = u[2], e.quadraticCurveToShort(s, o);
                break;
            case "t":
                s += u[1], o += u[2], e.quadraticCurveToShort(s, o);
                break;
            case "A":
                s = u[6], o = u[7], e.arcToSvg(u[1], u[2], u[3], u[4], u[5], s, o);
                break;
            case "a":
                s += u[6], o += u[7], e.arcToSvg(u[1], u[2], u[3], u[4], u[5], s, o);
                break;
            case "Z":
            case "z":
                e.closePath(), r.length > 0 && (i = r.pop(), i ? (s = i.startX, o = i.startY) : (s = 0, o = 0)), i = null;
                break;
            default:
                Oe(`Unknown SVG path command: ${c}`)
        }
        c !== "Z" && c !== "z" && i === null && (i = {
            startX: s,
            startY: o
        }, r.push(i))
    }
    return e
}
class Sx {
    constructor(e = 0, n = 0, r = 0) {
        this.type = "circle", this.x = e, this.y = n, this.radius = r
    }
    clone() {
        return new Sx(this.x, this.y, this.radius)
    }
    contains(e, n) {
        if (this.radius <= 0) return !1;
        const r = this.radius * this.radius;
        let i = this.x - e,
            s = this.y - n;
        return i *= i, s *= s, i + s <= r
    }
    strokeContains(e, n, r, i = .5) {
        if (this.radius === 0) return !1;
        const s = this.x - e,
            o = this.y - n,
            a = this.radius,
            l = (1 - i) * r,
            c = Math.sqrt(s * s + o * o);
        return c <= a + l && c > a - (r - l)
    }
    getBounds(e) {
        return e || (e = new it), e.x = this.x - this.radius, e.y = this.y - this.radius, e.width = this.radius * 2, e.height = this.radius * 2, e
    }
    copyFrom(e) {
        return this.x = e.x, this.y = e.y, this.radius = e.radius, this
    }
    copyTo(e) {
        return e.copyFrom(this), e
    }
    toString() {
        return `[pixi.js/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
    }
}
class Tx {
    constructor(e = 0, n = 0, r = 0, i = 0) {
        this.type = "ellipse", this.x = e, this.y = n, this.halfWidth = r, this.halfHeight = i
    }
    clone() {
        return new Tx(this.x, this.y, this.halfWidth, this.halfHeight)
    }
    contains(e, n) {
        if (this.halfWidth <= 0 || this.halfHeight <= 0) return !1;
        let r = (e - this.x) / this.halfWidth,
            i = (n - this.y) / this.halfHeight;
        return r *= r, i *= i, r + i <= 1
    }
    strokeContains(e, n, r, i = .5) {
        const {
            halfWidth: s,
            halfHeight: o
        } = this;
        if (s <= 0 || o <= 0) return !1;
        const a = r * (1 - i),
            l = r - a,
            c = s - l,
            u = o - l,
            d = s + a,
            f = o + a,
            h = e - this.x,
            p = n - this.y,
            b = h * h / (c * c) + p * p / (u * u),
            y = h * h / (d * d) + p * p / (f * f);
        return b > 1 && y <= 1
    }
    getBounds(e) {
        return e || (e = new it), e.x = this.x - this.halfWidth, e.y = this.y - this.halfHeight, e.width = this.halfWidth * 2, e.height = this.halfHeight * 2, e
    }
    copyFrom(e) {
        return this.x = e.x, this.y = e.y, this.halfWidth = e.halfWidth, this.halfHeight = e.halfHeight, this
    }
    copyTo(e) {
        return e.copyFrom(this), e
    }
    toString() {
        return `[pixi.js/math:Ellipse x=${this.x} y=${this.y} halfWidth=${this.halfWidth} halfHeight=${this.halfHeight}]`
    }
}

function Ose(t, e, n, r, i, s) {
    const o = t - n,
        a = e - r,
        l = i - n,
        c = s - r,
        u = o * l + a * c,
        d = l * l + c * c;
    let f = -1;
    d !== 0 && (f = u / d);
    let h, p;
    f < 0 ? (h = n, p = r) : f > 1 ? (h = i, p = s) : (h = n + f * l, p = r + f * c);
    const b = t - h,
        y = e - p;
    return b * b + y * y
}
let Ise, Mse;
class qc {
    constructor(...e) {
        this.type = "polygon";
        let n = Array.isArray(e[0]) ? e[0] : e;
        if (typeof n[0] != "number") {
            const r = [];
            for (let i = 0, s = n.length; i < s; i++) r.push(n[i].x, n[i].y);
            n = r
        }
        this.points = n, this.closePath = !0
    }
    isClockwise() {
        let e = 0;
        const n = this.points,
            r = n.length;
        for (let i = 0; i < r; i += 2) {
            const s = n[i],
                o = n[i + 1],
                a = n[(i + 2) % r],
                l = n[(i + 3) % r];
            e += (a - s) * (l + o)
        }
        return e < 0
    }
    containsPolygon(e) {
        const n = this.getBounds(Ise),
            r = e.getBounds(Mse);
        if (!n.containsRect(r)) return !1;
        const i = e.points;
        for (let s = 0; s < i.length; s += 2) {
            const o = i[s],
                a = i[s + 1];
            if (!this.contains(o, a)) return !1
        }
        return !0
    }
    clone() {
        const e = this.points.slice(),
            n = new qc(e);
        return n.closePath = this.closePath, n
    }
    contains(e, n) {
        let r = !1;
        const i = this.points.length / 2;
        for (let s = 0, o = i - 1; s < i; o = s++) {
            const a = this.points[s * 2],
                l = this.points[s * 2 + 1],
                c = this.points[o * 2],
                u = this.points[o * 2 + 1];
            l > n != u > n && e < (c - a) * ((n - l) / (u - l)) + a && (r = !r)
        }
        return r
    }
    strokeContains(e, n, r, i = .5) {
        const s = r * r,
            o = s * (1 - i),
            a = s - o,
            {
                points: l
            } = this,
            c = l.length - (this.closePath ? 0 : 2);
        for (let u = 0; u < c; u += 2) {
            const d = l[u],
                f = l[u + 1],
                h = l[(u + 2) % l.length],
                p = l[(u + 3) % l.length],
                b = Ose(e, n, d, f, h, p),
                y = Math.sign((h - d) * (n - f) - (p - f) * (e - d));
            if (b <= (y < 0 ? a : o)) return !0
        }
        return !1
    }
    getBounds(e) {
        e || (e = new it);
        const n = this.points;
        let r = 1 / 0,
            i = -1 / 0,
            s = 1 / 0,
            o = -1 / 0;
        for (let a = 0, l = n.length; a < l; a += 2) {
            const c = n[a],
                u = n[a + 1];
            r = c < r ? c : r, i = c > i ? c : i, s = u < s ? u : s, o = u > o ? u : o
        }
        return e.x = r, e.width = i - r, e.y = s, e.height = o - s, e
    }
    copyFrom(e) {
        return this.points = e.points.slice(), this.closePath = e.closePath, this
    }
    copyTo(e) {
        return e.copyFrom(this), e
    }
    toString() {
        return `[pixi.js/math:PolygoncloseStroke=${this.closePath}points=${this.points.reduce((e,n)=>`${e}, ${n}`,"")}]`
    }
    get lastX() {
        return this.points[this.points.length - 2]
    }
    get lastY() {
        return this.points[this.points.length - 1]
    }
    get x() {
        return Ie("8.11.0", "Polygon.lastX is deprecated, please use Polygon.lastX instead."), this.points[this.points.length - 2]
    }
    get y() {
        return Ie("8.11.0", "Polygon.y is deprecated, please use Polygon.lastY instead."), this.points[this.points.length - 1]
    }
    get startX() {
        return this.points[0]
    }
    get startY() {
        return this.points[1]
    }
}
const yf = (t, e, n, r, i, s, o) => {
    const a = t - n,
        l = e - r,
        c = Math.sqrt(a * a + l * l);
    return c >= i - s && c <= i + o
};
class Cx {
    constructor(e = 0, n = 0, r = 0, i = 0, s = 20) {
        this.type = "roundedRectangle", this.x = e, this.y = n, this.width = r, this.height = i, this.radius = s
    }
    getBounds(e) {
        return e || (e = new it), e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e
    }
    clone() {
        return new Cx(this.x, this.y, this.width, this.height, this.radius)
    }
    copyFrom(e) {
        return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this
    }
    copyTo(e) {
        return e.copyFrom(this), e
    }
    contains(e, n) {
        if (this.width <= 0 || this.height <= 0) return !1;
        if (e >= this.x && e <= this.x + this.width && n >= this.y && n <= this.y + this.height) {
            const r = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (n >= this.y + r && n <= this.y + this.height - r || e >= this.x + r && e <= this.x + this.width - r) return !0;
            let i = e - (this.x + r),
                s = n - (this.y + r);
            const o = r * r;
            if (i * i + s * s <= o || (i = e - (this.x + this.width - r), i * i + s * s <= o) || (s = n - (this.y + this.height - r), i * i + s * s <= o) || (i = e - (this.x + r), i * i + s * s <= o)) return !0
        }
        return !1
    }
    strokeContains(e, n, r, i = .5) {
        const {
            x: s,
            y: o,
            width: a,
            height: l,
            radius: c
        } = this, u = r * (1 - i), d = r - u, f = s + c, h = o + c, p = a - c * 2, b = l - c * 2, y = s + a, m = o + l;
        return (e >= s - u && e <= s + d || e >= y - d && e <= y + u) && n >= h && n <= h + b || (n >= o - u && n <= o + d || n >= m - d && n <= m + u) && e >= f && e <= f + p ? !0 : e < f && n < h && yf(e, n, f, h, c, d, u) || e > y - c && n < h && yf(e, n, y - c, h, c, d, u) || e > y - c && n > m - c && yf(e, n, y - c, m - c, c, d, u) || e < f && n > m - c && yf(e, n, f, m - c, c, d, u)
    }
    toString() {
        return `[pixi.js/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
    }
}
const jB = {};

function Px(t, e, n) {
    let r = 2166136261;
    for (let i = 0; i < e; i++) r ^= t[i].uid, r = Math.imul(r, 16777619), r >>>= 0;
    return jB[r] || Rse(t, e, r, n)
}

function Rse(t, e, n, r) {
    const i = {};
    let s = 0;
    for (let a = 0; a < r; a++) {
        const l = a < e ? t[a] : we.EMPTY.source;
        i[s++] = l.source, i[s++] = l.style
    }
    const o = new Gi(i);
    return jB[n] = o, o
}
class Za {
    constructor(e) {
        typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData), this.size = this.rawBinaryData.byteLength
    }
    get int8View() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View
    }
    get uint8View() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View
    }
    get int16View() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View
    }
    get int32View() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View
    }
    get float64View() {
        return this._float64Array || (this._float64Array = new Float64Array(this.rawBinaryData)), this._float64Array
    }
    get bigUint64View() {
        return this._bigUint64Array || (this._bigUint64Array = new BigUint64Array(this.rawBinaryData)), this._bigUint64Array
    }
    view(e) {
        return this[`${e}View`]
    }
    destroy() {
        this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this.uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null
    }
    static sizeOf(e) {
        switch (e) {
            case "int8":
            case "uint8":
                return 1;
            case "int16":
            case "uint16":
                return 2;
            case "int32":
            case "uint32":
            case "float32":
                return 4;
            default:
                throw new Error(`${e} isn't a valid view type`)
        }
    }
}

function T0(t, e) {
    const n = t.byteLength / 8 | 0,
        r = new Float64Array(t, 0, n);
    new Float64Array(e, 0, n).set(r);
    const s = t.byteLength - n * 8;
    if (s > 0) {
        const o = new Uint8Array(t, n * 8, s);
        new Uint8Array(e, n * 8, s).set(o)
    }
}
const kse = {
    normal: "normal-npm",
    add: "add-npm",
    screen: "screen-npm"
};
var Bt = (t => (t[t.DISABLED = 0] = "DISABLED", t[t.RENDERING_MASK_ADD = 1] = "RENDERING_MASK_ADD", t[t.MASK_ACTIVE = 2] = "MASK_ACTIVE", t[t.INVERSE_MASK_ACTIVE = 3] = "INVERSE_MASK_ACTIVE", t[t.RENDERING_MASK_REMOVE = 4] = "RENDERING_MASK_REMOVE", t[t.NONE = 5] = "NONE", t))(Bt || {});

function ku(t, e) {
    return e.alphaMode === "no-premultiply-alpha" && kse[t] || t
}
const Bse = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);

function Dse(t) {
    let e = "";
    for (let n = 0; n < t; ++n) n > 0 && (e += `
else `), n < t - 1 && (e += `if(test == ${n}.0){}`);
    return e
}

function VB(t, e) {
    if (t === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const n = e.createShader(e.FRAGMENT_SHADER);
    try {
        for (;;) {
            const r = Bse.replace(/%forloop%/gi, Dse(t));
            if (e.shaderSource(n, r), e.compileShader(n), !e.getShaderParameter(n, e.COMPILE_STATUS)) t = t / 2 | 0;
            else break
        }
    } finally {
        e.deleteShader(n)
    }
    return t
}
let Ua = null;

function $se() {
    var e;
    if (Ua) return Ua;
    const t = EB();
    return Ua = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), Ua = VB(Ua, t), (e = t.getExtension("WEBGL_lose_context")) == null || e.loseContext(), Ua
}
class Fse {
    constructor() {
        this.ids = Object.create(null), this.textures = [], this.count = 0
    }
    clear() {
        for (let e = 0; e < this.count; e++) {
            const n = this.textures[e];
            this.textures[e] = null, this.ids[n.uid] = null
        }
        this.count = 0
    }
}
class Lse {
    constructor() {
        this.renderPipeId = "batch", this.action = "startBatch", this.start = 0, this.size = 0, this.textures = new Fse, this.blendMode = "normal", this.topology = "triangle-strip", this.canBundle = !0
    }
    destroy() {
        this.textures = null, this.gpuBindGroup = null, this.bindGroup = null, this.batcher = null
    }
}
const WB = [];
let C0 = 0;

function VT() {
    return C0 > 0 ? WB[--C0] : new Lse
}

function WT(t) {
    WB[C0++] = t
}
let vc = 0;
const YB = class XB {
    constructor(e) {
        this.uid = vt("batcher"), this.dirty = !0, this.batchIndex = 0, this.batches = [], this._elements = [], e = { ...XB.defaultOptions,
            ...e
        }, e.maxTextures || (Ie("v8.8.0", "maxTextures is a required option for Batcher now, please pass it in the options"), e.maxTextures = $se());
        const {
            maxTextures: n,
            attributesInitialSize: r,
            indicesInitialSize: i
        } = e;
        this.attributeBuffer = new Za(r * 4), this.indexBuffer = new Uint16Array(i), this.maxTextures = n
    }
    begin() {
        this.elementSize = 0, this.elementStart = 0, this.indexSize = 0, this.attributeSize = 0;
        for (let e = 0; e < this.batchIndex; e++) WT(this.batches[e]);
        this.batchIndex = 0, this._batchIndexStart = 0, this._batchIndexSize = 0, this.dirty = !0
    }
    add(e) {
        this._elements[this.elementSize++] = e, e._indexStart = this.indexSize, e._attributeStart = this.attributeSize, e._batcher = this, this.indexSize += e.indexSize, this.attributeSize += e.attributeSize * this.vertexSize
    }
    checkAndUpdateTexture(e, n) {
        const r = e._batch.textures.ids[n._source.uid];
        return !r && r !== 0 ? !1 : (e._textureId = r, e.texture = n, !0)
    }
    updateElement(e) {
        this.dirty = !0;
        const n = this.attributeBuffer;
        e.packAsQuad ? this.packQuadAttributes(e, n.float32View, n.uint32View, e._attributeStart, e._textureId) : this.packAttributes(e, n.float32View, n.uint32View, e._attributeStart, e._textureId)
    }
    break (e) {
        const n = this._elements;
        if (!n[this.elementStart]) return;
        let r = VT(),
            i = r.textures;
        i.clear();
        const s = n[this.elementStart];
        let o = ku(s.blendMode, s.texture._source),
            a = s.topology;
        this.attributeSize * 4 > this.attributeBuffer.size && this._resizeAttributeBuffer(this.attributeSize * 4), this.indexSize > this.indexBuffer.length && this._resizeIndexBuffer(this.indexSize);
        const l = this.attributeBuffer.float32View,
            c = this.attributeBuffer.uint32View,
            u = this.indexBuffer;
        let d = this._batchIndexSize,
            f = this._batchIndexStart,
            h = "startBatch";
        const p = this.maxTextures;
        for (let b = this.elementStart; b < this.elementSize; ++b) {
            const y = n[b];
            n[b] = null;
            const g = y.texture._source,
                v = ku(y.blendMode, g),
                _ = o !== v || a !== y.topology;
            if (g._batchTick === vc && !_) {
                y._textureId = g._textureBindLocation, d += y.indexSize, y.packAsQuad ? (this.packQuadAttributes(y, l, c, y._attributeStart, y._textureId), this.packQuadIndex(u, y._indexStart, y._attributeStart / this.vertexSize)) : (this.packAttributes(y, l, c, y._attributeStart, y._textureId), this.packIndex(y, u, y._indexStart, y._attributeStart / this.vertexSize)), y._batch = r;
                continue
            }
            g._batchTick = vc, (i.count >= p || _) && (this._finishBatch(r, f, d - f, i, o, a, e, h), h = "renderBatch", f = d, o = v, a = y.topology, r = VT(), i = r.textures, i.clear(), ++vc), y._textureId = g._textureBindLocation = i.count, i.ids[g.uid] = i.count, i.textures[i.count++] = g, y._batch = r, d += y.indexSize, y.packAsQuad ? (this.packQuadAttributes(y, l, c, y._attributeStart, y._textureId), this.packQuadIndex(u, y._indexStart, y._attributeStart / this.vertexSize)) : (this.packAttributes(y, l, c, y._attributeStart, y._textureId), this.packIndex(y, u, y._indexStart, y._attributeStart / this.vertexSize))
        }
        i.count > 0 && (this._finishBatch(r, f, d - f, i, o, a, e, h), f = d, ++vc), this.elementStart = this.elementSize, this._batchIndexStart = f, this._batchIndexSize = d
    }
    _finishBatch(e, n, r, i, s, o, a, l) {
        e.gpuBindGroup = null, e.bindGroup = null, e.action = l, e.batcher = this, e.textures = i, e.blendMode = s, e.topology = o, e.start = n, e.size = r, ++vc, this.batches[this.batchIndex++] = e, a.add(e)
    }
    finish(e) {
        this.break(e)
    }
    ensureAttributeBuffer(e) {
        e * 4 <= this.attributeBuffer.size || this._resizeAttributeBuffer(e * 4)
    }
    ensureIndexBuffer(e) {
        e <= this.indexBuffer.length || this._resizeIndexBuffer(e)
    }
    _resizeAttributeBuffer(e) {
        const n = Math.max(e, this.attributeBuffer.size * 2),
            r = new Za(n);
        T0(this.attributeBuffer.rawBinaryData, r.rawBinaryData), this.attributeBuffer = r
    }
    _resizeIndexBuffer(e) {
        const n = this.indexBuffer;
        let r = Math.max(e, n.length * 1.5);
        r += r % 2;
        const i = r > 65535 ? new Uint32Array(r) : new Uint16Array(r);
        if (i.BYTES_PER_ELEMENT !== n.BYTES_PER_ELEMENT)
            for (let s = 0; s < n.length; s++) i[s] = n[s];
        else T0(n.buffer, i.buffer);
        this.indexBuffer = i
    }
    packQuadIndex(e, n, r) {
        e[n] = r + 0, e[n + 1] = r + 1, e[n + 2] = r + 2, e[n + 3] = r + 0, e[n + 4] = r + 2, e[n + 5] = r + 3
    }
    packIndex(e, n, r, i) {
        const s = e.indices,
            o = e.indexSize,
            a = e.indexOffset,
            l = e.attributeOffset;
        for (let c = 0; c < o; c++) n[r++] = i + s[c + a] - l
    }
    destroy() {
        for (let e = 0; e < this.batches.length; e++) WT(this.batches[e]);
        this.batches = null;
        for (let e = 0; e < this._elements.length; e++) this._elements[e]._batch = null;
        this._elements = null, this.indexBuffer = null, this.attributeBuffer.destroy(), this.attributeBuffer = null
    }
};
YB.defaultOptions = {
    maxTextures: null,
    attributesInitialSize: 4,
    indicesInitialSize: 6
};
let Nse = YB;
var Xe = (t => (t[t.MAP_READ = 1] = "MAP_READ", t[t.MAP_WRITE = 2] = "MAP_WRITE", t[t.COPY_SRC = 4] = "COPY_SRC", t[t.COPY_DST = 8] = "COPY_DST", t[t.INDEX = 16] = "INDEX", t[t.VERTEX = 32] = "VERTEX", t[t.UNIFORM = 64] = "UNIFORM", t[t.STORAGE = 128] = "STORAGE", t[t.INDIRECT = 256] = "INDIRECT", t[t.QUERY_RESOLVE = 512] = "QUERY_RESOLVE", t[t.STATIC = 1024] = "STATIC", t))(Xe || {});
let Jn = class extends ir {
    constructor(e) {
        let {
            data: n,
            size: r
        } = e;
        const {
            usage: i,
            label: s,
            shrinkToFit: o
        } = e;
        super(), this.uid = vt("buffer"), this._resourceType = "buffer", this._resourceId = vt("resource"), this._touched = 0, this._updateID = 1, this._dataInt32 = null, this.shrinkToFit = !0, this.destroyed = !1, n instanceof Array && (n = new Float32Array(n)), this._data = n, r ? ? (r = n == null ? void 0 : n.byteLength);
        const a = !!n;
        this.descriptor = {
            size: r,
            usage: i,
            mappedAtCreation: a,
            label: s
        }, this.shrinkToFit = o ? ? !0
    }
    get data() {
        return this._data
    }
    set data(e) {
        this.setDataWithSize(e, e.length, !0)
    }
    get dataInt32() {
        return this._dataInt32 || (this._dataInt32 = new Int32Array(this.data.buffer)), this._dataInt32
    }
    get static() {
        return !!(this.descriptor.usage & Xe.STATIC)
    }
    set static(e) {
        e ? this.descriptor.usage |= Xe.STATIC : this.descriptor.usage &= ~Xe.STATIC
    }
    setDataWithSize(e, n, r) {
        if (this._updateID++, this._updateSize = n * e.BYTES_PER_ELEMENT, this._data === e) {
            r && this.emit("update", this);
            return
        }
        const i = this._data;
        if (this._data = e, this._dataInt32 = null, !i || i.length !== e.length) {
            !this.shrinkToFit && i && e.byteLength < i.byteLength ? r && this.emit("update", this) : (this.descriptor.size = e.byteLength, this._resourceId = vt("resource"), this.emit("change", this));
            return
        }
        r && this.emit("update", this)
    }
    update(e) {
        this._updateSize = e ? ? this._updateSize, this._updateID++, this.emit("update", this)
    }
    destroy() {
        this.destroyed = !0, this.emit("destroy", this), this.emit("change", this), this._data = null, this.descriptor = null, this.removeAllListeners()
    }
};

function qB(t, e) {
    if (!(t instanceof Jn)) {
        let n = e ? Xe.INDEX : Xe.VERTEX;
        t instanceof Array && (e ? (t = new Uint32Array(t), n = Xe.INDEX | Xe.COPY_DST) : (t = new Float32Array(t), n = Xe.VERTEX | Xe.COPY_DST)), t = new Jn({
            data: t,
            label: e ? "index-mesh-buffer" : "vertex-mesh-buffer",
            usage: n
        })
    }
    return t
}

function Use(t, e, n) {
    const r = t.getAttribute(e);
    if (!r) return n.minX = 0, n.minY = 0, n.maxX = 0, n.maxY = 0, n;
    const i = r.buffer.data;
    let s = 1 / 0,
        o = 1 / 0,
        a = -1 / 0,
        l = -1 / 0;
    const c = i.BYTES_PER_ELEMENT,
        u = (r.offset || 0) / c,
        d = (r.stride || 2 * 4) / c;
    for (let f = u; f < i.length; f += d) {
        const h = i[f],
            p = i[f + 1];
        h > a && (a = h), p > l && (l = p), h < s && (s = h), p < o && (o = p)
    }
    return n.minX = s, n.minY = o, n.maxX = a, n.maxY = l, n
}

function Gse(t) {
    return (t instanceof Jn || Array.isArray(t) || t.BYTES_PER_ELEMENT) && (t = {
        buffer: t
    }), t.buffer = qB(t.buffer, !1), t
}
class hd extends ir {
    constructor(e = {}) {
        super(), this.uid = vt("geometry"), this._layoutKey = 0, this.instanceCount = 1, this._bounds = new rn, this._boundsDirty = !0;
        const {
            attributes: n,
            indexBuffer: r,
            topology: i
        } = e;
        if (this.buffers = [], this.attributes = {}, n)
            for (const s in n) this.addAttribute(s, n[s]);
        this.instanceCount = e.instanceCount ? ? 1, r && this.addIndex(r), this.topology = i || "triangle-list"
    }
    onBufferUpdate() {
        this._boundsDirty = !0, this.emit("update", this)
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    getIndex() {
        return this.indexBuffer
    }
    getBuffer(e) {
        return this.getAttribute(e).buffer
    }
    getSize() {
        for (const e in this.attributes) {
            const n = this.attributes[e];
            return n.buffer.data.length / (n.stride / 4 || n.size)
        }
        return 0
    }
    addAttribute(e, n) {
        const r = Gse(n);
        this.buffers.indexOf(r.buffer) === -1 && (this.buffers.push(r.buffer), r.buffer.on("update", this.onBufferUpdate, this), r.buffer.on("change", this.onBufferUpdate, this)), this.attributes[e] = r
    }
    addIndex(e) {
        this.indexBuffer = qB(e, !0), this.buffers.push(this.indexBuffer)
    }
    get bounds() {
        return this._boundsDirty ? (this._boundsDirty = !1, Use(this, "aPosition", this._bounds)) : this._bounds
    }
    destroy(e = !1) {
        this.emit("destroy", this), this.removeAllListeners(), e && this.buffers.forEach(n => n.destroy()), this.attributes = null, this.buffers = null, this.indexBuffer = null, this._bounds = null
    }
}
const Hse = new Float32Array(1),
    zse = new Uint32Array(1);
class jse extends hd {
    constructor() {
        const n = new Jn({
                data: Hse,
                label: "attribute-batch-buffer",
                usage: Xe.VERTEX | Xe.COPY_DST,
                shrinkToFit: !1
            }),
            r = new Jn({
                data: zse,
                label: "index-batch-buffer",
                usage: Xe.INDEX | Xe.COPY_DST,
                shrinkToFit: !1
            }),
            i = 6 * 4;
        super({
            attributes: {
                aPosition: {
                    buffer: n,
                    format: "float32x2",
                    stride: i,
                    offset: 0
                },
                aUV: {
                    buffer: n,
                    format: "float32x2",
                    stride: i,
                    offset: 2 * 4
                },
                aColor: {
                    buffer: n,
                    format: "unorm8x4",
                    stride: i,
                    offset: 4 * 4
                },
                aTextureIdAndRound: {
                    buffer: n,
                    format: "uint16x2",
                    stride: i,
                    offset: 5 * 4
                }
            },
            indexBuffer: r
        })
    }
}

function YT(t, e, n) {
    if (t)
        for (const r in t) {
            const i = r.toLocaleLowerCase(),
                s = e[i];
            if (s) {
                let o = t[r];
                r === "header" && (o = o.replace(/@in\s+[^;]+;\s*/g, "").replace(/@out\s+[^;]+;\s*/g, "")), n && s.push(`//----${n}----//`), s.push(o)
            } else Oe(`${r} placement hook does not exist in shader`)
        }
}
const Vse = /\{\{(.*?)\}\}/g;

function XT(t) {
    var r;
    const e = {};
    return (((r = t.match(Vse)) == null ? void 0 : r.map(i => i.replace(/[{()}]/g, ""))) ? ? []).forEach(i => {
        e[i] = []
    }), e
}

function qT(t, e) {
    let n;
    const r = /@in\s+([^;]+);/g;
    for (;
        (n = r.exec(t)) !== null;) e.push(n[1])
}

function KT(t, e, n = !1) {
    const r = [];
    qT(e, r), t.forEach(a => {
        a.header && qT(a.header, r)
    });
    const i = r;
    n && i.sort();
    const s = i.map((a, l) => `       @location(${l}) ${a},`).join(`
`);
    let o = e.replace(/@in\s+[^;]+;\s*/g, "");
    return o = o.replace("{{in}}", `
${s}
`), o
}

function JT(t, e) {
    let n;
    const r = /@out\s+([^;]+);/g;
    for (;
        (n = r.exec(t)) !== null;) e.push(n[1])
}

function Wse(t) {
    const n = /\b(\w+)\s*:/g.exec(t);
    return n ? n[1] : ""
}

function Yse(t) {
    const e = /@.*?\s+/g;
    return t.replace(e, "")
}

function Xse(t, e) {
    const n = [];
    JT(e, n), t.forEach(l => {
        l.header && JT(l.header, n)
    });
    let r = 0;
    const i = n.sort().map(l => l.indexOf("builtin") > -1 ? l : `@location(${r++}) ${l}`).join(`,
`),
        s = n.sort().map(l => `       var ${Yse(l)};`).join(`
`),
        o = `return VSOutput(
            ${n.sort().map(l=>` ${Wse(l)}`).join(`,
`)});`;
    let a = e.replace(/@out\s+[^;]+;\s*/g, "");
    return a = a.replace("{{struct}}", `
${i}
`), a = a.replace("{{start}}", `
${s}
`), a = a.replace("{{return}}", `
${o}
`), a
}

function ZT(t, e) {
    let n = t;
    for (const r in e) {
        const i = e[r];
        i.join(`
`).length ? n = n.replace(`{{${r}}}`, `//-----${r} START-----//
${i.join(`
`)}
//----${r} FINISH----//`) : n = n.replace(`{{${r}}}`, "")
    }
    return n
}
const Cs = Object.create(null),
    Rg = new Map;
let qse = 0;

function Kse({
    template: t,
    bits: e
}) {
    const n = KB(t, e);
    if (Cs[n]) return Cs[n];
    const {
        vertex: r,
        fragment: i
    } = Zse(t, e);
    return Cs[n] = JB(r, i, e), Cs[n]
}

function Jse({
    template: t,
    bits: e
}) {
    const n = KB(t, e);
    return Cs[n] || (Cs[n] = JB(t.vertex, t.fragment, e)), Cs[n]
}

function Zse(t, e) {
    const n = e.map(o => o.vertex).filter(o => !!o),
        r = e.map(o => o.fragment).filter(o => !!o);
    let i = KT(n, t.vertex, !0);
    i = Xse(n, i);
    const s = KT(r, t.fragment, !0);
    return {
        vertex: i,
        fragment: s
    }
}

function KB(t, e) {
    return e.map(n => (Rg.has(n) || Rg.set(n, qse++), Rg.get(n))).sort((n, r) => n - r).join("-") + t.vertex + t.fragment
}

function JB(t, e, n) {
    const r = XT(t),
        i = XT(e);
    return n.forEach(s => {
        YT(s.vertex, r, s.name), YT(s.fragment, i, s.name)
    }), {
        vertex: ZT(t, r),
        fragment: ZT(e, i)
    }
}
const Qse = `
    @in aPosition: vec2<f32>;
    @in aUV: vec2<f32>;

    @out @builtin(position) vPosition: vec4<f32>;
    @out vUV : vec2<f32>;
    @out vColor : vec4<f32>;

    {{header}}

    struct VSOutput {
        {{struct}}
    };

    @vertex
    fn main( {{in}} ) -> VSOutput {

        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;
        var modelMatrix = mat3x3<f32>(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        var position = aPosition;
        var uv = aUV;

        {{start}}

        vColor = vec4<f32>(1., 1., 1., 1.);

        {{main}}

        vUV = uv;

        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;

        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);

        vColor *= globalUniforms.uWorldColorAlpha;

        {{end}}

        {{return}}
    };
`,
    eoe = `
    @in vUV : vec2<f32>;
    @in vColor : vec4<f32>;

    {{header}}

    @fragment
    fn main(
        {{in}}
      ) -> @location(0) vec4<f32> {

        {{start}}

        var outColor:vec4<f32>;

        {{main}}

        var finalColor:vec4<f32> = outColor * vColor;

        {{end}}

        return finalColor;
      };
`,
    toe = `
    in vec2 aPosition;
    in vec2 aUV;

    out vec4 vColor;
    out vec2 vUV;

    {{header}}

    void main(void){

        mat3 worldTransformMatrix = uWorldTransformMatrix;
        mat3 modelMatrix = mat3(
            1.0, 0.0, 0.0,
            0.0, 1.0, 0.0,
            0.0, 0.0, 1.0
          );
        vec2 position = aPosition;
        vec2 uv = aUV;

        {{start}}

        vColor = vec4(1.);

        {{main}}

        vUV = uv;

        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;

        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);

        vColor *= uWorldColorAlpha;

        {{end}}
    }
`,
    noe = `

    in vec4 vColor;
    in vec2 vUV;

    out vec4 finalColor;

    {{header}}

    void main(void) {

        {{start}}

        vec4 outColor;

        {{main}}

        finalColor = outColor * vColor;

        {{end}}
    }
`,
    roe = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
        struct GlobalUniforms {
            uProjectionMatrix:mat3x3<f32>,
            uWorldTransformMatrix:mat3x3<f32>,
            uWorldColorAlpha: vec4<f32>,
            uResolution: vec2<f32>,
        }

        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;
        `
        }
    },
    ioe = {
        name: "global-uniforms-bit",
        vertex: {
            header: `
          uniform mat3 uProjectionMatrix;
          uniform mat3 uWorldTransformMatrix;
          uniform vec4 uWorldColorAlpha;
          uniform vec2 uResolution;
        `
        }
    };

function pd({
    bits: t,
    name: e
}) {
    const n = Kse({
        template: {
            fragment: eoe,
            vertex: Qse
        },
        bits: [roe, ...t]
    });
    return io.from({
        name: e,
        vertex: {
            source: n.vertex,
            entryPoint: "main"
        },
        fragment: {
            source: n.fragment,
            entryPoint: "main"
        }
    })
}

function md({
    bits: t,
    name: e
}) {
    return new wa({
        name: e,
        ...Jse({
            template: {
                vertex: toe,
                fragment: noe
            },
            bits: [ioe, ...t]
        })
    })
}
const Ax = {
        name: "color-bit",
        vertex: {
            header: `
            @in aColor: vec4<f32>;
        `,
            main: `
            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);
        `
        }
    },
    Ox = {
        name: "color-bit",
        vertex: {
            header: `
            in vec4 aColor;
        `,
            main: `
            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);
        `
        }
    },
    kg = {};

function soe(t) {
    const e = [];
    if (t === 1) e.push("@group(1) @binding(0) var textureSource1: texture_2d<f32>;"), e.push("@group(1) @binding(1) var textureSampler1: sampler;");
    else {
        let n = 0;
        for (let r = 0; r < t; r++) e.push(`@group(1) @binding(${n++}) var textureSource${r+1}: texture_2d<f32>;`), e.push(`@group(1) @binding(${n++}) var textureSampler${r+1}: sampler;`)
    }
    return e.join(`
`)
}

function ooe(t) {
    const e = [];
    if (t === 1) e.push("outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);");
    else {
        e.push("switch vTextureId {");
        for (let n = 0; n < t; n++) n === t - 1 ? e.push("  default:{") : e.push(`  case ${n}:{`), e.push(`      outColor = textureSampleGrad(textureSource${n+1}, textureSampler${n+1}, vUV, uvDx, uvDy);`), e.push("      break;}");
        e.push("}")
    }
    return e.join(`
`)
}

function Ix(t) {
    return kg[t] || (kg[t] = {
        name: "texture-batch-bit",
        vertex: {
            header: `
                @in aTextureIdAndRound: vec2<u32>;
                @out @interpolate(flat) vTextureId : u32;
            `,
            main: `
                vTextureId = aTextureIdAndRound.y;
            `,
            end: `
                if(aTextureIdAndRound.x == 1)
                {
                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
                }
            `
        },
        fragment: {
            header: `
                @in @interpolate(flat) vTextureId: u32;

                ${soe(t)}
            `,
            main: `
                var uvDx = dpdx(vUV);
                var uvDy = dpdy(vUV);

                ${ooe(t)}
            `
        }
    }), kg[t]
}
const Bg = {};

function aoe(t) {
    const e = [];
    for (let n = 0; n < t; n++) n > 0 && e.push("else"), n < t - 1 && e.push(`if(vTextureId < ${n}.5)`), e.push("{"), e.push(`	outColor = texture(uTextures[${n}], vUV);`), e.push("}");
    return e.join(`
`)
}

function Mx(t) {
    return Bg[t] || (Bg[t] = {
        name: "texture-batch-bit",
        vertex: {
            header: `
                in vec2 aTextureIdAndRound;
                out float vTextureId;

            `,
            main: `
                vTextureId = aTextureIdAndRound.y;
            `,
            end: `
                if(aTextureIdAndRound.x == 1.)
                {
                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
                }
            `
        },
        fragment: {
            header: `
                in float vTextureId;

                uniform sampler2D uTextures[${t}];

            `,
            main: `

                ${aoe(t)}
            `
        }
    }), Bg[t]
}
const gd = {
        name: "round-pixels-bit",
        vertex: {
            header: `
            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32>
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    },
    yd = {
        name: "round-pixels-bit",
        vertex: {
            header: `
            vec2 roundPixels(vec2 position, vec2 targetSize)
            {
                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
            }
        `
        }
    },
    QT = {};

function Rx(t) {
    let e = QT[t];
    if (e) return e;
    const n = new Int32Array(t);
    for (let r = 0; r < t; r++) n[r] = r;
    return e = QT[t] = new Pn({
        uTextures: {
            value: n,
            type: "i32",
            size: t
        }
    }, {
        isStatic: !0
    }), e
}
class loe extends br {
    constructor(e) {
        const n = md({
                name: "batch",
                bits: [Ox, Mx(e), yd]
            }),
            r = pd({
                name: "batch",
                bits: [Ax, Ix(e), gd]
            });
        super({
            glProgram: n,
            gpuProgram: r,
            resources: {
                batchSamplers: Rx(e)
            }
        })
    }
}
let Dg = null;
const ZB = class QB extends Nse {
    constructor(e) {
        super(e), this.geometry = new jse, this.name = QB.extension.name, this.vertexSize = 6, Dg ? ? (Dg = new loe(e.maxTextures)), this.shader = Dg
    }
    packAttributes(e, n, r, i, s) {
        const o = s << 16 | e.roundPixels & 65535,
            a = e.transform,
            l = a.a,
            c = a.b,
            u = a.c,
            d = a.d,
            f = a.tx,
            h = a.ty,
            {
                positions: p,
                uvs: b
            } = e,
            y = e.color,
            m = e.attributeOffset,
            g = m + e.attributeSize;
        for (let v = m; v < g; v++) {
            const _ = v * 2,
                x = p[_],
                w = p[_ + 1];
            n[i++] = l * x + u * w + f, n[i++] = d * w + c * x + h, n[i++] = b[_], n[i++] = b[_ + 1], r[i++] = y, r[i++] = o
        }
    }
    packQuadAttributes(e, n, r, i, s) {
        const o = e.texture,
            a = e.transform,
            l = a.a,
            c = a.b,
            u = a.c,
            d = a.d,
            f = a.tx,
            h = a.ty,
            p = e.bounds,
            b = p.maxX,
            y = p.minX,
            m = p.maxY,
            g = p.minY,
            v = o.uvs,
            _ = e.color,
            x = s << 16 | e.roundPixels & 65535;
        n[i + 0] = l * y + u * g + f, n[i + 1] = d * g + c * y + h, n[i + 2] = v.x0, n[i + 3] = v.y0, r[i + 4] = _, r[i + 5] = x, n[i + 6] = l * b + u * g + f, n[i + 7] = d * g + c * b + h, n[i + 8] = v.x1, n[i + 9] = v.y1, r[i + 10] = _, r[i + 11] = x, n[i + 12] = l * b + u * m + f, n[i + 13] = d * m + c * b + h, n[i + 14] = v.x2, n[i + 15] = v.y2, r[i + 16] = _, r[i + 17] = x, n[i + 18] = l * y + u * m + f, n[i + 19] = d * m + c * y + h, n[i + 20] = v.x3, n[i + 21] = v.y3, r[i + 22] = _, r[i + 23] = x
    }
};
ZB.extension = {
    type: [G.Batcher],
    name: "default"
};
let kx = ZB;

function coe(t, e, n, r, i, s, o, a = null) {
    let l = 0;
    n *= e, i *= s;
    const c = a.a,
        u = a.b,
        d = a.c,
        f = a.d,
        h = a.tx,
        p = a.ty;
    for (; l < o;) {
        const b = t[n],
            y = t[n + 1];
        r[i] = c * b + d * y + h, r[i + 1] = u * b + f * y + p, i += s, n += e, l++
    }
}

function uoe(t, e, n, r) {
    let i = 0;
    for (e *= n; i < r;) t[e] = 0, t[e + 1] = 0, e += n, i++
}

function eD(t, e, n, r, i) {
    const s = e.a,
        o = e.b,
        a = e.c,
        l = e.d,
        c = e.tx,
        u = e.ty;
    n || (n = 0), r || (r = 2), i || (i = t.length / r - n);
    let d = n * r;
    for (let f = 0; f < i; f++) {
        const h = t[d],
            p = t[d + 1];
        t[d] = s * h + a * p + c, t[d + 1] = o * h + l * p + u, d += r
    }
}
const doe = new Te;
class Bx {
    constructor() {
        this.packAsQuad = !1, this.batcherName = "default", this.topology = "triangle-list", this.applyTransform = !0, this.roundPixels = 0, this._batcher = null, this._batch = null
    }
    get uvs() {
        return this.geometryData.uvs
    }
    get positions() {
        return this.geometryData.vertices
    }
    get indices() {
        return this.geometryData.indices
    }
    get blendMode() {
        return this.renderable && this.applyTransform ? this.renderable.groupBlendMode : "normal"
    }
    get color() {
        const e = this.baseColor,
            n = e >> 16 | e & 65280 | (e & 255) << 16,
            r = this.renderable;
        return r ? sB(n, r.groupColor) + (this.alpha * r.groupAlpha * 255 << 24) : n + (this.alpha * 255 << 24)
    }
    get transform() {
        var e;
        return ((e = this.renderable) == null ? void 0 : e.groupTransform) || doe
    }
    copyTo(e) {
        e.indexOffset = this.indexOffset, e.indexSize = this.indexSize, e.attributeOffset = this.attributeOffset, e.attributeSize = this.attributeSize, e.baseColor = this.baseColor, e.alpha = this.alpha, e.texture = this.texture, e.geometryData = this.geometryData, e.topology = this.topology
    }
    reset() {
        this.applyTransform = !0, this.renderable = null, this.topology = "triangle-list"
    }
}
const Bu = {
        extension: {
            type: G.ShapeBuilder,
            name: "circle"
        },
        build(t, e) {
            let n, r, i, s, o, a;
            if (t.type === "circle") {
                const _ = t;
                if (o = a = _.radius, o <= 0) return !1;
                n = _.x, r = _.y, i = s = 0
            } else if (t.type === "ellipse") {
                const _ = t;
                if (o = _.halfWidth, a = _.halfHeight, o <= 0 || a <= 0) return !1;
                n = _.x, r = _.y, i = s = 0
            } else {
                const _ = t,
                    x = _.width / 2,
                    w = _.height / 2;
                n = _.x + x, r = _.y + w, o = a = Math.max(0, Math.min(_.radius, Math.min(x, w))), i = x - o, s = w - a
            }
            if (i < 0 || s < 0) return !1;
            const l = Math.ceil(2.3 * Math.sqrt(o + a)),
                c = l * 8 + (i ? 4 : 0) + (s ? 4 : 0);
            if (c === 0) return !1;
            if (l === 0) return e[0] = e[6] = n + i, e[1] = e[3] = r + s, e[2] = e[4] = n - i, e[5] = e[7] = r - s, !0;
            let u = 0,
                d = l * 4 + (i ? 2 : 0) + 2,
                f = d,
                h = c,
                p = i + o,
                b = s,
                y = n + p,
                m = n - p,
                g = r + b;
            if (e[u++] = y, e[u++] = g, e[--d] = g, e[--d] = m, s) {
                const _ = r - b;
                e[f++] = m, e[f++] = _, e[--h] = _, e[--h] = y
            }
            for (let _ = 1; _ < l; _++) {
                const x = Math.PI / 2 * (_ / l),
                    w = i + Math.cos(x) * o,
                    E = s + Math.sin(x) * a,
                    C = n + w,
                    A = n - w,
                    T = r + E,
                    S = r - E;
                e[u++] = C, e[u++] = T, e[--d] = T, e[--d] = A, e[f++] = A, e[f++] = S, e[--h] = S, e[--h] = C
            }
            p = i, b = s + a, y = n + p, m = n - p, g = r + b;
            const v = r - b;
            return e[u++] = y, e[u++] = g, e[--h] = v, e[--h] = y, i && (e[u++] = m, e[u++] = g, e[--h] = v, e[--h] = m), !0
        },
        triangulate(t, e, n, r, i, s) {
            if (t.length === 0) return;
            let o = 0,
                a = 0;
            for (let u = 0; u < t.length; u += 2) o += t[u], a += t[u + 1];
            o /= t.length / 2, a /= t.length / 2;
            let l = r;
            e[l * n] = o, e[l * n + 1] = a;
            const c = l++;
            for (let u = 0; u < t.length; u += 2) e[l * n] = t[u], e[l * n + 1] = t[u + 1], u > 0 && (i[s++] = l, i[s++] = c, i[s++] = l - 1), l++;
            i[s++] = c + 1, i[s++] = c, i[s++] = l - 1
        }
    },
    foe = { ...Bu,
        extension: { ...Bu.extension,
            name: "ellipse"
        }
    },
    hoe = { ...Bu,
        extension: { ...Bu.extension,
            name: "roundedRectangle"
        }
    },
    tD = 1e-4,
    eC = 1e-4;

function poe(t) {
    const e = t.length;
    if (e < 6) return 1;
    let n = 0;
    for (let r = 0, i = t[e - 2], s = t[e - 1]; r < e; r += 2) {
        const o = t[r],
            a = t[r + 1];
        n += (o - i) * (a + s), i = o, s = a
    }
    return n < 0 ? -1 : 1
}

function tC(t, e, n, r, i, s, o, a) {
    const l = t - n * i,
        c = e - r * i,
        u = t + n * s,
        d = e + r * s;
    let f, h;
    o ? (f = r, h = -n) : (f = -r, h = n);
    const p = l + f,
        b = c + h,
        y = u + f,
        m = d + h;
    return a.push(p, b), a.push(y, m), 2
}

function po(t, e, n, r, i, s, o, a) {
    const l = n - t,
        c = r - e;
    let u = Math.atan2(l, c),
        d = Math.atan2(i - t, s - e);
    a && u < d ? u += Math.PI * 2 : !a && u > d && (d += Math.PI * 2);
    let f = u;
    const h = d - u,
        p = Math.abs(h),
        b = Math.sqrt(l * l + c * c),
        y = (15 * p * Math.sqrt(b) / Math.PI >> 0) + 1,
        m = h / y;
    if (f += m, a) {
        o.push(t, e), o.push(n, r);
        for (let g = 1, v = f; g < y; g++, v += m) o.push(t, e), o.push(t + Math.sin(v) * b, e + Math.cos(v) * b);
        o.push(t, e), o.push(i, s)
    } else {
        o.push(n, r), o.push(t, e);
        for (let g = 1, v = f; g < y; g++, v += m) o.push(t + Math.sin(v) * b, e + Math.cos(v) * b), o.push(t, e);
        o.push(i, s), o.push(t, e)
    }
    return y * 2
}

function moe(t, e, n, r, i, s) {
    const o = tD;
    if (t.length === 0) return;
    const a = e;
    let l = a.alignment;
    if (e.alignment !== .5) {
        let Y = poe(t);
        n && (Y *= -1), l = (l - .5) * Y + .5
    }
    const c = new dt(t[0], t[1]),
        u = new dt(t[t.length - 2], t[t.length - 1]),
        d = r,
        f = Math.abs(c.x - u.x) < o && Math.abs(c.y - u.y) < o;
    if (d) {
        t = t.slice(), f && (t.pop(), t.pop(), u.set(t[t.length - 2], t[t.length - 1]));
        const Y = (c.x + u.x) * .5,
            le = (u.y + c.y) * .5;
        t.unshift(Y, le), t.push(Y, le)
    }
    const h = i,
        p = t.length / 2;
    let b = t.length;
    const y = h.length / 2,
        m = a.width / 2,
        g = m * m,
        v = a.miterLimit * a.miterLimit;
    let _ = t[0],
        x = t[1],
        w = t[2],
        E = t[3],
        C = 0,
        A = 0,
        T = -(x - E),
        S = _ - w,
        P = 0,
        R = 0,
        D = Math.sqrt(T * T + S * S);
    T /= D, S /= D, T *= m, S *= m;
    const H = l,
        B = (1 - H) * 2,
        N = H * 2;
    d || (a.cap === "round" ? b += po(_ - T * (B - N) * .5, x - S * (B - N) * .5, _ - T * B, x - S * B, _ + T * N, x + S * N, h, !0) + 2 : a.cap === "square" && (b += tC(_, x, T, S, B, N, !0, h))), h.push(_ - T * B, x - S * B), h.push(_ + T * N, x + S * N);
    for (let Y = 1; Y < p - 1; ++Y) {
        _ = t[(Y - 1) * 2], x = t[(Y - 1) * 2 + 1], w = t[Y * 2], E = t[Y * 2 + 1], C = t[(Y + 1) * 2], A = t[(Y + 1) * 2 + 1], T = -(x - E), S = _ - w, D = Math.sqrt(T * T + S * S), T /= D, S /= D, T *= m, S *= m, P = -(E - A), R = w - C, D = Math.sqrt(P * P + R * R), P /= D, R /= D, P *= m, R *= m;
        const le = w - _,
            ae = x - E,
            W = w - C,
            ne = A - E,
            fe = le * W + ae * ne,
            $ = ae * W - ne * le,
            X = $ < 0;
        if (Math.abs($) < .001 * Math.abs(fe)) {
            h.push(w - T * B, E - S * B), h.push(w + T * N, E + S * N), fe >= 0 && (a.join === "round" ? b += po(w, E, w - T * B, E - S * B, w - P * B, E - R * B, h, !1) + 4 : b += 2, h.push(w - P * N, E - R * N), h.push(w + P * B, E + R * B));
            continue
        }
        const F = (-T + _) * (-S + E) - (-T + w) * (-S + x),
            Z = (-P + C) * (-R + E) - (-P + w) * (-R + A),
            K = (le * Z - W * F) / $,
            ce = (ne * F - ae * Z) / $,
            de = (K - w) * (K - w) + (ce - E) * (ce - E),
            ge = w + (K - w) * B,
            O = E + (ce - E) * B,
            L = w - (K - w) * N,
            j = E - (ce - E) * N,
            ie = Math.min(le * le + ae * ae, W * W + ne * ne),
            oe = X ? B : N,
            M = ie + oe * oe * g;
        de <= M ? a.join === "bevel" || de / g > v ? (X ? (h.push(ge, O), h.push(w + T * N, E + S * N), h.push(ge, O), h.push(w + P * N, E + R * N)) : (h.push(w - T * B, E - S * B), h.push(L, j), h.push(w - P * B, E - R * B), h.push(L, j)), b += 2) : a.join === "round" ? X ? (h.push(ge, O), h.push(w + T * N, E + S * N), b += po(w, E, w + T * N, E + S * N, w + P * N, E + R * N, h, !0) + 4, h.push(ge, O), h.push(w + P * N, E + R * N)) : (h.push(w - T * B, E - S * B), h.push(L, j), b += po(w, E, w - T * B, E - S * B, w - P * B, E - R * B, h, !1) + 4, h.push(w - P * B, E - R * B), h.push(L, j)) : (h.push(ge, O), h.push(L, j)) : (h.push(w - T * B, E - S * B), h.push(w + T * N, E + S * N), a.join === "round" ? X ? b += po(w, E, w + T * N, E + S * N, w + P * N, E + R * N, h, !0) + 2 : b += po(w, E, w - T * B, E - S * B, w - P * B, E - R * B, h, !1) + 2 : a.join === "miter" && de / g <= v && (X ? (h.push(L, j), h.push(L, j)) : (h.push(ge, O), h.push(ge, O)), b += 2), h.push(w - P * B, E - R * B), h.push(w + P * N, E + R * N), b += 2)
    }
    _ = t[(p - 2) * 2], x = t[(p - 2) * 2 + 1], w = t[(p - 1) * 2], E = t[(p - 1) * 2 + 1], T = -(x - E), S = _ - w, D = Math.sqrt(T * T + S * S), T /= D, S /= D, T *= m, S *= m, h.push(w - T * B, E - S * B), h.push(w + T * N, E + S * N), d || (a.cap === "round" ? b += po(w - T * (B - N) * .5, E - S * (B - N) * .5, w - T * B, E - S * B, w + T * N, E + S * N, h, !1) + 2 : a.cap === "square" && (b += tC(w, E, T, S, B, N, !1, h)));
    const V = eC * eC;
    for (let Y = y; Y < b + y - 2; ++Y) _ = h[Y * 2], x = h[Y * 2 + 1], w = h[(Y + 1) * 2], E = h[(Y + 1) * 2 + 1], C = h[(Y + 2) * 2], A = h[(Y + 2) * 2 + 1], !(Math.abs(_ * (E - A) + w * (A - x) + C * (x - E)) < V) && s.push(Y, Y + 1, Y + 2)
}

function goe(t, e, n, r) {
    const i = tD;
    if (t.length === 0) return;
    const s = t[0],
        o = t[1],
        a = t[t.length - 2],
        l = t[t.length - 1],
        c = e || Math.abs(s - a) < i && Math.abs(o - l) < i,
        u = n,
        d = t.length / 2,
        f = u.length / 2;
    for (let h = 0; h < d; h++) u.push(t[h * 2]), u.push(t[h * 2 + 1]);
    for (let h = 0; h < d - 1; h++) r.push(f + h, f + h + 1);
    c && r.push(f + d - 1, f)
}

function nD(t, e, n, r, i, s, o) {
    const a = pse(t, e, 2);
    if (!a) return;
    for (let c = 0; c < a.length; c += 3) s[o++] = a[c] + i, s[o++] = a[c + 1] + i, s[o++] = a[c + 2] + i;
    let l = i * r;
    for (let c = 0; c < t.length; c += 2) n[l] = t[c], n[l + 1] = t[c + 1], l += r
}
const yoe = [],
    voe = {
        extension: {
            type: G.ShapeBuilder,
            name: "polygon"
        },
        build(t, e) {
            for (let n = 0; n < t.points.length; n++) e[n] = t.points[n];
            return !0
        },
        triangulate(t, e, n, r, i, s) {
            nD(t, yoe, e, n, r, i, s)
        }
    },
    _oe = {
        extension: {
            type: G.ShapeBuilder,
            name: "rectangle"
        },
        build(t, e) {
            const n = t,
                r = n.x,
                i = n.y,
                s = n.width,
                o = n.height;
            return s > 0 && o > 0 ? (e[0] = r, e[1] = i, e[2] = r + s, e[3] = i, e[4] = r + s, e[5] = i + o, e[6] = r, e[7] = i + o, !0) : !1
        },
        triangulate(t, e, n, r, i, s) {
            let o = 0;
            r *= n, e[r + o] = t[0], e[r + o + 1] = t[1], o += n, e[r + o] = t[2], e[r + o + 1] = t[3], o += n, e[r + o] = t[6], e[r + o + 1] = t[7], o += n, e[r + o] = t[4], e[r + o + 1] = t[5], o += n;
            const a = r / n;
            i[s++] = a, i[s++] = a + 1, i[s++] = a + 2, i[s++] = a + 1, i[s++] = a + 3, i[s++] = a + 2
        }
    },
    boe = {
        extension: {
            type: G.ShapeBuilder,
            name: "triangle"
        },
        build(t, e) {
            return e[0] = t.x, e[1] = t.y, e[2] = t.x2, e[3] = t.y2, e[4] = t.x3, e[5] = t.y3, !0
        },
        triangulate(t, e, n, r, i, s) {
            let o = 0;
            r *= n, e[r + o] = t[0], e[r + o + 1] = t[1], o += n, e[r + o] = t[2], e[r + o + 1] = t[3], o += n, e[r + o] = t[4], e[r + o + 1] = t[5];
            const a = r / n;
            i[s++] = a, i[s++] = a + 1, i[s++] = a + 2
        }
    },
    xoe = new Te,
    woe = new it;

function Eoe(t, e, n, r) {
    const i = e.matrix ? t.copyFrom(e.matrix).invert() : t.identity();
    if (e.textureSpace === "local") {
        const o = n.getBounds(woe);
        e.width && o.pad(e.width);
        const {
            x: a,
            y: l
        } = o, c = 1 / o.width, u = 1 / o.height, d = -a * c, f = -l * u, h = i.a, p = i.b, b = i.c, y = i.d;
        i.a *= c, i.b *= c, i.c *= u, i.d *= u, i.tx = d * h + f * b + i.tx, i.ty = d * p + f * y + i.ty
    } else i.translate(e.texture.frame.x, e.texture.frame.y), i.scale(1 / e.texture.source.width, 1 / e.texture.source.height);
    const s = e.texture.source.style;
    return !(e.fill instanceof Qi) && s.addressMode === "clamp-to-edge" && (s.addressMode = "repeat", s.update()), r && i.append(xoe.copyFrom(r).invert()), i
}
const nm = {};
Re.handleByMap(G.ShapeBuilder, nm);
Re.add(_oe, voe, boe, Bu, foe, hoe);
const Soe = new it,
    Toe = new Te;

function Coe(t, e) {
    const {
        geometryData: n,
        batches: r
    } = e;
    r.length = 0, n.indices.length = 0, n.vertices.length = 0, n.uvs.length = 0;
    for (let i = 0; i < t.instructions.length; i++) {
        const s = t.instructions[i];
        if (s.action === "texture") Poe(s.data, r, n);
        else if (s.action === "fill" || s.action === "stroke") {
            const o = s.action === "stroke",
                a = s.data.path.shapePath,
                l = s.data.style,
                c = s.data.hole;
            o && c && nC(c.shapePath, l, !0, r, n), c && (a.shapePrimitives[a.shapePrimitives.length - 1].holes = c.shapePath.shapePrimitives), nC(a, l, o, r, n)
        }
    }
}

function Poe(t, e, n) {
    const r = [],
        i = nm.rectangle,
        s = Soe;
    s.x = t.dx, s.y = t.dy, s.width = t.dw, s.height = t.dh;
    const o = t.transform;
    if (!i.build(s, r)) return;
    const {
        vertices: a,
        uvs: l,
        indices: c
    } = n, u = c.length, d = a.length / 2;
    o && eD(r, o), i.triangulate(r, a, 2, d, c, u);
    const f = t.image,
        h = f.uvs;
    l.push(h.x0, h.y0, h.x1, h.y1, h.x3, h.y3, h.x2, h.y2);
    const p = nn.get(Bx);
    p.indexOffset = u, p.indexSize = c.length - u, p.attributeOffset = d, p.attributeSize = a.length / 2 - d, p.baseColor = t.style, p.alpha = t.alpha, p.texture = f, p.geometryData = n, e.push(p)
}

function nC(t, e, n, r, i) {
    const {
        vertices: s,
        uvs: o,
        indices: a
    } = i;
    t.shapePrimitives.forEach(({
        shape: l,
        transform: c,
        holes: u
    }) => {
        const d = [],
            f = nm[l.type];
        if (!f.build(l, d)) return;
        const h = a.length,
            p = s.length / 2;
        let b = "triangle-list";
        if (c && eD(d, c), n) {
            const v = l.closePath ? ? !0,
                _ = e;
            _.pixelLine ? (goe(d, v, s, a), b = "line-list") : moe(d, _, !1, v, s, a)
        } else if (u) {
            const v = [],
                _ = d.slice();
            Aoe(u).forEach(w => {
                v.push(_.length / 2), _.push(...w)
            }), nD(_, v, s, 2, p, a, h)
        } else f.triangulate(d, s, 2, p, a, h);
        const y = o.length / 2,
            m = e.texture;
        if (m !== we.WHITE) {
            const v = Eoe(Toe, e, l, c);
            coe(s, 2, p, o, y, 2, s.length / 2 - p, v)
        } else uoe(o, y, 2, s.length / 2 - p);
        const g = nn.get(Bx);
        g.indexOffset = h, g.indexSize = a.length - h, g.attributeOffset = p, g.attributeSize = s.length / 2 - p, g.baseColor = e.color, g.alpha = e.alpha, g.texture = m, g.geometryData = i, g.topology = b, r.push(g)
    })
}

function Aoe(t) {
    const e = [];
    for (let n = 0; n < t.length; n++) {
        const r = t[n].shape,
            i = [];
        nm[r.type].build(r, i) && e.push(i)
    }
    return e
}
class Ooe {
    constructor() {
        this.batches = [], this.geometryData = {
            vertices: [],
            uvs: [],
            indices: []
        }
    }
}
class Ioe {
    constructor() {
        this.instructions = new lB
    }
    init(e) {
        this.batcher = new kx({
            maxTextures: e
        }), this.instructions.reset()
    }
    get geometry() {
        return Ie(Dre, "GraphicsContextRenderData#geometry is deprecated, please use batcher.geometry instead."), this.batcher.geometry
    }
}
const Dx = class P0 {
    constructor(e) {
        this._gpuContextHash = {}, this._graphicsDataContextHash = Object.create(null), this._renderer = e, e.renderableGC.addManagedHash(this, "_gpuContextHash"), e.renderableGC.addManagedHash(this, "_graphicsDataContextHash")
    }
    init(e) {
        P0.defaultOptions.bezierSmoothness = (e == null ? void 0 : e.bezierSmoothness) ? ? P0.defaultOptions.bezierSmoothness
    }
    getContextRenderData(e) {
        return this._graphicsDataContextHash[e.uid] || this._initContextRenderData(e)
    }
    updateGpuContext(e) {
        let n = this._gpuContextHash[e.uid] || this._initContext(e);
        if (e.dirty) {
            n ? this._cleanGraphicsContextData(e) : n = this._initContext(e), Coe(e, n);
            const r = e.batchMode;
            e.customShader || r === "no-batch" ? n.isBatchable = !1 : r === "auto" ? n.isBatchable = n.geometryData.vertices.length < 400 : n.isBatchable = !0, e.dirty = !1
        }
        return n
    }
    getGpuContext(e) {
        return this._gpuContextHash[e.uid] || this._initContext(e)
    }
    _initContextRenderData(e) {
        const n = nn.get(Ioe, {
                maxTextures: this._renderer.limits.maxBatchableTextures
            }),
            {
                batches: r,
                geometryData: i
            } = this._gpuContextHash[e.uid],
            s = i.vertices.length,
            o = i.indices.length;
        for (let u = 0; u < r.length; u++) r[u].applyTransform = !1;
        const a = n.batcher;
        a.ensureAttributeBuffer(s), a.ensureIndexBuffer(o), a.begin();
        for (let u = 0; u < r.length; u++) {
            const d = r[u];
            a.add(d)
        }
        a.finish(n.instructions);
        const l = a.geometry;
        l.indexBuffer.setDataWithSize(a.indexBuffer, a.indexSize, !0), l.buffers[0].setDataWithSize(a.attributeBuffer.float32View, a.attributeSize, !0);
        const c = a.batches;
        for (let u = 0; u < c.length; u++) {
            const d = c[u];
            d.bindGroup = Px(d.textures.textures, d.textures.count, this._renderer.limits.maxBatchableTextures)
        }
        return this._graphicsDataContextHash[e.uid] = n, n
    }
    _initContext(e) {
        const n = new Ooe;
        return n.context = e, this._gpuContextHash[e.uid] = n, e.on("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid]
    }
    onGraphicsContextDestroy(e) {
        this._cleanGraphicsContextData(e), e.off("destroy", this.onGraphicsContextDestroy, this), this._gpuContextHash[e.uid] = null
    }
    _cleanGraphicsContextData(e) {
        const n = this._gpuContextHash[e.uid];
        n.isBatchable || this._graphicsDataContextHash[e.uid] && (nn.return(this.getContextRenderData(e)), this._graphicsDataContextHash[e.uid] = null), n.batches && n.batches.forEach(r => {
            nn.return(r)
        })
    }
    destroy() {
        for (const e in this._gpuContextHash) this._gpuContextHash[e] && this.onGraphicsContextDestroy(this._gpuContextHash[e].context)
    }
};
Dx.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "graphicsContext"
};
Dx.defaultOptions = {
    bezierSmoothness: .5
};
let $x = Dx;
const Moe = 8,
    vf = 11920929e-14,
    Roe = 1;

function rD(t, e, n, r, i, s, o, a, l, c) {
    const d = Math.min(.99, Math.max(0, c ? ? $x.defaultOptions.bezierSmoothness));
    let f = (Roe - d) / 1;
    return f *= f, koe(e, n, r, i, s, o, a, l, t, f), t
}

function koe(t, e, n, r, i, s, o, a, l, c) {
    A0(t, e, n, r, i, s, o, a, l, c, 0), l.push(o, a)
}

function A0(t, e, n, r, i, s, o, a, l, c, u) {
    if (u > Moe) return;
    const d = (t + n) / 2,
        f = (e + r) / 2,
        h = (n + i) / 2,
        p = (r + s) / 2,
        b = (i + o) / 2,
        y = (s + a) / 2,
        m = (d + h) / 2,
        g = (f + p) / 2,
        v = (h + b) / 2,
        _ = (p + y) / 2,
        x = (m + v) / 2,
        w = (g + _) / 2;
    if (u > 0) {
        let E = o - t,
            C = a - e;
        const A = Math.abs((n - o) * C - (r - a) * E),
            T = Math.abs((i - o) * C - (s - a) * E);
        if (A > vf && T > vf) {
            if ((A + T) * (A + T) <= c * (E * E + C * C)) {
                l.push(x, w);
                return
            }
        } else if (A > vf) {
            if (A * A <= c * (E * E + C * C)) {
                l.push(x, w);
                return
            }
        } else if (T > vf) {
            if (T * T <= c * (E * E + C * C)) {
                l.push(x, w);
                return
            }
        } else if (E = x - (t + o) / 2, C = w - (e + a) / 2, E * E + C * C <= c) {
            l.push(x, w);
            return
        }
    }
    A0(t, e, d, f, m, g, x, w, l, c, u + 1), A0(x, w, v, _, b, y, o, a, l, c, u + 1)
}
const Boe = 8,
    Doe = 11920929e-14,
    $oe = 1;

function Foe(t, e, n, r, i, s, o, a) {
    const c = Math.min(.99, Math.max(0, a ? ? $x.defaultOptions.bezierSmoothness));
    let u = ($oe - c) / 1;
    return u *= u, Loe(e, n, r, i, s, o, t, u), t
}

function Loe(t, e, n, r, i, s, o, a) {
    O0(o, t, e, n, r, i, s, a, 0), o.push(i, s)
}

function O0(t, e, n, r, i, s, o, a, l) {
    if (l > Boe) return;
    const c = (e + r) / 2,
        u = (n + i) / 2,
        d = (r + s) / 2,
        f = (i + o) / 2,
        h = (c + d) / 2,
        p = (u + f) / 2;
    let b = s - e,
        y = o - n;
    const m = Math.abs((r - s) * y - (i - o) * b);
    if (m > Doe) {
        if (m * m <= a * (b * b + y * y)) {
            t.push(h, p);
            return
        }
    } else if (b = h - (e + s) / 2, y = p - (n + o) / 2, b * b + y * y <= a) {
        t.push(h, p);
        return
    }
    O0(t, e, n, c, u, h, p, a, l + 1), O0(t, h, p, d, f, s, o, a, l + 1)
}

function iD(t, e, n, r, i, s, o, a) {
    let l = Math.abs(i - s);
    (!o && i > s || o && s > i) && (l = 2 * Math.PI - l), a || (a = Math.max(6, Math.floor(6 * Math.pow(r, 1 / 3) * (l / Math.PI)))), a = Math.max(a, 3);
    let c = l / a,
        u = i;
    c *= o ? -1 : 1;
    for (let d = 0; d < a + 1; d++) {
        const f = Math.cos(u),
            h = Math.sin(u),
            p = e + f * r,
            b = n + h * r;
        t.push(p, b), u += c
    }
}

function Noe(t, e, n, r, i, s) {
    const o = t[t.length - 2],
        l = t[t.length - 1] - n,
        c = o - e,
        u = i - n,
        d = r - e,
        f = Math.abs(l * d - c * u);
    if (f < 1e-8 || s === 0) {
        (t[t.length - 2] !== e || t[t.length - 1] !== n) && t.push(e, n);
        return
    }
    const h = l * l + c * c,
        p = u * u + d * d,
        b = l * u + c * d,
        y = s * Math.sqrt(h) / f,
        m = s * Math.sqrt(p) / f,
        g = y * b / h,
        v = m * b / p,
        _ = y * d + m * c,
        x = y * u + m * l,
        w = c * (m + g),
        E = l * (m + g),
        C = d * (y + v),
        A = u * (y + v),
        T = Math.atan2(E - x, w - _),
        S = Math.atan2(A - x, C - _);
    iD(t, _ + e, x + n, s, T, S, c * u > d * l)
}
const Kc = Math.PI * 2,
    $g = {
        centerX: 0,
        centerY: 0,
        ang1: 0,
        ang2: 0
    },
    Fg = ({
        x: t,
        y: e
    }, n, r, i, s, o, a, l) => {
        t *= n, e *= r;
        const c = i * t - s * e,
            u = s * t + i * e;
        return l.x = c + o, l.y = u + a, l
    };

function Uoe(t, e) {
    const n = e === -1.5707963267948966 ? -.551915024494 : 1.3333333333333333 * Math.tan(e / 4),
        r = e === 1.5707963267948966 ? .551915024494 : n,
        i = Math.cos(t),
        s = Math.sin(t),
        o = Math.cos(t + e),
        a = Math.sin(t + e);
    return [{
        x: i - s * r,
        y: s + i * r
    }, {
        x: o + a * r,
        y: a - o * r
    }, {
        x: o,
        y: a
    }]
}
const rC = (t, e, n, r) => {
        const i = t * r - e * n < 0 ? -1 : 1;
        let s = t * n + e * r;
        return s > 1 && (s = 1), s < -1 && (s = -1), i * Math.acos(s)
    },
    Goe = (t, e, n, r, i, s, o, a, l, c, u, d, f) => {
        const h = Math.pow(i, 2),
            p = Math.pow(s, 2),
            b = Math.pow(u, 2),
            y = Math.pow(d, 2);
        let m = h * p - h * y - p * b;
        m < 0 && (m = 0), m /= h * y + p * b, m = Math.sqrt(m) * (o === a ? -1 : 1);
        const g = m * i / s * d,
            v = m * -s / i * u,
            _ = c * g - l * v + (t + n) / 2,
            x = l * g + c * v + (e + r) / 2,
            w = (u - g) / i,
            E = (d - v) / s,
            C = (-u - g) / i,
            A = (-d - v) / s,
            T = rC(1, 0, w, E);
        let S = rC(w, E, C, A);
        a === 0 && S > 0 && (S -= Kc), a === 1 && S < 0 && (S += Kc), f.centerX = _, f.centerY = x, f.ang1 = T, f.ang2 = S
    };

function Hoe(t, e, n, r, i, s, o, a = 0, l = 0, c = 0) {
    if (s === 0 || o === 0) return;
    const u = Math.sin(a * Kc / 360),
        d = Math.cos(a * Kc / 360),
        f = d * (e - r) / 2 + u * (n - i) / 2,
        h = -u * (e - r) / 2 + d * (n - i) / 2;
    if (f === 0 && h === 0) return;
    s = Math.abs(s), o = Math.abs(o);
    const p = Math.pow(f, 2) / Math.pow(s, 2) + Math.pow(h, 2) / Math.pow(o, 2);
    p > 1 && (s *= Math.sqrt(p), o *= Math.sqrt(p)), Goe(e, n, r, i, s, o, l, c, u, d, f, h, $g);
    let {
        ang1: b,
        ang2: y
    } = $g;
    const {
        centerX: m,
        centerY: g
    } = $g;
    let v = Math.abs(y) / (Kc / 4);
    Math.abs(1 - v) < 1e-7 && (v = 1);
    const _ = Math.max(Math.ceil(v), 1);
    y /= _;
    let x = t[t.length - 2],
        w = t[t.length - 1];
    const E = {
        x: 0,
        y: 0
    };
    for (let C = 0; C < _; C++) {
        const A = Uoe(b, y),
            {
                x: T,
                y: S
            } = Fg(A[0], s, o, d, u, m, g, E),
            {
                x: P,
                y: R
            } = Fg(A[1], s, o, d, u, m, g, E),
            {
                x: D,
                y: H
            } = Fg(A[2], s, o, d, u, m, g, E);
        rD(t, x, w, T, S, P, R, D, H), x = D, w = H, b += y
    }
}

function zoe(t, e, n) {
    const r = (o, a) => {
            const l = a.x - o.x,
                c = a.y - o.y,
                u = Math.sqrt(l * l + c * c),
                d = l / u,
                f = c / u;
            return {
                len: u,
                nx: d,
                ny: f
            }
        },
        i = (o, a) => {
            o === 0 ? t.moveTo(a.x, a.y) : t.lineTo(a.x, a.y)
        };
    let s = e[e.length - 1];
    for (let o = 0; o < e.length; o++) {
        const a = e[o % e.length],
            l = a.radius ? ? n;
        if (l <= 0) {
            i(o, a), s = a;
            continue
        }
        const c = e[(o + 1) % e.length],
            u = r(a, s),
            d = r(a, c);
        if (u.len < 1e-4 || d.len < 1e-4) {
            i(o, a), s = a;
            continue
        }
        let f = Math.asin(u.nx * d.ny - u.ny * d.nx),
            h = 1,
            p = !1;
        u.nx * d.nx - u.ny * -d.ny < 0 ? f < 0 ? f = Math.PI + f : (f = Math.PI - f, h = -1, p = !0) : f > 0 && (h = -1, p = !0);
        const b = f / 2;
        let y, m = Math.abs(Math.cos(b) * l / Math.sin(b));
        m > Math.min(u.len / 2, d.len / 2) ? (m = Math.min(u.len / 2, d.len / 2), y = Math.abs(m * Math.sin(b) / Math.cos(b))) : y = l;
        const g = a.x + d.nx * m + -d.ny * y * h,
            v = a.y + d.ny * m + d.nx * y * h,
            _ = Math.atan2(u.ny, u.nx) + Math.PI / 2 * h,
            x = Math.atan2(d.ny, d.nx) - Math.PI / 2 * h;
        o === 0 && t.moveTo(g + Math.cos(_) * y, v + Math.sin(_) * y), t.arc(g, v, y, _, x, p), s = a
    }
}

function joe(t, e, n, r) {
    const i = (a, l) => Math.sqrt((a.x - l.x) ** 2 + (a.y - l.y) ** 2),
        s = (a, l, c) => ({
            x: a.x + (l.x - a.x) * c,
            y: a.y + (l.y - a.y) * c
        }),
        o = e.length;
    for (let a = 0; a < o; a++) {
        const l = e[(a + 1) % o],
            c = l.radius ? ? n;
        if (c <= 0) {
            a === 0 ? t.moveTo(l.x, l.y) : t.lineTo(l.x, l.y);
            continue
        }
        const u = e[a],
            d = e[(a + 2) % o],
            f = i(u, l);
        let h;
        if (f < 1e-4) h = l;
        else {
            const y = Math.min(f / 2, c);
            h = s(l, u, y / f)
        }
        const p = i(d, l);
        let b;
        if (p < 1e-4) b = l;
        else {
            const y = Math.min(p / 2, c);
            b = s(l, d, y / p)
        }
        a === 0 ? t.moveTo(h.x, h.y) : t.lineTo(h.x, h.y), t.quadraticCurveTo(l.x, l.y, b.x, b.y, r)
    }
}
const Voe = new it;
class Woe {
    constructor(e) {
        this.shapePrimitives = [], this._currentPoly = null, this._bounds = new rn, this._graphicsPath2D = e, this.signed = e.checkForHoles
    }
    moveTo(e, n) {
        return this.startPoly(e, n), this
    }
    lineTo(e, n) {
        this._ensurePoly();
        const r = this._currentPoly.points,
            i = r[r.length - 2],
            s = r[r.length - 1];
        return (i !== e || s !== n) && r.push(e, n), this
    }
    arc(e, n, r, i, s, o) {
        this._ensurePoly(!1);
        const a = this._currentPoly.points;
        return iD(a, e, n, r, i, s, o), this
    }
    arcTo(e, n, r, i, s) {
        this._ensurePoly();
        const o = this._currentPoly.points;
        return Noe(o, e, n, r, i, s), this
    }
    arcToSvg(e, n, r, i, s, o, a) {
        const l = this._currentPoly.points;
        return Hoe(l, this._currentPoly.lastX, this._currentPoly.lastY, o, a, e, n, r, i, s), this
    }
    bezierCurveTo(e, n, r, i, s, o, a) {
        this._ensurePoly();
        const l = this._currentPoly;
        return rD(this._currentPoly.points, l.lastX, l.lastY, e, n, r, i, s, o, a), this
    }
    quadraticCurveTo(e, n, r, i, s) {
        this._ensurePoly();
        const o = this._currentPoly;
        return Foe(this._currentPoly.points, o.lastX, o.lastY, e, n, r, i, s), this
    }
    closePath() {
        return this.endPoly(!0), this
    }
    addPath(e, n) {
        this.endPoly(), n && !n.isIdentity() && (e = e.clone(!0), e.transform(n));
        const r = this.shapePrimitives,
            i = r.length;
        for (let s = 0; s < e.instructions.length; s++) {
            const o = e.instructions[s];
            this[o.action](...o.data)
        }
        if (e.checkForHoles && r.length - i > 1) {
            let s = null;
            for (let o = i; o < r.length; o++) {
                const a = r[o];
                if (a.shape.type === "polygon") {
                    const l = a.shape,
                        c = s == null ? void 0 : s.shape;
                    c && c.containsPolygon(l) ? (s.holes || (s.holes = []), s.holes.push(a), r.copyWithin(o, o + 1), r.length--, o--) : s = a
                }
            }
        }
        return this
    }
    finish(e = !1) {
        this.endPoly(e)
    }
    rect(e, n, r, i, s) {
        return this.drawShape(new it(e, n, r, i), s), this
    }
    circle(e, n, r, i) {
        return this.drawShape(new Sx(e, n, r), i), this
    }
    poly(e, n, r) {
        const i = new qc(e);
        return i.closePath = n, this.drawShape(i, r), this
    }
    regularPoly(e, n, r, i, s = 0, o) {
        i = Math.max(i | 0, 3);
        const a = -1 * Math.PI / 2 + s,
            l = Math.PI * 2 / i,
            c = [];
        for (let u = 0; u < i; u++) {
            const d = a - u * l;
            c.push(e + r * Math.cos(d), n + r * Math.sin(d))
        }
        return this.poly(c, !0, o), this
    }
    roundPoly(e, n, r, i, s, o = 0, a) {
        if (i = Math.max(i | 0, 3), s <= 0) return this.regularPoly(e, n, r, i, o);
        const l = r * Math.sin(Math.PI / i) - .001;
        s = Math.min(s, l);
        const c = -1 * Math.PI / 2 + o,
            u = Math.PI * 2 / i,
            d = (i - 2) * Math.PI / i / 2;
        for (let f = 0; f < i; f++) {
            const h = f * u + c,
                p = e + r * Math.cos(h),
                b = n + r * Math.sin(h),
                y = h + Math.PI + d,
                m = h - Math.PI - d,
                g = p + s * Math.cos(y),
                v = b + s * Math.sin(y),
                _ = p + s * Math.cos(m),
                x = b + s * Math.sin(m);
            f === 0 ? this.moveTo(g, v) : this.lineTo(g, v), this.quadraticCurveTo(p, b, _, x, a)
        }
        return this.closePath()
    }
    roundShape(e, n, r = !1, i) {
        return e.length < 3 ? this : (r ? joe(this, e, n, i) : zoe(this, e, n), this.closePath())
    }
    filletRect(e, n, r, i, s) {
        if (s === 0) return this.rect(e, n, r, i);
        const o = Math.min(r, i) / 2,
            a = Math.min(o, Math.max(-o, s)),
            l = e + r,
            c = n + i,
            u = a < 0 ? -a : 0,
            d = Math.abs(a);
        return this.moveTo(e, n + d).arcTo(e + u, n + u, e + d, n, d).lineTo(l - d, n).arcTo(l - u, n + u, l, n + d, d).lineTo(l, c - d).arcTo(l - u, c - u, e + r - d, c, d).lineTo(e + d, c).arcTo(e + u, c - u, e, c - d, d).closePath()
    }
    chamferRect(e, n, r, i, s, o) {
        if (s <= 0) return this.rect(e, n, r, i);
        const a = Math.min(s, Math.min(r, i) / 2),
            l = e + r,
            c = n + i,
            u = [e + a, n, l - a, n, l, n + a, l, c - a, l - a, c, e + a, c, e, c - a, e, n + a];
        for (let d = u.length - 1; d >= 2; d -= 2) u[d] === u[d - 2] && u[d - 1] === u[d - 3] && u.splice(d - 1, 2);
        return this.poly(u, !0, o)
    }
    ellipse(e, n, r, i, s) {
        return this.drawShape(new Tx(e, n, r, i), s), this
    }
    roundRect(e, n, r, i, s, o) {
        return this.drawShape(new Cx(e, n, r, i, s), o), this
    }
    drawShape(e, n) {
        return this.endPoly(), this.shapePrimitives.push({
            shape: e,
            transform: n
        }), this
    }
    startPoly(e, n) {
        let r = this._currentPoly;
        return r && this.endPoly(), r = new qc, r.points.push(e, n), this._currentPoly = r, this
    }
    endPoly(e = !1) {
        const n = this._currentPoly;
        return n && n.points.length > 2 && (n.closePath = e, this.shapePrimitives.push({
            shape: n
        })), this._currentPoly = null, this
    }
    _ensurePoly(e = !0) {
        if (!this._currentPoly && (this._currentPoly = new qc, e)) {
            const n = this.shapePrimitives[this.shapePrimitives.length - 1];
            if (n) {
                let r = n.shape.x,
                    i = n.shape.y;
                if (n.transform && !n.transform.isIdentity()) {
                    const s = n.transform,
                        o = r;
                    r = s.a * r + s.c * i + s.tx, i = s.b * o + s.d * i + s.ty
                }
                this._currentPoly.points.push(r, i)
            } else this._currentPoly.points.push(0, 0)
        }
    }
    buildPath() {
        const e = this._graphicsPath2D;
        this.shapePrimitives.length = 0, this._currentPoly = null;
        for (let n = 0; n < e.instructions.length; n++) {
            const r = e.instructions[n];
            this[r.action](...r.data)
        }
        this.finish()
    }
    get bounds() {
        const e = this._bounds;
        e.clear();
        const n = this.shapePrimitives;
        for (let r = 0; r < n.length; r++) {
            const i = n[r],
                s = i.shape.getBounds(Voe);
            i.transform ? e.addRect(s, i.transform) : e.addRect(s)
        }
        return e
    }
}
class Pl {
    constructor(e, n = !1) {
        this.instructions = [], this.uid = vt("graphicsPath"), this._dirty = !0, this.checkForHoles = n, typeof e == "string" ? Ase(e, this) : this.instructions = (e == null ? void 0 : e.slice()) ? ? []
    }
    get shapePath() {
        return this._shapePath || (this._shapePath = new Woe(this)), this._dirty && (this._dirty = !1, this._shapePath.buildPath()), this._shapePath
    }
    addPath(e, n) {
        return e = e.clone(), this.instructions.push({
            action: "addPath",
            data: [e, n]
        }), this._dirty = !0, this
    }
    arc(...e) {
        return this.instructions.push({
            action: "arc",
            data: e
        }), this._dirty = !0, this
    }
    arcTo(...e) {
        return this.instructions.push({
            action: "arcTo",
            data: e
        }), this._dirty = !0, this
    }
    arcToSvg(...e) {
        return this.instructions.push({
            action: "arcToSvg",
            data: e
        }), this._dirty = !0, this
    }
    bezierCurveTo(...e) {
        return this.instructions.push({
            action: "bezierCurveTo",
            data: e
        }), this._dirty = !0, this
    }
    bezierCurveToShort(e, n, r, i, s) {
        const o = this.instructions[this.instructions.length - 1],
            a = this.getLastPoint(dt.shared);
        let l = 0,
            c = 0;
        if (!o || o.action !== "bezierCurveTo") l = a.x, c = a.y;
        else {
            l = o.data[2], c = o.data[3];
            const u = a.x,
                d = a.y;
            l = u + (u - l), c = d + (d - c)
        }
        return this.instructions.push({
            action: "bezierCurveTo",
            data: [l, c, e, n, r, i, s]
        }), this._dirty = !0, this
    }
    closePath() {
        return this.instructions.push({
            action: "closePath",
            data: []
        }), this._dirty = !0, this
    }
    ellipse(...e) {
        return this.instructions.push({
            action: "ellipse",
            data: e
        }), this._dirty = !0, this
    }
    lineTo(...e) {
        return this.instructions.push({
            action: "lineTo",
            data: e
        }), this._dirty = !0, this
    }
    moveTo(...e) {
        return this.instructions.push({
            action: "moveTo",
            data: e
        }), this
    }
    quadraticCurveTo(...e) {
        return this.instructions.push({
            action: "quadraticCurveTo",
            data: e
        }), this._dirty = !0, this
    }
    quadraticCurveToShort(e, n, r) {
        const i = this.instructions[this.instructions.length - 1],
            s = this.getLastPoint(dt.shared);
        let o = 0,
            a = 0;
        if (!i || i.action !== "quadraticCurveTo") o = s.x, a = s.y;
        else {
            o = i.data[0], a = i.data[1];
            const l = s.x,
                c = s.y;
            o = l + (l - o), a = c + (c - a)
        }
        return this.instructions.push({
            action: "quadraticCurveTo",
            data: [o, a, e, n, r]
        }), this._dirty = !0, this
    }
    rect(e, n, r, i, s) {
        return this.instructions.push({
            action: "rect",
            data: [e, n, r, i, s]
        }), this._dirty = !0, this
    }
    circle(e, n, r, i) {
        return this.instructions.push({
            action: "circle",
            data: [e, n, r, i]
        }), this._dirty = !0, this
    }
    roundRect(...e) {
        return this.instructions.push({
            action: "roundRect",
            data: e
        }), this._dirty = !0, this
    }
    poly(...e) {
        return this.instructions.push({
            action: "poly",
            data: e
        }), this._dirty = !0, this
    }
    regularPoly(...e) {
        return this.instructions.push({
            action: "regularPoly",
            data: e
        }), this._dirty = !0, this
    }
    roundPoly(...e) {
        return this.instructions.push({
            action: "roundPoly",
            data: e
        }), this._dirty = !0, this
    }
    roundShape(...e) {
        return this.instructions.push({
            action: "roundShape",
            data: e
        }), this._dirty = !0, this
    }
    filletRect(...e) {
        return this.instructions.push({
            action: "filletRect",
            data: e
        }), this._dirty = !0, this
    }
    chamferRect(...e) {
        return this.instructions.push({
            action: "chamferRect",
            data: e
        }), this._dirty = !0, this
    }
    star(e, n, r, i, s, o, a) {
        s || (s = i / 2);
        const l = -1 * Math.PI / 2 + o,
            c = r * 2,
            u = Math.PI * 2 / c,
            d = [];
        for (let f = 0; f < c; f++) {
            const h = f % 2 ? s : i,
                p = f * u + l;
            d.push(e + h * Math.cos(p), n + h * Math.sin(p))
        }
        return this.poly(d, !0, a), this
    }
    clone(e = !1) {
        const n = new Pl;
        if (n.checkForHoles = this.checkForHoles, !e) n.instructions = this.instructions.slice();
        else
            for (let r = 0; r < this.instructions.length; r++) {
                const i = this.instructions[r];
                n.instructions.push({
                    action: i.action,
                    data: i.data.slice()
                })
            }
        return n
    }
    clear() {
        return this.instructions.length = 0, this._dirty = !0, this
    }
    transform(e) {
        if (e.isIdentity()) return this;
        const n = e.a,
            r = e.b,
            i = e.c,
            s = e.d,
            o = e.tx,
            a = e.ty;
        let l = 0,
            c = 0,
            u = 0,
            d = 0,
            f = 0,
            h = 0,
            p = 0,
            b = 0;
        for (let y = 0; y < this.instructions.length; y++) {
            const m = this.instructions[y],
                g = m.data;
            switch (m.action) {
                case "moveTo":
                case "lineTo":
                    l = g[0], c = g[1], g[0] = n * l + i * c + o, g[1] = r * l + s * c + a;
                    break;
                case "bezierCurveTo":
                    u = g[0], d = g[1], f = g[2], h = g[3], l = g[4], c = g[5], g[0] = n * u + i * d + o, g[1] = r * u + s * d + a, g[2] = n * f + i * h + o, g[3] = r * f + s * h + a, g[4] = n * l + i * c + o, g[5] = r * l + s * c + a;
                    break;
                case "quadraticCurveTo":
                    u = g[0], d = g[1], l = g[2], c = g[3], g[0] = n * u + i * d + o, g[1] = r * u + s * d + a, g[2] = n * l + i * c + o, g[3] = r * l + s * c + a;
                    break;
                case "arcToSvg":
                    l = g[5], c = g[6], p = g[0], b = g[1], g[0] = n * p + i * b, g[1] = r * p + s * b, g[5] = n * l + i * c + o, g[6] = r * l + s * c + a;
                    break;
                case "circle":
                    g[4] = _c(g[3], e);
                    break;
                case "rect":
                    g[4] = _c(g[4], e);
                    break;
                case "ellipse":
                    g[8] = _c(g[8], e);
                    break;
                case "roundRect":
                    g[5] = _c(g[5], e);
                    break;
                case "addPath":
                    g[0].transform(e);
                    break;
                case "poly":
                    g[2] = _c(g[2], e);
                    break;
                default:
                    Oe("unknown transform action", m.action);
                    break
            }
        }
        return this._dirty = !0, this
    }
    get bounds() {
        return this.shapePath.bounds
    }
    getLastPoint(e) {
        let n = this.instructions.length - 1,
            r = this.instructions[n];
        if (!r) return e.x = 0, e.y = 0, e;
        for (; r.action === "closePath";) {
            if (n--, n < 0) return e.x = 0, e.y = 0, e;
            r = this.instructions[n]
        }
        switch (r.action) {
            case "moveTo":
            case "lineTo":
                e.x = r.data[0], e.y = r.data[1];
                break;
            case "quadraticCurveTo":
                e.x = r.data[2], e.y = r.data[3];
                break;
            case "bezierCurveTo":
                e.x = r.data[4], e.y = r.data[5];
                break;
            case "arc":
            case "arcToSvg":
                e.x = r.data[5], e.y = r.data[6];
                break;
            case "addPath":
                r.data[0].getLastPoint(e);
                break
        }
        return e
    }
}

function _c(t, e) {
    return t ? t.prepend(e) : e.clone()
}

function Pt(t, e, n) {
    const r = t.getAttribute(e);
    return r ? Number(r) : n
}

function Yoe(t, e) {
    const n = t.querySelectorAll("defs");
    for (let r = 0; r < n.length; r++) {
        const i = n[r];
        for (let s = 0; s < i.children.length; s++) {
            const o = i.children[s];
            switch (o.nodeName.toLowerCase()) {
                case "lineargradient":
                    e.defs[o.id] = Xoe(o);
                    break;
                case "radialgradient":
                    e.defs[o.id] = qoe();
                    break
            }
        }
    }
}

function Xoe(t) {
    const e = Pt(t, "x1", 0),
        n = Pt(t, "y1", 0),
        r = Pt(t, "x2", 1),
        i = Pt(t, "y2", 0),
        s = t.getAttribute("gradientUnits") || "objectBoundingBox",
        o = new Qi(e, n, r, i, s === "objectBoundingBox" ? "local" : "global");
    for (let a = 0; a < t.children.length; a++) {
        const l = t.children[a],
            c = Pt(l, "offset", 0),
            u = tt.shared.setValue(l.getAttribute("stop-color")).toNumber();
        o.addColorStop(c, u)
    }
    return o
}

function qoe(t) {
    return Oe("[SVG Parser] Radial gradients are not yet supported"), new Qi(0, 0, 1, 0)
}

function iC(t) {
    const e = t.match(/url\s*\(\s*['"]?\s*#([^'"\s)]+)\s*['"]?\s*\)/i);
    return e ? e[1] : ""
}
const sC = {
    fill: {
        type: "paint",
        default: 0
    },
    "fill-opacity": {
        type: "number",
        default: 1
    },
    stroke: {
        type: "paint",
        default: 0
    },
    "stroke-width": {
        type: "number",
        default: 1
    },
    "stroke-opacity": {
        type: "number",
        default: 1
    },
    "stroke-linecap": {
        type: "string",
        default: "butt"
    },
    "stroke-linejoin": {
        type: "string",
        default: "miter"
    },
    "stroke-miterlimit": {
        type: "number",
        default: 10
    },
    "stroke-dasharray": {
        type: "string",
        default: "none"
    },
    "stroke-dashoffset": {
        type: "number",
        default: 0
    },
    opacity: {
        type: "number",
        default: 1
    }
};

function sD(t, e) {
    const n = t.getAttribute("style"),
        r = {},
        i = {},
        s = {
            strokeStyle: r,
            fillStyle: i,
            useFill: !1,
            useStroke: !1
        };
    for (const o in sC) {
        const a = t.getAttribute(o);
        a && oC(e, s, o, a.trim())
    }
    if (n) {
        const o = n.split(";");
        for (let a = 0; a < o.length; a++) {
            const l = o[a].trim(),
                [c, u] = l.split(":");
            sC[c] && oC(e, s, c, u.trim())
        }
    }
    return {
        strokeStyle: s.useStroke ? r : null,
        fillStyle: s.useFill ? i : null,
        useFill: s.useFill,
        useStroke: s.useStroke
    }
}

function oC(t, e, n, r) {
    switch (n) {
        case "stroke":
            if (r !== "none") {
                if (r.startsWith("url(")) {
                    const i = iC(r);
                    e.strokeStyle.fill = t.defs[i]
                } else e.strokeStyle.color = tt.shared.setValue(r).toNumber();
                e.useStroke = !0
            }
            break;
        case "stroke-width":
            e.strokeStyle.width = Number(r);
            break;
        case "fill":
            if (r !== "none") {
                if (r.startsWith("url(")) {
                    const i = iC(r);
                    e.fillStyle.fill = t.defs[i]
                } else e.fillStyle.color = tt.shared.setValue(r).toNumber();
                e.useFill = !0
            }
            break;
        case "fill-opacity":
            e.fillStyle.alpha = Number(r);
            break;
        case "stroke-opacity":
            e.strokeStyle.alpha = Number(r);
            break;
        case "opacity":
            e.fillStyle.alpha = Number(r), e.strokeStyle.alpha = Number(r);
            break
    }
}

function Koe(t, e) {
    if (typeof t == "string") {
        const o = document.createElement("div");
        o.innerHTML = t.trim(), t = o.querySelector("svg")
    }
    const n = {
        context: e,
        defs: {},
        path: new Pl
    };
    Yoe(t, n);
    const r = t.children,
        {
            fillStyle: i,
            strokeStyle: s
        } = sD(t, n);
    for (let o = 0; o < r.length; o++) {
        const a = r[o];
        a.nodeName.toLowerCase() !== "defs" && oD(a, n, i, s)
    }
    return e
}

function oD(t, e, n, r) {
    const i = t.children,
        {
            fillStyle: s,
            strokeStyle: o
        } = sD(t, e);
    s && n ? n = { ...n,
        ...s
    } : s && (n = s), o && r ? r = { ...r,
        ...o
    } : o && (r = o);
    const a = !n && !r;
    a && (n = {
        color: 0
    });
    let l, c, u, d, f, h, p, b, y, m, g, v, _, x, w, E, C;
    switch (t.nodeName.toLowerCase()) {
        case "path":
            x = t.getAttribute("d"), t.getAttribute("fill-rule") === "evenodd" && Oe("SVG Evenodd fill rule not supported, your svg may render incorrectly"), w = new Pl(x, !0), e.context.path(w), n && e.context.fill(n), r && e.context.stroke(r);
            break;
        case "circle":
            p = Pt(t, "cx", 0), b = Pt(t, "cy", 0), y = Pt(t, "r", 0), e.context.ellipse(p, b, y, y), n && e.context.fill(n), r && e.context.stroke(r);
            break;
        case "rect":
            l = Pt(t, "x", 0), c = Pt(t, "y", 0), E = Pt(t, "width", 0), C = Pt(t, "height", 0), m = Pt(t, "rx", 0), g = Pt(t, "ry", 0), m || g ? e.context.roundRect(l, c, E, C, m || g) : e.context.rect(l, c, E, C), n && e.context.fill(n), r && e.context.stroke(r);
            break;
        case "ellipse":
            p = Pt(t, "cx", 0), b = Pt(t, "cy", 0), m = Pt(t, "rx", 0), g = Pt(t, "ry", 0), e.context.beginPath(), e.context.ellipse(p, b, m, g), n && e.context.fill(n), r && e.context.stroke(r);
            break;
        case "line":
            u = Pt(t, "x1", 0), d = Pt(t, "y1", 0), f = Pt(t, "x2", 0), h = Pt(t, "y2", 0), e.context.beginPath(), e.context.moveTo(u, d), e.context.lineTo(f, h), r && e.context.stroke(r);
            break;
        case "polygon":
            _ = t.getAttribute("points"), v = _.match(/\d+/g).map(A => parseInt(A, 10)), e.context.poly(v, !0), n && e.context.fill(n), r && e.context.stroke(r);
            break;
        case "polyline":
            _ = t.getAttribute("points"), v = _.match(/\d+/g).map(A => parseInt(A, 10)), e.context.poly(v, !1), r && e.context.stroke(r);
            break;
        case "g":
        case "svg":
            break;
        default:
            {
                Oe(`[SVG parser] <${t.nodeName}> elements unsupported`);
                break
            }
    }
    a && (n = null);
    for (let A = 0; A < i.length; A++) oD(i[A], e, n, r)
}

function Joe(t) {
    return tt.isColorLike(t)
}

function aC(t) {
    return t instanceof tm
}

function lC(t) {
    return t instanceof Qi
}

function Zoe(t) {
    return t instanceof we
}

function Qoe(t, e, n) {
    const r = tt.shared.setValue(e ? ? 0);
    return t.color = r.toNumber(), t.alpha = r.alpha === 1 ? n.alpha : r.alpha, t.texture = we.WHITE, { ...n,
        ...t
    }
}

function eae(t, e, n) {
    return t.texture = e, { ...n,
        ...t
    }
}

function cC(t, e, n) {
    return t.fill = e, t.color = 16777215, t.texture = e.texture, t.matrix = e.transform, { ...n,
        ...t
    }
}

function uC(t, e, n) {
    return e.buildGradient(), t.fill = e, t.color = 16777215, t.texture = e.texture, t.matrix = e.transform, t.textureSpace = e.textureSpace, { ...n,
        ...t
    }
}

function tae(t, e) {
    const n = { ...e,
            ...t
        },
        r = tt.shared.setValue(n.color);
    return n.alpha *= r.alpha, n.color = r.toNumber(), n
}

function Ro(t, e) {
    if (t == null) return null;
    const n = {},
        r = t;
    return Joe(t) ? Qoe(n, t, e) : Zoe(t) ? eae(n, t, e) : aC(t) ? cC(n, t, e) : lC(t) ? uC(n, t, e) : r.fill && aC(r.fill) ? cC(r, r.fill, e) : r.fill && lC(r.fill) ? uC(r, r.fill, e) : tae(r, e)
}

function kh(t, e) {
    const {
        width: n,
        alignment: r,
        miterLimit: i,
        cap: s,
        join: o,
        pixelLine: a,
        ...l
    } = e, c = Ro(t, l);
    return c ? {
        width: n,
        alignment: r,
        miterLimit: i,
        cap: s,
        join: o,
        pixelLine: a,
        ...c
    } : null
}
const nae = new dt,
    dC = new Te,
    Fx = class Yr extends ir {
        constructor() {
            super(...arguments), this.uid = vt("graphicsContext"), this.dirty = !0, this.batchMode = "auto", this.instructions = [], this._activePath = new Pl, this._transform = new Te, this._fillStyle = { ...Yr.defaultFillStyle
            }, this._strokeStyle = { ...Yr.defaultStrokeStyle
            }, this._stateStack = [], this._tick = 0, this._bounds = new rn, this._boundsDirty = !0
        }
        clone() {
            const e = new Yr;
            return e.batchMode = this.batchMode, e.instructions = this.instructions.slice(), e._activePath = this._activePath.clone(), e._transform = this._transform.clone(), e._fillStyle = { ...this._fillStyle
            }, e._strokeStyle = { ...this._strokeStyle
            }, e._stateStack = this._stateStack.slice(), e._bounds = this._bounds.clone(), e._boundsDirty = !0, e
        }
        get fillStyle() {
            return this._fillStyle
        }
        set fillStyle(e) {
            this._fillStyle = Ro(e, Yr.defaultFillStyle)
        }
        get strokeStyle() {
            return this._strokeStyle
        }
        set strokeStyle(e) {
            this._strokeStyle = kh(e, Yr.defaultStrokeStyle)
        }
        setFillStyle(e) {
            return this._fillStyle = Ro(e, Yr.defaultFillStyle), this
        }
        setStrokeStyle(e) {
            return this._strokeStyle = Ro(e, Yr.defaultStrokeStyle), this
        }
        texture(e, n, r, i, s, o) {
            return this.instructions.push({
                action: "texture",
                data: {
                    image: e,
                    dx: r || 0,
                    dy: i || 0,
                    dw: s || e.frame.width,
                    dh: o || e.frame.height,
                    transform: this._transform.clone(),
                    alpha: this._fillStyle.alpha,
                    style: n ? tt.shared.setValue(n).toNumber() : 16777215
                }
            }), this.onUpdate(), this
        }
        beginPath() {
            return this._activePath = new Pl, this
        }
        fill(e, n) {
            let r;
            const i = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && i && i.action === "stroke" ? r = i.data.path : r = this._activePath.clone(), r ? (e != null && (n !== void 0 && typeof e == "number" && (Ie(Ye, "GraphicsContext.fill(color, alpha) is deprecated, use GraphicsContext.fill({ color, alpha }) instead"), e = {
                color: e,
                alpha: n
            }), this._fillStyle = Ro(e, Yr.defaultFillStyle)), this.instructions.push({
                action: "fill",
                data: {
                    style: this.fillStyle,
                    path: r
                }
            }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this
        }
        _initNextPathLocation() {
            const {
                x: e,
                y: n
            } = this._activePath.getLastPoint(dt.shared);
            this._activePath.clear(), this._activePath.moveTo(e, n)
        }
        stroke(e) {
            let n;
            const r = this.instructions[this.instructions.length - 1];
            return this._tick === 0 && r && r.action === "fill" ? n = r.data.path : n = this._activePath.clone(), n ? (e != null && (this._strokeStyle = kh(e, Yr.defaultStrokeStyle)), this.instructions.push({
                action: "stroke",
                data: {
                    style: this.strokeStyle,
                    path: n
                }
            }), this.onUpdate(), this._initNextPathLocation(), this._tick = 0, this) : this
        }
        cut() {
            for (let e = 0; e < 2; e++) {
                const n = this.instructions[this.instructions.length - 1 - e],
                    r = this._activePath.clone();
                if (n && (n.action === "stroke" || n.action === "fill"))
                    if (n.data.hole) n.data.hole.addPath(r);
                    else {
                        n.data.hole = r;
                        break
                    }
            }
            return this._initNextPathLocation(), this
        }
        arc(e, n, r, i, s, o) {
            this._tick++;
            const a = this._transform;
            return this._activePath.arc(a.a * e + a.c * n + a.tx, a.b * e + a.d * n + a.ty, r, i, s, o), this
        }
        arcTo(e, n, r, i, s) {
            this._tick++;
            const o = this._transform;
            return this._activePath.arcTo(o.a * e + o.c * n + o.tx, o.b * e + o.d * n + o.ty, o.a * r + o.c * i + o.tx, o.b * r + o.d * i + o.ty, s), this
        }
        arcToSvg(e, n, r, i, s, o, a) {
            this._tick++;
            const l = this._transform;
            return this._activePath.arcToSvg(e, n, r, i, s, l.a * o + l.c * a + l.tx, l.b * o + l.d * a + l.ty), this
        }
        bezierCurveTo(e, n, r, i, s, o, a) {
            this._tick++;
            const l = this._transform;
            return this._activePath.bezierCurveTo(l.a * e + l.c * n + l.tx, l.b * e + l.d * n + l.ty, l.a * r + l.c * i + l.tx, l.b * r + l.d * i + l.ty, l.a * s + l.c * o + l.tx, l.b * s + l.d * o + l.ty, a), this
        }
        closePath() {
            var e;
            return this._tick++, (e = this._activePath) == null || e.closePath(), this
        }
        ellipse(e, n, r, i) {
            return this._tick++, this._activePath.ellipse(e, n, r, i, this._transform.clone()), this
        }
        circle(e, n, r) {
            return this._tick++, this._activePath.circle(e, n, r, this._transform.clone()), this
        }
        path(e) {
            return this._tick++, this._activePath.addPath(e, this._transform.clone()), this
        }
        lineTo(e, n) {
            this._tick++;
            const r = this._transform;
            return this._activePath.lineTo(r.a * e + r.c * n + r.tx, r.b * e + r.d * n + r.ty), this
        }
        moveTo(e, n) {
            this._tick++;
            const r = this._transform,
                i = this._activePath.instructions,
                s = r.a * e + r.c * n + r.tx,
                o = r.b * e + r.d * n + r.ty;
            return i.length === 1 && i[0].action === "moveTo" ? (i[0].data[0] = s, i[0].data[1] = o, this) : (this._activePath.moveTo(s, o), this)
        }
        quadraticCurveTo(e, n, r, i, s) {
            this._tick++;
            const o = this._transform;
            return this._activePath.quadraticCurveTo(o.a * e + o.c * n + o.tx, o.b * e + o.d * n + o.ty, o.a * r + o.c * i + o.tx, o.b * r + o.d * i + o.ty, s), this
        }
        rect(e, n, r, i) {
            return this._tick++, this._activePath.rect(e, n, r, i, this._transform.clone()), this
        }
        roundRect(e, n, r, i, s) {
            return this._tick++, this._activePath.roundRect(e, n, r, i, s, this._transform.clone()), this
        }
        poly(e, n) {
            return this._tick++, this._activePath.poly(e, n, this._transform.clone()), this
        }
        regularPoly(e, n, r, i, s = 0, o) {
            return this._tick++, this._activePath.regularPoly(e, n, r, i, s, o), this
        }
        roundPoly(e, n, r, i, s, o) {
            return this._tick++, this._activePath.roundPoly(e, n, r, i, s, o), this
        }
        roundShape(e, n, r, i) {
            return this._tick++, this._activePath.roundShape(e, n, r, i), this
        }
        filletRect(e, n, r, i, s) {
            return this._tick++, this._activePath.filletRect(e, n, r, i, s), this
        }
        chamferRect(e, n, r, i, s, o) {
            return this._tick++, this._activePath.chamferRect(e, n, r, i, s, o), this
        }
        star(e, n, r, i, s = 0, o = 0) {
            return this._tick++, this._activePath.star(e, n, r, i, s, o, this._transform.clone()), this
        }
        svg(e) {
            return this._tick++, Koe(e, this), this
        }
        restore() {
            const e = this._stateStack.pop();
            return e && (this._transform = e.transform, this._fillStyle = e.fillStyle, this._strokeStyle = e.strokeStyle), this
        }
        save() {
            return this._stateStack.push({
                transform: this._transform.clone(),
                fillStyle: { ...this._fillStyle
                },
                strokeStyle: { ...this._strokeStyle
                }
            }), this
        }
        getTransform() {
            return this._transform
        }
        resetTransform() {
            return this._transform.identity(), this
        }
        rotate(e) {
            return this._transform.rotate(e), this
        }
        scale(e, n = e) {
            return this._transform.scale(e, n), this
        }
        setTransform(e, n, r, i, s, o) {
            return e instanceof Te ? (this._transform.set(e.a, e.b, e.c, e.d, e.tx, e.ty), this) : (this._transform.set(e, n, r, i, s, o), this)
        }
        transform(e, n, r, i, s, o) {
            return e instanceof Te ? (this._transform.append(e), this) : (dC.set(e, n, r, i, s, o), this._transform.append(dC), this)
        }
        translate(e, n = e) {
            return this._transform.translate(e, n), this
        }
        clear() {
            return this._activePath.clear(), this.instructions.length = 0, this.resetTransform(), this.onUpdate(), this
        }
        onUpdate() {
            this.dirty || (this.emit("update", this, 16), this.dirty = !0, this._boundsDirty = !0)
        }
        get bounds() {
            if (!this._boundsDirty) return this._bounds;
            const e = this._bounds;
            e.clear();
            for (let n = 0; n < this.instructions.length; n++) {
                const r = this.instructions[n],
                    i = r.action;
                if (i === "fill") {
                    const s = r.data;
                    e.addBounds(s.path.bounds)
                } else if (i === "texture") {
                    const s = r.data;
                    e.addFrame(s.dx, s.dy, s.dx + s.dw, s.dy + s.dh, s.transform)
                }
                if (i === "stroke") {
                    const s = r.data,
                        o = s.style.alignment,
                        a = s.style.width * (1 - o),
                        l = s.path.bounds;
                    e.addFrame(l.minX - a, l.minY - a, l.maxX + a, l.maxY + a)
                }
            }
            return e
        }
        containsPoint(e) {
            var i;
            if (!this.bounds.containsPoint(e.x, e.y)) return !1;
            const n = this.instructions;
            let r = !1;
            for (let s = 0; s < n.length; s++) {
                const o = n[s],
                    a = o.data,
                    l = a.path;
                if (!o.action || !l) continue;
                const c = a.style,
                    u = l.shapePath.shapePrimitives;
                for (let d = 0; d < u.length; d++) {
                    const f = u[d].shape;
                    if (!c || !f) continue;
                    const h = u[d].transform,
                        p = h ? h.applyInverse(e, nae) : e;
                    if (o.action === "fill") r = f.contains(p.x, p.y);
                    else {
                        const y = c;
                        r = f.strokeContains(p.x, p.y, y.width, y.alignment)
                    }
                    const b = a.hole;
                    if (b) {
                        const y = (i = b.shapePath) == null ? void 0 : i.shapePrimitives;
                        if (y)
                            for (let m = 0; m < y.length; m++) y[m].shape.contains(p.x, p.y) && (r = !1)
                    }
                    if (r) return !0
                }
            }
            return r
        }
        destroy(e = !1) {
            if (this._stateStack.length = 0, this._transform = null, this.emit("destroy", this), this.removeAllListeners(), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
                const r = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
                this._fillStyle.texture && this._fillStyle.texture.destroy(r), this._strokeStyle.texture && this._strokeStyle.texture.destroy(r)
            }
            this._fillStyle = null, this._strokeStyle = null, this.instructions = null, this._activePath = null, this._bounds = null, this._stateStack = null, this.customShader = null, this._transform = null
        }
    };
Fx.defaultFillStyle = {
    color: 16777215,
    alpha: 1,
    texture: we.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local"
};
Fx.defaultStrokeStyle = {
    width: 1,
    color: 16777215,
    alpha: 1,
    alignment: .5,
    miterLimit: 10,
    cap: "butt",
    join: "miter",
    texture: we.WHITE,
    matrix: null,
    fill: null,
    textureSpace: "local",
    pixelLine: !1
};
let hr = Fx;
const fC = ["align", "breakWords", "cssOverrides", "fontVariant", "fontWeight", "leading", "letterSpacing", "lineHeight", "padding", "textBaseline", "trim", "whiteSpace", "wordWrap", "wordWrapWidth", "fontFamily", "fontStyle", "fontSize"];

function rae(t) {
    const e = [];
    let n = 0;
    for (let r = 0; r < fC.length; r++) {
        const i = `_${fC[r]}`;
        e[n++] = t[i]
    }
    return n = aD(t._fill, e, n), n = sae(t._stroke, e, n), n = oae(t.dropShadow, e, n), n = iae(t.filters, e, n), e.join("-")
}

function iae(t, e, n) {
    if (!t) return n;
    for (const r of t) e[n++] = r.uid;
    return n
}

function aD(t, e, n) {
    var r;
    return t && (e[n++] = t.color, e[n++] = t.alpha, e[n++] = (r = t.fill) == null ? void 0 : r.styleKey), n
}

function sae(t, e, n) {
    return t && (n = aD(t, e, n), e[n++] = t.width, e[n++] = t.alignment, e[n++] = t.cap, e[n++] = t.join, e[n++] = t.miterLimit), n
}

function oae(t, e, n) {
    return t && (e[n++] = t.alpha, e[n++] = t.angle, e[n++] = t.blur, e[n++] = t.distance, e[n++] = tt.shared.setValue(t.color).toNumber()), n
}
const Lx = class Xa extends ir {
    constructor(e = {}) {
        super(), aae(e);
        const n = { ...Xa.defaultTextStyle,
            ...e
        };
        for (const r in n) {
            const i = r;
            this[i] = n[r]
        }
        this.update()
    }
    get align() {
        return this._align
    }
    set align(e) {
        this._align = e, this.update()
    }
    get breakWords() {
        return this._breakWords
    }
    set breakWords(e) {
        this._breakWords = e, this.update()
    }
    get dropShadow() {
        return this._dropShadow
    }
    set dropShadow(e) {
        e !== null && typeof e == "object" ? this._dropShadow = this._createProxy({ ...Xa.defaultDropShadow,
            ...e
        }) : this._dropShadow = e ? this._createProxy({ ...Xa.defaultDropShadow
        }) : null, this.update()
    }
    get fontFamily() {
        return this._fontFamily
    }
    set fontFamily(e) {
        this._fontFamily = e, this.update()
    }
    get fontSize() {
        return this._fontSize
    }
    set fontSize(e) {
        typeof e == "string" ? this._fontSize = parseInt(e, 10) : this._fontSize = e, this.update()
    }
    get fontStyle() {
        return this._fontStyle
    }
    set fontStyle(e) {
        this._fontStyle = e.toLowerCase(), this.update()
    }
    get fontVariant() {
        return this._fontVariant
    }
    set fontVariant(e) {
        this._fontVariant = e, this.update()
    }
    get fontWeight() {
        return this._fontWeight
    }
    set fontWeight(e) {
        this._fontWeight = e, this.update()
    }
    get leading() {
        return this._leading
    }
    set leading(e) {
        this._leading = e, this.update()
    }
    get letterSpacing() {
        return this._letterSpacing
    }
    set letterSpacing(e) {
        this._letterSpacing = e, this.update()
    }
    get lineHeight() {
        return this._lineHeight
    }
    set lineHeight(e) {
        this._lineHeight = e, this.update()
    }
    get padding() {
        return this._padding
    }
    set padding(e) {
        this._padding = e, this.update()
    }
    get filters() {
        return this._filters
    }
    set filters(e) {
        this._filters = e, this.update()
    }
    get trim() {
        return this._trim
    }
    set trim(e) {
        this._trim = e, this.update()
    }
    get textBaseline() {
        return this._textBaseline
    }
    set textBaseline(e) {
        this._textBaseline = e, this.update()
    }
    get whiteSpace() {
        return this._whiteSpace
    }
    set whiteSpace(e) {
        this._whiteSpace = e, this.update()
    }
    get wordWrap() {
        return this._wordWrap
    }
    set wordWrap(e) {
        this._wordWrap = e, this.update()
    }
    get wordWrapWidth() {
        return this._wordWrapWidth
    }
    set wordWrapWidth(e) {
        this._wordWrapWidth = e, this.update()
    }
    get fill() {
        return this._originalFill
    }
    set fill(e) {
        e !== this._originalFill && (this._originalFill = e, this._isFillStyle(e) && (this._originalFill = this._createProxy({ ...hr.defaultFillStyle,
            ...e
        }, () => {
            this._fill = Ro({ ...this._originalFill
            }, hr.defaultFillStyle)
        })), this._fill = Ro(e === 0 ? "black" : e, hr.defaultFillStyle), this.update())
    }
    get stroke() {
        return this._originalStroke
    }
    set stroke(e) {
        e !== this._originalStroke && (this._originalStroke = e, this._isFillStyle(e) && (this._originalStroke = this._createProxy({ ...hr.defaultStrokeStyle,
            ...e
        }, () => {
            this._stroke = kh({ ...this._originalStroke
            }, hr.defaultStrokeStyle)
        })), this._stroke = kh(e, hr.defaultStrokeStyle), this.update())
    }
    _generateKey() {
        return this._styleKey = rae(this), this._styleKey
    }
    update() {
        this._styleKey = null, this.emit("update", this)
    }
    reset() {
        const e = Xa.defaultTextStyle;
        for (const n in e) this[n] = e[n]
    }
    get styleKey() {
        return this._styleKey || this._generateKey()
    }
    clone() {
        return new Xa({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this._dropShadow ? { ...this._dropShadow
            } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            leading: this.leading,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            textBaseline: this.textBaseline,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            filters: this._filters ? [...this._filters] : void 0
        })
    }
    _getFinalPadding() {
        let e = 0;
        if (this._filters)
            for (let n = 0; n < this._filters.length; n++) e += this._filters[n].padding;
        return Math.max(this._padding, e)
    }
    destroy(e = !1) {
        var r, i, s, o;
        if (this.removeAllListeners(), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
            const a = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
            (r = this._fill) != null && r.texture && this._fill.texture.destroy(a), (i = this._originalFill) != null && i.texture && this._originalFill.texture.destroy(a), (s = this._stroke) != null && s.texture && this._stroke.texture.destroy(a), (o = this._originalStroke) != null && o.texture && this._originalStroke.texture.destroy(a)
        }
        this._fill = null, this._stroke = null, this.dropShadow = null, this._originalStroke = null, this._originalFill = null
    }
    _createProxy(e, n) {
        return new Proxy(e, {
            set: (r, i, s) => (r[i] = s, n == null || n(i, s), this.update(), !0)
        })
    }
    _isFillStyle(e) {
        return (e ? ? null) !== null && !(tt.isColorLike(e) || e instanceof Qi || e instanceof tm)
    }
};
Lx.defaultDropShadow = {
    alpha: 1,
    angle: Math.PI / 6,
    blur: 0,
    color: "black",
    distance: 5
};
Lx.defaultTextStyle = {
    align: "left",
    breakWords: !1,
    dropShadow: null,
    fill: "black",
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    padding: 0,
    stroke: null,
    textBaseline: "alphabetic",
    trim: !1,
    whiteSpace: "pre",
    wordWrap: !1,
    wordWrapWidth: 100
};
let es = Lx;

function aae(t) {
    const e = t;
    if (typeof e.dropShadow == "boolean" && e.dropShadow) {
        const n = es.defaultDropShadow;
        t.dropShadow = {
            alpha: e.dropShadowAlpha ? ? n.alpha,
            angle: e.dropShadowAngle ? ? n.angle,
            blur: e.dropShadowBlur ? ? n.blur,
            color: e.dropShadowColor ? ? n.color,
            distance: e.dropShadowDistance ? ? n.distance
        }
    }
    if (e.strokeThickness !== void 0) {
        Ie(Ye, "strokeThickness is now a part of stroke");
        const n = e.stroke;
        let r = {};
        if (tt.isColorLike(n)) r.color = n;
        else if (n instanceof Qi || n instanceof tm) r.fill = n;
        else if (Object.hasOwnProperty.call(n, "color") || Object.hasOwnProperty.call(n, "fill")) r = n;
        else throw new Error("Invalid stroke value.");
        t.stroke = { ...r,
            width: e.strokeThickness
        }
    }
    if (Array.isArray(e.fillGradientStops)) {
        Ie(Ye, "gradient fill is now a fill pattern: `new FillGradient(...)`");
        let n;
        t.fontSize == null ? t.fontSize = es.defaultTextStyle.fontSize : typeof t.fontSize == "string" ? n = parseInt(t.fontSize, 10) : n = t.fontSize;
        const r = new Qi({
                start: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: (n || 0) * 1.7
                }
            }),
            i = e.fillGradientStops.map(s => tt.shared.setValue(s).toNumber());
        i.forEach((s, o) => {
            const a = o / (i.length - 1);
            r.addColorStop(a, s)
        }), t.fill = {
            fill: r
        }
    }
}
class lae {
    constructor(e) {
        this._canvasPool = Object.create(null), this.canvasOptions = e || {}, this.enableFullScreen = !1
    }
    _createCanvasAndContext(e, n) {
        const r = Ge.get().createCanvas();
        r.width = e, r.height = n;
        const i = r.getContext("2d");
        return {
            canvas: r,
            context: i
        }
    }
    getOptimalCanvasAndContext(e, n, r = 1) {
        e = Math.ceil(e * r - 1e-6), n = Math.ceil(n * r - 1e-6), e = El(e), n = El(n);
        const i = (e << 17) + (n << 1);
        this._canvasPool[i] || (this._canvasPool[i] = []);
        let s = this._canvasPool[i].pop();
        return s || (s = this._createCanvasAndContext(e, n)), s
    }
    returnCanvasAndContext(e) {
        const n = e.canvas,
            {
                width: r,
                height: i
            } = n,
            s = (r << 17) + (i << 1);
        e.context.resetTransform(), e.context.clearRect(0, 0, r, i), this._canvasPool[s].push(e)
    }
    clear() {
        this._canvasPool = {}
    }
}
const qs = new lae,
    hC = 1e5;

function Bh(t, e, n, r = 0) {
    if (t.texture === we.WHITE && !t.fill) return tt.shared.setValue(t.color).setAlpha(t.alpha ? ? 1).toHexa();
    if (t.fill) {
        if (t.fill instanceof tm) {
            const i = t.fill,
                s = e.createPattern(i.texture.source.resource, "repeat"),
                o = i.transform.copyTo(Te.shared);
            return o.scale(i.texture.frame.width, i.texture.frame.height), s.setTransform(o), s
        } else if (t.fill instanceof Qi) {
            const i = t.fill,
                s = i.type === "linear",
                o = i.textureSpace === "local";
            let a = 1,
                l = 1;
            o && n && (a = n.width + r, l = n.height + r);
            let c, u = !1;
            if (s) {
                const {
                    start: d,
                    end: f
                } = i;
                c = e.createLinearGradient(d.x * a, d.y * l, f.x * a, f.y * l), u = Math.abs(f.x - d.x) < Math.abs((f.y - d.y) * .1)
            } else {
                const {
                    center: d,
                    innerRadius: f,
                    outerCenter: h,
                    outerRadius: p
                } = i;
                c = e.createRadialGradient(d.x * a, d.y * l, f * a, h.x * a, h.y * l, p * a)
            }
            if (u && o && n) {
                const d = n.lineHeight / l;
                for (let f = 0; f < n.lines.length; f++) {
                    const h = (f * n.lineHeight + r / 2) / l;
                    i.colorStops.forEach(p => {
                        const b = h + p.offset * d;
                        c.addColorStop(Math.floor(b * hC) / hC, tt.shared.setValue(p.color).toHex())
                    })
                }
            } else i.colorStops.forEach(d => {
                c.addColorStop(d.offset, tt.shared.setValue(d.color).toHex())
            });
            return c
        }
    } else {
        const i = e.createPattern(t.texture.source.resource, "repeat"),
            s = t.matrix.copyTo(Te.shared);
        return s.scale(t.texture.frame.width, t.texture.frame.height), i.setTransform(s), i
    }
    return Oe("FillStyle not recognised", t), "red"
}
const lD = class cD extends zB {
    constructor(e) {
        super(), this.resolution = 1, this.pages = [], this._padding = 0, this._measureCache = Object.create(null), this._currentChars = [], this._currentX = 0, this._currentY = 0, this._currentMaxCharHeight = 0, this._currentPageIndex = -1, this._skipKerning = !1;
        const n = { ...cD.defaultOptions,
            ...e
        };
        this._textureSize = n.textureSize, this._mipmap = n.mipmap;
        const r = n.style.clone();
        n.overrideFill && (r._fill.color = 16777215, r._fill.alpha = 1, r._fill.texture = we.WHITE, r._fill.fill = null), this.applyFillAsTint = n.overrideFill;
        const i = r.fontSize;
        r.fontSize = this.baseMeasurementFontSize;
        const s = Rh(r);
        n.overrideSize ? r._stroke && (r._stroke.width *= this.baseRenderedFontSize / i) : r.fontSize = this.baseRenderedFontSize = i, this._style = r, this._skipKerning = n.skipKerning ? ? !1, this.resolution = n.resolution ? ? 1, this._padding = n.padding ? ? 4, n.textureStyle && (this._textureStyle = n.textureStyle instanceof Zi ? n.textureStyle : new Zi(n.textureStyle)), this.fontMetrics = Ir.measureFont(s), this.lineHeight = r.lineHeight || this.fontMetrics.fontSize || r.fontSize
    }
    ensureCharacters(e) {
        var y, m;
        const n = Ir.graphemeSegmenter(e).filter(g => !this._currentChars.includes(g)).filter((g, v, _) => _.indexOf(g) === v);
        if (!n.length) return;
        this._currentChars = [...this._currentChars, ...n];
        let r;
        this._currentPageIndex === -1 ? r = this._nextPage() : r = this.pages[this._currentPageIndex];
        let {
            canvas: i,
            context: s
        } = r.canvasAndContext, o = r.texture.source;
        const a = this._style;
        let l = this._currentX,
            c = this._currentY,
            u = this._currentMaxCharHeight;
        const d = this.baseRenderedFontSize / this.baseMeasurementFontSize,
            f = this._padding * d;
        let h = !1;
        const p = i.width / this.resolution,
            b = i.height / this.resolution;
        for (let g = 0; g < n.length; g++) {
            const v = n[g],
                _ = Ir.measureText(v, a, i, !1);
            _.lineHeight = _.height;
            const x = _.width * d,
                w = Math.ceil((a.fontStyle === "italic" ? 2 : 1) * x),
                E = _.height * d,
                C = w + f * 2,
                A = E + f * 2;
            if (h = !1, v !== `
` && v !== "\r" && v !== "	" && v !== " " && (h = !0, u = Math.ceil(Math.max(A, u))), l + C > p && (c += u, u = A, l = 0, c + u > b)) {
                o.update();
                const S = this._nextPage();
                i = S.canvasAndContext.canvas, s = S.canvasAndContext.context, o = S.texture.source, l = 0, c = 0, u = 0
            }
            const T = x / d - (((y = a.dropShadow) == null ? void 0 : y.distance) ? ? 0) - (((m = a._stroke) == null ? void 0 : m.width) ? ? 0);
            if (this.chars[v] = {
                    id: v.codePointAt(0),
                    xOffset: -this._padding,
                    yOffset: -this._padding,
                    xAdvance: T,
                    kerning: {}
                }, h) {
                this._drawGlyph(s, _, l + f, c + f, d, a);
                const S = o.width * d,
                    P = o.height * d,
                    R = new it(l / S * o.width, c / P * o.height, C / S * o.width, A / P * o.height);
                this.chars[v].texture = new we({
                    source: o,
                    frame: R
                }), l += Math.ceil(C)
            }
        }
        o.update(), this._currentX = l, this._currentY = c, this._currentMaxCharHeight = u, this._skipKerning && this._applyKerning(n, s)
    }
    get pageTextures() {
        return Ie(Ye, "BitmapFont.pageTextures is deprecated, please use BitmapFont.pages instead."), this.pages
    }
    _applyKerning(e, n) {
        const r = this._measureCache;
        for (let i = 0; i < e.length; i++) {
            const s = e[i];
            for (let o = 0; o < this._currentChars.length; o++) {
                const a = this._currentChars[o];
                let l = r[s];
                l || (l = r[s] = n.measureText(s).width);
                let c = r[a];
                c || (c = r[a] = n.measureText(a).width);
                let u = n.measureText(s + a).width,
                    d = u - (l + c);
                d && (this.chars[s].kerning[a] = d), u = n.measureText(s + a).width, d = u - (l + c), d && (this.chars[a].kerning[s] = d)
            }
        }
    }
    _nextPage() {
        this._currentPageIndex++;
        const e = this.resolution,
            n = qs.getOptimalCanvasAndContext(this._textureSize, this._textureSize, e);
        this._setupContext(n.context, this._style, e);
        const r = e * (this.baseRenderedFontSize / this.baseMeasurementFontSize),
            i = new we({
                source: new ia({
                    resource: n.canvas,
                    resolution: r,
                    alphaMode: "premultiply-alpha-on-upload",
                    autoGenerateMipmaps: this._mipmap
                })
            });
        this._textureStyle && (i.source.style = this._textureStyle);
        const s = {
            canvasAndContext: n,
            texture: i
        };
        return this.pages[this._currentPageIndex] = s, s
    }
    _setupContext(e, n, r) {
        n.fontSize = this.baseRenderedFontSize, e.scale(r, r), e.font = Rh(n), n.fontSize = this.baseMeasurementFontSize, e.textBaseline = n.textBaseline;
        const i = n._stroke,
            s = (i == null ? void 0 : i.width) ? ? 0;
        if (i && (e.lineWidth = s, e.lineJoin = i.join, e.miterLimit = i.miterLimit, e.strokeStyle = Bh(i, e)), n._fill && (e.fillStyle = Bh(n._fill, e)), n.dropShadow) {
            const o = n.dropShadow,
                a = tt.shared.setValue(o.color).toArray(),
                l = o.blur * r,
                c = o.distance * r;
            e.shadowColor = `rgba(${a[0]*255},${a[1]*255},${a[2]*255},${o.alpha})`, e.shadowBlur = l, e.shadowOffsetX = Math.cos(o.angle) * c, e.shadowOffsetY = Math.sin(o.angle) * c
        } else e.shadowColor = "black", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0
    }
    _drawGlyph(e, n, r, i, s, o) {
        const a = n.text,
            l = n.fontProperties,
            c = o._stroke,
            u = ((c == null ? void 0 : c.width) ? ? 0) * s,
            d = r + u / 2,
            f = i - u / 2,
            h = l.descent * s,
            p = n.lineHeight * s;
        let b = !1;
        o.stroke && u && (b = !0, e.strokeText(a, d, f + p - h));
        const {
            shadowBlur: y,
            shadowOffsetX: m,
            shadowOffsetY: g
        } = e;
        o._fill && (b && (e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0), e.fillText(a, d, f + p - h)), b && (e.shadowBlur = y, e.shadowOffsetX = m, e.shadowOffsetY = g)
    }
    destroy() {
        super.destroy();
        for (let e = 0; e < this.pages.length; e++) {
            const {
                canvasAndContext: n,
                texture: r
            } = this.pages[e];
            qs.returnCanvasAndContext(n), r.destroy(!0)
        }
        this.pages = null
    }
};
lD.defaultOptions = {
    textureSize: 512,
    style: new es,
    mipmap: !0
};
let pC = lD;

function uD(t, e, n, r) {
    const i = {
        width: 0,
        height: 0,
        offsetY: 0,
        scale: e.fontSize / n.baseMeasurementFontSize,
        lines: [{
            width: 0,
            charPositions: [],
            spaceWidth: 0,
            spacesIndex: [],
            chars: []
        }]
    };
    i.offsetY = n.baseLineOffset;
    let s = i.lines[0],
        o = null,
        a = !0;
    const l = {
            spaceWord: !1,
            width: 0,
            start: 0,
            index: 0,
            positions: [],
            chars: []
        },
        c = y => {
            const m = s.width;
            for (let g = 0; g < l.index; g++) {
                const v = y.positions[g];
                s.chars.push(y.chars[g]), s.charPositions.push(v + m)
            }
            s.width += y.width, a = !1, l.width = 0, l.index = 0, l.chars.length = 0
        },
        u = () => {
            let y = s.chars.length - 1;
            if (r) {
                let m = s.chars[y];
                for (; m === " ";) s.width -= n.chars[m].xAdvance, m = s.chars[--y]
            }
            i.width = Math.max(i.width, s.width), s = {
                width: 0,
                charPositions: [],
                chars: [],
                spaceWidth: 0,
                spacesIndex: []
            }, a = !0, i.lines.push(s), i.height += n.lineHeight
        },
        d = n.baseMeasurementFontSize / e.fontSize,
        f = e.letterSpacing * d,
        h = e.wordWrapWidth * d,
        p = e.wordWrap && e.breakWords,
        b = y => y - f > h;
    for (let y = 0; y < t.length + 1; y++) {
        let m;
        const g = y === t.length;
        g || (m = t[y]);
        const v = n.chars[m] || n.chars[" "];
        if (/(?:\s)/.test(m) || m === "\r" || m === `
` || g) {
            if (!a && e.wordWrap && b(s.width + l.width) ? (u(), c(l), g || s.charPositions.push(0)) : (l.start = s.width, c(l), g || s.charPositions.push(0)), m === "\r" || m === `
`) s.width !== 0 && u();
            else if (!g) {
                const E = v.xAdvance + (v.kerning[o] || 0) + f;
                s.width += E, s.spaceWidth = E, s.spacesIndex.push(s.charPositions.length), s.chars.push(m)
            }
        } else {
            const w = v.kerning[o] || 0,
                E = v.xAdvance + w + f;
            p && b(s.width + l.width + E) && (c(l), u()), l.positions[l.index++] = l.width + w, l.chars.push(m), l.width += E
        }
        o = m
    }
    return u(), e.align === "center" ? cae(i) : e.align === "right" ? uae(i) : e.align === "justify" && dae(i), i
}

function cae(t) {
    for (let e = 0; e < t.lines.length; e++) {
        const n = t.lines[e],
            r = t.width / 2 - n.width / 2;
        for (let i = 0; i < n.charPositions.length; i++) n.charPositions[i] += r
    }
}

function uae(t) {
    for (let e = 0; e < t.lines.length; e++) {
        const n = t.lines[e],
            r = t.width - n.width;
        for (let i = 0; i < n.charPositions.length; i++) n.charPositions[i] += r
    }
}

function dae(t) {
    const e = t.width;
    for (let n = 0; n < t.lines.length; n++) {
        const r = t.lines[n];
        let i = 0,
            s = r.spacesIndex[i++],
            o = 0;
        const a = r.spacesIndex.length,
            c = (e - r.width) / a;
        for (let u = 0; u < r.charPositions.length; u++) u === s && (s = r.spacesIndex[i++], o += c), r.charPositions[u] += o
    }
}

function fae(t) {
    if (t === "") return [];
    typeof t == "string" && (t = [t]);
    const e = [];
    for (let n = 0, r = t.length; n < r; n++) {
        const i = t[n];
        if (Array.isArray(i)) {
            if (i.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${i.length}.`);
            if (i[0].length === 0 || i[1].length === 0) throw new Error("[BitmapFont]: Invalid character delimiter.");
            const s = i[0].charCodeAt(0),
                o = i[1].charCodeAt(0);
            if (o < s) throw new Error("[BitmapFont]: Invalid character range.");
            for (let a = s, l = o; a <= l; a++) e.push(String.fromCharCode(a))
        } else e.push(...Array.from(i))
    }
    if (e.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return e
}
let _f = 0;
class hae {
    constructor() {
        this.ALPHA = [
            ["a", "z"],
            ["A", "Z"], " "
        ], this.NUMERIC = [
            ["0", "9"]
        ], this.ALPHANUMERIC = [
            ["a", "z"],
            ["A", "Z"],
            ["0", "9"], " "
        ], this.ASCII = [
            [" ", "~"]
        ], this.defaultOptions = {
            chars: this.ALPHANUMERIC,
            resolution: 1,
            padding: 4,
            skipKerning: !1,
            textureStyle: null
        }
    }
    getFont(e, n) {
        var o;
        let r = `${n.fontFamily}-bitmap`,
            i = !0;
        if (n._fill.fill && !n._stroke) r += n._fill.fill.styleKey, i = !1;
        else if (n._stroke || n.dropShadow) {
            let a = n.styleKey;
            a = a.substring(0, a.lastIndexOf("-")), r = `${a}-bitmap`, i = !1
        }
        if (!ut.has(r)) {
            const a = new pC({
                style: n,
                overrideFill: i,
                overrideSize: !0,
                ...this.defaultOptions
            });
            _f++, _f > 50 && Oe("BitmapText", `You have dynamically created ${_f} bitmap fonts, this can be inefficient. Try pre installing your font styles using \`BitmapFont.install({name:"style1", style})\``), a.once("destroy", () => {
                _f--, ut.remove(r)
            }), ut.set(r, a)
        }
        const s = ut.get(r);
        return (o = s.ensureCharacters) == null || o.call(s, e), s
    }
    getLayout(e, n, r = !0) {
        const i = this.getFont(e, n),
            s = Ir.graphemeSegmenter(e);
        return uD(s, n, i, r)
    }
    measureText(e, n, r = !0) {
        return this.getLayout(e, n, r)
    }
    install(...e) {
        var c, u, d, f;
        let n = e[0];
        typeof n == "string" && (n = {
            name: n,
            style: e[1],
            chars: (c = e[2]) == null ? void 0 : c.chars,
            resolution: (u = e[2]) == null ? void 0 : u.resolution,
            padding: (d = e[2]) == null ? void 0 : d.padding,
            skipKerning: (f = e[2]) == null ? void 0 : f.skipKerning
        }, Ie(Ye, "BitmapFontManager.install(name, style, options) is deprecated, use BitmapFontManager.install({name, style, ...options})"));
        const r = n == null ? void 0 : n.name;
        if (!r) throw new Error("[BitmapFontManager] Property `name` is required.");
        n = { ...this.defaultOptions,
            ...n
        };
        const i = n.style,
            s = i instanceof es ? i : new es(i),
            o = s._fill.fill !== null && s._fill.fill !== void 0,
            a = new pC({
                style: s,
                overrideFill: o,
                skipKerning: n.skipKerning,
                padding: n.padding,
                resolution: n.resolution,
                overrideSize: !1,
                textureStyle: n.textureStyle
            }),
            l = fae(n.chars);
        return a.ensureCharacters(l.join("")), ut.set(`${r}-bitmap`, a), a.once("destroy", () => ut.remove(`${r}-bitmap`)), a
    }
    uninstall(e) {
        const n = `${e}-bitmap`,
            r = ut.get(n);
        r && r.destroy()
    }
}
const I0 = new hae;
class dD extends zB {
    constructor(e, n) {
        super();
        const {
            textures: r,
            data: i
        } = e;
        Object.keys(i.pages).forEach(s => {
            const o = i.pages[parseInt(s, 10)],
                a = r[o.id];
            this.pages.push({
                texture: a
            })
        }), Object.keys(i.chars).forEach(s => {
            const o = i.chars[s],
                {
                    frame: a,
                    source: l
                } = r[o.page],
                c = new it(o.x + a.x, o.y + a.y, o.width, o.height),
                u = new we({
                    source: l,
                    frame: c
                });
            this.chars[s] = {
                id: s.codePointAt(0),
                xOffset: o.xOffset,
                yOffset: o.yOffset,
                xAdvance: o.xAdvance,
                kerning: o.kerning ? ? {},
                texture: u
            }
        }), this.baseRenderedFontSize = i.fontSize, this.baseMeasurementFontSize = i.fontSize, this.fontMetrics = {
            ascent: 0,
            descent: 0,
            fontSize: i.fontSize
        }, this.baseLineOffset = i.baseLineOffset, this.lineHeight = i.lineHeight, this.fontFamily = i.fontFamily, this.distanceField = i.distanceField ? ? {
            type: "none",
            range: 0
        }, this.url = n
    }
    destroy() {
        super.destroy();
        for (let e = 0; e < this.pages.length; e++) {
            const {
                texture: n
            } = this.pages[e];
            n.destroy(!0)
        }
        this.pages = null
    }
    static install(e) {
        I0.install(e)
    }
    static uninstall(e) {
        I0.uninstall(e)
    }
}
const Lg = {
        test(t) {
            return typeof t == "string" && t.startsWith("info face=")
        },
        parse(t) {
            const e = t.match(/^[a-z]+\s+.+$/gm),
                n = {
                    info: [],
                    common: [],
                    page: [],
                    char: [],
                    chars: [],
                    kerning: [],
                    kernings: [],
                    distanceField: []
                };
            for (const d in e) {
                const f = e[d].match(/^[a-z]+/gm)[0],
                    h = e[d].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
                    p = {};
                for (const b in h) {
                    const y = h[b].split("="),
                        m = y[0],
                        g = y[1].replace(/"/gm, ""),
                        v = parseFloat(g),
                        _ = isNaN(v) ? g : v;
                    p[m] = _
                }
                n[f].push(p)
            }
            const r = {
                    chars: {},
                    pages: [],
                    lineHeight: 0,
                    fontSize: 0,
                    fontFamily: "",
                    distanceField: null,
                    baseLineOffset: 0
                },
                [i] = n.info,
                [s] = n.common,
                [o] = n.distanceField ? ? [];
            o && (r.distanceField = {
                range: parseInt(o.distanceRange, 10),
                type: o.fieldType
            }), r.fontSize = parseInt(i.size, 10), r.fontFamily = i.face, r.lineHeight = parseInt(s.lineHeight, 10);
            const a = n.page;
            for (let d = 0; d < a.length; d++) r.pages.push({
                id: parseInt(a[d].id, 10) || 0,
                file: a[d].file
            });
            const l = {};
            r.baseLineOffset = r.lineHeight - parseInt(s.base, 10);
            const c = n.char;
            for (let d = 0; d < c.length; d++) {
                const f = c[d],
                    h = parseInt(f.id, 10);
                let p = f.letter ? ? f.char ? ? String.fromCharCode(h);
                p === "space" && (p = " "), l[h] = p, r.chars[p] = {
                    id: h,
                    page: parseInt(f.page, 10) || 0,
                    x: parseInt(f.x, 10),
                    y: parseInt(f.y, 10),
                    width: parseInt(f.width, 10),
                    height: parseInt(f.height, 10),
                    xOffset: parseInt(f.xoffset, 10),
                    yOffset: parseInt(f.yoffset, 10),
                    xAdvance: parseInt(f.xadvance, 10),
                    kerning: {}
                }
            }
            const u = n.kerning || [];
            for (let d = 0; d < u.length; d++) {
                const f = parseInt(u[d].first, 10),
                    h = parseInt(u[d].second, 10),
                    p = parseInt(u[d].amount, 10);
                r.chars[l[h]].kerning[l[f]] = p
            }
            return r
        }
    },
    mC = {
        test(t) {
            const e = t;
            return typeof e != "string" && "getElementsByTagName" in e && e.getElementsByTagName("page").length && e.getElementsByTagName("info")[0].getAttribute("face") !== null
        },
        parse(t) {
            const e = {
                    chars: {},
                    pages: [],
                    lineHeight: 0,
                    fontSize: 0,
                    fontFamily: "",
                    distanceField: null,
                    baseLineOffset: 0
                },
                n = t.getElementsByTagName("info")[0],
                r = t.getElementsByTagName("common")[0],
                i = t.getElementsByTagName("distanceField")[0];
            i && (e.distanceField = {
                type: i.getAttribute("fieldType"),
                range: parseInt(i.getAttribute("distanceRange"), 10)
            });
            const s = t.getElementsByTagName("page"),
                o = t.getElementsByTagName("char"),
                a = t.getElementsByTagName("kerning");
            e.fontSize = parseInt(n.getAttribute("size"), 10), e.fontFamily = n.getAttribute("face"), e.lineHeight = parseInt(r.getAttribute("lineHeight"), 10);
            for (let c = 0; c < s.length; c++) e.pages.push({
                id: parseInt(s[c].getAttribute("id"), 10) || 0,
                file: s[c].getAttribute("file")
            });
            const l = {};
            e.baseLineOffset = e.lineHeight - parseInt(r.getAttribute("base"), 10);
            for (let c = 0; c < o.length; c++) {
                const u = o[c],
                    d = parseInt(u.getAttribute("id"), 10);
                let f = u.getAttribute("letter") ? ? u.getAttribute("char") ? ? String.fromCharCode(d);
                f === "space" && (f = " "), l[d] = f, e.chars[f] = {
                    id: d,
                    page: parseInt(u.getAttribute("page"), 10) || 0,
                    x: parseInt(u.getAttribute("x"), 10),
                    y: parseInt(u.getAttribute("y"), 10),
                    width: parseInt(u.getAttribute("width"), 10),
                    height: parseInt(u.getAttribute("height"), 10),
                    xOffset: parseInt(u.getAttribute("xoffset"), 10),
                    yOffset: parseInt(u.getAttribute("yoffset"), 10),
                    xAdvance: parseInt(u.getAttribute("xadvance"), 10),
                    kerning: {}
                }
            }
            for (let c = 0; c < a.length; c++) {
                const u = parseInt(a[c].getAttribute("first"), 10),
                    d = parseInt(a[c].getAttribute("second"), 10),
                    f = parseInt(a[c].getAttribute("amount"), 10);
                e.chars[l[d]].kerning[l[u]] = f
            }
            return e
        }
    },
    gC = {
        test(t) {
            return typeof t == "string" && t.includes("<font>") ? mC.test(Ge.get().parseXML(t)) : !1
        },
        parse(t) {
            return mC.parse(Ge.get().parseXML(t))
        }
    },
    pae = [".xml", ".fnt"],
    mae = {
        extension: {
            type: G.CacheParser,
            name: "cacheBitmapFont"
        },
        test: t => t instanceof dD,
        getCacheableAssets(t, e) {
            const n = {};
            return t.forEach(r => {
                n[r] = e, n[`${r}-bitmap`] = e
            }), n[`${e.fontFamily}-bitmap`] = e, n
        }
    },
    gae = {
        extension: {
            type: G.LoadParser,
            priority: ro.Normal
        },
        name: "loadBitmapFont",
        test(t) {
            return pae.includes(Ln.extname(t).toLowerCase())
        },
        async testParse(t) {
            return Lg.test(t) || gC.test(t)
        },
        async parse(t, e, n) {
            const r = Lg.test(t) ? Lg.parse(t) : gC.parse(t),
                {
                    src: i
                } = e,
                {
                    pages: s
                } = r,
                o = [],
                a = r.distanceField ? {
                    scaleMode: "linear",
                    alphaMode: "premultiply-alpha-on-upload",
                    autoGenerateMipmaps: !1,
                    resolution: 1
                } : {};
            for (let d = 0; d < s.length; ++d) {
                const f = s[d].file;
                let h = Ln.join(Ln.dirname(i), f);
                h = g0(h, i), o.push({
                    src: h,
                    data: a
                })
            }
            const l = await n.load(o),
                c = o.map(d => l[d.src]);
            return new dD({
                data: r,
                textures: c
            }, i)
        },
        async load(t, e) {
            return await (await Ge.get().fetch(t)).text()
        },
        async unload(t, e, n) {
            await Promise.all(t.pages.map(r => n.unload(r.texture.source._sourceOrigin))), t.destroy()
        }
    };
class yae {
    constructor(e, n = !1) {
        this._loader = e, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = n
    }
    add(e) {
        e.forEach(n => {
            this._assetList.push(n)
        }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next()
    }
    async _next() {
        if (this._assetList.length && this._isActive) {
            this._isLoading = !0;
            const e = [],
                n = Math.min(this._assetList.length, this._maxConcurrent);
            for (let r = 0; r < n; r++) e.push(this._assetList.pop());
            await this._loader.load(e), this._isLoading = !1, this._next()
        }
    }
    get active() {
        return this._isActive
    }
    set active(e) {
        this._isActive !== e && (this._isActive = e, e && !this._isLoading && this._next())
    }
}
const vae = {
    extension: {
        type: G.CacheParser,
        name: "cacheTextureArray"
    },
    test: t => Array.isArray(t) && t.every(e => e instanceof we),
    getCacheableAssets: (t, e) => {
        const n = {};
        return t.forEach(r => {
            e.forEach((i, s) => {
                n[r + (s === 0 ? "" : s + 1)] = i
            })
        }), n
    }
};
async function fD(t) {
    if ("Image" in globalThis) return new Promise(e => {
        const n = new Image;
        n.onload = () => {
            e(!0)
        }, n.onerror = () => {
            e(!1)
        }, n.src = t
    });
    if ("createImageBitmap" in globalThis && "fetch" in globalThis) {
        try {
            const e = await (await fetch(t)).blob();
            await createImageBitmap(e)
        } catch {
            return !1
        }
        return !0
    }
    return !1
}
const _ae = {
        extension: {
            type: G.DetectionParser,
            priority: 1
        },
        test: async () => fD("data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="),
        add: async t => [...t, "avif"],
        remove: async t => t.filter(e => e !== "avif")
    },
    yC = ["png", "jpg", "jpeg"],
    bae = {
        extension: {
            type: G.DetectionParser,
            priority: -1
        },
        test: () => Promise.resolve(!0),
        add: async t => [...t, ...yC],
        remove: async t => t.filter(e => !yC.includes(e))
    },
    xae = "WorkerGlobalScope" in globalThis && globalThis instanceof globalThis.WorkerGlobalScope;

function Nx(t) {
    return xae ? !1 : document.createElement("video").canPlayType(t) !== ""
}
const wae = {
        extension: {
            type: G.DetectionParser,
            priority: 0
        },
        test: async () => Nx("video/mp4"),
        add: async t => [...t, "mp4", "m4v"],
        remove: async t => t.filter(e => e !== "mp4" && e !== "m4v")
    },
    Eae = {
        extension: {
            type: G.DetectionParser,
            priority: 0
        },
        test: async () => Nx("video/ogg"),
        add: async t => [...t, "ogv"],
        remove: async t => t.filter(e => e !== "ogv")
    },
    Sae = {
        extension: {
            type: G.DetectionParser,
            priority: 0
        },
        test: async () => Nx("video/webm"),
        add: async t => [...t, "webm"],
        remove: async t => t.filter(e => e !== "webm")
    },
    Tae = {
        extension: {
            type: G.DetectionParser,
            priority: 0
        },
        test: async () => fD("data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="),
        add: async t => [...t, "webp"],
        remove: async t => t.filter(e => e !== "webp")
    };
class Cae {
    constructor() {
        this._parsers = [], this._parsersValidated = !1, this.parsers = new Proxy(this._parsers, {
            set: (e, n, r) => (this._parsersValidated = !1, e[n] = r, !0)
        }), this.promiseCache = {}
    }
    reset() {
        this._parsersValidated = !1, this.promiseCache = {}
    }
    _getLoadPromiseAndParser(e, n) {
        const r = {
            promise: null,
            parser: null
        };
        return r.promise = (async () => {
            var o, a;
            let i = null,
                s = null;
            if (n.loadParser && (s = this._parserHash[n.loadParser], s || Oe(`[Assets] specified load parser "${n.loadParser}" not found while loading ${e}`)), !s) {
                for (let l = 0; l < this.parsers.length; l++) {
                    const c = this.parsers[l];
                    if (c.load && ((o = c.test) != null && o.call(c, e, n, this))) {
                        s = c;
                        break
                    }
                }
                if (!s) return Oe(`[Assets] ${e} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`), null
            }
            i = await s.load(e, n, this), r.parser = s;
            for (let l = 0; l < this.parsers.length; l++) {
                const c = this.parsers[l];
                c.parse && c.parse && await ((a = c.testParse) == null ? void 0 : a.call(c, i, n, this)) && (i = await c.parse(i, n, this) || i, r.parser = c)
            }
            return i
        })(), r
    }
    async load(e, n) {
        this._parsersValidated || this._validateParsers();
        let r = 0;
        const i = {},
            s = Ih(e),
            o = Or(e, c => ({
                alias: [c],
                src: c,
                data: {}
            })),
            a = o.length,
            l = o.map(async c => {
                const u = Ln.toAbsolute(c.src);
                if (!i[c.src]) try {
                    this.promiseCache[u] || (this.promiseCache[u] = this._getLoadPromiseAndParser(u, c)), i[c.src] = await this.promiseCache[u].promise, n && n(++r / a)
                } catch (d) {
                    throw delete this.promiseCache[u], delete i[c.src], new Error(`[Loader.load] Failed to load ${u}.
${d}`)
                }
            });
        return await Promise.all(l), s ? i[o[0].src] : i
    }
    async unload(e) {
        const r = Or(e, i => ({
            alias: [i],
            src: i
        })).map(async i => {
            var a, l;
            const s = Ln.toAbsolute(i.src),
                o = this.promiseCache[s];
            if (o) {
                const c = await o.promise;
                delete this.promiseCache[s], await ((l = (a = o.parser) == null ? void 0 : a.unload) == null ? void 0 : l.call(a, c, i, this))
            }
        });
        await Promise.all(r)
    }
    _validateParsers() {
        this._parsersValidated = !0, this._parserHash = this._parsers.filter(e => e.name).reduce((e, n) => (n.name ? e[n.name] && Oe(`[Assets] loadParser name conflict "${n.name}"`) : Oe("[Assets] loadParser should have a name"), { ...e,
            [n.name]: n
        }), {})
    }
}

function Kl(t, e) {
    if (Array.isArray(e)) {
        for (const n of e)
            if (t.startsWith(`data:${n}`)) return !0;
        return !1
    }
    return t.startsWith(`data:${e}`)
}

function Jl(t, e) {
    const n = t.split("?")[0],
        r = Ln.extname(n).toLowerCase();
    return Array.isArray(e) ? e.includes(r) : r === e
}
const Pae = ".json",
    Aae = "application/json",
    Oae = {
        extension: {
            type: G.LoadParser,
            priority: ro.Low
        },
        name: "loadJson",
        test(t) {
            return Kl(t, Aae) || Jl(t, Pae)
        },
        async load(t) {
            return await (await Ge.get().fetch(t)).json()
        }
    },
    Iae = ".txt",
    Mae = "text/plain",
    Rae = {
        name: "loadTxt",
        extension: {
            type: G.LoadParser,
            priority: ro.Low,
            name: "loadTxt"
        },
        test(t) {
            return Kl(t, Mae) || Jl(t, Iae)
        },
        async load(t) {
            return await (await Ge.get().fetch(t)).text()
        }
    },
    kae = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"],
    Bae = [".ttf", ".otf", ".woff", ".woff2"],
    Dae = ["font/ttf", "font/otf", "font/woff", "font/woff2"],
    $ae = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i;

function Fae(t) {
    const e = Ln.extname(t),
        i = Ln.basename(t, e).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(a => a.charAt(0).toUpperCase() + a.slice(1));
    let s = i.length > 0;
    for (const a of i)
        if (!a.match($ae)) {
            s = !1;
            break
        }
    let o = i.join(" ");
    return s || (o = `"${o.replace(/[\\"]/g,"\\$&")}"`), o
}
const Lae = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/;

function Nae(t) {
    return Lae.test(t) ? t : encodeURI(t)
}
const Uae = {
    extension: {
        type: G.LoadParser,
        priority: ro.Low
    },
    name: "loadWebFont",
    test(t) {
        return Kl(t, Dae) || Jl(t, Bae)
    },
    async load(t, e) {
        var r, i, s;
        const n = Ge.get().getFontFaceSet();
        if (n) {
            const o = [],
                a = ((r = e.data) == null ? void 0 : r.family) ? ? Fae(t),
                l = ((s = (i = e.data) == null ? void 0 : i.weights) == null ? void 0 : s.filter(u => kae.includes(u))) ? ? ["normal"],
                c = e.data ? ? {};
            for (let u = 0; u < l.length; u++) {
                const d = l[u],
                    f = new FontFace(a, `url(${Nae(t)})`, { ...c,
                        weight: d
                    });
                await f.load(), n.add(f), o.push(f)
            }
            return ut.set(`${a}-and-url`, {
                url: t,
                fontFaces: o
            }), o.length === 1 ? o[0] : o
        }
        return Oe("[loadWebFont] FontFace API is not supported. Skipping loading font"), null
    },
    unload(t) {
        (Array.isArray(t) ? t : [t]).forEach(e => {
            ut.remove(`${e.family}-and-url`), Ge.get().getFontFaceSet().delete(e)
        })
    }
};

function Ux(t, e = 1) {
    var r;
    const n = (r = ql.RETINA_PREFIX) == null ? void 0 : r.exec(t);
    return n ? parseFloat(n[1]) : e
}

function Gx(t, e, n) {
    t.label = n, t._sourceOrigin = n;
    const r = new we({
            source: t,
            label: n
        }),
        i = () => {
            delete e.promiseCache[n], ut.has(n) && ut.remove(n)
        };
    return r.source.once("destroy", () => {
        e.promiseCache[n] && (Oe("[Assets] A TextureSource managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the TextureSource."), i())
    }), r.once("destroy", () => {
        t.destroyed || (Oe("[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture."), i())
    }), r
}
const Gae = ".svg",
    Hae = "image/svg+xml",
    zae = {
        extension: {
            type: G.LoadParser,
            priority: ro.Low,
            name: "loadSVG"
        },
        name: "loadSVG",
        config: {
            crossOrigin: "anonymous",
            parseAsGraphicsContext: !1
        },
        test(t) {
            return Kl(t, Hae) || Jl(t, Gae)
        },
        async load(t, e, n) {
            var r;
            return ((r = e.data) == null ? void 0 : r.parseAsGraphicsContext) ? ? this.config.parseAsGraphicsContext ? Vae(t) : jae(t, e, n, this.config.crossOrigin)
        },
        unload(t) {
            t.destroy(!0)
        }
    };
async function jae(t, e, n, r) {
    var y, m, g;
    const s = await (await Ge.get().fetch(t)).blob(),
        o = URL.createObjectURL(s),
        a = new Image;
    a.src = o, a.crossOrigin = r, await a.decode(), URL.revokeObjectURL(o);
    const l = document.createElement("canvas"),
        c = l.getContext("2d"),
        u = ((y = e.data) == null ? void 0 : y.resolution) || Ux(t),
        d = ((m = e.data) == null ? void 0 : m.width) ? ? a.width,
        f = ((g = e.data) == null ? void 0 : g.height) ? ? a.height;
    l.width = d * u, l.height = f * u, c.drawImage(a, 0, 0, d * u, f * u);
    const {
        parseAsGraphicsContext: h,
        ...p
    } = e.data ? ? {}, b = new ia({
        resource: l,
        alphaMode: "premultiply-alpha-on-upload",
        resolution: u,
        ...p
    });
    return Gx(b, n, t)
}
async function Vae(t) {
    const n = await (await Ge.get().fetch(t)).text(),
        r = new hr;
    return r.svg(n), r
}
const Wae = `(function () {
    'use strict';

    const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
    async function checkImageBitmap() {
      try {
        if (typeof createImageBitmap !== "function")
          return false;
        const response = await fetch(WHITE_PNG);
        const imageBlob = await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);
        return imageBitmap.width === 1 && imageBitmap.height === 1;
      } catch (_e) {
        return false;
      }
    }
    void checkImageBitmap().then((result) => {
      self.postMessage(result);
    });

})();
`;
let al = null,
    M0 = class {
        constructor() {
            al || (al = URL.createObjectURL(new Blob([Wae], {
                type: "application/javascript"
            }))), this.worker = new Worker(al)
        }
    };
M0.revokeObjectURL = function() {
    al && (URL.revokeObjectURL(al), al = null)
};
const Yae = `(function () {
    'use strict';

    async function loadImageBitmap(url, alphaMode) {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
      }
      const imageBlob = await response.blob();
      return alphaMode === "premultiplied-alpha" ? createImageBitmap(imageBlob, { premultiplyAlpha: "none" }) : createImageBitmap(imageBlob);
    }
    self.onmessage = async (event) => {
      try {
        const imageBitmap = await loadImageBitmap(event.data.data[0], event.data.data[1]);
        self.postMessage({
          data: imageBitmap,
          uuid: event.data.uuid,
          id: event.data.id
        }, [imageBitmap]);
      } catch (e) {
        self.postMessage({
          error: e,
          uuid: event.data.uuid,
          id: event.data.id
        });
      }
    };

})();
`;
let ll = null;
class hD {
    constructor() {
        ll || (ll = URL.createObjectURL(new Blob([Yae], {
            type: "application/javascript"
        }))), this.worker = new Worker(ll)
    }
}
hD.revokeObjectURL = function() {
    ll && (URL.revokeObjectURL(ll), ll = null)
};
let vC = 0,
    Ng;
class Xae {
    constructor() {
        this._initialized = !1, this._createdWorkers = 0, this._workerPool = [], this._queue = [], this._resolveHash = {}
    }
    isImageBitmapSupported() {
        return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(e => {
            const {
                worker: n
            } = new M0;
            n.addEventListener("message", r => {
                n.terminate(), M0.revokeObjectURL(), e(r.data)
            })
        }), this._isImageBitmapSupported)
    }
    loadImageBitmap(e, n) {
        var r;
        return this._run("loadImageBitmap", [e, (r = n == null ? void 0 : n.data) == null ? void 0 : r.alphaMode])
    }
    async _initWorkers() {
        this._initialized || (this._initialized = !0)
    }
    _getWorker() {
        Ng === void 0 && (Ng = navigator.hardwareConcurrency || 4);
        let e = this._workerPool.pop();
        return !e && this._createdWorkers < Ng && (this._createdWorkers++, e = new hD().worker, e.addEventListener("message", n => {
            this._complete(n.data), this._returnWorker(n.target), this._next()
        })), e
    }
    _returnWorker(e) {
        this._workerPool.push(e)
    }
    _complete(e) {
        e.error !== void 0 ? this._resolveHash[e.uuid].reject(e.error) : this._resolveHash[e.uuid].resolve(e.data), this._resolveHash[e.uuid] = null
    }
    async _run(e, n) {
        await this._initWorkers();
        const r = new Promise((i, s) => {
            this._queue.push({
                id: e,
                arguments: n,
                resolve: i,
                reject: s
            })
        });
        return this._next(), r
    }
    _next() {
        if (!this._queue.length) return;
        const e = this._getWorker();
        if (!e) return;
        const n = this._queue.pop(),
            r = n.id;
        this._resolveHash[vC] = {
            resolve: n.resolve,
            reject: n.reject
        }, e.postMessage({
            data: n.arguments,
            uuid: vC++,
            id: r
        })
    }
}
const _C = new Xae,
    qae = [".jpeg", ".jpg", ".png", ".webp", ".avif"],
    Kae = ["image/jpeg", "image/png", "image/webp", "image/avif"];
async function Jae(t, e) {
    var i;
    const n = await Ge.get().fetch(t);
    if (!n.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${t}: ${n.status} ${n.statusText}`);
    const r = await n.blob();
    return ((i = e == null ? void 0 : e.data) == null ? void 0 : i.alphaMode) === "premultiplied-alpha" ? createImageBitmap(r, {
        premultiplyAlpha: "none"
    }) : createImageBitmap(r)
}
const pD = {
        name: "loadTextures",
        extension: {
            type: G.LoadParser,
            priority: ro.High,
            name: "loadTextures"
        },
        config: {
            preferWorkers: !0,
            preferCreateImageBitmap: !0,
            crossOrigin: "anonymous"
        },
        test(t) {
            return Kl(t, Kae) || Jl(t, qae)
        },
        async load(t, e, n) {
            var s;
            let r = null;
            globalThis.createImageBitmap && this.config.preferCreateImageBitmap ? this.config.preferWorkers && await _C.isImageBitmapSupported() ? r = await _C.loadImageBitmap(t, e) : r = await Jae(t, e) : r = await new Promise((o, a) => {
                r = new Image, r.crossOrigin = this.config.crossOrigin, r.src = t, r.complete ? o(r) : (r.onload = () => {
                    o(r)
                }, r.onerror = a)
            });
            const i = new ia({
                resource: r,
                alphaMode: "premultiply-alpha-on-upload",
                resolution: ((s = e.data) == null ? void 0 : s.resolution) || Ux(t),
                ...e.data
            });
            return Gx(i, n, t)
        },
        unload(t) {
            t.destroy(!0)
        }
    },
    mD = [".mp4", ".m4v", ".webm", ".ogg", ".ogv", ".h264", ".avi", ".mov"],
    Zae = mD.map(t => `video/${t.substring(1)}`);

function Qae(t, e, n) {
    n === void 0 && !e.startsWith("data:") ? t.crossOrigin = tle(e) : n !== !1 && (t.crossOrigin = typeof n == "string" ? n : "anonymous")
}

function ele(t) {
    return new Promise((e, n) => {
        t.addEventListener("canplaythrough", r), t.addEventListener("error", i), t.load();

        function r() {
            s(), e()
        }

        function i(o) {
            s(), n(o)
        }

        function s() {
            t.removeEventListener("canplaythrough", r), t.removeEventListener("error", i)
        }
    })
}

function tle(t, e = globalThis.location) {
    if (t.startsWith("data:")) return "";
    e || (e = globalThis.location);
    const n = new URL(t, document.baseURI);
    return n.hostname !== e.hostname || n.port !== e.port || n.protocol !== e.protocol ? "anonymous" : ""
}
const nle = {
        name: "loadVideo",
        extension: {
            type: G.LoadParser,
            name: "loadVideo"
        },
        test(t) {
            const e = Kl(t, Zae),
                n = Jl(t, mD);
            return e || n
        },
        async load(t, e, n) {
            var l, c;
            const r = { ...Yf.defaultOptions,
                    resolution: ((l = e.data) == null ? void 0 : l.resolution) || Ux(t),
                    alphaMode: ((c = e.data) == null ? void 0 : c.alphaMode) || await gB(),
                    ...e.data
                },
                i = document.createElement("video"),
                s = {
                    preload: r.autoLoad !== !1 ? "auto" : void 0,
                    "webkit-playsinline": r.playsinline !== !1 ? "" : void 0,
                    playsinline: r.playsinline !== !1 ? "" : void 0,
                    muted: r.muted === !0 ? "" : void 0,
                    loop: r.loop === !0 ? "" : void 0,
                    autoplay: r.autoPlay !== !1 ? "" : void 0
                };
            Object.keys(s).forEach(u => {
                const d = s[u];
                d !== void 0 && i.setAttribute(u, d)
            }), r.muted === !0 && (i.muted = !0), Qae(i, t, r.crossorigin);
            const o = document.createElement("source");
            let a;
            if (t.startsWith("data:")) a = t.slice(5, t.indexOf(";"));
            else if (!t.startsWith("blob:")) {
                const u = t.split("?")[0].slice(t.lastIndexOf(".") + 1).toLowerCase();
                a = Yf.MIME_TYPES[u] || `video/${u}`
            }
            return o.src = t, a && (o.type = a), new Promise(u => {
                const d = async () => {
                    const f = new Yf({ ...r,
                        resource: i
                    });
                    i.removeEventListener("canplay", d), e.data.preload && await ele(i), u(Gx(f, n, t))
                };
                r.preload && !r.autoPlay && i.load(), i.addEventListener("canplay", d), i.appendChild(o)
            })
        },
        unload(t) {
            t.destroy(!0)
        }
    },
    gD = {
        extension: {
            type: G.ResolveParser,
            name: "resolveTexture"
        },
        test: pD.test,
        parse: t => {
            var e;
            return {
                resolution: parseFloat(((e = ql.RETINA_PREFIX.exec(t)) == null ? void 0 : e[1]) ? ? "1"),
                format: t.split(".").pop(),
                src: t
            }
        }
    },
    rle = {
        extension: {
            type: G.ResolveParser,
            priority: -2,
            name: "resolveJson"
        },
        test: t => ql.RETINA_PREFIX.test(t) && t.endsWith(".json"),
        parse: gD.parse
    };
class ile {
    constructor() {
        this._detections = [], this._initialized = !1, this.resolver = new ql, this.loader = new Cae, this.cache = ut, this._backgroundLoader = new yae(this.loader), this._backgroundLoader.active = !0, this.reset()
    }
    async init(e = {}) {
        var s, o;
        if (this._initialized) {
            Oe("[Assets]AssetManager already initialized, did you load before calling this Assets.init()?");
            return
        }
        if (this._initialized = !0, e.defaultSearchParams && this.resolver.setDefaultSearchParams(e.defaultSearchParams), e.basePath && (this.resolver.basePath = e.basePath), e.bundleIdentifier && this.resolver.setBundleIdentifier(e.bundleIdentifier), e.manifest) {
            let a = e.manifest;
            typeof a == "string" && (a = await this.load(a)), this.resolver.addManifest(a)
        }
        const n = ((s = e.texturePreference) == null ? void 0 : s.resolution) ? ? 1,
            r = typeof n == "number" ? [n] : n,
            i = await this._detectFormats({
                preferredFormats: (o = e.texturePreference) == null ? void 0 : o.format,
                skipDetections: e.skipDetections,
                detections: this._detections
            });
        this.resolver.prefer({
            params: {
                format: i,
                resolution: r
            }
        }), e.preferences && this.setPreferences(e.preferences)
    }
    add(e) {
        this.resolver.add(e)
    }
    async load(e, n) {
        this._initialized || await this.init();
        const r = Ih(e),
            i = Or(e).map(a => {
                if (typeof a != "string") {
                    const l = this.resolver.getAlias(a);
                    return l.some(c => !this.resolver.hasKey(c)) && this.add(a), Array.isArray(l) ? l[0] : l
                }
                return this.resolver.hasKey(a) || this.add({
                    alias: a,
                    src: a
                }), a
            }),
            s = this.resolver.resolve(i),
            o = await this._mapLoadToResolve(s, n);
        return r ? o[i[0]] : o
    }
    addBundle(e, n) {
        this.resolver.addBundle(e, n)
    }
    async loadBundle(e, n) {
        this._initialized || await this.init();
        let r = !1;
        typeof e == "string" && (r = !0, e = [e]);
        const i = this.resolver.resolveBundle(e),
            s = {},
            o = Object.keys(i);
        let a = 0,
            l = 0;
        const c = () => {
                n == null || n(++a / l)
            },
            u = o.map(d => {
                const f = i[d];
                return l += Object.keys(f).length, this._mapLoadToResolve(f, c).then(h => {
                    s[d] = h
                })
            });
        return await Promise.all(u), r ? s[e[0]] : s
    }
    async backgroundLoad(e) {
        this._initialized || await this.init(), typeof e == "string" && (e = [e]);
        const n = this.resolver.resolve(e);
        this._backgroundLoader.add(Object.values(n))
    }
    async backgroundLoadBundle(e) {
        this._initialized || await this.init(), typeof e == "string" && (e = [e]);
        const n = this.resolver.resolveBundle(e);
        Object.values(n).forEach(r => {
            this._backgroundLoader.add(Object.values(r))
        })
    }
    reset() {
        this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1
    }
    get(e) {
        if (typeof e == "string") return ut.get(e);
        const n = {};
        for (let r = 0; r < e.length; r++) n[r] = ut.get(e[r]);
        return n
    }
    async _mapLoadToResolve(e, n) {
        const r = [...new Set(Object.values(e))];
        this._backgroundLoader.active = !1;
        const i = await this.loader.load(r, n);
        this._backgroundLoader.active = !0;
        const s = {};
        return r.forEach(o => {
            const a = i[o.src],
                l = [o.src];
            o.alias && l.push(...o.alias), l.forEach(c => {
                s[c] = a
            }), ut.set(l, a)
        }), s
    }
    async unload(e) {
        this._initialized || await this.init();
        const n = Or(e).map(i => typeof i != "string" ? i.src : i),
            r = this.resolver.resolve(n);
        await this._unloadFromResolved(r)
    }
    async unloadBundle(e) {
        this._initialized || await this.init(), e = Or(e);
        const n = this.resolver.resolveBundle(e),
            r = Object.keys(n).map(i => this._unloadFromResolved(n[i]));
        await Promise.all(r)
    }
    async _unloadFromResolved(e) {
        const n = Object.values(e);
        n.forEach(r => {
            ut.remove(r.src)
        }), await this.loader.unload(n)
    }
    async _detectFormats(e) {
        let n = [];
        e.preferredFormats && (n = Array.isArray(e.preferredFormats) ? e.preferredFormats : [e.preferredFormats]);
        for (const r of e.detections) e.skipDetections || await r.test() ? n = await r.add(n) : e.skipDetections || (n = await r.remove(n));
        return n = n.filter((r, i) => n.indexOf(r) === i), n
    }
    get detections() {
        return this._detections
    }
    setPreferences(e) {
        this.loader.parsers.forEach(n => {
            n.config && Object.keys(n.config).filter(r => r in e).forEach(r => {
                n.config[r] = e[r]
            })
        })
    }
}
const bf = new ile;
Re.handleByList(G.LoadParser, bf.loader.parsers).handleByList(G.ResolveParser, bf.resolver.parsers).handleByList(G.CacheParser, bf.cache.parsers).handleByList(G.DetectionParser, bf.detections);
Re.add(vae, bae, _ae, Tae, wae, Eae, Sae, Oae, Rae, Uae, zae, pD, nle, gae, mae, gD, rle);
const bC = {
    loader: G.LoadParser,
    resolver: G.ResolveParser,
    cache: G.CacheParser,
    detection: G.DetectionParser
};
Re.handle(G.Asset, t => {
    const e = t.ref;
    Object.entries(bC).filter(([n]) => !!e[n]).forEach(([n, r]) => Re.add(Object.assign(e[n], {
        extension: e[n].extension ? ? r
    })))
}, t => {
    const e = t.ref;
    Object.keys(bC).filter(n => !!e[n]).forEach(n => Re.remove(e[n]))
});
class yD {
    constructor(e) {
        this._attachedDomElements = [], this._renderer = e, this._renderer.runners.postrender.add(this), this._domElement = document.createElement("div"), this._domElement.style.position = "absolute", this._domElement.style.top = "0", this._domElement.style.left = "0", this._domElement.style.pointerEvents = "none", this._domElement.style.zIndex = "1000"
    }
    addRenderable(e, n) {
        this._attachedDomElements.includes(e) || this._attachedDomElements.push(e)
    }
    updateRenderable(e) {}
    validateRenderable(e) {
        return !0
    }
    postrender() {
        var s;
        const e = this._attachedDomElements;
        if (e.length === 0) {
            this._domElement.remove();
            return
        }
        const n = this._renderer.view.canvas;
        this._domElement.parentNode !== n.parentNode && ((s = n.parentNode) == null || s.appendChild(this._domElement));
        const r = parseFloat(n.style.width) / n.width * this._renderer.resolution,
            i = parseFloat(n.style.height) / n.height * this._renderer.resolution;
        this._domElement.style.transform = `translate(${n.offsetLeft}px, ${n.offsetTop}px) scale(${r}, ${i})`;
        for (let o = 0; o < e.length; o++) {
            const a = e[o],
                l = a.element;
            if (!a.parent || a.globalDisplayStatus < 7) l == null || l.remove(), e.splice(o, 1), o--;
            else {
                this._domElement.contains(l) || (l.style.position = "absolute", l.style.pointerEvents = "auto", this._domElement.appendChild(l));
                const c = a.worldTransform,
                    u = a._anchor,
                    d = a.width * u.x,
                    f = a.height * u.y;
                l.style.transformOrigin = `${d}px ${f}px`, l.style.transform = `matrix(${c.a}, ${c.b}, ${c.c}, ${c.d}, ${c.tx-d}, ${c.ty-f})`, l.style.opacity = a.groupAlpha.toString()
            }
        }
    }
    destroy() {
        var e;
        this._renderer.runners.postrender.remove(this);
        for (let n = 0; n < this._attachedDomElements.length; n++)(e = this._attachedDomElements[n].element) == null || e.remove();
        this._attachedDomElements.length = 0, this._domElement.remove(), this._renderer = null
    }
}
yD.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "dom"
};
class sle {
    constructor() {
        this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this._tickerAdded = !1, this._pauseUpdate = !0
    }
    init(e) {
        this.removeTickerListener(), this.events = e, this.interactionFrequency = 10, this._deltaTime = 0, this._didMove = !1, this._tickerAdded = !1, this._pauseUpdate = !0
    }
    get pauseUpdate() {
        return this._pauseUpdate
    }
    set pauseUpdate(e) {
        this._pauseUpdate = e
    }
    addTickerListener() {
        this._tickerAdded || !this.domElement || (bn.system.add(this._tickerUpdate, this, Tl.INTERACTION), this._tickerAdded = !0)
    }
    removeTickerListener() {
        this._tickerAdded && (bn.system.remove(this._tickerUpdate, this), this._tickerAdded = !1)
    }
    pointerMoved() {
        this._didMove = !0
    }
    _update() {
        if (!this.domElement || this._pauseUpdate) return;
        if (this._didMove) {
            this._didMove = !1;
            return
        }
        const e = this.events._rootPointerEvent;
        this.events.supportsTouchEvents && e.pointerType === "touch" || globalThis.document.dispatchEvent(this.events.supportsPointerEvents ? new PointerEvent("pointermove", {
            clientX: e.clientX,
            clientY: e.clientY,
            pointerType: e.pointerType,
            pointerId: e.pointerId
        }) : new MouseEvent("mousemove", {
            clientX: e.clientX,
            clientY: e.clientY
        }))
    }
    _tickerUpdate(e) {
        this._deltaTime += e.deltaTime, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this._update())
    }
}
const Es = new sle;
class Dh extends fd {
    constructor() {
        super(...arguments), this.client = new dt, this.movement = new dt, this.offset = new dt, this.global = new dt, this.screen = new dt
    }
    get clientX() {
        return this.client.x
    }
    get clientY() {
        return this.client.y
    }
    get x() {
        return this.clientX
    }
    get y() {
        return this.clientY
    }
    get movementX() {
        return this.movement.x
    }
    get movementY() {
        return this.movement.y
    }
    get offsetX() {
        return this.offset.x
    }
    get offsetY() {
        return this.offset.y
    }
    get globalX() {
        return this.global.x
    }
    get globalY() {
        return this.global.y
    }
    get screenX() {
        return this.screen.x
    }
    get screenY() {
        return this.screen.y
    }
    getLocalPosition(e, n, r) {
        return e.worldTransform.applyInverse(r || this.global, n)
    }
    getModifierState(e) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(e)
    }
    initMouseEvent(e, n, r, i, s, o, a, l, c, u, d, f, h, p, b) {
        throw new Error("Method not implemented.")
    }
}
class Sr extends Dh {
    constructor() {
        super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1
    }
    getCoalescedEvents() {
        return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : []
    }
    getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!")
    }
}
class Al extends Dh {
    constructor() {
        super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2
    }
}
Al.DOM_DELTA_PIXEL = 0;
Al.DOM_DELTA_LINE = 1;
Al.DOM_DELTA_PAGE = 2;
const ole = 2048,
    ale = new dt,
    bc = new dt;
class lle {
    constructor(e) {
        this.dispatch = new ir, this.moveOnAll = !1, this.enableGlobalMoveEvents = !0, this.mappingState = {
            trackingData: {}
        }, this.eventPool = new Map, this._allInteractiveElements = [], this._hitElements = [], this._isPointerMoveEvent = !1, this.rootTarget = e, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel)
    }
    addEventMapping(e, n) {
        this.mappingTable[e] || (this.mappingTable[e] = []), this.mappingTable[e].push({
            fn: n,
            priority: 0
        }), this.mappingTable[e].sort((r, i) => r.priority - i.priority)
    }
    dispatchEvent(e, n) {
        e.propagationStopped = !1, e.propagationImmediatelyStopped = !1, this.propagate(e, n), this.dispatch.emit(n || e.type, e)
    }
    mapEvent(e) {
        if (!this.rootTarget) return;
        const n = this.mappingTable[e.type];
        if (n)
            for (let r = 0, i = n.length; r < i; r++) n[r].fn(e);
        else Oe(`[EventBoundary]: Event mapping not defined for ${e.type}`)
    }
    hitTest(e, n) {
        Es.pauseUpdate = !0;
        const i = this._isPointerMoveEvent && this.enableGlobalMoveEvents ? "hitTestMoveRecursive" : "hitTestRecursive",
            s = this[i](this.rootTarget, this.rootTarget.eventMode, ale.set(e, n), this.hitTestFn, this.hitPruneFn);
        return s && s[0]
    }
    propagate(e, n) {
        if (!e.target) return;
        const r = e.composedPath();
        e.eventPhase = e.CAPTURING_PHASE;
        for (let i = 0, s = r.length - 1; i < s; i++)
            if (e.currentTarget = r[i], this.notifyTarget(e, n), e.propagationStopped || e.propagationImmediatelyStopped) return;
        if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, n), !(e.propagationStopped || e.propagationImmediatelyStopped)) {
            e.eventPhase = e.BUBBLING_PHASE;
            for (let i = r.length - 2; i >= 0; i--)
                if (e.currentTarget = r[i], this.notifyTarget(e, n), e.propagationStopped || e.propagationImmediatelyStopped) return
        }
    }
    all(e, n, r = this._allInteractiveElements) {
        if (r.length === 0) return;
        e.eventPhase = e.BUBBLING_PHASE;
        const i = Array.isArray(n) ? n : [n];
        for (let s = r.length - 1; s >= 0; s--) i.forEach(o => {
            e.currentTarget = r[s], this.notifyTarget(e, o)
        })
    }
    propagationPath(e) {
        const n = [e];
        for (let r = 0; r < ole && e !== this.rootTarget && e.parent; r++) {
            if (!e.parent) throw new Error("Cannot find propagation path to disconnected target");
            n.push(e.parent), e = e.parent
        }
        return n.reverse(), n
    }
    hitTestMoveRecursive(e, n, r, i, s, o = !1) {
        let a = !1;
        if (this._interactivePrune(e)) return null;
        if ((e.eventMode === "dynamic" || n === "dynamic") && (Es.pauseUpdate = !1), e.interactiveChildren && e.children) {
            const u = e.children;
            for (let d = u.length - 1; d >= 0; d--) {
                const f = u[d],
                    h = this.hitTestMoveRecursive(f, this._isInteractive(n) ? n : f.eventMode, r, i, s, o || s(e, r));
                if (h) {
                    if (h.length > 0 && !h[h.length - 1].parent) continue;
                    const p = e.isInteractive();
                    (h.length > 0 || p) && (p && this._allInteractiveElements.push(e), h.push(e)), this._hitElements.length === 0 && (this._hitElements = h), a = !0
                }
            }
        }
        const l = this._isInteractive(n),
            c = e.isInteractive();
        return c && c && this._allInteractiveElements.push(e), o || this._hitElements.length > 0 ? null : a ? this._hitElements : l && !s(e, r) && i(e, r) ? c ? [e] : [] : null
    }
    hitTestRecursive(e, n, r, i, s) {
        if (this._interactivePrune(e) || s(e, r)) return null;
        if ((e.eventMode === "dynamic" || n === "dynamic") && (Es.pauseUpdate = !1), e.interactiveChildren && e.children) {
            const l = e.children,
                c = r;
            for (let u = l.length - 1; u >= 0; u--) {
                const d = l[u],
                    f = this.hitTestRecursive(d, this._isInteractive(n) ? n : d.eventMode, c, i, s);
                if (f) {
                    if (f.length > 0 && !f[f.length - 1].parent) continue;
                    const h = e.isInteractive();
                    return (f.length > 0 || h) && f.push(e), f
                }
            }
        }
        const o = this._isInteractive(n),
            a = e.isInteractive();
        return o && i(e, r) ? a ? [e] : [] : null
    }
    _isInteractive(e) {
        return e === "static" || e === "dynamic"
    }
    _interactivePrune(e) {
        return !e || !e.visible || !e.renderable || !e.measurable || e.eventMode === "none" || e.eventMode === "passive" && !e.interactiveChildren
    }
    hitPruneFn(e, n) {
        if (e.hitArea && (e.worldTransform.applyInverse(n, bc), !e.hitArea.contains(bc.x, bc.y))) return !0;
        if (e.effects && e.effects.length)
            for (let r = 0; r < e.effects.length; r++) {
                const i = e.effects[r];
                if (i.containsPoint && !i.containsPoint(n, this.hitTestFn)) return !0
            }
        return !1
    }
    hitTestFn(e, n) {
        return e.hitArea ? !0 : e != null && e.containsPoint ? (e.worldTransform.applyInverse(n, bc), e.containsPoint(bc)) : !1
    }
    notifyTarget(e, n) {
        var s, o;
        if (!e.currentTarget.isInteractive()) return;
        n ? ? (n = e.type);
        const r = `on${n}`;
        (o = (s = e.currentTarget)[r]) == null || o.call(s, e);
        const i = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${n}capture` : n;
        this._notifyListeners(e, i), e.eventPhase === e.AT_TARGET && this._notifyListeners(e, n)
    }
    mapPointerDown(e) {
        if (!(e instanceof Sr)) {
            Oe("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = this.createPointerEvent(e);
        if (this.dispatchEvent(n, "pointerdown"), n.pointerType === "touch") this.dispatchEvent(n, "touchstart");
        else if (n.pointerType === "mouse" || n.pointerType === "pen") {
            const i = n.button === 2;
            this.dispatchEvent(n, i ? "rightdown" : "mousedown")
        }
        const r = this.trackingData(e.pointerId);
        r.pressTargetsByButton[e.button] = n.composedPath(), this.freeEvent(n)
    }
    mapPointerMove(e) {
        var l, c;
        if (!(e instanceof Sr)) {
            Oe("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        this._allInteractiveElements.length = 0, this._hitElements.length = 0, this._isPointerMoveEvent = !0;
        const n = this.createPointerEvent(e);
        this._isPointerMoveEvent = !1;
        const r = n.pointerType === "mouse" || n.pointerType === "pen",
            i = this.trackingData(e.pointerId),
            s = this.findMountedTarget(i.overTargets);
        if (((l = i.overTargets) == null ? void 0 : l.length) > 0 && s !== n.target) {
            const u = e.type === "mousemove" ? "mouseout" : "pointerout",
                d = this.createPointerEvent(e, u, s);
            if (this.dispatchEvent(d, "pointerout"), r && this.dispatchEvent(d, "mouseout"), !n.composedPath().includes(s)) {
                const f = this.createPointerEvent(e, "pointerleave", s);
                for (f.eventPhase = f.AT_TARGET; f.target && !n.composedPath().includes(f.target);) f.currentTarget = f.target, this.notifyTarget(f), r && this.notifyTarget(f, "mouseleave"), f.target = f.target.parent;
                this.freeEvent(f)
            }
            this.freeEvent(d)
        }
        if (s !== n.target) {
            const u = e.type === "mousemove" ? "mouseover" : "pointerover",
                d = this.clonePointerEvent(n, u);
            this.dispatchEvent(d, "pointerover"), r && this.dispatchEvent(d, "mouseover");
            let f = s == null ? void 0 : s.parent;
            for (; f && f !== this.rootTarget.parent && f !== n.target;) f = f.parent;
            if (!f || f === this.rootTarget.parent) {
                const p = this.clonePointerEvent(n, "pointerenter");
                for (p.eventPhase = p.AT_TARGET; p.target && p.target !== s && p.target !== this.rootTarget.parent;) p.currentTarget = p.target, this.notifyTarget(p), r && this.notifyTarget(p, "mouseenter"), p.target = p.target.parent;
                this.freeEvent(p)
            }
            this.freeEvent(d)
        }
        const o = [],
            a = this.enableGlobalMoveEvents ? ? !0;
        this.moveOnAll ? o.push("pointermove") : this.dispatchEvent(n, "pointermove"), a && o.push("globalpointermove"), n.pointerType === "touch" && (this.moveOnAll ? o.splice(1, 0, "touchmove") : this.dispatchEvent(n, "touchmove"), a && o.push("globaltouchmove")), r && (this.moveOnAll ? o.splice(1, 0, "mousemove") : this.dispatchEvent(n, "mousemove"), a && o.push("globalmousemove"), this.cursor = (c = n.target) == null ? void 0 : c.cursor), o.length > 0 && this.all(n, o), this._allInteractiveElements.length = 0, this._hitElements.length = 0, i.overTargets = n.composedPath(), this.freeEvent(n)
    }
    mapPointerOver(e) {
        var o;
        if (!(e instanceof Sr)) {
            Oe("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = this.trackingData(e.pointerId),
            r = this.createPointerEvent(e),
            i = r.pointerType === "mouse" || r.pointerType === "pen";
        this.dispatchEvent(r, "pointerover"), i && this.dispatchEvent(r, "mouseover"), r.pointerType === "mouse" && (this.cursor = (o = r.target) == null ? void 0 : o.cursor);
        const s = this.clonePointerEvent(r, "pointerenter");
        for (s.eventPhase = s.AT_TARGET; s.target && s.target !== this.rootTarget.parent;) s.currentTarget = s.target, this.notifyTarget(s), i && this.notifyTarget(s, "mouseenter"), s.target = s.target.parent;
        n.overTargets = r.composedPath(), this.freeEvent(r), this.freeEvent(s)
    }
    mapPointerOut(e) {
        if (!(e instanceof Sr)) {
            Oe("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = this.trackingData(e.pointerId);
        if (n.overTargets) {
            const r = e.pointerType === "mouse" || e.pointerType === "pen",
                i = this.findMountedTarget(n.overTargets),
                s = this.createPointerEvent(e, "pointerout", i);
            this.dispatchEvent(s), r && this.dispatchEvent(s, "mouseout");
            const o = this.createPointerEvent(e, "pointerleave", i);
            for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent;) o.currentTarget = o.target, this.notifyTarget(o), r && this.notifyTarget(o, "mouseleave"), o.target = o.target.parent;
            n.overTargets = null, this.freeEvent(s), this.freeEvent(o)
        }
        this.cursor = null
    }
    mapPointerUp(e) {
        if (!(e instanceof Sr)) {
            Oe("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = performance.now(),
            r = this.createPointerEvent(e);
        if (this.dispatchEvent(r, "pointerup"), r.pointerType === "touch") this.dispatchEvent(r, "touchend");
        else if (r.pointerType === "mouse" || r.pointerType === "pen") {
            const a = r.button === 2;
            this.dispatchEvent(r, a ? "rightup" : "mouseup")
        }
        const i = this.trackingData(e.pointerId),
            s = this.findMountedTarget(i.pressTargetsByButton[e.button]);
        let o = s;
        if (s && !r.composedPath().includes(s)) {
            let a = s;
            for (; a && !r.composedPath().includes(a);) {
                if (r.currentTarget = a, this.notifyTarget(r, "pointerupoutside"), r.pointerType === "touch") this.notifyTarget(r, "touchendoutside");
                else if (r.pointerType === "mouse" || r.pointerType === "pen") {
                    const l = r.button === 2;
                    this.notifyTarget(r, l ? "rightupoutside" : "mouseupoutside")
                }
                a = a.parent
            }
            delete i.pressTargetsByButton[e.button], o = a
        }
        if (o) {
            const a = this.clonePointerEvent(r, "click");
            a.target = o, a.path = null, i.clicksByButton[e.button] || (i.clicksByButton[e.button] = {
                clickCount: 0,
                target: a.target,
                timeStamp: n
            });
            const l = i.clicksByButton[e.button];
            if (l.target === a.target && n - l.timeStamp < 200 ? ++l.clickCount : l.clickCount = 1, l.target = a.target, l.timeStamp = n, a.detail = l.clickCount, a.pointerType === "mouse") {
                const c = a.button === 2;
                this.dispatchEvent(a, c ? "rightclick" : "click")
            } else a.pointerType === "touch" && this.dispatchEvent(a, "tap");
            this.dispatchEvent(a, "pointertap"), this.freeEvent(a)
        }
        this.freeEvent(r)
    }
    mapPointerUpOutside(e) {
        if (!(e instanceof Sr)) {
            Oe("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const n = this.trackingData(e.pointerId),
            r = this.findMountedTarget(n.pressTargetsByButton[e.button]),
            i = this.createPointerEvent(e);
        if (r) {
            let s = r;
            for (; s;) i.currentTarget = s, this.notifyTarget(i, "pointerupoutside"), i.pointerType === "touch" ? this.notifyTarget(i, "touchendoutside") : (i.pointerType === "mouse" || i.pointerType === "pen") && this.notifyTarget(i, i.button === 2 ? "rightupoutside" : "mouseupoutside"), s = s.parent;
            delete n.pressTargetsByButton[e.button]
        }
        this.freeEvent(i)
    }
    mapWheel(e) {
        if (!(e instanceof Al)) {
            Oe("EventBoundary cannot map a non-wheel event as a wheel event");
            return
        }
        const n = this.createWheelEvent(e);
        this.dispatchEvent(n), this.freeEvent(n)
    }
    findMountedTarget(e) {
        if (!e) return null;
        let n = e[0];
        for (let r = 1; r < e.length && e[r].parent === n; r++) n = e[r];
        return n
    }
    createPointerEvent(e, n, r) {
        const i = this.allocateEvent(Sr);
        return this.copyPointerData(e, i), this.copyMouseData(e, i), this.copyData(e, i), i.nativeEvent = e.nativeEvent, i.originalEvent = e, i.target = r ? ? this.hitTest(i.global.x, i.global.y) ? ? this._hitElements[0], typeof n == "string" && (i.type = n), i
    }
    createWheelEvent(e) {
        const n = this.allocateEvent(Al);
        return this.copyWheelData(e, n), this.copyMouseData(e, n), this.copyData(e, n), n.nativeEvent = e.nativeEvent, n.originalEvent = e, n.target = this.hitTest(n.global.x, n.global.y), n
    }
    clonePointerEvent(e, n) {
        const r = this.allocateEvent(Sr);
        return r.nativeEvent = e.nativeEvent, r.originalEvent = e.originalEvent, this.copyPointerData(e, r), this.copyMouseData(e, r), this.copyData(e, r), r.target = e.target, r.path = e.composedPath().slice(), r.type = n ? ? r.type, r
    }
    copyWheelData(e, n) {
        n.deltaMode = e.deltaMode, n.deltaX = e.deltaX, n.deltaY = e.deltaY, n.deltaZ = e.deltaZ
    }
    copyPointerData(e, n) {
        e instanceof Sr && n instanceof Sr && (n.pointerId = e.pointerId, n.width = e.width, n.height = e.height, n.isPrimary = e.isPrimary, n.pointerType = e.pointerType, n.pressure = e.pressure, n.tangentialPressure = e.tangentialPressure, n.tiltX = e.tiltX, n.tiltY = e.tiltY, n.twist = e.twist)
    }
    copyMouseData(e, n) {
        e instanceof Dh && n instanceof Dh && (n.altKey = e.altKey, n.button = e.button, n.buttons = e.buttons, n.client.copyFrom(e.client), n.ctrlKey = e.ctrlKey, n.metaKey = e.metaKey, n.movement.copyFrom(e.movement), n.screen.copyFrom(e.screen), n.shiftKey = e.shiftKey, n.global.copyFrom(e.global))
    }
    copyData(e, n) {
        n.isTrusted = e.isTrusted, n.srcElement = e.srcElement, n.timeStamp = performance.now(), n.type = e.type, n.detail = e.detail, n.view = e.view, n.which = e.which, n.layer.copyFrom(e.layer), n.page.copyFrom(e.page)
    }
    trackingData(e) {
        return this.mappingState.trackingData[e] || (this.mappingState.trackingData[e] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
        }), this.mappingState.trackingData[e]
    }
    allocateEvent(e) {
        this.eventPool.has(e) || this.eventPool.set(e, []);
        const n = this.eventPool.get(e).pop() || new e(this);
        return n.eventPhase = n.NONE, n.currentTarget = null, n.defaultPrevented = !1, n.path = null, n.target = null, n
    }
    freeEvent(e) {
        if (e.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const n = e.constructor;
        this.eventPool.has(n) || this.eventPool.set(n, []), this.eventPool.get(n).push(e)
    }
    _notifyListeners(e, n) {
        const r = e.currentTarget._events[n];
        if (r)
            if ("fn" in r) r.once && e.currentTarget.removeListener(n, r.fn, void 0, !0), r.fn.call(r.context, e);
            else
                for (let i = 0, s = r.length; i < s && !e.propagationImmediatelyStopped; i++) r[i].once && e.currentTarget.removeListener(n, r[i].fn, void 0, !0), r[i].fn.call(r[i].context, e)
    }
}
const cle = 1,
    ule = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
    },
    Hx = class R0 {
        constructor(e) {
            this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = e, this.rootBoundary = new lle(null), Es.init(this), this.autoPreventDefault = !0, this._eventsAdded = !1, this._rootPointerEvent = new Sr(null), this._rootWheelEvent = new Al(null), this.cursorStyles = {
                default: "inherit",
                pointer: "pointer"
            }, this.features = new Proxy({ ...R0.defaultEventFeatures
            }, {
                set: (n, r, i) => (r === "globalMove" && (this.rootBoundary.enableGlobalMoveEvents = i), n[r] = i, !0)
            }), this._onPointerDown = this._onPointerDown.bind(this), this._onPointerMove = this._onPointerMove.bind(this), this._onPointerUp = this._onPointerUp.bind(this), this._onPointerOverOut = this._onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this)
        }
        static get defaultEventMode() {
            return this._defaultEventMode
        }
        init(e) {
            const {
                canvas: n,
                resolution: r
            } = this.renderer;
            this.setTargetElement(n), this.resolution = r, R0._defaultEventMode = e.eventMode ? ? "passive", Object.assign(this.features, e.eventFeatures ? ? {}), this.rootBoundary.enableGlobalMoveEvents = this.features.globalMove
        }
        resolutionChange(e) {
            this.resolution = e
        }
        destroy() {
            this.setTargetElement(null), this.renderer = null, this._currentCursor = null
        }
        setCursor(e) {
            e || (e = "default");
            let n = !0;
            if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (n = !1), this._currentCursor === e) return;
            this._currentCursor = e;
            const r = this.cursorStyles[e];
            if (r) switch (typeof r) {
                case "string":
                    n && (this.domElement.style.cursor = r);
                    break;
                case "function":
                    r(e);
                    break;
                case "object":
                    n && Object.assign(this.domElement.style, r);
                    break
            } else n && typeof e == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, e) && (this.domElement.style.cursor = e)
        }
        get pointer() {
            return this._rootPointerEvent
        }
        _onPointerDown(e) {
            if (!this.features.click) return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            const n = this._normalizeToPointerData(e);
            this.autoPreventDefault && n[0].isNormalized && (e.cancelable || !("cancelable" in e)) && e.preventDefault();
            for (let r = 0, i = n.length; r < i; r++) {
                const s = n[r],
                    o = this._bootstrapEvent(this._rootPointerEvent, s);
                this.rootBoundary.mapEvent(o)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        _onPointerMove(e) {
            if (!this.features.move) return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, Es.pointerMoved();
            const n = this._normalizeToPointerData(e);
            for (let r = 0, i = n.length; r < i; r++) {
                const s = this._bootstrapEvent(this._rootPointerEvent, n[r]);
                this.rootBoundary.mapEvent(s)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        _onPointerUp(e) {
            if (!this.features.click) return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            let n = e.target;
            e.composedPath && e.composedPath().length > 0 && (n = e.composedPath()[0]);
            const r = n !== this.domElement ? "outside" : "",
                i = this._normalizeToPointerData(e);
            for (let s = 0, o = i.length; s < o; s++) {
                const a = this._bootstrapEvent(this._rootPointerEvent, i[s]);
                a.type += r, this.rootBoundary.mapEvent(a)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        _onPointerOverOut(e) {
            if (!this.features.click) return;
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered;
            const n = this._normalizeToPointerData(e);
            for (let r = 0, i = n.length; r < i; r++) {
                const s = this._bootstrapEvent(this._rootPointerEvent, n[r]);
                this.rootBoundary.mapEvent(s)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onWheel(e) {
            if (!this.features.wheel) return;
            const n = this.normalizeWheelEvent(e);
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(n)
        }
        setTargetElement(e) {
            this._removeEvents(), this.domElement = e, Es.domElement = e, this._addEvents()
        }
        _addEvents() {
            if (this._eventsAdded || !this.domElement) return;
            Es.addTickerListener();
            const e = this.domElement.style;
            e && (globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "none", e.msTouchAction = "none") : this.supportsPointerEvents && (e.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this._onPointerMove, !0), this.domElement.addEventListener("pointerdown", this._onPointerDown, !0), this.domElement.addEventListener("pointerleave", this._onPointerOverOut, !0), this.domElement.addEventListener("pointerover", this._onPointerOverOut, !0), globalThis.addEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this._onPointerMove, !0), this.domElement.addEventListener("mousedown", this._onPointerDown, !0), this.domElement.addEventListener("mouseout", this._onPointerOverOut, !0), this.domElement.addEventListener("mouseover", this._onPointerOverOut, !0), globalThis.addEventListener("mouseup", this._onPointerUp, !0), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this._onPointerDown, !0), this.domElement.addEventListener("touchend", this._onPointerUp, !0), this.domElement.addEventListener("touchmove", this._onPointerMove, !0))), this.domElement.addEventListener("wheel", this.onWheel, {
                passive: !0,
                capture: !0
            }), this._eventsAdded = !0
        }
        _removeEvents() {
            if (!this._eventsAdded || !this.domElement) return;
            Es.removeTickerListener();
            const e = this.domElement.style;
            e && (globalThis.navigator.msPointerEnabled ? (e.msContentZooming = "", e.msTouchAction = "") : this.supportsPointerEvents && (e.touchAction = "")), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this._onPointerMove, !0), this.domElement.removeEventListener("pointerdown", this._onPointerDown, !0), this.domElement.removeEventListener("pointerleave", this._onPointerOverOut, !0), this.domElement.removeEventListener("pointerover", this._onPointerOverOut, !0), globalThis.removeEventListener("pointerup", this._onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this._onPointerMove, !0), this.domElement.removeEventListener("mousedown", this._onPointerDown, !0), this.domElement.removeEventListener("mouseout", this._onPointerOverOut, !0), this.domElement.removeEventListener("mouseover", this._onPointerOverOut, !0), globalThis.removeEventListener("mouseup", this._onPointerUp, !0), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this._onPointerDown, !0), this.domElement.removeEventListener("touchend", this._onPointerUp, !0), this.domElement.removeEventListener("touchmove", this._onPointerMove, !0))), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this._eventsAdded = !1
        }
        mapPositionToPoint(e, n, r) {
            const i = this.domElement.isConnected ? this.domElement.getBoundingClientRect() : {
                    x: 0,
                    y: 0,
                    width: this.domElement.width,
                    height: this.domElement.height,
                    left: 0,
                    top: 0
                },
                s = 1 / this.resolution;
            e.x = (n - i.left) * (this.domElement.width / i.width) * s, e.y = (r - i.top) * (this.domElement.height / i.height) * s
        }
        _normalizeToPointerData(e) {
            const n = [];
            if (this.supportsTouchEvents && e instanceof TouchEvent)
                for (let r = 0, i = e.changedTouches.length; r < i; r++) {
                    const s = e.changedTouches[r];
                    typeof s.button > "u" && (s.button = 0), typeof s.buttons > "u" && (s.buttons = 1), typeof s.isPrimary > "u" && (s.isPrimary = e.touches.length === 1 && e.type === "touchstart"), typeof s.width > "u" && (s.width = s.radiusX || 1), typeof s.height > "u" && (s.height = s.radiusY || 1), typeof s.tiltX > "u" && (s.tiltX = 0), typeof s.tiltY > "u" && (s.tiltY = 0), typeof s.pointerType > "u" && (s.pointerType = "touch"), typeof s.pointerId > "u" && (s.pointerId = s.identifier || 0), typeof s.pressure > "u" && (s.pressure = s.force || .5), typeof s.twist > "u" && (s.twist = 0), typeof s.tangentialPressure > "u" && (s.tangentialPressure = 0), typeof s.layerX > "u" && (s.layerX = s.offsetX = s.clientX), typeof s.layerY > "u" && (s.layerY = s.offsetY = s.clientY), s.isNormalized = !0, s.type = e.type, n.push(s)
                } else if (!globalThis.MouseEvent || e instanceof MouseEvent && (!this.supportsPointerEvents || !(e instanceof globalThis.PointerEvent))) {
                    const r = e;
                    typeof r.isPrimary > "u" && (r.isPrimary = !0), typeof r.width > "u" && (r.width = 1), typeof r.height > "u" && (r.height = 1), typeof r.tiltX > "u" && (r.tiltX = 0), typeof r.tiltY > "u" && (r.tiltY = 0), typeof r.pointerType > "u" && (r.pointerType = "mouse"), typeof r.pointerId > "u" && (r.pointerId = cle), typeof r.pressure > "u" && (r.pressure = .5), typeof r.twist > "u" && (r.twist = 0), typeof r.tangentialPressure > "u" && (r.tangentialPressure = 0), r.isNormalized = !0, n.push(r)
                } else n.push(e);
            return n
        }
        normalizeWheelEvent(e) {
            const n = this._rootWheelEvent;
            return this._transferMouseData(n, e), n.deltaX = e.deltaX, n.deltaY = e.deltaY, n.deltaZ = e.deltaZ, n.deltaMode = e.deltaMode, this.mapPositionToPoint(n.screen, e.clientX, e.clientY), n.global.copyFrom(n.screen), n.offset.copyFrom(n.screen), n.nativeEvent = e, n.type = e.type, n
        }
        _bootstrapEvent(e, n) {
            return e.originalEvent = null, e.nativeEvent = n, e.pointerId = n.pointerId, e.width = n.width, e.height = n.height, e.isPrimary = n.isPrimary, e.pointerType = n.pointerType, e.pressure = n.pressure, e.tangentialPressure = n.tangentialPressure, e.tiltX = n.tiltX, e.tiltY = n.tiltY, e.twist = n.twist, this._transferMouseData(e, n), this.mapPositionToPoint(e.screen, n.clientX, n.clientY), e.global.copyFrom(e.screen), e.offset.copyFrom(e.screen), e.isTrusted = n.isTrusted, e.type === "pointerleave" && (e.type = "pointerout"), e.type.startsWith("mouse") && (e.type = e.type.replace("mouse", "pointer")), e.type.startsWith("touch") && (e.type = ule[e.type] || e.type), e
        }
        _transferMouseData(e, n) {
            e.isTrusted = n.isTrusted, e.srcElement = n.srcElement, e.timeStamp = performance.now(), e.type = n.type, e.altKey = n.altKey, e.button = n.button, e.buttons = n.buttons, e.client.x = n.clientX, e.client.y = n.clientY, e.ctrlKey = n.ctrlKey, e.metaKey = n.metaKey, e.movement.x = n.movementX, e.movement.y = n.movementY, e.page.x = n.pageX, e.page.y = n.pageY, e.relatedTarget = null, e.shiftKey = n.shiftKey
        }
    };
Hx.extension = {
    name: "events",
    type: [G.WebGLSystem, G.CanvasSystem, G.WebGPUSystem],
    priority: -1
};
Hx.defaultEventFeatures = {
    move: !0,
    globalMove: !0,
    click: !0,
    wheel: !0
};
let vD = Hx;
const dle = {
        onclick: null,
        onmousedown: null,
        onmouseenter: null,
        onmouseleave: null,
        onmousemove: null,
        onglobalmousemove: null,
        onmouseout: null,
        onmouseover: null,
        onmouseup: null,
        onmouseupoutside: null,
        onpointercancel: null,
        onpointerdown: null,
        onpointerenter: null,
        onpointerleave: null,
        onpointermove: null,
        onglobalpointermove: null,
        onpointerout: null,
        onpointerover: null,
        onpointertap: null,
        onpointerup: null,
        onpointerupoutside: null,
        onrightclick: null,
        onrightdown: null,
        onrightup: null,
        onrightupoutside: null,
        ontap: null,
        ontouchcancel: null,
        ontouchend: null,
        ontouchendoutside: null,
        ontouchmove: null,
        onglobaltouchmove: null,
        ontouchstart: null,
        onwheel: null,
        get interactive() {
            return this.eventMode === "dynamic" || this.eventMode === "static"
        },
        set interactive(t) {
            this.eventMode = t ? "static" : "passive"
        },
        _internalEventMode: void 0,
        get eventMode() {
            return this._internalEventMode ? ? vD.defaultEventMode
        },
        set eventMode(t) {
            this._internalEventMode = t
        },
        isInteractive() {
            return this.eventMode === "static" || this.eventMode === "dynamic"
        },
        interactiveChildren: !0,
        hitArea: null,
        addEventListener(t, e, n) {
            const r = typeof n == "boolean" && n || typeof n == "object" && n.capture,
                i = typeof n == "object" ? n.signal : void 0,
                s = typeof n == "object" ? n.once === !0 : !1,
                o = typeof e == "function" ? void 0 : e;
            t = r ? `${t}capture` : t;
            const a = typeof e == "function" ? e : e.handleEvent,
                l = this;
            i && i.addEventListener("abort", () => {
                l.off(t, a, o)
            }), s ? l.once(t, a, o) : l.on(t, a, o)
        },
        removeEventListener(t, e, n) {
            const r = typeof n == "boolean" && n || typeof n == "object" && n.capture,
                i = typeof e == "function" ? void 0 : e;
            t = r ? `${t}capture` : t, e = typeof e == "function" ? e : e.handleEvent, this.off(t, e, i)
        },
        dispatchEvent(t) {
            if (!(t instanceof fd)) throw new Error("Container cannot propagate events outside of the Federated Events API");
            return t.defaultPrevented = !1, t.path = null, t.target = this, t.manager.dispatchEvent(t), !t.defaultPrevented
        }
    },
    _D = {
        5: [.153388, .221461, .250301],
        7: [.071303, .131514, .189879, .214607],
        9: [.028532, .067234, .124009, .179044, .20236],
        11: [.0093, .028002, .065984, .121703, .175713, .198596],
        13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
        15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
    },
    fle = ["in vec2 vBlurTexCoords[%size%];", "uniform sampler2D uTexture;", "out vec4 finalColor;", "void main(void)", "{", "    finalColor = vec4(0.0);", "    %blur%", "}"].join(`
`);

function hle(t) {
    const e = _D[t],
        n = e.length;
    let r = fle,
        i = "";
    const s = "finalColor += texture(uTexture, vBlurTexCoords[%index%]) * %value%;";
    let o;
    for (let a = 0; a < t; a++) {
        let l = s.replace("%index%", a.toString());
        o = a, a >= n && (o = t - a - 1), l = l.replace("%value%", e[o].toString()), i += l, i += `
`
    }
    return r = r.replace("%blur%", i), r = r.replace("%size%", t.toString()), r
}
const ple = `
    in vec2 aPosition;

    uniform float uStrength;

    out vec2 vBlurTexCoords[%size%];

    uniform vec4 uInputSize;
    uniform vec4 uOutputFrame;
    uniform vec4 uOutputTexture;

    vec4 filterVertexPosition( void )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;

    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

    vec2 filterTextureCoord( void )
    {
        return aPosition * (uOutputFrame.zw * uInputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        float pixelStrength = uInputSize.%dimension% * uStrength;

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;

function mle(t, e) {
    const n = Math.ceil(t / 2);
    let r = ple,
        i = "",
        s;
    e ? s = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * pixelStrength, 0.0);" : s = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * pixelStrength);";
    for (let o = 0; o < t; o++) {
        let a = s.replace("%index%", o.toString());
        a = a.replace("%sampleIndex%", `${o-(n-1)}.0`), i += a, i += `
`
    }
    return r = r.replace("%blur%", i), r = r.replace("%size%", t.toString()), r = r.replace("%dimension%", e ? "z" : "w"), r
}

function gle(t, e) {
    const n = mle(e, t),
        r = hle(e);
    return wa.from({
        vertex: n,
        fragment: r,
        name: `blur-${t?"horizontal":"vertical"}-pass-filter`
    })
}
var yle = `

struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct BlurUniforms {
  uStrength:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> blurUniforms : BlurUniforms;


struct VSOutput {
    @builtin(position) position: vec4<f32>,
    %blur-struct%
  };

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);  
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}


@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>, 
) -> VSOutput {

  let filteredCord = filterTextureCoord(aPosition);

  let pixelStrength = gfu.uInputSize.%dimension% * blurUniforms.uStrength;

  return VSOutput(
   filterVertexPosition(aPosition),
    %blur-vertex-out%
  );
}

@fragment
fn mainFragment(
  @builtin(position) position: vec4<f32>,
  %blur-fragment-in%
) -> @location(0) vec4<f32> {

    var   finalColor = vec4(0.0);

    %blur-sampling%

    return finalColor;
}`;

function vle(t, e) {
    const n = _D[e],
        r = n.length,
        i = [],
        s = [],
        o = [];
    for (let d = 0; d < e; d++) {
        i[d] = `@location(${d}) offset${d}: vec2<f32>,`, t ? s[d] = `filteredCord + vec2(${d-r+1} * pixelStrength, 0.0),` : s[d] = `filteredCord + vec2(0.0, ${d-r+1} * pixelStrength),`;
        const f = d < r ? d : e - d - 1,
            h = n[f].toString();
        o[d] = `finalColor += textureSample(uTexture, uSampler, offset${d}) * ${h};`
    }
    const a = i.join(`
`),
        l = s.join(`
`),
        c = o.join(`
`),
        u = yle.replace("%blur-struct%", a).replace("%blur-vertex-out%", l).replace("%blur-fragment-in%", a).replace("%blur-sampling%", c).replace("%dimension%", t ? "z" : "w");
    return io.from({
        vertex: {
            source: u,
            entryPoint: "mainVertex"
        },
        fragment: {
            source: u,
            entryPoint: "mainFragment"
        }
    })
}
const bD = class xD extends wx {
    constructor(e) {
        e = { ...xD.defaultOptions,
            ...e
        };
        const n = gle(e.horizontal, e.kernelSize),
            r = vle(e.horizontal, e.kernelSize);
        super({
            glProgram: n,
            gpuProgram: r,
            resources: {
                blurUniforms: {
                    uStrength: {
                        value: 0,
                        type: "f32"
                    }
                }
            },
            ...e
        }), this.horizontal = e.horizontal, this._quality = 0, this.quality = e.quality, this.blur = e.strength, this._uniforms = this.resources.blurUniforms.uniforms
    }
    apply(e, n, r, i) {
        if (this._uniforms.uStrength = this.strength / this.passes, this.passes === 1) e.applyFilter(this, n, r, i);
        else {
            const s = Ft.getSameSizeTexture(n);
            let o = n,
                a = s;
            this._state.blend = !1;
            const l = e.renderer.type === tr.WEBGPU;
            for (let c = 0; c < this.passes - 1; c++) {
                e.applyFilter(this, o, a, c === 0 ? !0 : l);
                const u = a;
                a = o, o = u
            }
            this._state.blend = !0, e.applyFilter(this, o, r, i), Ft.returnTexture(s)
        }
    }
    get blur() {
        return this.strength
    }
    set blur(e) {
        this.padding = 1 + Math.abs(e) * 2, this.strength = e
    }
    get quality() {
        return this._quality
    }
    set quality(e) {
        this._quality = e, this.passes = e
    }
};
bD.defaultOptions = {
    strength: 8,
    quality: 4,
    kernelSize: 5
};
let Ug = bD;
class _le extends wx {
    constructor(...e) {
        let n = e[0] ? ? {};
        typeof n == "number" && (Ie(Ye, "BlurFilter constructor params are now options object. See params: { strength, quality, resolution, kernelSize }"), n = {
            strength: n
        }, e[1] !== void 0 && (n.quality = e[1]), e[2] !== void 0 && (n.resolution = e[2] || "inherit"), e[3] !== void 0 && (n.kernelSize = e[3])), n = { ...Ug.defaultOptions,
            ...n
        };
        const {
            strength: r,
            strengthX: i,
            strengthY: s,
            quality: o,
            ...a
        } = n;
        super({ ...a,
            compatibleRenderers: tr.BOTH,
            resources: {}
        }), this._repeatEdgePixels = !1, this.blurXFilter = new Ug({
            horizontal: !0,
            ...n
        }), this.blurYFilter = new Ug({
            horizontal: !1,
            ...n
        }), this.quality = o, this.strengthX = i ? ? r, this.strengthY = s ? ? r, this.repeatEdgePixels = !1
    }
    apply(e, n, r, i) {
        const s = Math.abs(this.blurXFilter.strength),
            o = Math.abs(this.blurYFilter.strength);
        if (s && o) {
            const a = Ft.getSameSizeTexture(n);
            this.blurXFilter.blendMode = "normal", this.blurXFilter.apply(e, n, a, !0), this.blurYFilter.blendMode = this.blendMode, this.blurYFilter.apply(e, a, r, i), Ft.returnTexture(a)
        } else o ? (this.blurYFilter.blendMode = this.blendMode, this.blurYFilter.apply(e, n, r, i)) : (this.blurXFilter.blendMode = this.blendMode, this.blurXFilter.apply(e, n, r, i))
    }
    updatePadding() {
        this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.blur), Math.abs(this.blurYFilter.blur)) * 2
    }
    get strength() {
        if (this.strengthX !== this.strengthY) throw new Error("BlurFilter's strengthX and strengthY are different");
        return this.strengthX
    }
    set strength(e) {
        this.blurXFilter.blur = this.blurYFilter.blur = e, this.updatePadding()
    }
    get quality() {
        return this.blurXFilter.quality
    }
    set quality(e) {
        this.blurXFilter.quality = this.blurYFilter.quality = e
    }
    get strengthX() {
        return this.blurXFilter.blur
    }
    set strengthX(e) {
        this.blurXFilter.blur = e, this.updatePadding()
    }
    get strengthY() {
        return this.blurYFilter.blur
    }
    set strengthY(e) {
        this.blurYFilter.blur = e, this.updatePadding()
    }
    get blur() {
        return Ie("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead."), this.strength
    }
    set blur(e) {
        Ie("8.3.0", "BlurFilter.blur is deprecated, please use BlurFilter.strength instead."), this.strength = e
    }
    get blurX() {
        return Ie("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead."), this.strengthX
    }
    set blurX(e) {
        Ie("8.3.0", "BlurFilter.blurX is deprecated, please use BlurFilter.strengthX instead."), this.strengthX = e
    }
    get blurY() {
        return Ie("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead."), this.strengthY
    }
    set blurY(e) {
        Ie("8.3.0", "BlurFilter.blurY is deprecated, please use BlurFilter.strengthY instead."), this.strengthY = e
    }
    get repeatEdgePixels() {
        return this._repeatEdgePixels
    }
    set repeatEdgePixels(e) {
        this._repeatEdgePixels = e, this.updatePadding()
    }
}
_le.defaultOptions = {
    strength: 8,
    quality: 4,
    kernelSize: 5
};
class wD {
    constructor(e) {
        this._renderer = e
    }
    push(e, n, r) {
        this._renderer.renderPipes.batch.break(r), r.add({
            renderPipeId: "filter",
            canBundle: !1,
            action: "pushFilter",
            container: n,
            filterEffect: e
        })
    }
    pop(e, n, r) {
        this._renderer.renderPipes.batch.break(r), r.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: !1
        })
    }
    execute(e) {
        e.action === "pushFilter" ? this._renderer.filter.push(e) : e.action === "popFilter" && this._renderer.filter.pop()
    }
    destroy() {
        this._renderer = null
    }
}
wD.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "filter"
};

function ble(t, e) {
    e.clear();
    const n = e.matrix;
    for (let r = 0; r < t.length; r++) {
        const i = t[r];
        i.globalDisplayStatus < 7 || (e.matrix = i.worldTransform, e.addBounds(i.bounds))
    }
    return e.matrix = n, e
}
const xle = new hd({
    attributes: {
        aPosition: {
            buffer: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            format: "float32x2",
            stride: 2 * 4,
            offset: 0
        }
    },
    indexBuffer: new Uint32Array([0, 1, 2, 0, 2, 3])
});
class wle {
    constructor() {
        this.skip = !1, this.inputTexture = null, this.backTexture = null, this.filters = null, this.bounds = new rn, this.container = null, this.blendRequired = !1, this.outputRenderSurface = null, this.globalFrame = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        }
    }
}
class ED {
    constructor(e) {
        this._filterStackIndex = 0, this._filterStack = [], this._filterGlobalUniforms = new Pn({
            uInputSize: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uInputPixel: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uInputClamp: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uOutputFrame: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uGlobalFrame: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uOutputTexture: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            }
        }), this._globalFilterBindGroup = new Gi({}), this.renderer = e
    }
    get activeBackTexture() {
        var e;
        return (e = this._activeFilterData) == null ? void 0 : e.backTexture
    }
    push(e) {
        const n = this.renderer,
            r = e.filterEffect.filters,
            i = this._pushFilterData();
        i.skip = !1, i.filters = r, i.container = e.container, i.outputRenderSurface = n.renderTarget.renderSurface;
        const s = n.renderTarget.renderTarget.colorTexture.source,
            o = s.resolution,
            a = s.antialias;
        if (r.length === 0) {
            i.skip = !0;
            return
        }
        const l = i.bounds;
        if (this._calculateFilterArea(e, l), this._calculateFilterBounds(i, n.renderTarget.rootViewPort, a, o, 1), i.skip) return;
        const c = this._getPreviousFilterData(),
            u = this._findFilterResolution(o);
        let d = 0,
            f = 0;
        c && (d = c.bounds.minX, f = c.bounds.minY), this._calculateGlobalFrame(i, d, f, u, s.width, s.height), this._setupFilterTextures(i, l, n, c)
    }
    generateFilteredTexture({
        texture: e,
        filters: n
    }) {
        const r = this._pushFilterData();
        this._activeFilterData = r, r.skip = !1, r.filters = n;
        const i = e.source,
            s = i.resolution,
            o = i.antialias;
        if (n.length === 0) return r.skip = !0, e;
        const a = r.bounds;
        if (a.addRect(e.frame), this._calculateFilterBounds(r, a.rectangle, o, s, 0), r.skip) return e;
        const l = s,
            c = 0,
            u = 0;
        this._calculateGlobalFrame(r, c, u, l, i.width, i.height), r.outputRenderSurface = Ft.getOptimalTexture(a.width, a.height, r.resolution, r.antialias), r.backTexture = we.EMPTY, r.inputTexture = e, this.renderer.renderTarget.finishRenderPass(), this._applyFiltersToTexture(r, !0);
        const f = r.outputRenderSurface;
        return f.source.alphaMode = "premultiplied-alpha", f
    }
    pop() {
        const e = this.renderer,
            n = this._popFilterData();
        n.skip || (e.globalUniforms.pop(), e.renderTarget.finishRenderPass(), this._activeFilterData = n, this._applyFiltersToTexture(n, !1), n.blendRequired && Ft.returnTexture(n.backTexture), Ft.returnTexture(n.inputTexture))
    }
    getBackTexture(e, n, r) {
        const i = e.colorTexture.source._resolution,
            s = Ft.getOptimalTexture(n.width, n.height, i, !1);
        let o = n.minX,
            a = n.minY;
        r && (o -= r.minX, a -= r.minY), o = Math.floor(o * i), a = Math.floor(a * i);
        const l = Math.ceil(n.width * i),
            c = Math.ceil(n.height * i);
        return this.renderer.renderTarget.copyToTexture(e, s, {
            x: o,
            y: a
        }, {
            width: l,
            height: c
        }, {
            x: 0,
            y: 0
        }), s
    }
    applyFilter(e, n, r, i) {
        const s = this.renderer,
            o = this._activeFilterData,
            l = o.outputRenderSurface === r,
            c = s.renderTarget.rootRenderTarget.colorTexture.source._resolution,
            u = this._findFilterResolution(c);
        let d = 0,
            f = 0;
        if (l) {
            const h = this._findPreviousFilterOffset();
            d = h.x, f = h.y
        }
        this._updateFilterUniforms(n, r, o, d, f, u, l, i), this._setupBindGroupsAndRender(e, n, s)
    }
    calculateSpriteMatrix(e, n) {
        const r = this._activeFilterData,
            i = e.set(r.inputTexture._source.width, 0, 0, r.inputTexture._source.height, r.bounds.minX, r.bounds.minY),
            s = n.worldTransform.copyTo(Te.shared),
            o = n.renderGroup || n.parentRenderGroup;
        return o && o.cacheToLocalTransform && s.prepend(o.cacheToLocalTransform), s.invert(), i.prepend(s), i.scale(1 / n.texture.frame.width, 1 / n.texture.frame.height), i.translate(n.anchor.x, n.anchor.y), i
    }
    destroy() {}
    _setupBindGroupsAndRender(e, n, r) {
        if (r.renderPipes.uniformBatch) {
            const i = r.renderPipes.uniformBatch.getUboResource(this._filterGlobalUniforms);
            this._globalFilterBindGroup.setResource(i, 0)
        } else this._globalFilterBindGroup.setResource(this._filterGlobalUniforms, 0);
        this._globalFilterBindGroup.setResource(n.source, 1), this._globalFilterBindGroup.setResource(n.source.style, 2), e.groups[0] = this._globalFilterBindGroup, r.encoder.draw({
            geometry: xle,
            shader: e,
            state: e._state,
            topology: "triangle-list"
        }), r.type === tr.WEBGL && r.renderTarget.finishRenderPass()
    }
    _setupFilterTextures(e, n, r, i) {
        if (e.backTexture = we.EMPTY, e.blendRequired) {
            r.renderTarget.finishRenderPass();
            const s = r.renderTarget.getRenderTarget(e.outputRenderSurface);
            e.backTexture = this.getBackTexture(s, n, i == null ? void 0 : i.bounds)
        }
        e.inputTexture = Ft.getOptimalTexture(n.width, n.height, e.resolution, e.antialias), r.renderTarget.bind(e.inputTexture, !0), r.globalUniforms.push({
            offset: n
        })
    }
    _calculateGlobalFrame(e, n, r, i, s, o) {
        const a = e.globalFrame;
        a.x = n * i, a.y = r * i, a.width = s * i, a.height = o * i
    }
    _updateFilterUniforms(e, n, r, i, s, o, a, l) {
        const c = this._filterGlobalUniforms.uniforms,
            u = c.uOutputFrame,
            d = c.uInputSize,
            f = c.uInputPixel,
            h = c.uInputClamp,
            p = c.uGlobalFrame,
            b = c.uOutputTexture;
        a ? (u[0] = r.bounds.minX - i, u[1] = r.bounds.minY - s) : (u[0] = 0, u[1] = 0), u[2] = e.frame.width, u[3] = e.frame.height, d[0] = e.source.width, d[1] = e.source.height, d[2] = 1 / d[0], d[3] = 1 / d[1], f[0] = e.source.pixelWidth, f[1] = e.source.pixelHeight, f[2] = 1 / f[0], f[3] = 1 / f[1], h[0] = .5 * f[2], h[1] = .5 * f[3], h[2] = e.frame.width * d[2] - .5 * f[2], h[3] = e.frame.height * d[3] - .5 * f[3];
        const y = this.renderer.renderTarget.rootRenderTarget.colorTexture;
        p[0] = i * o, p[1] = s * o, p[2] = y.source.width * o, p[3] = y.source.height * o, n instanceof we && (n.source.resource = null);
        const m = this.renderer.renderTarget.getRenderTarget(n);
        this.renderer.renderTarget.bind(n, !!l), n instanceof we ? (b[0] = n.frame.width, b[1] = n.frame.height) : (b[0] = m.width, b[1] = m.height), b[2] = m.isRoot ? -1 : 1, this._filterGlobalUniforms.update()
    }
    _findFilterResolution(e) {
        let n = this._filterStackIndex - 1;
        for (; n > 0 && this._filterStack[n].skip;) --n;
        return n > 0 && this._filterStack[n].inputTexture ? this._filterStack[n].inputTexture.source._resolution : e
    }
    _findPreviousFilterOffset() {
        let e = 0,
            n = 0,
            r = this._filterStackIndex;
        for (; r > 0;) {
            r--;
            const i = this._filterStack[r];
            if (!i.skip) {
                e = i.bounds.minX, n = i.bounds.minY;
                break
            }
        }
        return {
            x: e,
            y: n
        }
    }
    _calculateFilterArea(e, n) {
        if (e.renderables ? ble(e.renderables, n) : e.filterEffect.filterArea ? (n.clear(), n.addRect(e.filterEffect.filterArea), n.applyMatrix(e.container.worldTransform)) : e.container.getFastGlobalBounds(!0, n), e.container) {
            const i = (e.container.renderGroup || e.container.parentRenderGroup).cacheToLocalTransform;
            i && n.applyMatrix(i)
        }
    }
    _applyFiltersToTexture(e, n) {
        const r = e.inputTexture,
            i = e.bounds,
            s = e.filters;
        if (this._globalFilterBindGroup.setResource(r.source.style, 2), this._globalFilterBindGroup.setResource(e.backTexture.source, 3), s.length === 1) s[0].apply(this, r, e.outputRenderSurface, n);
        else {
            let o = e.inputTexture;
            const a = Ft.getOptimalTexture(i.width, i.height, o.source._resolution, !1);
            let l = a,
                c = 0;
            for (c = 0; c < s.length - 1; ++c) {
                s[c].apply(this, o, l, !0);
                const d = o;
                o = l, l = d
            }
            s[c].apply(this, o, e.outputRenderSurface, n), Ft.returnTexture(a)
        }
    }
    _calculateFilterBounds(e, n, r, i, s) {
        var b;
        const o = this.renderer,
            a = e.bounds,
            l = e.filters;
        let c = 1 / 0,
            u = 0,
            d = !0,
            f = !1,
            h = !1,
            p = !0;
        for (let y = 0; y < l.length; y++) {
            const m = l[y];
            if (c = Math.min(c, m.resolution === "inherit" ? i : m.resolution), u += m.padding, m.antialias === "off" ? d = !1 : m.antialias === "inherit" && d && (d = r), m.clipToViewport || (p = !1), !!!(m.compatibleRenderers & o.type)) {
                h = !1;
                break
            }
            if (m.blendRequired && !(((b = o.backBuffer) == null ? void 0 : b.useBackBuffer) ? ? !0)) {
                Oe("Blend filter requires backBuffer on WebGL renderer to be enabled. Set `useBackBuffer: true` in the renderer options."), h = !1;
                break
            }
            h = m.enabled || h, f || (f = m.blendRequired)
        }
        if (!h) {
            e.skip = !0;
            return
        }
        if (p && a.fitBounds(0, n.width / i, 0, n.height / i), a.scale(c).ceil().scale(1 / c).pad((u | 0) * s), !a.isPositive) {
            e.skip = !0;
            return
        }
        e.antialias = d, e.resolution = c, e.blendRequired = f
    }
    _popFilterData() {
        return this._filterStackIndex--, this._filterStack[this._filterStackIndex]
    }
    _getPreviousFilterData() {
        let e, n = this._filterStackIndex - 1;
        for (; n > 1 && (n--, e = this._filterStack[n], !!e.skip););
        return e
    }
    _pushFilterData() {
        let e = this._filterStack[this._filterStackIndex];
        return e || (e = this._filterStack[this._filterStackIndex] = new wle), this._filterStackIndex++, e
    }
}
ED.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "filter"
};
var Ele = `in vec2 vMaskCoord;
in vec2 vTextureCoord;

uniform sampler2D uTexture;
uniform sampler2D uMaskTexture;

uniform float uAlpha;
uniform vec4 uMaskClamp;
uniform float uInverse;

out vec4 finalColor;

void main(void)
{
    float clip = step(3.5,
        step(uMaskClamp.x, vMaskCoord.x) +
        step(uMaskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, uMaskClamp.z) +
        step(vMaskCoord.y, uMaskClamp.w));

    // TODO look into why this is needed
    float npmAlpha = uAlpha;
    vec4 original = texture(uTexture, vTextureCoord);
    vec4 masky = texture(uMaskTexture, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    float a = alphaMul * masky.r * npmAlpha * clip;

    if (uInverse == 1.0) {
        a = 1.0 - a;
    }

    finalColor = original * a;
}
`,
    Sle = `in vec2 aPosition;

out vec2 vTextureCoord;
out vec2 vMaskCoord;


uniform vec4 uInputSize;
uniform vec4 uOutputFrame;
uniform vec4 uOutputTexture;
uniform mat3 uFilterMatrix;

vec4 filterVertexPosition(  vec2 aPosition )
{
    vec2 position = aPosition * uOutputFrame.zw + uOutputFrame.xy;
       
    position.x = position.x * (2.0 / uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*uOutputTexture.z / uOutputTexture.y) - uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

vec2 filterTextureCoord(  vec2 aPosition )
{
    return aPosition * (uOutputFrame.zw * uInputSize.zw);
}

vec2 getFilterCoord( vec2 aPosition )
{
    return  ( uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}   

void main(void)
{
    gl_Position = filterVertexPosition(aPosition);
    vTextureCoord = filterTextureCoord(aPosition);
    vMaskCoord = getFilterCoord(aPosition);
}
`,
    xC = `struct GlobalFilterUniforms {
  uInputSize:vec4<f32>,
  uInputPixel:vec4<f32>,
  uInputClamp:vec4<f32>,
  uOutputFrame:vec4<f32>,
  uGlobalFrame:vec4<f32>,
  uOutputTexture:vec4<f32>,
};

struct MaskUniforms {
  uFilterMatrix:mat3x3<f32>,
  uMaskClamp:vec4<f32>,
  uAlpha:f32,
  uInverse:f32,
};

@group(0) @binding(0) var<uniform> gfu: GlobalFilterUniforms;
@group(0) @binding(1) var uTexture: texture_2d<f32>;
@group(0) @binding(2) var uSampler : sampler;

@group(1) @binding(0) var<uniform> filterUniforms : MaskUniforms;
@group(1) @binding(1) var uMaskTexture: texture_2d<f32>;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) filterUv : vec2<f32>,
};

fn filterVertexPosition(aPosition:vec2<f32>) -> vec4<f32>
{
    var position = aPosition * gfu.uOutputFrame.zw + gfu.uOutputFrame.xy;

    position.x = position.x * (2.0 / gfu.uOutputTexture.x) - 1.0;
    position.y = position.y * (2.0*gfu.uOutputTexture.z / gfu.uOutputTexture.y) - gfu.uOutputTexture.z;

    return vec4(position, 0.0, 1.0);
}

fn filterTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
    return aPosition * (gfu.uOutputFrame.zw * gfu.uInputSize.zw);
}

fn globalTextureCoord( aPosition:vec2<f32> ) -> vec2<f32>
{
  return  (aPosition.xy / gfu.uGlobalFrame.zw) + (gfu.uGlobalFrame.xy / gfu.uGlobalFrame.zw);
}

fn getFilterCoord(aPosition:vec2<f32> ) -> vec2<f32>
{
  return ( filterUniforms.uFilterMatrix * vec3( filterTextureCoord(aPosition), 1.0)  ).xy;
}

fn getSize() -> vec2<f32>
{
  return gfu.uGlobalFrame.zw;
}

@vertex
fn mainVertex(
  @location(0) aPosition : vec2<f32>,
) -> VSOutput {
  return VSOutput(
   filterVertexPosition(aPosition),
   filterTextureCoord(aPosition),
   getFilterCoord(aPosition)
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) filterUv: vec2<f32>,
  @builtin(position) position: vec4<f32>
) -> @location(0) vec4<f32> {

    var maskClamp = filterUniforms.uMaskClamp;
    var uAlpha = filterUniforms.uAlpha;

    var clip = step(3.5,
      step(maskClamp.x, filterUv.x) +
      step(maskClamp.y, filterUv.y) +
      step(filterUv.x, maskClamp.z) +
      step(filterUv.y, maskClamp.w));

    var mask = textureSample(uMaskTexture, uSampler, filterUv);
    var source = textureSample(uTexture, uSampler, uv);
    var alphaMul = 1.0 - uAlpha * (1.0 - mask.a);

    var a: f32 = alphaMul * mask.r * uAlpha * clip;

    if (filterUniforms.uInverse == 1.0) {
        a = 1.0 - a;
    }

    return source * a;
}
`;
class Tle extends wx {
    constructor(e) {
        const {
            sprite: n,
            ...r
        } = e, i = new Zk(n.texture), s = new Pn({
            uFilterMatrix: {
                value: new Te,
                type: "mat3x3<f32>"
            },
            uMaskClamp: {
                value: i.uClampFrame,
                type: "vec4<f32>"
            },
            uAlpha: {
                value: 1,
                type: "f32"
            },
            uInverse: {
                value: e.inverse ? 1 : 0,
                type: "f32"
            }
        }), o = io.from({
            vertex: {
                source: xC,
                entryPoint: "mainVertex"
            },
            fragment: {
                source: xC,
                entryPoint: "mainFragment"
            }
        }), a = wa.from({
            vertex: Sle,
            fragment: Ele,
            name: "mask-filter"
        });
        super({ ...r,
            gpuProgram: o,
            glProgram: a,
            resources: {
                filterUniforms: s,
                uMaskTexture: n.texture.source
            }
        }), this.sprite = n, this._textureMatrix = i
    }
    set inverse(e) {
        this.resources.filterUniforms.uniforms.uInverse = e ? 1 : 0
    }
    get inverse() {
        return this.resources.filterUniforms.uniforms.uInverse === 1
    }
    apply(e, n, r, i) {
        this._textureMatrix.texture = this.sprite.texture, e.calculateSpriteMatrix(this.resources.filterUniforms.uniforms.uFilterMatrix, this.sprite).prepend(this._textureMatrix.mapCoord), this.resources.uMaskTexture = this.sprite.texture.source, e.applyFilter(this, n, r, i)
    }
}
class $h extends dd {
    constructor(e) {
        e instanceof hr && (e = {
            context: e
        });
        const {
            context: n,
            roundPixels: r,
            ...i
        } = e || {};
        super({
            label: "Graphics",
            ...i
        }), this.renderPipeId = "graphics", n ? this._context = n : this._context = this._ownedContext = new hr, this._context.on("update", this.onViewUpdate, this), this.didViewUpdate = !0, this.allowChildren = !1, this.roundPixels = r ? ? !1
    }
    set context(e) {
        e !== this._context && (this._context.off("update", this.onViewUpdate, this), this._context = e, this._context.on("update", this.onViewUpdate, this), this.onViewUpdate())
    }
    get context() {
        return this._context
    }
    get bounds() {
        return this._context.bounds
    }
    updateBounds() {}
    containsPoint(e) {
        return this._context.containsPoint(e)
    }
    destroy(e) {
        this._ownedContext && !e ? this._ownedContext.destroy(e) : (e === !0 || (e == null ? void 0 : e.context) === !0) && this._context.destroy(e), this._ownedContext = null, this._context = null, super.destroy(e)
    }
    _callContextMethod(e, n) {
        return this.context[e](...n), this
    }
    setFillStyle(...e) {
        return this._callContextMethod("setFillStyle", e)
    }
    setStrokeStyle(...e) {
        return this._callContextMethod("setStrokeStyle", e)
    }
    fill(...e) {
        return this._callContextMethod("fill", e)
    }
    stroke(...e) {
        return this._callContextMethod("stroke", e)
    }
    texture(...e) {
        return this._callContextMethod("texture", e)
    }
    beginPath() {
        return this._callContextMethod("beginPath", [])
    }
    cut() {
        return this._callContextMethod("cut", [])
    }
    arc(...e) {
        return this._callContextMethod("arc", e)
    }
    arcTo(...e) {
        return this._callContextMethod("arcTo", e)
    }
    arcToSvg(...e) {
        return this._callContextMethod("arcToSvg", e)
    }
    bezierCurveTo(...e) {
        return this._callContextMethod("bezierCurveTo", e)
    }
    closePath() {
        return this._callContextMethod("closePath", [])
    }
    ellipse(...e) {
        return this._callContextMethod("ellipse", e)
    }
    circle(...e) {
        return this._callContextMethod("circle", e)
    }
    path(...e) {
        return this._callContextMethod("path", e)
    }
    lineTo(...e) {
        return this._callContextMethod("lineTo", e)
    }
    moveTo(...e) {
        return this._callContextMethod("moveTo", e)
    }
    quadraticCurveTo(...e) {
        return this._callContextMethod("quadraticCurveTo", e)
    }
    rect(...e) {
        return this._callContextMethod("rect", e)
    }
    roundRect(...e) {
        return this._callContextMethod("roundRect", e)
    }
    poly(...e) {
        return this._callContextMethod("poly", e)
    }
    regularPoly(...e) {
        return this._callContextMethod("regularPoly", e)
    }
    roundPoly(...e) {
        return this._callContextMethod("roundPoly", e)
    }
    roundShape(...e) {
        return this._callContextMethod("roundShape", e)
    }
    filletRect(...e) {
        return this._callContextMethod("filletRect", e)
    }
    chamferRect(...e) {
        return this._callContextMethod("chamferRect", e)
    }
    star(...e) {
        return this._callContextMethod("star", e)
    }
    svg(...e) {
        return this._callContextMethod("svg", e)
    }
    restore(...e) {
        return this._callContextMethod("restore", e)
    }
    save() {
        return this._callContextMethod("save", [])
    }
    getTransform() {
        return this.context.getTransform()
    }
    resetTransform() {
        return this._callContextMethod("resetTransform", [])
    }
    rotateTransform(...e) {
        return this._callContextMethod("rotate", e)
    }
    scaleTransform(...e) {
        return this._callContextMethod("scale", e)
    }
    setTransform(...e) {
        return this._callContextMethod("setTransform", e)
    }
    transform(...e) {
        return this._callContextMethod("transform", e)
    }
    translateTransform(...e) {
        return this._callContextMethod("translate", e)
    }
    clear() {
        return this._callContextMethod("clear", [])
    }
    get fillStyle() {
        return this._context.fillStyle
    }
    set fillStyle(e) {
        this._context.fillStyle = e
    }
    get strokeStyle() {
        return this._context.strokeStyle
    }
    set strokeStyle(e) {
        this._context.strokeStyle = e
    }
    clone(e = !1) {
        return e ? new $h(this._context.clone()) : (this._ownedContext = null, new $h(this._context))
    }
    lineStyle(e, n, r) {
        Ie(Ye, "Graphics#lineStyle is no longer needed. Use Graphics#setStrokeStyle to set the stroke style.");
        const i = {};
        return e && (i.width = e), n && (i.color = n), r && (i.alpha = r), this.context.strokeStyle = i, this
    }
    beginFill(e, n) {
        Ie(Ye, "Graphics#beginFill is no longer needed. Use Graphics#fill to fill the shape with the desired style.");
        const r = {};
        return e !== void 0 && (r.color = e), n !== void 0 && (r.alpha = n), this.context.fillStyle = r, this
    }
    endFill() {
        Ie(Ye, "Graphics#endFill is no longer needed. Use Graphics#fill to fill the shape with the desired style."), this.context.fill();
        const e = this.context.strokeStyle;
        return (e.width !== hr.defaultStrokeStyle.width || e.color !== hr.defaultStrokeStyle.color || e.alpha !== hr.defaultStrokeStyle.alpha) && this.context.stroke(), this
    }
    drawCircle(...e) {
        return Ie(Ye, "Graphics#drawCircle has been renamed to Graphics#circle"), this._callContextMethod("circle", e)
    }
    drawEllipse(...e) {
        return Ie(Ye, "Graphics#drawEllipse has been renamed to Graphics#ellipse"), this._callContextMethod("ellipse", e)
    }
    drawPolygon(...e) {
        return Ie(Ye, "Graphics#drawPolygon has been renamed to Graphics#poly"), this._callContextMethod("poly", e)
    }
    drawRect(...e) {
        return Ie(Ye, "Graphics#drawRect has been renamed to Graphics#rect"), this._callContextMethod("rect", e)
    }
    drawRoundedRect(...e) {
        return Ie(Ye, "Graphics#drawRoundedRect has been renamed to Graphics#roundRect"), this._callContextMethod("roundRect", e)
    }
    drawStar(...e) {
        return Ie(Ye, "Graphics#drawStar has been renamed to Graphics#star"), this._callContextMethod("star", e)
    }
}
const SD = class TD extends hd {
    constructor(...e) {
        let n = e[0] ? ? {};
        n instanceof Float32Array && (Ie(Ye, "use new MeshGeometry({ positions, uvs, indices }) instead"), n = {
            positions: n,
            uvs: e[1],
            indices: e[2]
        }), n = { ...TD.defaultOptions,
            ...n
        };
        const r = n.positions || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);
        let i = n.uvs;
        i || (n.positions ? i = new Float32Array(r.length) : i = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]));
        const s = n.indices || new Uint32Array([0, 1, 2, 0, 2, 3]),
            o = n.shrinkBuffersToFit,
            a = new Jn({
                data: r,
                label: "attribute-mesh-positions",
                shrinkToFit: o,
                usage: Xe.VERTEX | Xe.COPY_DST
            }),
            l = new Jn({
                data: i,
                label: "attribute-mesh-uvs",
                shrinkToFit: o,
                usage: Xe.VERTEX | Xe.COPY_DST
            }),
            c = new Jn({
                data: s,
                label: "index-mesh-buffer",
                shrinkToFit: o,
                usage: Xe.INDEX | Xe.COPY_DST
            });
        super({
            attributes: {
                aPosition: {
                    buffer: a,
                    format: "float32x2",
                    stride: 2 * 4,
                    offset: 0
                },
                aUV: {
                    buffer: l,
                    format: "float32x2",
                    stride: 2 * 4,
                    offset: 0
                }
            },
            indexBuffer: c,
            topology: n.topology
        }), this.batchMode = "auto"
    }
    get positions() {
        return this.attributes.aPosition.buffer.data
    }
    set positions(e) {
        this.attributes.aPosition.buffer.data = e
    }
    get uvs() {
        return this.attributes.aUV.buffer.data
    }
    set uvs(e) {
        this.attributes.aUV.buffer.data = e
    }
    get indices() {
        return this.indexBuffer.data
    }
    set indices(e) {
        this.indexBuffer.data = e
    }
};
SD.defaultOptions = {
    topology: "triangle-list",
    shrinkBuffersToFit: !1
};
let zx = SD;
class Cle {
    constructor({
        matrix: e,
        observer: n
    } = {}) {
        this.dirty = !0, this._matrix = e ? ? new Te, this.observer = n, this.position = new At(this, 0, 0), this.scale = new At(this, 1, 1), this.pivot = new At(this, 0, 0), this.skew = new At(this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1
    }
    get matrix() {
        const e = this._matrix;
        return this.dirty && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this.dirty = !1), e
    }
    _onUpdate(e) {
        var n;
        this.dirty = !0, e === this.skew && this.updateSkew(), (n = this.observer) == null || n._onUpdate(this)
    }
    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this.dirty = !0
    }
    toString() {
        return `[pixi.js/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
    }
    setFromMatrix(e) {
        e.decompose(this), this.dirty = !0
    }
    get rotation() {
        return this._rotation
    }
    set rotation(e) {
        this._rotation !== e && (this._rotation = e, this._onUpdate(this.skew))
    }
}
const CD = class Xf extends dd {
    constructor(...e) {
        let n = e[0] || {};
        n instanceof we && (n = {
            texture: n
        }), e.length > 1 && (Ie(Ye, "use new TilingSprite({ texture, width:100, height:100 }) instead"), n.width = e[1], n.height = e[2]), n = { ...Xf.defaultOptions,
            ...n
        };
        const {
            texture: r,
            anchor: i,
            tilePosition: s,
            tileScale: o,
            tileRotation: a,
            width: l,
            height: c,
            applyAnchorToTexture: u,
            roundPixels: d,
            ...f
        } = n ? ? {};
        super({
            label: "TilingSprite",
            ...f
        }), this.renderPipeId = "tilingSprite", this.batched = !0, this.allowChildren = !1, this._anchor = new At({
            _onUpdate: () => {
                this.onViewUpdate()
            }
        }), this.applyAnchorToTexture = u, this.texture = r, this._width = l ? ? r.width, this._height = c ? ? r.height, this._tileTransform = new Cle({
            observer: {
                _onUpdate: () => this.onViewUpdate()
            }
        }), i && (this.anchor = i), this.tilePosition = s, this.tileScale = o, this.tileRotation = a, this.roundPixels = d ? ? !1
    }
    static from(e, n = {}) {
        return typeof e == "string" ? new Xf({
            texture: ut.get(e),
            ...n
        }) : new Xf({
            texture: e,
            ...n
        })
    }
    get uvRespectAnchor() {
        return Oe("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"), this.applyAnchorToTexture
    }
    set uvRespectAnchor(e) {
        Oe("uvRespectAnchor is deprecated, please use applyAnchorToTexture instead"), this.applyAnchorToTexture = e
    }
    get clampMargin() {
        return this._texture.textureMatrix.clampMargin
    }
    set clampMargin(e) {
        this._texture.textureMatrix.clampMargin = e
    }
    get anchor() {
        return this._anchor
    }
    set anchor(e) {
        typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
    }
    get tilePosition() {
        return this._tileTransform.position
    }
    set tilePosition(e) {
        this._tileTransform.position.copyFrom(e)
    }
    get tileScale() {
        return this._tileTransform.scale
    }
    set tileScale(e) {
        typeof e == "number" ? this._tileTransform.scale.set(e) : this._tileTransform.scale.copyFrom(e)
    }
    set tileRotation(e) {
        this._tileTransform.rotation = e
    }
    get tileRotation() {
        return this._tileTransform.rotation
    }
    get tileTransform() {
        return this._tileTransform
    }
    set texture(e) {
        e || (e = we.EMPTY);
        const n = this._texture;
        n !== e && (n && n.dynamic && n.off("update", this.onViewUpdate, this), e.dynamic && e.on("update", this.onViewUpdate, this), this._texture = e, this.onViewUpdate())
    }
    get texture() {
        return this._texture
    }
    set width(e) {
        this._width = e, this.onViewUpdate()
    }
    get width() {
        return this._width
    }
    set height(e) {
        this._height = e, this.onViewUpdate()
    }
    get height() {
        return this._height
    }
    setSize(e, n) {
        typeof e == "object" && (n = e.height ? ? e.width, e = e.width), this._width = e, this._height = n ? ? e, this.onViewUpdate()
    }
    getSize(e) {
        return e || (e = {}), e.width = this._width, e.height = this._height, e
    }
    updateBounds() {
        const e = this._bounds,
            n = this._anchor,
            r = this._width,
            i = this._height;
        e.minX = -n._x * r, e.maxX = e.minX + r, e.minY = -n._y * i, e.maxY = e.minY + i
    }
    containsPoint(e) {
        const n = this._width,
            r = this._height,
            i = -n * this._anchor._x;
        let s = 0;
        return e.x >= i && e.x <= i + n && (s = -r * this._anchor._y, e.y >= s && e.y <= s + r)
    }
    destroy(e = !1) {
        if (super.destroy(e), this._anchor = null, this._tileTransform = null, this._bounds = null, typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
            const r = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource;
            this._texture.destroy(r)
        }
        this._texture = null
    }
};
CD.defaultOptions = {
    texture: we.EMPTY,
    anchor: {
        x: 0,
        y: 0
    },
    tilePosition: {
        x: 0,
        y: 0
    },
    tileScale: {
        x: 1,
        y: 1
    },
    tileRotation: 0,
    applyAnchorToTexture: !1
};
let _we = CD;
class Ple extends dd {
    constructor(e, n) {
        const {
            text: r,
            resolution: i,
            style: s,
            anchor: o,
            width: a,
            height: l,
            roundPixels: c,
            ...u
        } = e;
        super({ ...u
        }), this.batched = !0, this._resolution = null, this._autoResolution = !0, this._didTextUpdate = !0, this._styleClass = n, this.text = r ? ? "", this.style = s, this.resolution = i ? ? null, this.allowChildren = !1, this._anchor = new At({
            _onUpdate: () => {
                this.onViewUpdate()
            }
        }), o && (this.anchor = o), this.roundPixels = c ? ? !1, a !== void 0 && (this.width = a), l !== void 0 && (this.height = l)
    }
    get anchor() {
        return this._anchor
    }
    set anchor(e) {
        typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
    }
    set text(e) {
        e = e.toString(), this._text !== e && (this._text = e, this.onViewUpdate())
    }
    get text() {
        return this._text
    }
    set resolution(e) {
        this._autoResolution = e === null, this._resolution = e, this.onViewUpdate()
    }
    get resolution() {
        return this._resolution
    }
    get style() {
        return this._style
    }
    set style(e) {
        var n;
        e || (e = {}), (n = this._style) == null || n.off("update", this.onViewUpdate, this), e instanceof this._styleClass ? this._style = e : this._style = new this._styleClass(e), this._style.on("update", this.onViewUpdate, this), this.onViewUpdate()
    }
    get width() {
        return Math.abs(this.scale.x) * this.bounds.width
    }
    set width(e) {
        this._setWidth(e, this.bounds.width)
    }
    get height() {
        return Math.abs(this.scale.y) * this.bounds.height
    }
    set height(e) {
        this._setHeight(e, this.bounds.height)
    }
    getSize(e) {
        return e || (e = {}), e.width = Math.abs(this.scale.x) * this.bounds.width, e.height = Math.abs(this.scale.y) * this.bounds.height, e
    }
    setSize(e, n) {
        typeof e == "object" ? (n = e.height ? ? e.width, e = e.width) : n ? ? (n = e), e !== void 0 && this._setWidth(e, this.bounds.width), n !== void 0 && this._setHeight(n, this.bounds.height)
    }
    containsPoint(e) {
        const n = this.bounds.width,
            r = this.bounds.height,
            i = -n * this.anchor.x;
        let s = 0;
        return e.x >= i && e.x <= i + n && (s = -r * this.anchor.y, e.y >= s && e.y <= s + r)
    }
    onViewUpdate() {
        this.didViewUpdate || (this._didTextUpdate = !0), super.onViewUpdate()
    }
    destroy(e = !1) {
        super.destroy(e), this.owner = null, this._bounds = null, this._anchor = null, (typeof e == "boolean" ? e : e != null && e.style) && this._style.destroy(e), this._style = null, this._text = null
    }
}

function Ale(t, e) {
    let n = t[0] ? ? {};
    return (typeof n == "string" || t[1]) && (Ie(Ye, `use new ${e}({ text: "hi!", style }) instead`), n = {
        text: n,
        style: t[1]
    }), n
}
let mo = null,
    Ri = null;

function Ole(t, e) {
    mo || (mo = Ge.get().createCanvas(256, 128), Ri = mo.getContext("2d", {
        willReadFrequently: !0
    }), Ri.globalCompositeOperation = "copy", Ri.globalAlpha = 1), (mo.width < t || mo.height < e) && (mo.width = El(t), mo.height = El(e))
}

function wC(t, e, n) {
    for (let r = 0, i = 4 * n * e; r < e; ++r, i += 4)
        if (t[i + 3] !== 0) return !1;
    return !0
}

function EC(t, e, n, r, i) {
    const s = 4 * e;
    for (let o = r, a = r * s + 4 * n; o <= i; ++o, a += s)
        if (t[a + 3] !== 0) return !1;
    return !0
}

function Ile(...t) {
    let e = t[0];
    e.canvas || (e = {
        canvas: t[0],
        resolution: t[1]
    });
    const {
        canvas: n
    } = e, r = Math.min(e.resolution ? ? 1, 1), i = e.width ? ? n.width, s = e.height ? ? n.height;
    let o = e.output;
    if (Ole(i, s), !Ri) throw new TypeError("Failed to get canvas 2D context");
    Ri.drawImage(n, 0, 0, i, s, 0, 0, i * r, s * r);
    const l = Ri.getImageData(0, 0, i, s).data;
    let c = 0,
        u = 0,
        d = i - 1,
        f = s - 1;
    for (; u < s && wC(l, i, u);) ++u;
    if (u === s) return it.EMPTY;
    for (; wC(l, i, f);) --f;
    for (; EC(l, i, c, u, f);) ++c;
    for (; EC(l, i, d, u, f);) --d;
    return ++d, ++f, Ri.globalCompositeOperation = "source-over", Ri.strokeRect(c, u, d - c, f - u), Ri.globalCompositeOperation = "copy", o ? ? (o = new it), o.set(c / r, u / r, (d - c) / r, (f - u) / r), o
}
const SC = new it;
class Mle {
    getCanvasAndContext(e) {
        const {
            text: n,
            style: r,
            resolution: i = 1
        } = e, s = r._getFinalPadding(), o = Ir.measureText(n || " ", r), a = Math.ceil(Math.ceil(Math.max(1, o.width) + s * 2) * i), l = Math.ceil(Math.ceil(Math.max(1, o.height) + s * 2) * i), c = qs.getOptimalCanvasAndContext(a, l);
        this._renderTextToCanvas(n, r, s, i, c);
        const u = r.trim ? Ile({
            canvas: c.canvas,
            width: a,
            height: l,
            resolution: 1,
            output: SC
        }) : SC.set(0, 0, a, l);
        return {
            canvasAndContext: c,
            frame: u
        }
    }
    returnCanvasAndContext(e) {
        qs.returnCanvasAndContext(e)
    }
    _renderTextToCanvas(e, n, r, i, s) {
        var v, _, x, w;
        const {
            canvas: o,
            context: a
        } = s, l = Rh(n), c = Ir.measureText(e || " ", n), u = c.lines, d = c.lineHeight, f = c.lineWidths, h = c.maxLineWidth, p = c.fontProperties, b = o.height;
        if (a.resetTransform(), a.scale(i, i), a.textBaseline = n.textBaseline, (v = n._stroke) != null && v.width) {
            const E = n._stroke;
            a.lineWidth = E.width, a.miterLimit = E.miterLimit, a.lineJoin = E.join, a.lineCap = E.cap
        }
        a.font = l;
        let y, m;
        const g = n.dropShadow ? 2 : 1;
        for (let E = 0; E < g; ++E) {
            const C = n.dropShadow && E === 0,
                A = C ? Math.ceil(Math.max(1, b) + r * 2) : 0,
                T = A * i;
            if (C) {
                a.fillStyle = "black", a.strokeStyle = "black";
                const R = n.dropShadow,
                    D = R.color,
                    H = R.alpha;
                a.shadowColor = tt.shared.setValue(D).setAlpha(H).toRgbaString();
                const B = R.blur * i,
                    N = R.distance * i;
                a.shadowBlur = B, a.shadowOffsetX = Math.cos(R.angle) * N, a.shadowOffsetY = Math.sin(R.angle) * N + T
            } else {
                if (a.fillStyle = n._fill ? Bh(n._fill, a, c) : null, (_ = n._stroke) != null && _.width) {
                    const R = n._stroke.width * n._stroke.alignment;
                    a.strokeStyle = Bh(n._stroke, a, c, R)
                }
                a.shadowColor = "black"
            }
            let S = (d - p.fontSize) / 2;
            d - p.fontSize < 0 && (S = 0);
            const P = ((x = n._stroke) == null ? void 0 : x.width) ? ? 0;
            for (let R = 0; R < u.length; R++) y = P / 2, m = P / 2 + R * d + p.ascent + S, n.align === "right" ? y += h - f[R] : n.align === "center" && (y += (h - f[R]) / 2), (w = n._stroke) != null && w.width && this._drawLetterSpacing(u[R], n, s, y + r, m + r - A, !0), n._fill !== void 0 && this._drawLetterSpacing(u[R], n, s, y + r, m + r - A)
        }
    }
    _drawLetterSpacing(e, n, r, i, s, o = !1) {
        const {
            context: a
        } = r, l = n.letterSpacing;
        let c = !1;
        if (Ir.experimentalLetterSpacingSupported && (Ir.experimentalLetterSpacing ? (a.letterSpacing = `${l}px`, a.textLetterSpacing = `${l}px`, c = !0) : (a.letterSpacing = "0px", a.textLetterSpacing = "0px")), l === 0 || c) {
            o ? a.strokeText(e, i, s) : a.fillText(e, i, s);
            return
        }
        let u = i;
        const d = Ir.graphemeSegmenter(e);
        let f = a.measureText(e).width,
            h = 0;
        for (let p = 0; p < d.length; ++p) {
            const b = d[p];
            o ? a.strokeText(b, u, s) : a.fillText(b, u, s);
            let y = "";
            for (let m = p + 1; m < d.length; ++m) y += d[m];
            h = a.measureText(y).width, u += f - h + l, f = h
        }
    }
}
const Jc = new Mle;
class bwe extends Ple {
    constructor(...e) {
        const n = Ale(e, "Text");
        super(n, es), this.renderPipeId = "text", n.textureStyle && (this.textureStyle = n.textureStyle instanceof Zi ? n.textureStyle : new Zi(n.textureStyle))
    }
    updateBounds() {
        const e = this._bounds,
            n = this._anchor;
        let r = 0,
            i = 0;
        if (this._style.trim) {
            const {
                frame: s,
                canvasAndContext: o
            } = Jc.getCanvasAndContext({
                text: this.text,
                style: this._style,
                resolution: 1
            });
            Jc.returnCanvasAndContext(o), r = s.width, i = s.height
        } else {
            const s = Ir.measureText(this._text, this._style);
            r = s.width, i = s.height
        }
        e.minX = -n._x * r, e.maxX = e.minX + r, e.minY = -n._y * i, e.maxY = e.minY + i
    }
}

function Rle(t) {
    const e = t._stroke,
        n = t._fill,
        i = [`div { ${[`color: ${tt.shared.setValue(n.color).toHex()}`,`font-size: ${t.fontSize}px`,`font-family: ${t.fontFamily}`,`font-weight: ${t.fontWeight}`,`font-style: ${t.fontStyle}`,`font-variant: ${t.fontVariant}`,`letter-spacing: ${t.letterSpacing}px`,`text-align: ${t.align}`,`padding: ${t.padding}px`,`white-space: ${t.whiteSpace==="pre"&&t.wordWrap?"pre-wrap":t.whiteSpace}`,...t.lineHeight?[`line-height: ${t.lineHeight}px`]:[],...t.wordWrap?[`word-wrap: ${t.breakWords?"break-all":"break-word"}`,`max-width: ${t.wordWrapWidth}px`]:[],...e?[AD(e)]:[],...t.dropShadow?[PD(t.dropShadow)]:[],...t.cssOverrides].join(";")} }`];
    return kle(t.tagStyles, i), i.join(" ")
}

function PD(t) {
    const e = tt.shared.setValue(t.color).setAlpha(t.alpha).toHexa(),
        n = Math.round(Math.cos(t.angle) * t.distance),
        r = Math.round(Math.sin(t.angle) * t.distance),
        i = `${n}px ${r}px`;
    return t.blur > 0 ? `text-shadow: ${i} ${t.blur}px ${e}` : `text-shadow: ${i} ${e}`
}

function AD(t) {
    return [`-webkit-text-stroke-width: ${t.width}px`, `-webkit-text-stroke-color: ${tt.shared.setValue(t.color).toHex()}`, `text-stroke-width: ${t.width}px`, `text-stroke-color: ${tt.shared.setValue(t.color).toHex()}`, "paint-order: stroke"].join(";")
}
const TC = {
        fontSize: "font-size: {{VALUE}}px",
        fontFamily: "font-family: {{VALUE}}",
        fontWeight: "font-weight: {{VALUE}}",
        fontStyle: "font-style: {{VALUE}}",
        fontVariant: "font-variant: {{VALUE}}",
        letterSpacing: "letter-spacing: {{VALUE}}px",
        align: "text-align: {{VALUE}}",
        padding: "padding: {{VALUE}}px",
        whiteSpace: "white-space: {{VALUE}}",
        lineHeight: "line-height: {{VALUE}}px",
        wordWrapWidth: "max-width: {{VALUE}}px"
    },
    CC = {
        fill: t => `color: ${tt.shared.setValue(t).toHex()}`,
        breakWords: t => `word-wrap: ${t?"break-all":"break-word"}`,
        stroke: AD,
        dropShadow: PD
    };

function kle(t, e) {
    for (const n in t) {
        const r = t[n],
            i = [];
        for (const s in r) CC[s] ? i.push(CC[s](r[s])) : TC[s] && i.push(TC[s].replace("{{VALUE}}", r[s]));
        e.push(`${n} { ${i.join(";")} }`)
    }
}
class jx extends es {
    constructor(e = {}) {
        super(e), this._cssOverrides = [], this.cssOverrides = e.cssOverrides ? ? [], this.tagStyles = e.tagStyles ? ? {}
    }
    set cssOverrides(e) {
        this._cssOverrides = e instanceof Array ? e : [e], this.update()
    }
    get cssOverrides() {
        return this._cssOverrides
    }
    update() {
        this._cssStyle = null, super.update()
    }
    clone() {
        return new jx({
            align: this.align,
            breakWords: this.breakWords,
            dropShadow: this.dropShadow ? { ...this.dropShadow
            } : null,
            fill: this._fill,
            fontFamily: this.fontFamily,
            fontSize: this.fontSize,
            fontStyle: this.fontStyle,
            fontVariant: this.fontVariant,
            fontWeight: this.fontWeight,
            letterSpacing: this.letterSpacing,
            lineHeight: this.lineHeight,
            padding: this.padding,
            stroke: this._stroke,
            whiteSpace: this.whiteSpace,
            wordWrap: this.wordWrap,
            wordWrapWidth: this.wordWrapWidth,
            cssOverrides: this.cssOverrides,
            tagStyles: { ...this.tagStyles
            }
        })
    }
    get cssStyle() {
        return this._cssStyle || (this._cssStyle = Rle(this)), this._cssStyle
    }
    addOverride(...e) {
        const n = e.filter(r => !this.cssOverrides.includes(r));
        n.length > 0 && (this.cssOverrides.push(...n), this.update())
    }
    removeOverride(...e) {
        const n = e.filter(r => this.cssOverrides.includes(r));
        n.length > 0 && (this.cssOverrides = this.cssOverrides.filter(r => !n.includes(r)), this.update())
    }
    set fill(e) {
        typeof e != "string" && typeof e != "number" && Oe("[HTMLTextStyle] only color fill is not supported by HTMLText"), super.fill = e
    }
    set stroke(e) {
        e && typeof e != "string" && typeof e != "number" && Oe("[HTMLTextStyle] only color stroke is not supported by HTMLText"), super.stroke = e
    }
}
const PC = "http://www.w3.org/2000/svg",
    AC = "http://www.w3.org/1999/xhtml";
class OD {
    constructor() {
        this.svgRoot = document.createElementNS(PC, "svg"), this.foreignObject = document.createElementNS(PC, "foreignObject"), this.domElement = document.createElementNS(AC, "div"), this.styleElement = document.createElementNS(AC, "style"), this.image = new Image;
        const {
            foreignObject: e,
            svgRoot: n,
            styleElement: r,
            domElement: i
        } = this;
        e.setAttribute("width", "10000"), e.setAttribute("height", "10000"), e.style.overflow = "hidden", n.appendChild(e), e.appendChild(r), e.appendChild(i)
    }
}
let OC;

function Ble(t, e, n, r) {
    r || (r = OC || (OC = new OD));
    const {
        domElement: i,
        styleElement: s,
        svgRoot: o
    } = r;
    i.innerHTML = `<style>${e.cssStyle};</style><div style='padding:0'>${t}</div>`, i.setAttribute("style", "transform-origin: top left; display: inline-block"), n && (s.textContent = n), document.body.appendChild(o);
    const a = i.getBoundingClientRect();
    o.remove();
    const l = e.padding * 2;
    return {
        width: a.width - l,
        height: a.height - l
    }
}
class ID {
    constructor() {
        this._tempState = Fr.for2d(), this._didUploadHash = {}
    }
    init(e) {
        e.renderer.runners.contextChange.add(this)
    }
    contextChange() {
        this._didUploadHash = {}
    }
    start(e, n, r) {
        const i = e.renderer,
            s = this._didUploadHash[r.uid];
        i.shader.bind(r, s), s || (this._didUploadHash[r.uid] = !0), i.shader.updateUniformGroup(i.globalUniforms.uniformGroup), i.geometry.bind(n, r.glProgram)
    }
    execute(e, n) {
        const r = e.renderer;
        this._tempState.blendMode = n.blendMode, r.state.set(this._tempState);
        const i = n.textures.textures;
        for (let s = 0; s < n.textures.count; s++) r.texture.bind(i[s], s);
        r.geometry.draw(n.topology, n.size, n.start)
    }
}
ID.extension = {
    type: [G.WebGLPipesAdaptor],
    name: "batch"
};
const xf = Fr.for2d();
class MD {
    start(e, n, r) {
        const i = e.renderer,
            s = i.encoder,
            o = r.gpuProgram;
        this._shader = r, this._geometry = n, s.setGeometry(n, o), xf.blendMode = "normal", i.pipeline.getPipeline(n, o, xf);
        const a = i.globalUniforms.bindGroup;
        s.resetBindGroup(1), s.setBindGroup(0, a, o)
    }
    execute(e, n) {
        const r = this._shader.gpuProgram,
            i = e.renderer,
            s = i.encoder;
        if (!n.bindGroup) {
            const l = n.textures;
            n.bindGroup = Px(l.textures, l.count, i.limits.maxBatchableTextures)
        }
        xf.blendMode = n.blendMode;
        const o = i.bindGroup.getBindGroup(n.bindGroup, r, 1),
            a = i.pipeline.getPipeline(this._geometry, r, xf, n.topology);
        n.bindGroup._touch(i.textureGC.count), s.setPipeline(a), s.renderPassEncoder.setBindGroup(1, o), s.renderPassEncoder.drawIndexed(n.size, 1, n.start)
    }
}
MD.extension = {
    type: [G.WebGPUPipesAdaptor],
    name: "batch"
};
const Vx = class RD {
    constructor(e, n) {
        var r, i;
        this.state = Fr.for2d(), this._batchersByInstructionSet = Object.create(null), this._activeBatches = Object.create(null), this.renderer = e, this._adaptor = n, (i = (r = this._adaptor).init) == null || i.call(r, this)
    }
    static getBatcher(e) {
        return new this._availableBatchers[e]
    }
    buildStart(e) {
        let n = this._batchersByInstructionSet[e.uid];
        n || (n = this._batchersByInstructionSet[e.uid] = Object.create(null), n.default || (n.default = new kx({
            maxTextures: this.renderer.limits.maxBatchableTextures
        }))), this._activeBatches = n, this._activeBatch = this._activeBatches.default;
        for (const r in this._activeBatches) this._activeBatches[r].begin()
    }
    addToBatch(e, n) {
        if (this._activeBatch.name !== e.batcherName) {
            this._activeBatch.break(n);
            let r = this._activeBatches[e.batcherName];
            r || (r = this._activeBatches[e.batcherName] = RD.getBatcher(e.batcherName), r.begin()), this._activeBatch = r
        }
        this._activeBatch.add(e)
    }
    break (e) {
        this._activeBatch.break(e)
    }
    buildEnd(e) {
        this._activeBatch.break(e);
        const n = this._activeBatches;
        for (const r in n) {
            const i = n[r],
                s = i.geometry;
            s.indexBuffer.setDataWithSize(i.indexBuffer, i.indexSize, !0), s.buffers[0].setDataWithSize(i.attributeBuffer.float32View, i.attributeSize, !1)
        }
    }
    upload(e) {
        const n = this._batchersByInstructionSet[e.uid];
        for (const r in n) {
            const i = n[r],
                s = i.geometry;
            i.dirty && (i.dirty = !1, s.buffers[0].update(i.attributeSize * 4))
        }
    }
    execute(e) {
        if (e.action === "startBatch") {
            const n = e.batcher,
                r = n.geometry,
                i = n.shader;
            this._adaptor.start(this, r, i)
        }
        this._adaptor.execute(this, e)
    }
    destroy() {
        this.state = null, this.renderer = null, this._adaptor = null;
        for (const e in this._activeBatches) this._activeBatches[e].destroy();
        this._activeBatches = null
    }
};
Vx.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "batch"
};
Vx._availableBatchers = Object.create(null);
let kD = Vx;
Re.handleByMap(G.Batcher, kD._availableBatchers);
Re.add(kx);
const Zc = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            struct LocalUniforms {
                uTransformMatrix:mat3x3<f32>,
                uColor:vec4<f32>,
                uRound:f32,
            }

            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
            main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
            end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        }
    },
    Dle = { ...Zc,
        vertex: { ...Zc.vertex,
            header: Zc.vertex.header.replace("group(1)", "group(2)")
        }
    },
    Wx = {
        name: "local-uniform-bit",
        vertex: {
            header: `

            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix = uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        }
    },
    $le = {
        name: "texture-bit",
        vertex: {
            header: `

        struct TextureUniforms {
            uTextureMatrix:mat3x3<f32>,
        }

        @group(2) @binding(2) var<uniform> textureUniforms : TextureUniforms;
        `,
            main: `
            uv = (textureUniforms.uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        },
        fragment: {
            header: `
            @group(2) @binding(0) var uTexture: texture_2d<f32>;
            @group(2) @binding(1) var uSampler: sampler;


        `,
            main: `
            outColor = textureSample(uTexture, uSampler, vUV);
        `
        }
    },
    Fle = {
        name: "texture-bit",
        vertex: {
            header: `
            uniform mat3 uTextureMatrix;
        `,
            main: `
            uv = (uTextureMatrix * vec3(uv, 1.0)).xy;
        `
        },
        fragment: {
            header: `
        uniform sampler2D uTexture;


        `,
            main: `
            outColor = texture(uTexture, vUV);
        `
        }
    },
    Lle = new rn;
class Nle extends Ph {
    constructor() {
        super(), this.filters = [new Tle({
            sprite: new ra(we.EMPTY),
            inverse: !1,
            resolution: "inherit",
            antialias: "inherit"
        })]
    }
    get sprite() {
        return this.filters[0].sprite
    }
    set sprite(e) {
        this.filters[0].sprite = e
    }
    get inverse() {
        return this.filters[0].inverse
    }
    set inverse(e) {
        this.filters[0].inverse = e
    }
}
class BD {
    constructor(e) {
        this._activeMaskStage = [], this._renderer = e
    }
    push(e, n, r) {
        const i = this._renderer;
        if (i.renderPipes.batch.break(r), r.add({
                renderPipeId: "alphaMask",
                action: "pushMaskBegin",
                mask: e,
                inverse: n._maskOptions.inverse,
                canBundle: !1,
                maskedContainer: n
            }), e.inverse = n._maskOptions.inverse, e.renderMaskToTexture) {
            const s = e.mask;
            s.includeInBuild = !0, s.collectRenderables(r, i, null), s.includeInBuild = !1
        }
        i.renderPipes.batch.break(r), r.add({
            renderPipeId: "alphaMask",
            action: "pushMaskEnd",
            mask: e,
            maskedContainer: n,
            inverse: n._maskOptions.inverse,
            canBundle: !1
        })
    }
    pop(e, n, r) {
        this._renderer.renderPipes.batch.break(r), r.add({
            renderPipeId: "alphaMask",
            action: "popMaskEnd",
            mask: e,
            inverse: n._maskOptions.inverse,
            canBundle: !1
        })
    }
    execute(e) {
        const n = this._renderer,
            r = e.mask.renderMaskToTexture;
        if (e.action === "pushMaskBegin") {
            const i = nn.get(Nle);
            if (i.inverse = e.inverse, r) {
                e.mask.mask.measurable = !0;
                const s = yx(e.mask.mask, !0, Lle);
                e.mask.mask.measurable = !1, s.ceil();
                const o = n.renderTarget.renderTarget.colorTexture.source,
                    a = Ft.getOptimalTexture(s.width, s.height, o._resolution, o.antialias);
                n.renderTarget.push(a, !0), n.globalUniforms.push({
                    offset: s,
                    worldColor: 4294967295
                });
                const l = i.sprite;
                l.texture = a, l.worldTransform.tx = s.minX, l.worldTransform.ty = s.minY, this._activeMaskStage.push({
                    filterEffect: i,
                    maskedContainer: e.maskedContainer,
                    filterTexture: a
                })
            } else i.sprite = e.mask.mask, this._activeMaskStage.push({
                filterEffect: i,
                maskedContainer: e.maskedContainer
            })
        } else if (e.action === "pushMaskEnd") {
            const i = this._activeMaskStage[this._activeMaskStage.length - 1];
            r && (n.type === tr.WEBGL && n.renderTarget.finishRenderPass(), n.renderTarget.pop(), n.globalUniforms.pop()), n.filter.push({
                renderPipeId: "filter",
                action: "pushFilter",
                container: i.maskedContainer,
                filterEffect: i.filterEffect,
                canBundle: !1
            })
        } else if (e.action === "popMaskEnd") {
            n.filter.pop();
            const i = this._activeMaskStage.pop();
            r && Ft.returnTexture(i.filterTexture), nn.return(i.filterEffect)
        }
    }
    destroy() {
        this._renderer = null, this._activeMaskStage = null
    }
}
BD.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "alphaMask"
};
class DD {
    constructor(e) {
        this._colorStack = [], this._colorStackIndex = 0, this._currentColor = 0, this._renderer = e
    }
    buildStart() {
        this._colorStack[0] = 15, this._colorStackIndex = 1, this._currentColor = 15
    }
    push(e, n, r) {
        this._renderer.renderPipes.batch.break(r);
        const s = this._colorStack;
        s[this._colorStackIndex] = s[this._colorStackIndex - 1] & e.mask;
        const o = this._colorStack[this._colorStackIndex];
        o !== this._currentColor && (this._currentColor = o, r.add({
            renderPipeId: "colorMask",
            colorMask: o,
            canBundle: !1
        })), this._colorStackIndex++
    }
    pop(e, n, r) {
        this._renderer.renderPipes.batch.break(r);
        const s = this._colorStack;
        this._colorStackIndex--;
        const o = s[this._colorStackIndex - 1];
        o !== this._currentColor && (this._currentColor = o, r.add({
            renderPipeId: "colorMask",
            colorMask: o,
            canBundle: !1
        }))
    }
    execute(e) {
        this._renderer.colorMask.setMask(e.colorMask)
    }
    destroy() {
        this._colorStack = null
    }
}
DD.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "colorMask"
};
class $D {
    constructor(e) {
        this._maskStackHash = {}, this._maskHash = new WeakMap, this._renderer = e
    }
    push(e, n, r) {
        var i;
        const s = e,
            o = this._renderer;
        o.renderPipes.batch.break(r), o.renderPipes.blendMode.setBlendMode(s.mask, "none", r), r.add({
            renderPipeId: "stencilMask",
            action: "pushMaskBegin",
            mask: e,
            inverse: n._maskOptions.inverse,
            canBundle: !1
        });
        const a = s.mask;
        a.includeInBuild = !0, this._maskHash.has(s) || this._maskHash.set(s, {
            instructionsStart: 0,
            instructionsLength: 0
        });
        const l = this._maskHash.get(s);
        l.instructionsStart = r.instructionSize, a.collectRenderables(r, o, null), a.includeInBuild = !1, o.renderPipes.batch.break(r), r.add({
            renderPipeId: "stencilMask",
            action: "pushMaskEnd",
            mask: e,
            inverse: n._maskOptions.inverse,
            canBundle: !1
        });
        const c = r.instructionSize - l.instructionsStart - 1;
        l.instructionsLength = c;
        const u = o.renderTarget.renderTarget.uid;
        (i = this._maskStackHash)[u] ? ? (i[u] = 0)
    }
    pop(e, n, r) {
        const i = e,
            s = this._renderer;
        s.renderPipes.batch.break(r), s.renderPipes.blendMode.setBlendMode(i.mask, "none", r), r.add({
            renderPipeId: "stencilMask",
            action: "popMaskBegin",
            inverse: n._maskOptions.inverse,
            canBundle: !1
        });
        const o = this._maskHash.get(e);
        for (let a = 0; a < o.instructionsLength; a++) r.instructions[r.instructionSize++] = r.instructions[o.instructionsStart++];
        r.add({
            renderPipeId: "stencilMask",
            action: "popMaskEnd",
            canBundle: !1
        })
    }
    execute(e) {
        var n;
        const r = this._renderer,
            i = r.renderTarget.renderTarget.uid;
        let s = (n = this._maskStackHash)[i] ? ? (n[i] = 0);
        e.action === "pushMaskBegin" ? (r.renderTarget.ensureDepthStencil(), r.stencil.setStencilMode(Bt.RENDERING_MASK_ADD, s), s++, r.colorMask.setMask(0)) : e.action === "pushMaskEnd" ? (e.inverse ? r.stencil.setStencilMode(Bt.INVERSE_MASK_ACTIVE, s) : r.stencil.setStencilMode(Bt.MASK_ACTIVE, s), r.colorMask.setMask(15)) : e.action === "popMaskBegin" ? (r.colorMask.setMask(0), s !== 0 ? r.stencil.setStencilMode(Bt.RENDERING_MASK_REMOVE, s) : (r.renderTarget.clear(null, Yn.STENCIL), r.stencil.setStencilMode(Bt.DISABLED, s)), s--) : e.action === "popMaskEnd" && (e.inverse ? r.stencil.setStencilMode(Bt.INVERSE_MASK_ACTIVE, s) : r.stencil.setStencilMode(Bt.MASK_ACTIVE, s), r.colorMask.setMask(15)), this._maskStackHash[i] = s
    }
    destroy() {
        this._renderer = null, this._maskStackHash = null, this._maskHash = null
    }
}
$D.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "stencilMask"
};
var qf = (t => (t[t.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", t[t.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", t[t.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", t))(qf || {});
class Ule {
    constructor(e, n) {
        this._lastBindBaseLocation = -1, this._lastBindCallId = -1, this.buffer = e || null, this.updateID = -1, this.byteLength = -1, this.type = n
    }
}
class FD {
    constructor(e) {
        this._gpuBuffers = Object.create(null), this._boundBufferBases = Object.create(null), this._minBaseLocation = 0, this._nextBindBaseIndex = this._minBaseLocation, this._bindCallId = 0, this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuBuffers")
    }
    destroy() {
        this._renderer = null, this._gl = null, this._gpuBuffers = null, this._boundBufferBases = null
    }
    contextChange() {
        this._gl = this._renderer.gl, this._gpuBuffers = Object.create(null), this._maxBindings = this._renderer.limits.maxUniformBindings
    }
    getGlBuffer(e) {
        return this._gpuBuffers[e.uid] || this.createGLBuffer(e)
    }
    bind(e) {
        const {
            _gl: n
        } = this, r = this.getGlBuffer(e);
        n.bindBuffer(r.type, r.buffer)
    }
    bindBufferBase(e, n) {
        const {
            _gl: r
        } = this;
        this._boundBufferBases[n] !== e && (this._boundBufferBases[n] = e, e._lastBindBaseLocation = n, r.bindBufferBase(r.UNIFORM_BUFFER, n, e.buffer))
    }
    nextBindBase(e) {
        this._bindCallId++, this._minBaseLocation = 0, e && (this._boundBufferBases[0] = null, this._minBaseLocation = 1, this._nextBindBaseIndex < 1 && (this._nextBindBaseIndex = 1))
    }
    freeLocationForBufferBase(e) {
        let n = this.getLastBindBaseLocation(e);
        if (n >= this._minBaseLocation) return e._lastBindCallId = this._bindCallId, n;
        let r = 0,
            i = this._nextBindBaseIndex;
        for (; r < 2;) {
            i >= this._maxBindings && (i = this._minBaseLocation, r++);
            const s = this._boundBufferBases[i];
            if (s && s._lastBindCallId === this._bindCallId) {
                i++;
                continue
            }
            break
        }
        return n = i, this._nextBindBaseIndex = i + 1, r >= 2 ? -1 : (e._lastBindCallId = this._bindCallId, this._boundBufferBases[n] = null, n)
    }
    getLastBindBaseLocation(e) {
        const n = e._lastBindBaseLocation;
        return this._boundBufferBases[n] === e ? n : -1
    }
    bindBufferRange(e, n, r, i) {
        const {
            _gl: s
        } = this;
        r || (r = 0), n || (n = 0), this._boundBufferBases[n] = null, s.bindBufferRange(s.UNIFORM_BUFFER, n || 0, e.buffer, r * 256, i || 256)
    }
    updateBuffer(e) {
        const {
            _gl: n
        } = this, r = this.getGlBuffer(e);
        if (e._updateID === r.updateID) return r;
        r.updateID = e._updateID, n.bindBuffer(r.type, r.buffer);
        const i = e.data,
            s = e.descriptor.usage & Xe.STATIC ? n.STATIC_DRAW : n.DYNAMIC_DRAW;
        return i ? r.byteLength >= i.byteLength ? n.bufferSubData(r.type, 0, i, 0, e._updateSize / i.BYTES_PER_ELEMENT) : (r.byteLength = i.byteLength, n.bufferData(r.type, i, s)) : (r.byteLength = e.descriptor.size, n.bufferData(r.type, r.byteLength, s)), r
    }
    destroyAll() {
        const e = this._gl;
        for (const n in this._gpuBuffers) e.deleteBuffer(this._gpuBuffers[n].buffer);
        this._gpuBuffers = Object.create(null)
    }
    onBufferDestroy(e, n) {
        const r = this._gpuBuffers[e.uid],
            i = this._gl;
        n || i.deleteBuffer(r.buffer), this._gpuBuffers[e.uid] = null
    }
    createGLBuffer(e) {
        const {
            _gl: n
        } = this;
        let r = qf.ARRAY_BUFFER;
        e.descriptor.usage & Xe.INDEX ? r = qf.ELEMENT_ARRAY_BUFFER : e.descriptor.usage & Xe.UNIFORM && (r = qf.UNIFORM_BUFFER);
        const i = new Ule(n.createBuffer(), r);
        return this._gpuBuffers[e.uid] = i, e.on("destroy", this.onBufferDestroy, this), i
    }
    resetState() {
        this._boundBufferBases = Object.create(null)
    }
}
FD.extension = {
    type: [G.WebGLSystem],
    name: "buffer"
};
const Yx = class LD {
    constructor(e) {
        this.supports = {
            uint32Indices: !0,
            uniformBufferObject: !0,
            vertexArrayObject: !0,
            srgbTextures: !0,
            nonPowOf2wrapping: !0,
            msaa: !0,
            nonPowOf2mipmaps: !0
        }, this._renderer = e, this.extensions = Object.create(null), this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this)
    }
    get isLost() {
        return !this.gl || this.gl.isContextLost()
    }
    contextChange(e) {
        this.gl = e, this._renderer.gl = e
    }
    init(e) {
        e = { ...LD.defaultOptions,
            ...e
        };
        let n = this.multiView = e.multiView;
        if (e.context && n && (Oe("Renderer created with both a context and multiview enabled. Disabling multiView as both cannot work together."), n = !1), n ? this.canvas = Ge.get().createCanvas(this._renderer.canvas.width, this._renderer.canvas.height) : this.canvas = this._renderer.view.canvas, e.context) this.initFromContext(e.context);
        else {
            const r = this._renderer.background.alpha < 1,
                i = e.premultipliedAlpha ? ? !0,
                s = e.antialias && !this._renderer.backBuffer.useBackBuffer;
            this.createContext(e.preferWebGLVersion, {
                alpha: r,
                premultipliedAlpha: i,
                antialias: s,
                stencil: !0,
                preserveDrawingBuffer: e.preserveDrawingBuffer,
                powerPreference: e.powerPreference ? ? "default"
            })
        }
    }
    ensureCanvasSize(e) {
        if (!this.multiView) {
            e !== this.canvas && Oe("multiView is disabled, but targetCanvas is not the main canvas");
            return
        }
        const {
            canvas: n
        } = this;
        (n.width < e.width || n.height < e.height) && (n.width = Math.max(e.width, e.width), n.height = Math.max(e.height, e.height))
    }
    initFromContext(e) {
        this.gl = e, this.webGLVersion = e instanceof Ge.get().getWebGLRenderingContext() ? 1 : 2, this.getExtensions(), this.validateContext(e), this._renderer.runners.contextChange.emit(e);
        const n = this._renderer.view.canvas;
        n.addEventListener("webglcontextlost", this.handleContextLost, !1), n.addEventListener("webglcontextrestored", this.handleContextRestored, !1)
    }
    createContext(e, n) {
        let r;
        const i = this.canvas;
        if (e === 2 && (r = i.getContext("webgl2", n)), !r && (r = i.getContext("webgl", n), !r)) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        this.gl = r, this.initFromContext(this.gl)
    }
    getExtensions() {
        const {
            gl: e
        } = this, n = {
            anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: e.getExtension("OES_texture_float_linear"),
            s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: e.getExtension("WEBGL_compressed_texture_etc"),
            etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: e.getExtension("WEBGL_compressed_texture_atc"),
            astc: e.getExtension("WEBGL_compressed_texture_astc"),
            bptc: e.getExtension("EXT_texture_compression_bptc"),
            rgtc: e.getExtension("EXT_texture_compression_rgtc"),
            loseContext: e.getExtension("WEBGL_lose_context")
        };
        if (this.webGLVersion === 1) this.extensions = { ...n,
            drawBuffers: e.getExtension("WEBGL_draw_buffers"),
            depthTexture: e.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: e.getExtension("OES_vertex_array_object") || e.getExtension("MOZ_OES_vertex_array_object") || e.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: e.getExtension("OES_element_index_uint"),
            floatTexture: e.getExtension("OES_texture_float"),
            floatTextureLinear: e.getExtension("OES_texture_float_linear"),
            textureHalfFloat: e.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: e.getExtension("OES_texture_half_float_linear"),
            vertexAttribDivisorANGLE: e.getExtension("ANGLE_instanced_arrays"),
            srgb: e.getExtension("EXT_sRGB")
        };
        else {
            this.extensions = { ...n,
                colorBufferFloat: e.getExtension("EXT_color_buffer_float")
            };
            const r = e.getExtension("WEBGL_provoking_vertex");
            r && r.provokingVertexWEBGL(r.FIRST_VERTEX_CONVENTION_WEBGL)
        }
    }
    handleContextLost(e) {
        e.preventDefault(), this._contextLossForced && (this._contextLossForced = !1, setTimeout(() => {
            var n;
            this.gl.isContextLost() && ((n = this.extensions.loseContext) == null || n.restoreContext())
        }, 0))
    }
    handleContextRestored() {
        this.getExtensions(), this._renderer.runners.contextChange.emit(this.gl)
    }
    destroy() {
        var n;
        const e = this._renderer.view.canvas;
        this._renderer = null, e.removeEventListener("webglcontextlost", this.handleContextLost), e.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), (n = this.extensions.loseContext) == null || n.loseContext()
    }
    forceContextLoss() {
        var e;
        (e = this.extensions.loseContext) == null || e.loseContext(), this._contextLossForced = !0
    }
    validateContext(e) {
        const n = e.getContextAttributes();
        n && !n.stencil && Oe("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        const r = this.supports,
            i = this.webGLVersion === 2,
            s = this.extensions;
        r.uint32Indices = i || !!s.uint32ElementIndex, r.uniformBufferObject = i, r.vertexArrayObject = i || !!s.vertexArrayObject, r.srgbTextures = i || !!s.srgb, r.nonPowOf2wrapping = i, r.nonPowOf2mipmaps = i, r.msaa = i, r.uint32Indices || Oe("Provided WebGL context does not support 32 index buffer, large scenes may not render correctly")
    }
};
Yx.extension = {
    type: [G.WebGLSystem],
    name: "context"
};
Yx.defaultOptions = {
    context: null,
    premultipliedAlpha: !0,
    preserveDrawingBuffer: !1,
    powerPreference: void 0,
    preferWebGLVersion: 2,
    multiView: !1
};
let Gle = Yx;

function ND(t, e) {
    for (const n in t.attributes) {
        const r = t.attributes[n],
            i = e[n];
        i ? (r.format ? ? (r.format = i.format), r.offset ? ? (r.offset = i.offset), r.instance ? ? (r.instance = i.instance)) : Oe(`Attribute ${n} is not present in the shader, but is present in the geometry. Unable to infer attribute details.`)
    }
    Hle(t)
}

function Hle(t) {
    const {
        buffers: e,
        attributes: n
    } = t, r = {}, i = {};
    for (const s in e) {
        const o = e[s];
        r[o.uid] = 0, i[o.uid] = 0
    }
    for (const s in n) {
        const o = n[s];
        r[o.buffer.uid] += Xs(o.format).stride
    }
    for (const s in n) {
        const o = n[s];
        o.stride ? ? (o.stride = r[o.buffer.uid]), o.start ? ? (o.start = i[o.buffer.uid]), i[o.buffer.uid] += Xs(o.format).stride
    }
}
var k0 = (t => (t[t.RGBA = 6408] = "RGBA", t[t.RGB = 6407] = "RGB", t[t.RG = 33319] = "RG", t[t.RED = 6403] = "RED", t[t.RGBA_INTEGER = 36249] = "RGBA_INTEGER", t[t.RGB_INTEGER = 36248] = "RGB_INTEGER", t[t.RG_INTEGER = 33320] = "RG_INTEGER", t[t.RED_INTEGER = 36244] = "RED_INTEGER", t[t.ALPHA = 6406] = "ALPHA", t[t.LUMINANCE = 6409] = "LUMINANCE", t[t.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", t[t.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", t[t.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", t))(k0 || {}),
    UD = (t => (t[t.TEXTURE_2D = 3553] = "TEXTURE_2D", t[t.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", t[t.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", t[t.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", t[t.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", t[t.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", t[t.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", t[t.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", t))(UD || {}),
    Qe = (t => (t[t.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", t[t.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", t[t.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", t[t.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", t[t.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", t[t.UNSIGNED_INT = 5125] = "UNSIGNED_INT", t[t.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", t[t.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", t[t.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", t[t.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", t[t.BYTE = 5120] = "BYTE", t[t.SHORT = 5122] = "SHORT", t[t.INT = 5124] = "INT", t[t.FLOAT = 5126] = "FLOAT", t[t.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", t[t.HALF_FLOAT = 36193] = "HALF_FLOAT", t))(Qe || {});
const IC = {
    uint8x2: Qe.UNSIGNED_BYTE,
    uint8x4: Qe.UNSIGNED_BYTE,
    sint8x2: Qe.BYTE,
    sint8x4: Qe.BYTE,
    unorm8x2: Qe.UNSIGNED_BYTE,
    unorm8x4: Qe.UNSIGNED_BYTE,
    snorm8x2: Qe.BYTE,
    snorm8x4: Qe.BYTE,
    uint16x2: Qe.UNSIGNED_SHORT,
    uint16x4: Qe.UNSIGNED_SHORT,
    sint16x2: Qe.SHORT,
    sint16x4: Qe.SHORT,
    unorm16x2: Qe.UNSIGNED_SHORT,
    unorm16x4: Qe.UNSIGNED_SHORT,
    snorm16x2: Qe.SHORT,
    snorm16x4: Qe.SHORT,
    float16x2: Qe.HALF_FLOAT,
    float16x4: Qe.HALF_FLOAT,
    float32: Qe.FLOAT,
    float32x2: Qe.FLOAT,
    float32x3: Qe.FLOAT,
    float32x4: Qe.FLOAT,
    uint32: Qe.UNSIGNED_INT,
    uint32x2: Qe.UNSIGNED_INT,
    uint32x3: Qe.UNSIGNED_INT,
    uint32x4: Qe.UNSIGNED_INT,
    sint32: Qe.INT,
    sint32x2: Qe.INT,
    sint32x3: Qe.INT,
    sint32x4: Qe.INT
};

function zle(t) {
    return IC[t] ? ? IC.float32
}
const jle = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 3,
    "triangle-list": 4,
    "triangle-strip": 5
};
class GD {
    constructor(e) {
        this._geometryVaoHash = Object.create(null), this._renderer = e, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this._renderer.renderableGC.addManagedHash(this, "_geometryVaoHash")
    }
    contextChange() {
        const e = this.gl = this._renderer.gl;
        if (!this._renderer.context.supports.vertexArrayObject) throw new Error("[PixiJS] Vertex Array Objects are not supported on this device");
        const n = this._renderer.context.extensions.vertexArrayObject;
        n && (e.createVertexArray = () => n.createVertexArrayOES(), e.bindVertexArray = i => n.bindVertexArrayOES(i), e.deleteVertexArray = i => n.deleteVertexArrayOES(i));
        const r = this._renderer.context.extensions.vertexAttribDivisorANGLE;
        r && (e.drawArraysInstanced = (i, s, o, a) => {
            r.drawArraysInstancedANGLE(i, s, o, a)
        }, e.drawElementsInstanced = (i, s, o, a, l) => {
            r.drawElementsInstancedANGLE(i, s, o, a, l)
        }, e.vertexAttribDivisor = (i, s) => r.vertexAttribDivisorANGLE(i, s)), this._activeGeometry = null, this._activeVao = null, this._geometryVaoHash = Object.create(null)
    }
    bind(e, n) {
        const r = this.gl;
        this._activeGeometry = e;
        const i = this.getVao(e, n);
        this._activeVao !== i && (this._activeVao = i, r.bindVertexArray(i)), this.updateBuffers()
    }
    resetState() {
        this.unbind()
    }
    updateBuffers() {
        const e = this._activeGeometry,
            n = this._renderer.buffer;
        for (let r = 0; r < e.buffers.length; r++) {
            const i = e.buffers[r];
            n.updateBuffer(i)
        }
    }
    checkCompatibility(e, n) {
        const r = e.attributes,
            i = n._attributeData;
        for (const s in i)
            if (!r[s]) throw new Error(`shader and geometry incompatible, geometry missing the "${s}" attribute`)
    }
    getSignature(e, n) {
        const r = e.attributes,
            i = n._attributeData,
            s = ["g", e.uid];
        for (const o in r) i[o] && s.push(o, i[o].location);
        return s.join("-")
    }
    getVao(e, n) {
        var r;
        return ((r = this._geometryVaoHash[e.uid]) == null ? void 0 : r[n._key]) || this.initGeometryVao(e, n)
    }
    initGeometryVao(e, n, r = !0) {
        const i = this._renderer.gl,
            s = this._renderer.buffer;
        this._renderer.shader._getProgramData(n), this.checkCompatibility(e, n);
        const o = this.getSignature(e, n);
        this._geometryVaoHash[e.uid] || (this._geometryVaoHash[e.uid] = Object.create(null), e.on("destroy", this.onGeometryDestroy, this));
        const a = this._geometryVaoHash[e.uid];
        let l = a[o];
        if (l) return a[n._key] = l, l;
        ND(e, n._attributeData);
        const c = e.buffers;
        l = i.createVertexArray(), i.bindVertexArray(l);
        for (let u = 0; u < c.length; u++) {
            const d = c[u];
            s.bind(d)
        }
        return this.activateVao(e, n), a[n._key] = l, a[o] = l, i.bindVertexArray(null), l
    }
    onGeometryDestroy(e, n) {
        const r = this._geometryVaoHash[e.uid],
            i = this.gl;
        if (r) {
            if (n)
                for (const s in r) this._activeVao !== r[s] && this.unbind(), i.deleteVertexArray(r[s]);
            this._geometryVaoHash[e.uid] = null
        }
    }
    destroyAll(e = !1) {
        const n = this.gl;
        for (const r in this._geometryVaoHash) {
            if (e)
                for (const i in this._geometryVaoHash[r]) {
                    const s = this._geometryVaoHash[r];
                    this._activeVao !== s && this.unbind(), n.deleteVertexArray(s[i])
                }
            this._geometryVaoHash[r] = null
        }
    }
    activateVao(e, n) {
        var a;
        const r = this._renderer.gl,
            i = this._renderer.buffer,
            s = e.attributes;
        e.indexBuffer && i.bind(e.indexBuffer);
        let o = null;
        for (const l in s) {
            const c = s[l],
                u = c.buffer,
                d = i.getGlBuffer(u),
                f = n._attributeData[l];
            if (f) {
                o !== d && (i.bind(u), o = d);
                const h = f.location;
                r.enableVertexAttribArray(h);
                const p = Xs(c.format),
                    b = zle(c.format);
                if (((a = f.format) == null ? void 0 : a.substring(1, 4)) === "int" ? r.vertexAttribIPointer(h, p.size, b, c.stride, c.offset) : r.vertexAttribPointer(h, p.size, b, p.normalised, c.stride, c.offset), c.instance)
                    if (this.hasInstance) {
                        const y = c.divisor ? ? 1;
                        r.vertexAttribDivisor(h, y)
                    } else throw new Error("geometry error, GPU Instancing is not supported on this device")
            }
        }
    }
    draw(e, n, r, i) {
        const {
            gl: s
        } = this._renderer, o = this._activeGeometry, a = jle[e || o.topology];
        if (i ? ? (i = o.instanceCount), o.indexBuffer) {
            const l = o.indexBuffer.data.BYTES_PER_ELEMENT,
                c = l === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
            i > 1 ? s.drawElementsInstanced(a, n || o.indexBuffer.data.length, c, (r || 0) * l, i) : s.drawElements(a, n || o.indexBuffer.data.length, c, (r || 0) * l)
        } else i > 1 ? s.drawArraysInstanced(a, r || 0, n || o.getSize(), i) : s.drawArrays(a, r || 0, n || o.getSize());
        return this
    }
    unbind() {
        this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null
    }
    destroy() {
        this._renderer = null, this.gl = null, this._activeVao = null, this._activeGeometry = null
    }
}
GD.extension = {
    type: [G.WebGLSystem],
    name: "geometry"
};
const Vle = new hd({
        attributes: {
            aPosition: [-1, -1, 3, -1, -1, 3]
        }
    }),
    Xx = class HD {
        constructor(e) {
            this.useBackBuffer = !1, this._useBackBufferThisRender = !1, this._renderer = e
        }
        init(e = {}) {
            const {
                useBackBuffer: n,
                antialias: r
            } = { ...HD.defaultOptions,
                ...e
            };
            this.useBackBuffer = n, this._antialias = r, this._renderer.context.supports.msaa || (Oe("antialiasing, is not supported on when using the back buffer"), this._antialias = !1), this._state = Fr.for2d();
            const i = new wa({
                vertex: `
                attribute vec2 aPosition;
                out vec2 vUv;

                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);

                    vUv = (aPosition + 1.0) / 2.0;

                    // flip dem UVs
                    vUv.y = 1.0 - vUv.y;
                }`,
                fragment: `
                in vec2 vUv;
                out vec4 finalColor;

                uniform sampler2D uTexture;

                void main() {
                    finalColor = texture(uTexture, vUv);
                }`,
                name: "big-triangle"
            });
            this._bigTriangleShader = new br({
                glProgram: i,
                resources: {
                    uTexture: we.WHITE.source
                }
            })
        }
        renderStart(e) {
            const n = this._renderer.renderTarget.getRenderTarget(e.target);
            if (this._useBackBufferThisRender = this.useBackBuffer && !!n.isRoot, this._useBackBufferThisRender) {
                const r = this._renderer.renderTarget.getRenderTarget(e.target);
                this._targetTexture = r.colorTexture, e.target = this._getBackBufferTexture(r.colorTexture)
            }
        }
        renderEnd() {
            this._presentBackBuffer()
        }
        _presentBackBuffer() {
            const e = this._renderer;
            e.renderTarget.finishRenderPass(), this._useBackBufferThisRender && (e.renderTarget.bind(this._targetTexture, !1), this._bigTriangleShader.resources.uTexture = this._backBufferTexture.source, e.encoder.draw({
                geometry: Vle,
                shader: this._bigTriangleShader,
                state: this._state
            }))
        }
        _getBackBufferTexture(e) {
            return this._backBufferTexture = this._backBufferTexture || new we({
                source: new Wt({
                    width: e.width,
                    height: e.height,
                    resolution: e._resolution,
                    antialias: this._antialias
                })
            }), this._backBufferTexture.source.resize(e.width, e.height, e._resolution), this._backBufferTexture
        }
        destroy() {
            this._backBufferTexture && (this._backBufferTexture.destroy(), this._backBufferTexture = null)
        }
    };
Xx.extension = {
    type: [G.WebGLSystem],
    name: "backBuffer",
    priority: 1
};
Xx.defaultOptions = {
    useBackBuffer: !1
};
let Wle = Xx;
class zD {
    constructor(e) {
        this._colorMaskCache = 15, this._renderer = e
    }
    setMask(e) {
        this._colorMaskCache !== e && (this._colorMaskCache = e, this._renderer.gl.colorMask(!!(e & 8), !!(e & 4), !!(e & 2), !!(e & 1)))
    }
}
zD.extension = {
    type: [G.WebGLSystem],
    name: "colorMask"
};
class jD {
    constructor(e) {
        this.commandFinished = Promise.resolve(), this._renderer = e
    }
    setGeometry(e, n) {
        this._renderer.geometry.bind(e, n.glProgram)
    }
    finishRenderPass() {}
    draw(e) {
        const n = this._renderer,
            {
                geometry: r,
                shader: i,
                state: s,
                skipSync: o,
                topology: a,
                size: l,
                start: c,
                instanceCount: u
            } = e;
        n.shader.bind(i, o), n.geometry.bind(r, n.shader._activeProgram), s && n.state.set(s), n.geometry.draw(a, l, c, u ? ? r.instanceCount)
    }
    destroy() {
        this._renderer = null
    }
}
jD.extension = {
    type: [G.WebGLSystem],
    name: "encoder"
};
class VD {
    constructor(e) {
        this._renderer = e
    }
    contextChange() {
        const e = this._renderer.gl;
        this.maxTextures = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), this.maxBatchableTextures = VB(this.maxTextures, e), this.maxUniformBindings = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS)
    }
    destroy() {}
}
VD.extension = {
    type: [G.WebGLSystem],
    name: "limits"
};
class Yle {
    constructor() {
        this.width = -1, this.height = -1, this.msaa = !1, this.msaaRenderBuffer = []
    }
}
const so = [];
so[Bt.NONE] = void 0;
so[Bt.DISABLED] = {
    stencilWriteMask: 0,
    stencilReadMask: 0
};
so[Bt.RENDERING_MASK_ADD] = {
    stencilFront: {
        compare: "equal",
        passOp: "increment-clamp"
    },
    stencilBack: {
        compare: "equal",
        passOp: "increment-clamp"
    }
};
so[Bt.RENDERING_MASK_REMOVE] = {
    stencilFront: {
        compare: "equal",
        passOp: "decrement-clamp"
    },
    stencilBack: {
        compare: "equal",
        passOp: "decrement-clamp"
    }
};
so[Bt.MASK_ACTIVE] = {
    stencilWriteMask: 0,
    stencilFront: {
        compare: "equal",
        passOp: "keep"
    },
    stencilBack: {
        compare: "equal",
        passOp: "keep"
    }
};
so[Bt.INVERSE_MASK_ACTIVE] = {
    stencilWriteMask: 0,
    stencilFront: {
        compare: "not-equal",
        passOp: "keep"
    },
    stencilBack: {
        compare: "not-equal",
        passOp: "keep"
    }
};
class WD {
    constructor(e) {
        this._stencilCache = {
            enabled: !1,
            stencilReference: 0,
            stencilMode: Bt.NONE
        }, this._renderTargetStencilState = Object.create(null), e.renderTarget.onRenderTargetChange.add(this)
    }
    contextChange(e) {
        this._gl = e, this._comparisonFuncMapping = {
            always: e.ALWAYS,
            never: e.NEVER,
            equal: e.EQUAL,
            "not-equal": e.NOTEQUAL,
            less: e.LESS,
            "less-equal": e.LEQUAL,
            greater: e.GREATER,
            "greater-equal": e.GEQUAL
        }, this._stencilOpsMapping = {
            keep: e.KEEP,
            zero: e.ZERO,
            replace: e.REPLACE,
            invert: e.INVERT,
            "increment-clamp": e.INCR,
            "decrement-clamp": e.DECR,
            "increment-wrap": e.INCR_WRAP,
            "decrement-wrap": e.DECR_WRAP
        }, this.resetState()
    }
    onRenderTargetChange(e) {
        if (this._activeRenderTarget === e) return;
        this._activeRenderTarget = e;
        let n = this._renderTargetStencilState[e.uid];
        n || (n = this._renderTargetStencilState[e.uid] = {
            stencilMode: Bt.DISABLED,
            stencilReference: 0
        }), this.setStencilMode(n.stencilMode, n.stencilReference)
    }
    resetState() {
        this._stencilCache.enabled = !1, this._stencilCache.stencilMode = Bt.NONE, this._stencilCache.stencilReference = 0
    }
    setStencilMode(e, n) {
        const r = this._renderTargetStencilState[this._activeRenderTarget.uid],
            i = this._gl,
            s = so[e],
            o = this._stencilCache;
        if (r.stencilMode = e, r.stencilReference = n, e === Bt.DISABLED) {
            this._stencilCache.enabled && (this._stencilCache.enabled = !1, i.disable(i.STENCIL_TEST));
            return
        }
        this._stencilCache.enabled || (this._stencilCache.enabled = !0, i.enable(i.STENCIL_TEST)), (e !== o.stencilMode || o.stencilReference !== n) && (o.stencilMode = e, o.stencilReference = n, i.stencilFunc(this._comparisonFuncMapping[s.stencilBack.compare], n, 255), i.stencilOp(i.KEEP, i.KEEP, this._stencilOpsMapping[s.stencilBack.passOp]))
    }
}
WD.extension = {
    type: [G.WebGLSystem],
    name: "stencil"
};
class YD {
    constructor(e) {
        this._syncFunctionHash = Object.create(null), this._adaptor = e, this._systemCheck()
    }
    _systemCheck() {
        if (!IB()) throw new Error("Current environment does not allow unsafe-eval, please use pixi.js/unsafe-eval module to enable support.")
    }
    ensureUniformGroup(e) {
        const n = this.getUniformGroupData(e);
        e.buffer || (e.buffer = new Jn({
            data: new Float32Array(n.layout.size / 4),
            usage: Xe.UNIFORM | Xe.COPY_DST
        }))
    }
    getUniformGroupData(e) {
        return this._syncFunctionHash[e._signature] || this._initUniformGroup(e)
    }
    _initUniformGroup(e) {
        const n = e._signature;
        let r = this._syncFunctionHash[n];
        if (!r) {
            const i = Object.keys(e.uniformStructures).map(a => e.uniformStructures[a]),
                s = this._adaptor.createUboElements(i),
                o = this._generateUboSync(s.uboElements);
            r = this._syncFunctionHash[n] = {
                layout: s,
                syncFunction: o
            }
        }
        return this._syncFunctionHash[n]
    }
    _generateUboSync(e) {
        return this._adaptor.generateUboSync(e)
    }
    syncUniformGroup(e, n, r) {
        const i = this.getUniformGroupData(e);
        e.buffer || (e.buffer = new Jn({
            data: new Float32Array(i.layout.size / 4),
            usage: Xe.UNIFORM | Xe.COPY_DST
        }));
        let s = null;
        return n || (n = e.buffer.data, s = e.buffer.dataInt32), r || (r = 0), i.syncFunction(e.uniforms, n, s, r), !0
    }
    updateUniformGroup(e) {
        if (e.isStatic && !e._dirtyId) return !1;
        e._dirtyId = 0;
        const n = this.syncUniformGroup(e);
        return e.buffer.update(), n
    }
    destroy() {
        this._syncFunctionHash = null
    }
}
const XD = {
    f32: 4,
    i32: 4,
    "vec2<f32>": 8,
    "vec3<f32>": 12,
    "vec4<f32>": 16,
    "vec2<i32>": 8,
    "vec3<i32>": 12,
    "vec4<i32>": 16,
    "mat2x2<f32>": 16 * 2,
    "mat3x3<f32>": 16 * 3,
    "mat4x4<f32>": 16 * 4
};

function Xle(t) {
    const e = t.map(s => ({
            data: s,
            offset: 0,
            size: 0
        })),
        n = 16;
    let r = 0,
        i = 0;
    for (let s = 0; s < e.length; s++) {
        const o = e[s];
        if (r = XD[o.data.type], !r) throw new Error(`Unknown type ${o.data.type}`);
        o.data.size > 1 && (r = Math.max(r, n) * o.data.size);
        const a = r === 12 ? 16 : r;
        o.size = r;
        const l = i % n;
        l > 0 && n - l < a ? i += (n - l) % 16 : i += (r - l % r) % r, o.offset = i, i += r
    }
    return i = Math.ceil(i / 16) * 16, {
        uboElements: e,
        size: i
    }
}
const ko = [{
    type: "mat3x3<f32>",
    test: t => t.value.a !== void 0,
    ubo: `
            var matrix = uv[name].toArray(true);
            data[offset] = matrix[0];
            data[offset + 1] = matrix[1];
            data[offset + 2] = matrix[2];
            data[offset + 4] = matrix[3];
            data[offset + 5] = matrix[4];
            data[offset + 6] = matrix[5];
            data[offset + 8] = matrix[6];
            data[offset + 9] = matrix[7];
            data[offset + 10] = matrix[8];
        `,
    uniform: `
            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));
        `
}, {
    type: "vec4<f32>",
    test: t => t.type === "vec4<f32>" && t.size === 1 && t.value.width !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
            data[offset + 2] = v.width;
            data[offset + 3] = v.height;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {
                cv[0] = v.x;
                cv[1] = v.y;
                cv[2] = v.width;
                cv[3] = v.height;
                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);
            }
        `
}, {
    type: "vec2<f32>",
    test: t => t.type === "vec2<f32>" && t.size === 1 && t.value.x !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.x;
            data[offset + 1] = v.y;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.x || cv[1] !== v.y) {
                cv[0] = v.x;
                cv[1] = v.y;
                gl.uniform2f(ud[name].location, v.x, v.y);
            }
        `
}, {
    type: "vec4<f32>",
    test: t => t.type === "vec4<f32>" && t.size === 1 && t.value.red !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
            data[offset + 3] = v.alpha;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                cv[3] = v.alpha;
                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);
            }
        `
}, {
    type: "vec3<f32>",
    test: t => t.type === "vec3<f32>" && t.size === 1 && t.value.red !== void 0,
    ubo: `
            v = uv[name];
            data[offset] = v.red;
            data[offset + 1] = v.green;
            data[offset + 2] = v.blue;
        `,
    uniform: `
            cv = ud[name].value;
            v = uv[name];
            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {
                cv[0] = v.red;
                cv[1] = v.green;
                cv[2] = v.blue;
                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);
            }
        `
}];

function qD(t, e, n, r) {
    const i = [`
        var v = null;
        var v2 = null;
        var t = 0;
        var index = 0;
        var name = null;
        var arrayOffset = null;
    `];
    let s = 0;
    for (let a = 0; a < t.length; a++) {
        const l = t[a],
            c = l.data.name;
        let u = !1,
            d = 0;
        for (let f = 0; f < ko.length; f++)
            if (ko[f].test(l.data)) {
                d = l.offset / 4, i.push(`name = "${c}";`, `offset += ${d-s};`, ko[f][e] || ko[f].ubo), u = !0;
                break
            }
        if (!u)
            if (l.data.size > 1) d = l.offset / 4, i.push(n(l, d - s));
            else {
                const f = r[l.data.type];
                d = l.offset / 4, i.push(`
                    v = uv.${c};
                    offset += ${d-s};
                    ${f};
                `)
            }
        s = d
    }
    const o = i.join(`
`);
    return new Function("uv", "data", "dataInt32", "offset", o)
}

function Ga(t, e) {
    return `
        for (let i = 0; i < ${t*e}; i++) {
            data[offset + (((i / ${t})|0) * 4) + (i % ${t})] = v[i];
        }
    `
}
const KD = {
        f32: `
        data[offset] = v;`,
        i32: `
        dataInt32[offset] = v;`,
        "vec2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];`,
        "vec3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];`,
        "vec4<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];`,
        "vec2<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];`,
        "vec3<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];`,
        "vec4<i32>": `
        dataInt32[offset] = v[0];
        dataInt32[offset + 1] = v[1];
        dataInt32[offset + 2] = v[2];
        dataInt32[offset + 3] = v[3];`,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 4] = v[2];
        data[offset + 5] = v[3];`,
        "mat3x3<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];
        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];`,
        "mat4x4<f32>": `
        for (let i = 0; i < 16; i++) {
            data[offset + i] = v[i];
        }`,
        "mat3x2<f32>": Ga(3, 2),
        "mat4x2<f32>": Ga(4, 2),
        "mat2x3<f32>": Ga(2, 3),
        "mat4x3<f32>": Ga(4, 3),
        "mat2x4<f32>": Ga(2, 4),
        "mat3x4<f32>": Ga(3, 4)
    },
    qle = { ...KD,
        "mat2x2<f32>": `
        data[offset] = v[0];
        data[offset + 1] = v[1];
        data[offset + 2] = v[2];
        data[offset + 3] = v[3];
    `
    };

function Kle(t, e) {
    const n = Math.max(XD[t.data.type] / 16, 1),
        r = t.data.value.length / t.data.size,
        i = (4 - r % 4) % 4,
        s = t.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
    return `
        v = uv.${t.data.name};
        offset += ${e};

        arrayOffset = offset;

        t = 0;

        for(var i=0; i < ${t.data.size*n}; i++)
        {
            for(var j = 0; j < ${r}; j++)
            {
                ${s}[arrayOffset++] = v[t++];
            }
            ${i!==0?`arrayOffset += ${i};`:""}
        }
    `
}

function Jle(t) {
    return qD(t, "uboStd40", Kle, KD)
}
class JD extends YD {
    constructor() {
        super({
            createUboElements: Xle,
            generateUboSync: Jle
        })
    }
}
JD.extension = {
    type: [G.WebGLSystem],
    name: "ubo"
};
class Zle {
    constructor() {
        this._clearColorCache = [0, 0, 0, 0], this._viewPortCache = new it
    }
    init(e, n) {
        this._renderer = e, this._renderTargetSystem = n, e.runners.contextChange.add(this)
    }
    contextChange() {
        this._clearColorCache = [0, 0, 0, 0], this._viewPortCache = new it
    }
    copyToTexture(e, n, r, i, s) {
        const o = this._renderTargetSystem,
            a = this._renderer,
            l = o.getGpuRenderTarget(e),
            c = a.gl;
        return this.finishRenderPass(e), c.bindFramebuffer(c.FRAMEBUFFER, l.resolveTargetFramebuffer), a.texture.bind(n, 0), c.copyTexSubImage2D(c.TEXTURE_2D, 0, s.x, s.y, r.x, r.y, i.width, i.height), n
    }
    startRenderPass(e, n = !0, r, i) {
        const s = this._renderTargetSystem,
            o = e.colorTexture,
            a = s.getGpuRenderTarget(e);
        let l = i.y;
        e.isRoot && (l = o.pixelHeight - i.height), e.colorTextures.forEach(d => {
            this._renderer.texture.unbind(d)
        });
        const c = this._renderer.gl;
        c.bindFramebuffer(c.FRAMEBUFFER, a.framebuffer);
        const u = this._viewPortCache;
        (u.x !== i.x || u.y !== l || u.width !== i.width || u.height !== i.height) && (u.x = i.x, u.y = l, u.width = i.width, u.height = i.height, c.viewport(i.x, l, i.width, i.height)), !a.depthStencilRenderBuffer && (e.stencil || e.depth) && this._initStencil(a), this.clear(e, n, r)
    }
    finishRenderPass(e) {
        const r = this._renderTargetSystem.getGpuRenderTarget(e);
        if (!r.msaa) return;
        const i = this._renderer.gl;
        i.bindFramebuffer(i.FRAMEBUFFER, r.resolveTargetFramebuffer), i.bindFramebuffer(i.READ_FRAMEBUFFER, r.framebuffer), i.blitFramebuffer(0, 0, r.width, r.height, 0, 0, r.width, r.height, i.COLOR_BUFFER_BIT, i.NEAREST), i.bindFramebuffer(i.FRAMEBUFFER, r.framebuffer)
    }
    initGpuRenderTarget(e) {
        const r = this._renderer.gl,
            i = new Yle;
        return e.colorTexture instanceof oi ? (this._renderer.context.ensureCanvasSize(e.colorTexture.resource), i.framebuffer = null, i) : (this._initColor(e, i), r.bindFramebuffer(r.FRAMEBUFFER, null), i)
    }
    destroyGpuRenderTarget(e) {
        const n = this._renderer.gl;
        e.framebuffer && (n.deleteFramebuffer(e.framebuffer), e.framebuffer = null), e.resolveTargetFramebuffer && (n.deleteFramebuffer(e.resolveTargetFramebuffer), e.resolveTargetFramebuffer = null), e.depthStencilRenderBuffer && (n.deleteRenderbuffer(e.depthStencilRenderBuffer), e.depthStencilRenderBuffer = null), e.msaaRenderBuffer.forEach(r => {
            n.deleteRenderbuffer(r)
        }), e.msaaRenderBuffer = null
    }
    clear(e, n, r) {
        if (!n) return;
        const i = this._renderTargetSystem;
        typeof n == "boolean" && (n = n ? Yn.ALL : Yn.NONE);
        const s = this._renderer.gl;
        if (n & Yn.COLOR) {
            r ? ? (r = i.defaultClearColor);
            const o = this._clearColorCache,
                a = r;
            (o[0] !== a[0] || o[1] !== a[1] || o[2] !== a[2] || o[3] !== a[3]) && (o[0] = a[0], o[1] = a[1], o[2] = a[2], o[3] = a[3], s.clearColor(a[0], a[1], a[2], a[3]))
        }
        s.clear(n)
    }
    resizeGpuRenderTarget(e) {
        if (e.isRoot) return;
        const r = this._renderTargetSystem.getGpuRenderTarget(e);
        this._resizeColor(e, r), (e.stencil || e.depth) && this._resizeStencil(r)
    }
    _initColor(e, n) {
        const r = this._renderer,
            i = r.gl,
            s = i.createFramebuffer();
        if (n.resolveTargetFramebuffer = s, i.bindFramebuffer(i.FRAMEBUFFER, s), n.width = e.colorTexture.source.pixelWidth, n.height = e.colorTexture.source.pixelHeight, e.colorTextures.forEach((o, a) => {
                const l = o.source;
                l.antialias && (r.context.supports.msaa ? n.msaa = !0 : Oe("[RenderTexture] Antialiasing on textures is not supported in WebGL1")), r.texture.bindSource(l, 0);
                const u = r.texture.getGlSource(l).texture;
                i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0 + a, 3553, u, 0)
            }), n.msaa) {
            const o = i.createFramebuffer();
            n.framebuffer = o, i.bindFramebuffer(i.FRAMEBUFFER, o), e.colorTextures.forEach((a, l) => {
                const c = i.createRenderbuffer();
                n.msaaRenderBuffer[l] = c
            })
        } else n.framebuffer = s;
        this._resizeColor(e, n)
    }
    _resizeColor(e, n) {
        const r = e.colorTexture.source;
        if (n.width = r.pixelWidth, n.height = r.pixelHeight, e.colorTextures.forEach((i, s) => {
                s !== 0 && i.source.resize(r.width, r.height, r._resolution)
            }), n.msaa) {
            const i = this._renderer,
                s = i.gl,
                o = n.framebuffer;
            s.bindFramebuffer(s.FRAMEBUFFER, o), e.colorTextures.forEach((a, l) => {
                const c = a.source;
                i.texture.bindSource(c, 0);
                const d = i.texture.getGlSource(c).internalFormat,
                    f = n.msaaRenderBuffer[l];
                s.bindRenderbuffer(s.RENDERBUFFER, f), s.renderbufferStorageMultisample(s.RENDERBUFFER, 4, d, c.pixelWidth, c.pixelHeight), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + l, s.RENDERBUFFER, f)
            })
        }
    }
    _initStencil(e) {
        if (e.framebuffer === null) return;
        const n = this._renderer.gl,
            r = n.createRenderbuffer();
        e.depthStencilRenderBuffer = r, n.bindRenderbuffer(n.RENDERBUFFER, r), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.RENDERBUFFER, r), this._resizeStencil(e)
    }
    _resizeStencil(e) {
        const n = this._renderer.gl;
        n.bindRenderbuffer(n.RENDERBUFFER, e.depthStencilRenderBuffer), e.msaa ? n.renderbufferStorageMultisample(n.RENDERBUFFER, 4, n.DEPTH24_STENCIL8, e.width, e.height) : n.renderbufferStorage(n.RENDERBUFFER, this._renderer.context.webGLVersion === 2 ? n.DEPTH24_STENCIL8 : n.DEPTH_STENCIL, e.width, e.height)
    }
    prerender(e) {
        const n = e.colorTexture.resource;
        this._renderer.context.multiView && oi.test(n) && this._renderer.context.ensureCanvasSize(n)
    }
    postrender(e) {
        if (this._renderer.context.multiView && oi.test(e.colorTexture.resource)) {
            const n = this._renderer.context.canvas,
                r = e.colorTexture;
            r.context2D.drawImage(n, 0, r.pixelHeight - n.height)
        }
    }
}

function Qle(t, e, n, r, i, s) {
    const o = s ? 1 : -1;
    return t.identity(), t.a = 1 / r * 2, t.d = o * (1 / i * 2), t.tx = -1 - e * t.a, t.ty = -o - n * t.d, t
}
const xc = new Map;

function ZD(t, e) {
    if (!xc.has(t)) {
        const n = new we({
                source: new oi({
                    resource: t,
                    ...e
                })
            }),
            r = () => {
                xc.get(t) === n && xc.delete(t)
            };
        n.once("destroy", r), n.source.once("destroy", r), xc.set(t, n)
    }
    return xc.get(t)
}

function ece(t) {
    const e = t.colorTexture.source.resource;
    return globalThis.HTMLCanvasElement && e instanceof HTMLCanvasElement && document.body.contains(e)
}
const QD = class e$ {
    constructor(e = {}) {
        if (this.uid = vt("renderTarget"), this.colorTextures = [], this.dirtyId = 0, this.isRoot = !1, this._size = new Float32Array(2), this._managedColorTextures = !1, e = { ...e$.defaultOptions,
                ...e
            }, this.stencil = e.stencil, this.depth = e.depth, this.isRoot = e.isRoot, typeof e.colorTextures == "number") {
            this._managedColorTextures = !0;
            for (let n = 0; n < e.colorTextures; n++) this.colorTextures.push(new Wt({
                width: e.width,
                height: e.height,
                resolution: e.resolution,
                antialias: e.antialias
            }))
        } else {
            this.colorTextures = [...e.colorTextures.map(r => r.source)];
            const n = this.colorTexture.source;
            this.resize(n.width, n.height, n._resolution)
        }
        this.colorTexture.source.on("resize", this.onSourceResize, this), (e.depthStencilTexture || this.stencil) && (e.depthStencilTexture instanceof we || e.depthStencilTexture instanceof Wt ? this.depthStencilTexture = e.depthStencilTexture.source : this.ensureDepthStencilTexture())
    }
    get size() {
        const e = this._size;
        return e[0] = this.pixelWidth, e[1] = this.pixelHeight, e
    }
    get width() {
        return this.colorTexture.source.width
    }
    get height() {
        return this.colorTexture.source.height
    }
    get pixelWidth() {
        return this.colorTexture.source.pixelWidth
    }
    get pixelHeight() {
        return this.colorTexture.source.pixelHeight
    }
    get resolution() {
        return this.colorTexture.source._resolution
    }
    get colorTexture() {
        return this.colorTextures[0]
    }
    onSourceResize(e) {
        this.resize(e.width, e.height, e._resolution, !0)
    }
    ensureDepthStencilTexture() {
        this.depthStencilTexture || (this.depthStencilTexture = new Wt({
            width: this.width,
            height: this.height,
            resolution: this.resolution,
            format: "depth24plus-stencil8",
            autoGenerateMipmaps: !1,
            antialias: !1,
            mipLevelCount: 1
        }))
    }
    resize(e, n, r = this.resolution, i = !1) {
        this.dirtyId++, this.colorTextures.forEach((s, o) => {
            i && o === 0 || s.source.resize(e, n, r)
        }), this.depthStencilTexture && this.depthStencilTexture.source.resize(e, n, r)
    }
    destroy() {
        this.colorTexture.source.off("resize", this.onSourceResize, this), this._managedColorTextures && this.colorTextures.forEach(e => {
            e.destroy()
        }), this.depthStencilTexture && (this.depthStencilTexture.destroy(), delete this.depthStencilTexture)
    }
};
QD.defaultOptions = {
    width: 0,
    height: 0,
    resolution: 1,
    colorTextures: 1,
    stencil: !1,
    depth: !1,
    antialias: !1,
    isRoot: !1
};
let B0 = QD;
class t$ {
    constructor(e) {
        this.rootViewPort = new it, this.viewport = new it, this.onRenderTargetChange = new DB("onRenderTargetChange"), this.projectionMatrix = new Te, this.defaultClearColor = [0, 0, 0, 0], this._renderSurfaceToRenderTargetHash = new Map, this._gpuRenderTargetHash = Object.create(null), this._renderTargetStack = [], this._renderer = e, e.renderableGC.addManagedHash(this, "_gpuRenderTargetHash")
    }
    finishRenderPass() {
        this.adaptor.finishRenderPass(this.renderTarget)
    }
    renderStart({
        target: e,
        clear: n,
        clearColor: r,
        frame: i
    }) {
        var s, o;
        this._renderTargetStack.length = 0, this.push(e, n, r, i), this.rootViewPort.copyFrom(this.viewport), this.rootRenderTarget = this.renderTarget, this.renderingToScreen = ece(this.rootRenderTarget), (o = (s = this.adaptor).prerender) == null || o.call(s, this.rootRenderTarget)
    }
    postrender() {
        var e, n;
        (n = (e = this.adaptor).postrender) == null || n.call(e, this.rootRenderTarget)
    }
    bind(e, n = !0, r, i) {
        const s = this.getRenderTarget(e),
            o = this.renderTarget !== s;
        this.renderTarget = s, this.renderSurface = e;
        const a = this.getGpuRenderTarget(s);
        (s.pixelWidth !== a.width || s.pixelHeight !== a.height) && (this.adaptor.resizeGpuRenderTarget(s), a.width = s.pixelWidth, a.height = s.pixelHeight);
        const l = s.colorTexture,
            c = this.viewport,
            u = l.pixelWidth,
            d = l.pixelHeight;
        if (!i && e instanceof we && (i = e.frame), i) {
            const f = l._resolution;
            c.x = i.x * f + .5 | 0, c.y = i.y * f + .5 | 0, c.width = i.width * f + .5 | 0, c.height = i.height * f + .5 | 0
        } else c.x = 0, c.y = 0, c.width = u, c.height = d;
        return Qle(this.projectionMatrix, 0, 0, c.width / l.resolution, c.height / l.resolution, !s.isRoot), this.adaptor.startRenderPass(s, n, r, c), o && this.onRenderTargetChange.emit(s), s
    }
    clear(e, n = Yn.ALL, r) {
        n && (e && (e = this.getRenderTarget(e)), this.adaptor.clear(e || this.renderTarget, n, r, this.viewport))
    }
    contextChange() {
        this._gpuRenderTargetHash = Object.create(null)
    }
    push(e, n = Yn.ALL, r, i) {
        const s = this.bind(e, n, r, i);
        return this._renderTargetStack.push({
            renderTarget: s,
            frame: i
        }), s
    }
    pop() {
        this._renderTargetStack.pop();
        const e = this._renderTargetStack[this._renderTargetStack.length - 1];
        this.bind(e.renderTarget, !1, null, e.frame)
    }
    getRenderTarget(e) {
        return e.isTexture && (e = e.source), this._renderSurfaceToRenderTargetHash.get(e) ? ? this._initRenderTarget(e)
    }
    copyToTexture(e, n, r, i, s) {
        r.x < 0 && (i.width += r.x, s.x -= r.x, r.x = 0), r.y < 0 && (i.height += r.y, s.y -= r.y, r.y = 0);
        const {
            pixelWidth: o,
            pixelHeight: a
        } = e;
        return i.width = Math.min(i.width, o - r.x), i.height = Math.min(i.height, a - r.y), this.adaptor.copyToTexture(e, n, r, i, s)
    }
    ensureDepthStencil() {
        this.renderTarget.stencil || (this.renderTarget.stencil = !0, this.adaptor.startRenderPass(this.renderTarget, !1, null, this.viewport))
    }
    destroy() {
        this._renderer = null, this._renderSurfaceToRenderTargetHash.forEach((e, n) => {
            e !== n && e.destroy()
        }), this._renderSurfaceToRenderTargetHash.clear(), this._gpuRenderTargetHash = Object.create(null)
    }
    _initRenderTarget(e) {
        let n = null;
        return oi.test(e) && (e = ZD(e).source), e instanceof B0 ? n = e : e instanceof Wt && (n = new B0({
            colorTextures: [e]
        }), e.source instanceof oi && (n.isRoot = !0), e.once("destroy", () => {
            n.destroy(), this._renderSurfaceToRenderTargetHash.delete(e);
            const r = this._gpuRenderTargetHash[n.uid];
            r && (this._gpuRenderTargetHash[n.uid] = null, this.adaptor.destroyGpuRenderTarget(r))
        })), this._renderSurfaceToRenderTargetHash.set(e, n), n
    }
    getGpuRenderTarget(e) {
        return this._gpuRenderTargetHash[e.uid] || (this._gpuRenderTargetHash[e.uid] = this.adaptor.initGpuRenderTarget(e))
    }
    resetState() {
        this.renderTarget = null, this.renderSurface = null
    }
}
class n$ extends t$ {
    constructor(e) {
        super(e), this.adaptor = new Zle, this.adaptor.init(e, this)
    }
}
n$.extension = {
    type: [G.WebGLSystem],
    name: "renderTarget"
};
class qx extends ir {
    constructor({
        buffer: e,
        offset: n,
        size: r
    }) {
        super(), this.uid = vt("buffer"), this._resourceType = "bufferResource", this._touched = 0, this._resourceId = vt("resource"), this._bufferResource = !0, this.destroyed = !1, this.buffer = e, this.offset = n | 0, this.size = r, this.buffer.on("change", this.onBufferChange, this)
    }
    onBufferChange() {
        this._resourceId = vt("resource"), this.emit("change", this)
    }
    destroy(e = !1) {
        this.destroyed = !0, e && this.buffer.destroy(), this.emit("change", this), this.buffer = null
    }
}

function tce(t, e) {
    const n = [],
        r = [`
        var g = s.groups;
        var sS = r.shader;
        var p = s.glProgram;
        var ugS = r.uniformGroup;
        var resources;
    `];
    let i = !1,
        s = 0;
    const o = e._getProgramData(t.glProgram);
    for (const l in t.groups) {
        const c = t.groups[l];
        n.push(`
            resources = g[${l}].resources;
        `);
        for (const u in c.resources) {
            const d = c.resources[u];
            if (d instanceof Pn)
                if (d.ubo) {
                    const f = t._uniformBindMap[l][Number(u)];
                    n.push(`
                        sS.bindUniformBlock(
                            resources[${u}],
                            '${f}',
                            ${t.glProgram._uniformBlockData[f].index}
                        );
                    `)
                } else n.push(`
                        ugS.updateUniformGroup(resources[${u}], p, sD);
                    `);
            else if (d instanceof qx) {
                const f = t._uniformBindMap[l][Number(u)];
                n.push(`
                    sS.bindUniformBlock(
                        resources[${u}],
                        '${f}',
                        ${t.glProgram._uniformBlockData[f].index}
                    );
                `)
            } else if (d instanceof Wt) {
                const f = t._uniformBindMap[l][u],
                    h = o.uniformData[f];
                h && (i || (i = !0, r.push(`
                        var tS = r.texture;
                        `)), e._gl.uniform1i(h.location, s), n.push(`
                        tS.bind(resources[${u}], ${s});
                    `), s++)
            }
        }
    }
    const a = [...r, ...n].join(`
`);
    return new Function("r", "s", "sD", a)
}
class nce {
    constructor(e, n) {
        this.program = e, this.uniformData = n, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBlockBindings = {}
    }
    destroy() {
        this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBlockBindings = null, this.program = null
    }
}

function MC(t, e, n) {
    const r = t.createShader(e);
    return t.shaderSource(r, n), t.compileShader(r), r
}

function Gg(t) {
    const e = new Array(t);
    for (let n = 0; n < e.length; n++) e[n] = !1;
    return e
}

function r$(t, e) {
    switch (t) {
        case "float":
            return 0;
        case "vec2":
            return new Float32Array(2 * e);
        case "vec3":
            return new Float32Array(3 * e);
        case "vec4":
            return new Float32Array(4 * e);
        case "int":
        case "uint":
        case "sampler2D":
        case "sampler2DArray":
            return 0;
        case "ivec2":
            return new Int32Array(2 * e);
        case "ivec3":
            return new Int32Array(3 * e);
        case "ivec4":
            return new Int32Array(4 * e);
        case "uvec2":
            return new Uint32Array(2 * e);
        case "uvec3":
            return new Uint32Array(3 * e);
        case "uvec4":
            return new Uint32Array(4 * e);
        case "bool":
            return !1;
        case "bvec2":
            return Gg(2 * e);
        case "bvec3":
            return Gg(3 * e);
        case "bvec4":
            return Gg(4 * e);
        case "mat2":
            return new Float32Array([1, 0, 0, 1]);
        case "mat3":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case "mat4":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
}
let wf = null;
const RC = {
        FLOAT: "float",
        FLOAT_VEC2: "vec2",
        FLOAT_VEC3: "vec3",
        FLOAT_VEC4: "vec4",
        INT: "int",
        INT_VEC2: "ivec2",
        INT_VEC3: "ivec3",
        INT_VEC4: "ivec4",
        UNSIGNED_INT: "uint",
        UNSIGNED_INT_VEC2: "uvec2",
        UNSIGNED_INT_VEC3: "uvec3",
        UNSIGNED_INT_VEC4: "uvec4",
        BOOL: "bool",
        BOOL_VEC2: "bvec2",
        BOOL_VEC3: "bvec3",
        BOOL_VEC4: "bvec4",
        FLOAT_MAT2: "mat2",
        FLOAT_MAT3: "mat3",
        FLOAT_MAT4: "mat4",
        SAMPLER_2D: "sampler2D",
        INT_SAMPLER_2D: "sampler2D",
        UNSIGNED_INT_SAMPLER_2D: "sampler2D",
        SAMPLER_CUBE: "samplerCube",
        INT_SAMPLER_CUBE: "samplerCube",
        UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
        SAMPLER_2D_ARRAY: "sampler2DArray",
        INT_SAMPLER_2D_ARRAY: "sampler2DArray",
        UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
    },
    rce = {
        float: "float32",
        vec2: "float32x2",
        vec3: "float32x3",
        vec4: "float32x4",
        int: "sint32",
        ivec2: "sint32x2",
        ivec3: "sint32x3",
        ivec4: "sint32x4",
        uint: "uint32",
        uvec2: "uint32x2",
        uvec3: "uint32x3",
        uvec4: "uint32x4",
        bool: "uint32",
        bvec2: "uint32x2",
        bvec3: "uint32x3",
        bvec4: "uint32x4"
    };

function i$(t, e) {
    if (!wf) {
        const n = Object.keys(RC);
        wf = {};
        for (let r = 0; r < n.length; ++r) {
            const i = n[r];
            wf[t[i]] = RC[i]
        }
    }
    return wf[e]
}

function ice(t, e) {
    const n = i$(t, e);
    return rce[n] || "float32"
}

function sce(t, e, n = !1) {
    const r = {},
        i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
    for (let o = 0; o < i; o++) {
        const a = e.getActiveAttrib(t, o);
        if (a.name.startsWith("gl_")) continue;
        const l = ice(e, a.type);
        r[a.name] = {
            location: 0,
            format: l,
            stride: Xs(l).stride,
            offset: 0,
            instance: !1,
            start: 0
        }
    }
    const s = Object.keys(r);
    if (n) {
        s.sort((o, a) => o > a ? 1 : -1);
        for (let o = 0; o < s.length; o++) r[s[o]].location = o, e.bindAttribLocation(t, o, s[o]);
        e.linkProgram(t)
    } else
        for (let o = 0; o < s.length; o++) r[s[o]].location = e.getAttribLocation(t, s[o]);
    return r
}

function oce(t, e) {
    if (!e.ACTIVE_UNIFORM_BLOCKS) return {};
    const n = {},
        r = e.getProgramParameter(t, e.ACTIVE_UNIFORM_BLOCKS);
    for (let i = 0; i < r; i++) {
        const s = e.getActiveUniformBlockName(t, i),
            o = e.getUniformBlockIndex(t, s),
            a = e.getActiveUniformBlockParameter(t, i, e.UNIFORM_BLOCK_DATA_SIZE);
        n[s] = {
            name: s,
            index: o,
            size: a
        }
    }
    return n
}

function ace(t, e) {
    const n = {},
        r = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < r; i++) {
        const s = e.getActiveUniform(t, i),
            o = s.name.replace(/\[.*?\]$/, ""),
            a = !!s.name.match(/\[.*?\]$/),
            l = i$(e, s.type);
        n[o] = {
            name: o,
            index: i,
            type: l,
            size: s.size,
            isArray: a,
            value: r$(l, s.size)
        }
    }
    return n
}

function kC(t, e) {
    const n = t.getShaderSource(e).split(`
`).map((c, u) => `${u}: ${c}`),
        r = t.getShaderInfoLog(e),
        i = r.split(`
`),
        s = {},
        o = i.map(c => parseFloat(c.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(c => c && !s[c] ? (s[c] = !0, !0) : !1),
        a = [""];
    o.forEach(c => {
        n[c - 1] = `%c${n[c-1]}%c`, a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
    });
    const l = n.join(`
`);
    a[0] = l, console.error(r), console.groupCollapsed("click to view full shader code"), console.warn(...a), console.groupEnd()
}

function lce(t, e, n, r) {
    t.getProgramParameter(e, t.LINK_STATUS) || (t.getShaderParameter(n, t.COMPILE_STATUS) || kC(t, n), t.getShaderParameter(r, t.COMPILE_STATUS) || kC(t, r), console.error("PixiJS Error: Could not initialize shader."), t.getProgramInfoLog(e) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(e)))
}

function cce(t, e) {
    const n = MC(t, t.VERTEX_SHADER, e.vertex),
        r = MC(t, t.FRAGMENT_SHADER, e.fragment),
        i = t.createProgram();
    t.attachShader(i, n), t.attachShader(i, r);
    const s = e.transformFeedbackVaryings;
    s && (typeof t.transformFeedbackVaryings != "function" ? Oe("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : t.transformFeedbackVaryings(i, s.names, s.bufferMode === "separate" ? t.SEPARATE_ATTRIBS : t.INTERLEAVED_ATTRIBS)), t.linkProgram(i), t.getProgramParameter(i, t.LINK_STATUS) || lce(t, i, n, r), e._attributeData = sce(i, t, !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertex)), e._uniformData = ace(i, t), e._uniformBlockData = oce(i, t), t.deleteShader(n), t.deleteShader(r);
    const o = {};
    for (const l in e._uniformData) {
        const c = e._uniformData[l];
        o[l] = {
            location: t.getUniformLocation(i, l),
            value: r$(c.type, c.size)
        }
    }
    return new nce(i, o)
}
const Ef = {
    textureCount: 0,
    blockIndex: 0
};
class s$ {
    constructor(e) {
        this._activeProgram = null, this._programDataHash = Object.create(null), this._shaderSyncFunctions = Object.create(null), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_programDataHash")
    }
    contextChange(e) {
        this._gl = e, this._programDataHash = Object.create(null), this._shaderSyncFunctions = Object.create(null), this._activeProgram = null
    }
    bind(e, n) {
        if (this._setProgram(e.glProgram), n) return;
        Ef.textureCount = 0, Ef.blockIndex = 0;
        let r = this._shaderSyncFunctions[e.glProgram._key];
        r || (r = this._shaderSyncFunctions[e.glProgram._key] = this._generateShaderSync(e, this)), this._renderer.buffer.nextBindBase(!!e.glProgram.transformFeedbackVaryings), r(this._renderer, e, Ef)
    }
    updateUniformGroup(e) {
        this._renderer.uniformGroup.updateUniformGroup(e, this._activeProgram, Ef)
    }
    bindUniformBlock(e, n, r = 0) {
        const i = this._renderer.buffer,
            s = this._getProgramData(this._activeProgram),
            o = e._bufferResource;
        o || this._renderer.ubo.updateUniformGroup(e);
        const a = e.buffer,
            l = i.updateBuffer(a),
            c = i.freeLocationForBufferBase(l);
        if (o) {
            const {
                offset: d,
                size: f
            } = e;
            d === 0 && f === a.data.byteLength ? i.bindBufferBase(l, c) : i.bindBufferRange(l, c, d)
        } else i.getLastBindBaseLocation(l) !== c && i.bindBufferBase(l, c);
        const u = this._activeProgram._uniformBlockData[n].index;
        s.uniformBlockBindings[r] !== c && (s.uniformBlockBindings[r] = c, this._renderer.gl.uniformBlockBinding(s.program, u, c))
    }
    _setProgram(e) {
        if (this._activeProgram === e) return;
        this._activeProgram = e;
        const n = this._getProgramData(e);
        this._gl.useProgram(n.program)
    }
    _getProgramData(e) {
        return this._programDataHash[e._key] || this._createProgramData(e)
    }
    _createProgramData(e) {
        const n = e._key;
        return this._programDataHash[n] = cce(this._gl, e), this._programDataHash[n]
    }
    destroy() {
        for (const e of Object.keys(this._programDataHash)) this._programDataHash[e].destroy(), this._programDataHash[e] = null;
        this._programDataHash = null
    }
    _generateShaderSync(e, n) {
        return tce(e, n)
    }
    resetState() {
        this._activeProgram = null
    }
}
s$.extension = {
    type: [G.WebGLSystem],
    name: "shader"
};
const uce = {
        f32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1f(location, v);
        }`,
        "vec2<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2f(location, v[0], v[1]);
        }`,
        "vec3<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3f(location, v[0], v[1], v[2]);
        }`,
        "vec4<f32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4f(location, v[0], v[1], v[2], v[3]);
        }`,
        i32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<i32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        u32: `if (cv !== v) {
            cu.value = v;
            gl.uniform1ui(location, v);
        }`,
        "vec2<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2ui(location, v[0], v[1]);
        }`,
        "vec3<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3ui(location, v[0], v[1], v[2]);
        }`,
        "vec4<u32>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
        }`,
        bool: `if (cv !== v) {
            cu.value = v;
            gl.uniform1i(location, v);
        }`,
        "vec2<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1]) {
            cv[0] = v[0];
            cv[1] = v[1];
            gl.uniform2i(location, v[0], v[1]);
        }`,
        "vec3<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            gl.uniform3i(location, v[0], v[1], v[2]);
        }`,
        "vec4<bool>": `if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3]) {
            cv[0] = v[0];
            cv[1] = v[1];
            cv[2] = v[2];
            cv[3] = v[3];
            gl.uniform4i(location, v[0], v[1], v[2], v[3]);
        }`,
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);"
    },
    dce = {
        f32: "gl.uniform1fv(location, v);",
        "vec2<f32>": "gl.uniform2fv(location, v);",
        "vec3<f32>": "gl.uniform3fv(location, v);",
        "vec4<f32>": "gl.uniform4fv(location, v);",
        "mat2x2<f32>": "gl.uniformMatrix2fv(location, false, v);",
        "mat3x3<f32>": "gl.uniformMatrix3fv(location, false, v);",
        "mat4x4<f32>": "gl.uniformMatrix4fv(location, false, v);",
        i32: "gl.uniform1iv(location, v);",
        "vec2<i32>": "gl.uniform2iv(location, v);",
        "vec3<i32>": "gl.uniform3iv(location, v);",
        "vec4<i32>": "gl.uniform4iv(location, v);",
        u32: "gl.uniform1iv(location, v);",
        "vec2<u32>": "gl.uniform2iv(location, v);",
        "vec3<u32>": "gl.uniform3iv(location, v);",
        "vec4<u32>": "gl.uniform4iv(location, v);",
        bool: "gl.uniform1iv(location, v);",
        "vec2<bool>": "gl.uniform2iv(location, v);",
        "vec3<bool>": "gl.uniform3iv(location, v);",
        "vec4<bool>": "gl.uniform4iv(location, v);"
    };

function fce(t, e) {
    const n = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
        var name = null;
    `];
    for (const r in t.uniforms) {
        if (!e[r]) {
            t.uniforms[r] instanceof Pn ? t.uniforms[r].ubo ? n.push(`
                        renderer.shader.bindUniformBlock(uv.${r}, "${r}");
                    `) : n.push(`
                        renderer.shader.updateUniformGroup(uv.${r});
                    `) : t.uniforms[r] instanceof qx && n.push(`
                        renderer.shader.bindBufferResource(uv.${r}, "${r}");
                    `);
            continue
        }
        const i = t.uniformStructures[r];
        let s = !1;
        for (let o = 0; o < ko.length; o++) {
            const a = ko[o];
            if (i.type === a.type && a.test(i)) {
                n.push(`name = "${r}";`, ko[o].uniform), s = !0;
                break
            }
        }
        if (!s) {
            const a = (i.size === 1 ? uce : dce)[i.type].replace("location", `ud["${r}"].location`);
            n.push(`
            cu = ud["${r}"];
            cv = cu.value;
            v = uv["${r}"];
            ${a};`)
        }
    }
    return new Function("ud", "uv", "renderer", "syncData", n.join(`
`))
}
class o$ {
    constructor(e) {
        this._cache = {}, this._uniformGroupSyncHash = {}, this._renderer = e, this.gl = null, this._cache = {}
    }
    contextChange(e) {
        this.gl = e
    }
    updateUniformGroup(e, n, r) {
        const i = this._renderer.shader._getProgramData(n);
        (!e.isStatic || e._dirtyId !== i.uniformDirtyGroups[e.uid]) && (i.uniformDirtyGroups[e.uid] = e._dirtyId, this._getUniformSyncFunction(e, n)(i.uniformData, e.uniforms, this._renderer, r))
    }
    _getUniformSyncFunction(e, n) {
        var r;
        return ((r = this._uniformGroupSyncHash[e._signature]) == null ? void 0 : r[n._key]) || this._createUniformSyncFunction(e, n)
    }
    _createUniformSyncFunction(e, n) {
        const r = this._uniformGroupSyncHash[e._signature] || (this._uniformGroupSyncHash[e._signature] = {}),
            i = this._getSignature(e, n._uniformData, "u");
        return this._cache[i] || (this._cache[i] = this._generateUniformsSync(e, n._uniformData)), r[n._key] = this._cache[i], r[n._key]
    }
    _generateUniformsSync(e, n) {
        return fce(e, n)
    }
    _getSignature(e, n, r) {
        const i = e.uniforms,
            s = [`${r}-`];
        for (const o in i) s.push(o), n[o] && s.push(n[o].type);
        return s.join("-")
    }
    destroy() {
        this._renderer = null, this._cache = null
    }
}
o$.extension = {
    type: [G.WebGLSystem],
    name: "uniformGroup"
};

function hce(t) {
    const e = {};
    if (e.normal = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e.add = [t.ONE, t.ONE], e.multiply = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e.screen = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e.none = [0, 0], e["normal-npm"] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], e["add-npm"] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE], e["screen-npm"] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], e.erase = [t.ZERO, t.ONE_MINUS_SRC_ALPHA], !(t instanceof Ge.get().getWebGLRenderingContext())) e.min = [t.ONE, t.ONE, t.ONE, t.ONE, t.MIN, t.MIN], e.max = [t.ONE, t.ONE, t.ONE, t.ONE, t.MAX, t.MAX];
    else {
        const r = t.getExtension("EXT_blend_minmax");
        r && (e.min = [t.ONE, t.ONE, t.ONE, t.ONE, r.MIN_EXT, r.MIN_EXT], e.max = [t.ONE, t.ONE, t.ONE, t.ONE, r.MAX_EXT, r.MAX_EXT])
    }
    return e
}
const pce = 0,
    mce = 1,
    gce = 2,
    yce = 3,
    vce = 4,
    _ce = 5,
    a$ = class D0 {
        constructor(e) {
            this._invertFrontFace = !1, this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = "none", this._blendEq = !1, this.map = [], this.map[pce] = this.setBlend, this.map[mce] = this.setOffset, this.map[gce] = this.setCullFace, this.map[yce] = this.setDepthTest, this.map[vce] = this.setFrontFace, this.map[_ce] = this.setDepthMask, this.checks = [], this.defaultState = Fr.for2d(), e.renderTarget.onRenderTargetChange.add(this)
        }
        onRenderTargetChange(e) {
            this._invertFrontFace = !e.isRoot, this._cullFace ? this.setFrontFace(this._frontFace) : this._frontFaceDirty = !0
        }
        contextChange(e) {
            this.gl = e, this.blendModesMap = hce(e), this.resetState()
        }
        set(e) {
            if (e || (e = this.defaultState), this.stateId !== e.data) {
                let n = this.stateId ^ e.data,
                    r = 0;
                for (; n;) n & 1 && this.map[r].call(this, !!(e.data & 1 << r)), n >>= 1, r++;
                this.stateId = e.data
            }
            for (let n = 0; n < this.checks.length; n++) this.checks[n](this, e)
        }
        forceState(e) {
            e || (e = this.defaultState);
            for (let n = 0; n < this.map.length; n++) this.map[n].call(this, !!(e.data & 1 << n));
            for (let n = 0; n < this.checks.length; n++) this.checks[n](this, e);
            this.stateId = e.data
        }
        setBlend(e) {
            this._updateCheck(D0._checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND)
        }
        setOffset(e) {
            this._updateCheck(D0._checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
        }
        setDepthTest(e) {
            this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST)
        }
        setDepthMask(e) {
            this.gl.depthMask(e)
        }
        setCullFace(e) {
            this._cullFace = e, this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE), this._cullFace && this._frontFaceDirty && this.setFrontFace(this._frontFace)
        }
        setFrontFace(e) {
            this._frontFace = e, this._frontFaceDirty = !1;
            const n = this._invertFrontFace ? !e : e;
            this._glFrontFace !== n && (this._glFrontFace = n, this.gl.frontFace(this.gl[n ? "CW" : "CCW"]))
        }
        setBlendMode(e) {
            if (this.blendModesMap[e] || (e = "normal"), e === this.blendMode) return;
            this.blendMode = e;
            const n = this.blendModesMap[e],
                r = this.gl;
            n.length === 2 ? r.blendFunc(n[0], n[1]) : r.blendFuncSeparate(n[0], n[1], n[2], n[3]), n.length === 6 ? (this._blendEq = !0, r.blendEquationSeparate(n[4], n[5])) : this._blendEq && (this._blendEq = !1, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD))
        }
        setPolygonOffset(e, n) {
            this.gl.polygonOffset(e, n)
        }
        resetState() {
            this._glFrontFace = !1, this._frontFace = !1, this._cullFace = !1, this._frontFaceDirty = !1, this._invertFrontFace = !1, this.gl.frontFace(this.gl.CCW), this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = "", this.setBlendMode("normal")
        }
        _updateCheck(e, n) {
            const r = this.checks.indexOf(e);
            n && r === -1 ? this.checks.push(e) : !n && r !== -1 && this.checks.splice(r, 1)
        }
        static _checkBlendMode(e, n) {
            e.setBlendMode(n.blendMode)
        }
        static _checkPolygonOffset(e, n) {
            e.setPolygonOffset(1, n.polygonOffset)
        }
        destroy() {
            this.gl = null, this.checks.length = 0
        }
    };
a$.extension = {
    type: [G.WebGLSystem],
    name: "state"
};
let bce = a$;
class xce {
    constructor(e) {
        this.target = UD.TEXTURE_2D, this.texture = e, this.width = -1, this.height = -1, this.type = Qe.UNSIGNED_BYTE, this.internalFormat = k0.RGBA, this.format = k0.RGBA, this.samplerType = 0
    }
}
const wce = {
        id: "buffer",
        upload(t, e, n) {
            e.width === t.width || e.height === t.height ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, t.width, t.height, e.format, e.type, t.resource) : n.texImage2D(e.target, 0, e.internalFormat, t.width, t.height, 0, e.format, e.type, t.resource), e.width = t.width, e.height = t.height
        }
    },
    Ece = {
        "bc1-rgba-unorm": !0,
        "bc1-rgba-unorm-srgb": !0,
        "bc2-rgba-unorm": !0,
        "bc2-rgba-unorm-srgb": !0,
        "bc3-rgba-unorm": !0,
        "bc3-rgba-unorm-srgb": !0,
        "bc4-r-unorm": !0,
        "bc4-r-snorm": !0,
        "bc5-rg-unorm": !0,
        "bc5-rg-snorm": !0,
        "bc6h-rgb-ufloat": !0,
        "bc6h-rgb-float": !0,
        "bc7-rgba-unorm": !0,
        "bc7-rgba-unorm-srgb": !0,
        "etc2-rgb8unorm": !0,
        "etc2-rgb8unorm-srgb": !0,
        "etc2-rgb8a1unorm": !0,
        "etc2-rgb8a1unorm-srgb": !0,
        "etc2-rgba8unorm": !0,
        "etc2-rgba8unorm-srgb": !0,
        "eac-r11unorm": !0,
        "eac-r11snorm": !0,
        "eac-rg11unorm": !0,
        "eac-rg11snorm": !0,
        "astc-4x4-unorm": !0,
        "astc-4x4-unorm-srgb": !0,
        "astc-5x4-unorm": !0,
        "astc-5x4-unorm-srgb": !0,
        "astc-5x5-unorm": !0,
        "astc-5x5-unorm-srgb": !0,
        "astc-6x5-unorm": !0,
        "astc-6x5-unorm-srgb": !0,
        "astc-6x6-unorm": !0,
        "astc-6x6-unorm-srgb": !0,
        "astc-8x5-unorm": !0,
        "astc-8x5-unorm-srgb": !0,
        "astc-8x6-unorm": !0,
        "astc-8x6-unorm-srgb": !0,
        "astc-8x8-unorm": !0,
        "astc-8x8-unorm-srgb": !0,
        "astc-10x5-unorm": !0,
        "astc-10x5-unorm-srgb": !0,
        "astc-10x6-unorm": !0,
        "astc-10x6-unorm-srgb": !0,
        "astc-10x8-unorm": !0,
        "astc-10x8-unorm-srgb": !0,
        "astc-10x10-unorm": !0,
        "astc-10x10-unorm-srgb": !0,
        "astc-12x10-unorm": !0,
        "astc-12x10-unorm-srgb": !0,
        "astc-12x12-unorm": !0,
        "astc-12x12-unorm-srgb": !0
    },
    Sce = {
        id: "compressed",
        upload(t, e, n) {
            n.pixelStorei(n.UNPACK_ALIGNMENT, 4);
            let r = t.pixelWidth,
                i = t.pixelHeight;
            const s = !!Ece[t.format];
            for (let o = 0; o < t.resource.length; o++) {
                const a = t.resource[o];
                s ? n.compressedTexImage2D(n.TEXTURE_2D, o, e.internalFormat, r, i, 0, a) : n.texImage2D(n.TEXTURE_2D, o, e.internalFormat, r, i, 0, e.format, e.type, a), r = Math.max(r >> 1, 1), i = Math.max(i >> 1, 1)
            }
        }
    },
    l$ = {
        id: "image",
        upload(t, e, n, r) {
            const i = e.width,
                s = e.height,
                o = t.pixelWidth,
                a = t.pixelHeight,
                l = t.resourceWidth,
                c = t.resourceHeight;
            l < o || c < a ? ((i !== o || s !== a) && n.texImage2D(e.target, 0, e.internalFormat, o, a, 0, e.format, e.type, null), r === 2 ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, l, c, e.format, e.type, t.resource) : n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, e.format, e.type, t.resource)) : i === o && s === a ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, e.format, e.type, t.resource) : r === 2 ? n.texImage2D(e.target, 0, e.internalFormat, o, a, 0, e.format, e.type, t.resource) : n.texImage2D(e.target, 0, e.internalFormat, e.format, e.type, t.resource), e.width = o, e.height = a
        }
    },
    Tce = {
        id: "video",
        upload(t, e, n, r) {
            if (!t.isValid) {
                n.texImage2D(e.target, 0, e.internalFormat, 1, 1, 0, e.format, e.type, null);
                return
            }
            l$.upload(t, e, n, r)
        }
    },
    BC = {
        linear: 9729,
        nearest: 9728
    },
    Cce = {
        linear: {
            linear: 9987,
            nearest: 9985
        },
        nearest: {
            linear: 9986,
            nearest: 9984
        }
    },
    Hg = {
        "clamp-to-edge": 33071,
        repeat: 10497,
        "mirror-repeat": 33648
    },
    Pce = {
        never: 512,
        less: 513,
        equal: 514,
        "less-equal": 515,
        greater: 516,
        "not-equal": 517,
        "greater-equal": 518,
        always: 519
    };

function DC(t, e, n, r, i, s, o, a) {
    const l = s;
    if (!a || t.addressModeU !== "repeat" || t.addressModeV !== "repeat" || t.addressModeW !== "repeat") {
        const c = Hg[o ? "clamp-to-edge" : t.addressModeU],
            u = Hg[o ? "clamp-to-edge" : t.addressModeV],
            d = Hg[o ? "clamp-to-edge" : t.addressModeW];
        e[i](l, e.TEXTURE_WRAP_S, c), e[i](l, e.TEXTURE_WRAP_T, u), e.TEXTURE_WRAP_R && e[i](l, e.TEXTURE_WRAP_R, d)
    }
    if ((!a || t.magFilter !== "linear") && e[i](l, e.TEXTURE_MAG_FILTER, BC[t.magFilter]), n) {
        if (!a || t.mipmapFilter !== "linear") {
            const c = Cce[t.minFilter][t.mipmapFilter];
            e[i](l, e.TEXTURE_MIN_FILTER, c)
        }
    } else e[i](l, e.TEXTURE_MIN_FILTER, BC[t.minFilter]);
    if (r && t.maxAnisotropy > 1) {
        const c = Math.min(t.maxAnisotropy, e.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
        e[i](l, r.TEXTURE_MAX_ANISOTROPY_EXT, c)
    }
    t.compare && e[i](l, e.TEXTURE_COMPARE_FUNC, Pce[t.compare])
}

function Ace(t) {
    return {
        r8unorm: t.RED,
        r8snorm: t.RED,
        r8uint: t.RED,
        r8sint: t.RED,
        r16uint: t.RED,
        r16sint: t.RED,
        r16float: t.RED,
        rg8unorm: t.RG,
        rg8snorm: t.RG,
        rg8uint: t.RG,
        rg8sint: t.RG,
        r32uint: t.RED,
        r32sint: t.RED,
        r32float: t.RED,
        rg16uint: t.RG,
        rg16sint: t.RG,
        rg16float: t.RG,
        rgba8unorm: t.RGBA,
        "rgba8unorm-srgb": t.RGBA,
        rgba8snorm: t.RGBA,
        rgba8uint: t.RGBA,
        rgba8sint: t.RGBA,
        bgra8unorm: t.RGBA,
        "bgra8unorm-srgb": t.RGBA,
        rgb9e5ufloat: t.RGB,
        rgb10a2unorm: t.RGBA,
        rg11b10ufloat: t.RGB,
        rg32uint: t.RG,
        rg32sint: t.RG,
        rg32float: t.RG,
        rgba16uint: t.RGBA,
        rgba16sint: t.RGBA,
        rgba16float: t.RGBA,
        rgba32uint: t.RGBA,
        rgba32sint: t.RGBA,
        rgba32float: t.RGBA,
        stencil8: t.STENCIL_INDEX8,
        depth16unorm: t.DEPTH_COMPONENT,
        depth24plus: t.DEPTH_COMPONENT,
        "depth24plus-stencil8": t.DEPTH_STENCIL,
        depth32float: t.DEPTH_COMPONENT,
        "depth32float-stencil8": t.DEPTH_STENCIL
    }
}

function Oce(t, e) {
    let n = {},
        r = t.RGBA;
    return t instanceof Ge.get().getWebGLRenderingContext() ? e.srgb && (n = {
        "rgba8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT,
        "bgra8unorm-srgb": e.srgb.SRGB8_ALPHA8_EXT
    }) : (n = {
        "rgba8unorm-srgb": t.SRGB8_ALPHA8,
        "bgra8unorm-srgb": t.SRGB8_ALPHA8
    }, r = t.RGBA8), {
        r8unorm: t.R8,
        r8snorm: t.R8_SNORM,
        r8uint: t.R8UI,
        r8sint: t.R8I,
        r16uint: t.R16UI,
        r16sint: t.R16I,
        r16float: t.R16F,
        rg8unorm: t.RG8,
        rg8snorm: t.RG8_SNORM,
        rg8uint: t.RG8UI,
        rg8sint: t.RG8I,
        r32uint: t.R32UI,
        r32sint: t.R32I,
        r32float: t.R32F,
        rg16uint: t.RG16UI,
        rg16sint: t.RG16I,
        rg16float: t.RG16F,
        rgba8unorm: t.RGBA,
        ...n,
        rgba8snorm: t.RGBA8_SNORM,
        rgba8uint: t.RGBA8UI,
        rgba8sint: t.RGBA8I,
        bgra8unorm: r,
        rgb9e5ufloat: t.RGB9_E5,
        rgb10a2unorm: t.RGB10_A2,
        rg11b10ufloat: t.R11F_G11F_B10F,
        rg32uint: t.RG32UI,
        rg32sint: t.RG32I,
        rg32float: t.RG32F,
        rgba16uint: t.RGBA16UI,
        rgba16sint: t.RGBA16I,
        rgba16float: t.RGBA16F,
        rgba32uint: t.RGBA32UI,
        rgba32sint: t.RGBA32I,
        rgba32float: t.RGBA32F,
        stencil8: t.STENCIL_INDEX8,
        depth16unorm: t.DEPTH_COMPONENT16,
        depth24plus: t.DEPTH_COMPONENT24,
        "depth24plus-stencil8": t.DEPTH24_STENCIL8,
        depth32float: t.DEPTH_COMPONENT32F,
        "depth32float-stencil8": t.DEPTH32F_STENCIL8,
        ...e.s3tc ? {
            "bc1-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT1_EXT,
            "bc2-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT3_EXT,
            "bc3-rgba-unorm": e.s3tc.COMPRESSED_RGBA_S3TC_DXT5_EXT
        } : {},
        ...e.s3tc_sRGB ? {
            "bc1-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
            "bc2-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
            "bc3-rgba-unorm-srgb": e.s3tc_sRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        } : {},
        ...e.rgtc ? {
            "bc4-r-unorm": e.rgtc.COMPRESSED_RED_RGTC1_EXT,
            "bc4-r-snorm": e.rgtc.COMPRESSED_SIGNED_RED_RGTC1_EXT,
            "bc5-rg-unorm": e.rgtc.COMPRESSED_RED_GREEN_RGTC2_EXT,
            "bc5-rg-snorm": e.rgtc.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
        } : {},
        ...e.bptc ? {
            "bc6h-rgb-float": e.bptc.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
            "bc6h-rgb-ufloat": e.bptc.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
            "bc7-rgba-unorm": e.bptc.COMPRESSED_RGBA_BPTC_UNORM_EXT,
            "bc7-rgba-unorm-srgb": e.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
        } : {},
        ...e.etc ? {
            "etc2-rgb8unorm": e.etc.COMPRESSED_RGB8_ETC2,
            "etc2-rgb8unorm-srgb": e.etc.COMPRESSED_SRGB8_ETC2,
            "etc2-rgb8a1unorm": e.etc.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2,
            "etc2-rgb8a1unorm-srgb": e.etc.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2,
            "etc2-rgba8unorm": e.etc.COMPRESSED_RGBA8_ETC2_EAC,
            "etc2-rgba8unorm-srgb": e.etc.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC,
            "eac-r11unorm": e.etc.COMPRESSED_R11_EAC,
            "eac-rg11unorm": e.etc.COMPRESSED_SIGNED_RG11_EAC
        } : {},
        ...e.astc ? {
            "astc-4x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_4x4_KHR,
            "astc-4x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR,
            "astc-5x4-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x4_KHR,
            "astc-5x4-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR,
            "astc-5x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_5x5_KHR,
            "astc-5x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR,
            "astc-6x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x5_KHR,
            "astc-6x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR,
            "astc-6x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_6x6_KHR,
            "astc-6x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR,
            "astc-8x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x5_KHR,
            "astc-8x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR,
            "astc-8x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x6_KHR,
            "astc-8x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR,
            "astc-8x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_8x8_KHR,
            "astc-8x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR,
            "astc-10x5-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x5_KHR,
            "astc-10x5-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR,
            "astc-10x6-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x6_KHR,
            "astc-10x6-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR,
            "astc-10x8-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x8_KHR,
            "astc-10x8-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR,
            "astc-10x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_10x10_KHR,
            "astc-10x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR,
            "astc-12x10-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x10_KHR,
            "astc-12x10-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR,
            "astc-12x12-unorm": e.astc.COMPRESSED_RGBA_ASTC_12x12_KHR,
            "astc-12x12-unorm-srgb": e.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
        } : {}
    }
}

function Ice(t) {
    return {
        r8unorm: t.UNSIGNED_BYTE,
        r8snorm: t.BYTE,
        r8uint: t.UNSIGNED_BYTE,
        r8sint: t.BYTE,
        r16uint: t.UNSIGNED_SHORT,
        r16sint: t.SHORT,
        r16float: t.HALF_FLOAT,
        rg8unorm: t.UNSIGNED_BYTE,
        rg8snorm: t.BYTE,
        rg8uint: t.UNSIGNED_BYTE,
        rg8sint: t.BYTE,
        r32uint: t.UNSIGNED_INT,
        r32sint: t.INT,
        r32float: t.FLOAT,
        rg16uint: t.UNSIGNED_SHORT,
        rg16sint: t.SHORT,
        rg16float: t.HALF_FLOAT,
        rgba8unorm: t.UNSIGNED_BYTE,
        "rgba8unorm-srgb": t.UNSIGNED_BYTE,
        rgba8snorm: t.BYTE,
        rgba8uint: t.UNSIGNED_BYTE,
        rgba8sint: t.BYTE,
        bgra8unorm: t.UNSIGNED_BYTE,
        "bgra8unorm-srgb": t.UNSIGNED_BYTE,
        rgb9e5ufloat: t.UNSIGNED_INT_5_9_9_9_REV,
        rgb10a2unorm: t.UNSIGNED_INT_2_10_10_10_REV,
        rg11b10ufloat: t.UNSIGNED_INT_10F_11F_11F_REV,
        rg32uint: t.UNSIGNED_INT,
        rg32sint: t.INT,
        rg32float: t.FLOAT,
        rgba16uint: t.UNSIGNED_SHORT,
        rgba16sint: t.SHORT,
        rgba16float: t.HALF_FLOAT,
        rgba32uint: t.UNSIGNED_INT,
        rgba32sint: t.INT,
        rgba32float: t.FLOAT,
        stencil8: t.UNSIGNED_BYTE,
        depth16unorm: t.UNSIGNED_SHORT,
        depth24plus: t.UNSIGNED_INT,
        "depth24plus-stencil8": t.UNSIGNED_INT_24_8,
        depth32float: t.FLOAT,
        "depth32float-stencil8": t.FLOAT_32_UNSIGNED_INT_24_8_REV
    }
}
const Mce = 4;
class c$ {
    constructor(e) {
        this.managedTextures = [], this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundTextures = [], this._activeTextureLocation = -1, this._boundSamplers = Object.create(null), this._uploads = {
            image: l$,
            buffer: wce,
            video: Tce,
            compressed: Sce
        }, this._premultiplyAlpha = !1, this._useSeparateSamplers = !1, this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_glTextures"), this._renderer.renderableGC.addManagedHash(this, "_glSamplers")
    }
    contextChange(e) {
        this._gl = e, this._mapFormatToInternalFormat || (this._mapFormatToInternalFormat = Oce(e, this._renderer.context.extensions), this._mapFormatToType = Ice(e), this._mapFormatToFormat = Ace(e)), this._glTextures = Object.create(null), this._glSamplers = Object.create(null), this._boundSamplers = Object.create(null), this._premultiplyAlpha = !1;
        for (let n = 0; n < 16; n++) this.bind(we.EMPTY, n)
    }
    initSource(e) {
        this.bind(e)
    }
    bind(e, n = 0) {
        const r = e.source;
        e ? (this.bindSource(r, n), this._useSeparateSamplers && this._bindSampler(r.style, n)) : (this.bindSource(null, n), this._useSeparateSamplers && this._bindSampler(null, n))
    }
    bindSource(e, n = 0) {
        const r = this._gl;
        if (e._touched = this._renderer.textureGC.count, this._boundTextures[n] !== e) {
            this._boundTextures[n] = e, this._activateLocation(n), e || (e = we.EMPTY.source);
            const i = this.getGlSource(e);
            r.bindTexture(i.target, i.texture)
        }
    }
    _bindSampler(e, n = 0) {
        const r = this._gl;
        if (!e) {
            this._boundSamplers[n] = null, r.bindSampler(n, null);
            return
        }
        const i = this._getGlSampler(e);
        this._boundSamplers[n] !== i && (this._boundSamplers[n] = i, r.bindSampler(n, i))
    }
    unbind(e) {
        const n = e.source,
            r = this._boundTextures,
            i = this._gl;
        for (let s = 0; s < r.length; s++)
            if (r[s] === n) {
                this._activateLocation(s);
                const o = this.getGlSource(n);
                i.bindTexture(o.target, null), r[s] = null
            }
    }
    _activateLocation(e) {
        this._activeTextureLocation !== e && (this._activeTextureLocation = e, this._gl.activeTexture(this._gl.TEXTURE0 + e))
    }
    _initSource(e) {
        const n = this._gl,
            r = new xce(n.createTexture());
        if (r.type = this._mapFormatToType[e.format], r.internalFormat = this._mapFormatToInternalFormat[e.format], r.format = this._mapFormatToFormat[e.format], e.autoGenerateMipmaps && (this._renderer.context.supports.nonPowOf2mipmaps || e.isPowerOfTwo)) {
            const i = Math.max(e.width, e.height);
            e.mipLevelCount = Math.floor(Math.log2(i)) + 1
        }
        return this._glTextures[e.uid] = r, this.managedTextures.includes(e) || (e.on("update", this.onSourceUpdate, this), e.on("resize", this.onSourceUpdate, this), e.on("styleChange", this.onStyleChange, this), e.on("destroy", this.onSourceDestroy, this), e.on("unload", this.onSourceUnload, this), e.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(e)), this.onSourceUpdate(e), this.updateStyle(e, !1), r
    }
    onStyleChange(e) {
        this.updateStyle(e, !1)
    }
    updateStyle(e, n) {
        const r = this._gl,
            i = this.getGlSource(e);
        r.bindTexture(r.TEXTURE_2D, i.texture), this._boundTextures[this._activeTextureLocation] = e, DC(e.style, r, e.mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "texParameteri", r.TEXTURE_2D, !this._renderer.context.supports.nonPowOf2wrapping && !e.isPowerOfTwo, n)
    }
    onSourceUnload(e) {
        const n = this._glTextures[e.uid];
        n && (this.unbind(e), this._glTextures[e.uid] = null, this._gl.deleteTexture(n.texture))
    }
    onSourceUpdate(e) {
        const n = this._gl,
            r = this.getGlSource(e);
        n.bindTexture(n.TEXTURE_2D, r.texture), this._boundTextures[this._activeTextureLocation] = e;
        const i = e.alphaMode === "premultiply-alpha-on-upload";
        this._premultiplyAlpha !== i && (this._premultiplyAlpha = i, n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i)), this._uploads[e.uploadMethodId] ? this._uploads[e.uploadMethodId].upload(e, r, n, this._renderer.context.webGLVersion) : n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, e.pixelWidth, e.pixelHeight, 0, n.RGBA, n.UNSIGNED_BYTE, null), e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e, !1)
    }
    onUpdateMipmaps(e, n = !0) {
        n && this.bindSource(e, 0);
        const r = this.getGlSource(e);
        this._gl.generateMipmap(r.target)
    }
    onSourceDestroy(e) {
        e.off("destroy", this.onSourceDestroy, this), e.off("update", this.onSourceUpdate, this), e.off("resize", this.onSourceUpdate, this), e.off("unload", this.onSourceUnload, this), e.off("styleChange", this.onStyleChange, this), e.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(e), 1), this.onSourceUnload(e)
    }
    _initSampler(e) {
        const n = this._gl,
            r = this._gl.createSampler();
        return this._glSamplers[e._resourceId] = r, DC(e, n, this._boundTextures[this._activeTextureLocation].mipLevelCount > 1, this._renderer.context.extensions.anisotropicFiltering, "samplerParameteri", r, !1, !0), this._glSamplers[e._resourceId]
    }
    _getGlSampler(e) {
        return this._glSamplers[e._resourceId] || this._initSampler(e)
    }
    getGlSource(e) {
        return this._glTextures[e.uid] || this._initSource(e)
    }
    generateCanvas(e) {
        const {
            pixels: n,
            width: r,
            height: i
        } = this.getPixels(e), s = Ge.get().createCanvas();
        s.width = r, s.height = i;
        const o = s.getContext("2d");
        if (o) {
            const a = o.createImageData(r, i);
            a.data.set(n), o.putImageData(a, 0, 0)
        }
        return s
    }
    getPixels(e) {
        const n = e.source.resolution,
            r = e.frame,
            i = Math.max(Math.round(r.width * n), 1),
            s = Math.max(Math.round(r.height * n), 1),
            o = new Uint8Array(Mce * i * s),
            a = this._renderer,
            l = a.renderTarget.getRenderTarget(e),
            c = a.renderTarget.getGpuRenderTarget(l),
            u = a.gl;
        return u.bindFramebuffer(u.FRAMEBUFFER, c.resolveTargetFramebuffer), u.readPixels(Math.round(r.x * n), Math.round(r.y * n), i, s, u.RGBA, u.UNSIGNED_BYTE, o), {
            pixels: new Uint8ClampedArray(o.buffer),
            width: i,
            height: s
        }
    }
    destroy() {
        this.managedTextures.slice().forEach(e => this.onSourceDestroy(e)), this.managedTextures = null, this._renderer = null
    }
    resetState() {
        this._activeTextureLocation = -1, this._boundTextures.fill(we.EMPTY.source), this._boundSamplers = Object.create(null);
        const e = this._gl;
        this._premultiplyAlpha = !1, e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this._premultiplyAlpha)
    }
}
c$.extension = {
    type: [G.WebGLSystem],
    name: "texture"
};
class u$ {
    contextChange(e) {
        const n = new Pn({
                uColor: {
                    value: new Float32Array([1, 1, 1, 1]),
                    type: "vec4<f32>"
                },
                uTransformMatrix: {
                    value: new Te,
                    type: "mat3x3<f32>"
                },
                uRound: {
                    value: 0,
                    type: "f32"
                }
            }),
            r = e.limits.maxBatchableTextures,
            i = md({
                name: "graphics",
                bits: [Ox, Mx(r), Wx, yd]
            });
        this.shader = new br({
            glProgram: i,
            resources: {
                localUniforms: n,
                batchSamplers: Rx(r)
            }
        })
    }
    execute(e, n) {
        const r = n.context,
            i = r.customShader || this.shader,
            s = e.renderer,
            o = s.graphicsContext,
            {
                batcher: a,
                instructions: l
            } = o.getContextRenderData(r);
        i.groups[0] = s.globalUniforms.bindGroup, s.state.set(e.state), s.shader.bind(i), s.geometry.bind(a.geometry, i.glProgram);
        const c = l.instructions;
        for (let u = 0; u < l.instructionSize; u++) {
            const d = c[u];
            if (d.size) {
                for (let f = 0; f < d.textures.count; f++) s.texture.bind(d.textures.textures[f], f);
                s.geometry.draw(d.topology, d.size, d.start)
            }
        }
    }
    destroy() {
        this.shader.destroy(!0), this.shader = null
    }
}
u$.extension = {
    type: [G.WebGLPipesAdaptor],
    name: "graphics"
};
class d$ {
    init() {
        const e = md({
            name: "mesh",
            bits: [Wx, Fle, yd]
        });
        this._shader = new br({
            glProgram: e,
            resources: {
                uTexture: we.EMPTY.source,
                textureUniforms: {
                    uTextureMatrix: {
                        type: "mat3x3<f32>",
                        value: new Te
                    }
                }
            }
        })
    }
    execute(e, n) {
        const r = e.renderer;
        let i = n._shader;
        if (i) {
            if (!i.glProgram) {
                Oe("Mesh shader has no glProgram", n.shader);
                return
            }
        } else {
            i = this._shader;
            const s = n.texture,
                o = s.source;
            i.resources.uTexture = o, i.resources.uSampler = o.style, i.resources.textureUniforms.uniforms.uTextureMatrix = s.textureMatrix.mapCoord
        }
        i.groups[100] = r.globalUniforms.bindGroup, i.groups[101] = e.localUniformsBindGroup, r.encoder.draw({
            geometry: n._geometry,
            shader: i,
            state: n.state
        })
    }
    destroy() {
        this._shader.destroy(!0), this._shader = null
    }
}
d$.extension = {
    type: [G.WebGLPipesAdaptor],
    name: "mesh"
};
class f$ {
    constructor(e) {
        this._renderer = e
    }
    updateRenderable() {}
    destroyRenderable() {}
    validateRenderable() {
        return !1
    }
    addRenderable(e, n) {
        this._renderer.renderPipes.batch.break(n), n.add(e)
    }
    execute(e) {
        e.isRenderable && e.render(this._renderer)
    }
    destroy() {
        this._renderer = null
    }
}
f$.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "customRender"
};
class rm {
    constructor() {
        this.batcherName = "default", this.topology = "triangle-list", this.attributeSize = 4, this.indexSize = 6, this.packAsQuad = !0, this.roundPixels = 0, this._attributeStart = 0, this._batcher = null, this._batch = null
    }
    get blendMode() {
        return this.renderable.groupBlendMode
    }
    get color() {
        return this.renderable.groupColorAlpha
    }
    reset() {
        this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.bounds = null
    }
    destroy() {}
}

function $0(t, e) {
    const n = t.instructionSet,
        r = n.instructions;
    for (let i = 0; i < n.instructionSize; i++) {
        const s = r[i];
        e[s.renderPipeId].execute(s)
    }
}
const Rce = new Te;
class h$ {
    constructor(e) {
        this._renderer = e
    }
    addRenderGroup(e, n) {
        e.isCachedAsTexture ? this._addRenderableCacheAsTexture(e, n) : this._addRenderableDirect(e, n)
    }
    execute(e) {
        e.isRenderable && (e.isCachedAsTexture ? this._executeCacheAsTexture(e) : this._executeDirect(e))
    }
    destroy() {
        this._renderer = null
    }
    _addRenderableDirect(e, n) {
        this._renderer.renderPipes.batch.break(n), e._batchableRenderGroup && (nn.return(e._batchableRenderGroup), e._batchableRenderGroup = null), n.add(e)
    }
    _addRenderableCacheAsTexture(e, n) {
        const r = e._batchableRenderGroup ? ? (e._batchableRenderGroup = nn.get(rm));
        r.renderable = e.root, r.transform = e.root.relativeGroupTransform, r.texture = e.texture, r.bounds = e._textureBounds, n.add(e), this._renderer.renderPipes.batch.addToBatch(r, n)
    }
    _executeCacheAsTexture(e) {
        if (e.textureNeedsUpdate) {
            e.textureNeedsUpdate = !1;
            const n = Rce.identity().translate(-e._textureBounds.x, -e._textureBounds.y);
            this._renderer.renderTarget.push(e.texture, !0, null, e.texture.frame), this._renderer.globalUniforms.push({
                worldTransformMatrix: n,
                worldColor: 4294967295
            }), $0(e, this._renderer.renderPipes), this._renderer.renderTarget.finishRenderPass(), this._renderer.renderTarget.pop(), this._renderer.globalUniforms.pop()
        }
        e._batchableRenderGroup._batcher.updateElement(e._batchableRenderGroup), e._batchableRenderGroup._batcher.geometry.buffers[0].update()
    }
    _executeDirect(e) {
        this._renderer.globalUniforms.push({
            worldTransformMatrix: e.inverseParentTextureTransform,
            worldColor: e.worldColorAlpha
        }), $0(e, this._renderer.renderPipes), this._renderer.globalUniforms.pop()
    }
}
h$.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "renderGroup"
};

function F0(t, e) {
    e || (e = 0);
    for (let n = e; n < t.length && t[n]; n++) t[n] = null
}
const kce = new er,
    $C = Xc | Oh | bx;

function p$(t, e = !1) {
    Bce(t);
    const n = t.childrenToUpdate,
        r = t.updateTick++;
    for (const i in n) {
        const s = Number(i),
            o = n[i],
            a = o.list,
            l = o.index;
        for (let c = 0; c < l; c++) {
            const u = a[c];
            u.parentRenderGroup === t && u.relativeRenderGroupDepth === s && m$(u, r, 0)
        }
        F0(a, l), o.index = 0
    }
    if (e)
        for (let i = 0; i < t.renderGroupChildren.length; i++) p$(t.renderGroupChildren[i], e)
}

function Bce(t) {
    const e = t.root;
    let n;
    if (t.renderGroupParent) {
        const r = t.renderGroupParent;
        t.worldTransform.appendFrom(e.relativeGroupTransform, r.worldTransform), t.worldColor = Ah(e.groupColor, r.worldColor), n = e.groupAlpha * r.worldAlpha
    } else t.worldTransform.copyFrom(e.localTransform), t.worldColor = e.localColor, n = e.localAlpha;
    n = n < 0 ? 0 : n > 1 ? 1 : n, t.worldAlpha = n, t.worldColorAlpha = t.worldColor + ((n * 255 | 0) << 24)
}

function m$(t, e, n) {
    if (e === t.updateTick) return;
    t.updateTick = e, t.didChange = !1;
    const r = t.localTransform;
    t.updateLocalTransform();
    const i = t.parent;
    if (i && !i.renderGroup ? (n |= t._updateFlags, t.relativeGroupTransform.appendFrom(r, i.relativeGroupTransform), n & $C && FC(t, i, n)) : (n = t._updateFlags, t.relativeGroupTransform.copyFrom(r), n & $C && FC(t, kce, n)), !t.renderGroup) {
        const s = t.children,
            o = s.length;
        for (let c = 0; c < o; c++) m$(s[c], e, n);
        const a = t.parentRenderGroup,
            l = t;
        l.renderPipeId && !a.structureDidChange && a.updateRenderable(l)
    }
}

function FC(t, e, n) {
    if (n & Oh) {
        t.groupColor = Ah(t.localColor, e.groupColor);
        let r = t.localAlpha * e.groupAlpha;
        r = r < 0 ? 0 : r > 1 ? 1 : r, t.groupAlpha = r, t.groupColorAlpha = t.groupColor + ((r * 255 | 0) << 24)
    }
    n & bx && (t.groupBlendMode = t.localBlendMode === "inherit" ? e.groupBlendMode : t.localBlendMode), n & Xc && (t.globalDisplayStatus = t.localDisplayStatus & e.globalDisplayStatus), t._updateFlags = 0
}

function Dce(t, e) {
    const {
        list: n,
        index: r
    } = t.childrenRenderablesToUpdate;
    let i = !1;
    for (let s = 0; s < r; s++) {
        const o = n[s];
        if (i = e[o.renderPipeId].validateRenderable(o), i) break
    }
    return t.structureDidChange = i, i
}
const $ce = new Te;
class g$ {
    constructor(e) {
        this._renderer = e
    }
    render({
        container: e,
        transform: n
    }) {
        const r = e.parent,
            i = e.renderGroup.renderGroupParent;
        e.parent = null, e.renderGroup.renderGroupParent = null;
        const s = this._renderer;
        let o = $ce;
        n && (o = o.copyFrom(e.renderGroup.localTransform), e.renderGroup.localTransform.copyFrom(n));
        const a = s.renderPipes;
        this._updateCachedRenderGroups(e.renderGroup, null), this._updateRenderGroups(e.renderGroup), s.globalUniforms.start({
            worldTransformMatrix: n ? e.renderGroup.localTransform : e.renderGroup.worldTransform,
            worldColor: e.renderGroup.worldColorAlpha
        }), $0(e.renderGroup, a), a.uniformBatch && a.uniformBatch.renderEnd(), n && e.renderGroup.localTransform.copyFrom(o), e.parent = r, e.renderGroup.renderGroupParent = i
    }
    destroy() {
        this._renderer = null
    }
    _updateCachedRenderGroups(e, n) {
        if (e.isCachedAsTexture) {
            if (!e.updateCacheTexture) return;
            n = e
        }
        e._parentCacheAsTextureRenderGroup = n;
        for (let r = e.renderGroupChildren.length - 1; r >= 0; r--) this._updateCachedRenderGroups(e.renderGroupChildren[r], n);
        if (e.invalidateMatrices(), e.isCachedAsTexture) {
            if (e.textureNeedsUpdate) {
                const r = e.root.getLocalBounds();
                r.ceil();
                const i = e.texture;
                e.texture && Ft.returnTexture(e.texture);
                const s = this._renderer,
                    o = e.textureOptions.resolution || s.view.resolution,
                    a = e.textureOptions.antialias ? ? s.view.antialias;
                e.texture = Ft.getOptimalTexture(r.width, r.height, o, a), e._textureBounds || (e._textureBounds = new rn), e._textureBounds.copyFrom(r), i !== e.texture && e.renderGroupParent && (e.renderGroupParent.structureDidChange = !0)
            }
        } else e.texture && (Ft.returnTexture(e.texture), e.texture = null)
    }
    _updateRenderGroups(e) {
        const n = this._renderer,
            r = n.renderPipes;
        if (e.runOnRender(n), e.instructionSet.renderPipes = r, e.structureDidChange ? F0(e.childrenRenderablesToUpdate.list, 0) : Dce(e, r), p$(e), e.structureDidChange ? (e.structureDidChange = !1, this._buildInstructions(e, n)) : this._updateRenderables(e), e.childrenRenderablesToUpdate.index = 0, n.renderPipes.batch.upload(e.instructionSet), !(e.isCachedAsTexture && !e.textureNeedsUpdate))
            for (let i = 0; i < e.renderGroupChildren.length; i++) this._updateRenderGroups(e.renderGroupChildren[i])
    }
    _updateRenderables(e) {
        const {
            list: n,
            index: r
        } = e.childrenRenderablesToUpdate;
        for (let i = 0; i < r; i++) {
            const s = n[i];
            s.didViewUpdate && e.updateRenderable(s)
        }
        F0(n, r)
    }
    _buildInstructions(e, n) {
        const r = e.root,
            i = e.instructionSet;
        i.reset();
        const s = n.renderPipes ? n : n.batch.renderer,
            o = s.renderPipes;
        o.batch.buildStart(i), o.blendMode.buildStart(), o.colorMask.buildStart(), r.sortableChildren && r.sortChildren(), r.collectRenderablesWithEffects(i, s, null), o.batch.buildEnd(i), o.blendMode.buildEnd(i)
    }
}
g$.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "renderGroup"
};
class y$ {
    constructor(e) {
        this._renderer = e
    }
    addRenderable(e, n) {
        const r = this._getGpuSprite(e);
        e.didViewUpdate && this._updateBatchableSprite(e, r), this._renderer.renderPipes.batch.addToBatch(r, n)
    }
    updateRenderable(e) {
        const n = this._getGpuSprite(e);
        e.didViewUpdate && this._updateBatchableSprite(e, n), n._batcher.updateElement(n)
    }
    validateRenderable(e) {
        const n = this._getGpuSprite(e);
        return !n._batcher.checkAndUpdateTexture(n, e._texture)
    }
    _updateBatchableSprite(e, n) {
        n.bounds = e.visualBounds, n.texture = e._texture
    }
    _getGpuSprite(e) {
        return e._gpuData[this._renderer.uid] || this._initGPUSprite(e)
    }
    _initGPUSprite(e) {
        const n = new rm;
        return n.renderable = e, n.transform = e.groupTransform, n.texture = e._texture, n.bounds = e.visualBounds, n.roundPixels = this._renderer._roundPixels | e._roundPixels, e._gpuData[this._renderer.uid] = n, n
    }
    destroy() {
        this._renderer = null
    }
}
y$.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "sprite"
};
const Kx = class v$ {
    constructor() {
        this.clearBeforeRender = !0, this._backgroundColor = new tt(0), this.color = this._backgroundColor, this.alpha = 1
    }
    init(e) {
        e = { ...v$.defaultOptions,
            ...e
        }, this.clearBeforeRender = e.clearBeforeRender, this.color = e.background || e.backgroundColor || this._backgroundColor, this.alpha = e.backgroundAlpha, this._backgroundColor.setAlpha(e.backgroundAlpha)
    }
    get color() {
        return this._backgroundColor
    }
    set color(e) {
        tt.shared.setValue(e).alpha < 1 && this._backgroundColor.alpha === 1 && Oe("Cannot set a transparent background on an opaque canvas. To enable transparency, set backgroundAlpha < 1 when initializing your Application."), this._backgroundColor.setValue(e)
    }
    get alpha() {
        return this._backgroundColor.alpha
    }
    set alpha(e) {
        this._backgroundColor.setAlpha(e)
    }
    get colorRgba() {
        return this._backgroundColor.toArray()
    }
    destroy() {}
};
Kx.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "background",
    priority: 0
};
Kx.defaultOptions = {
    backgroundAlpha: 1,
    backgroundColor: 0,
    clearBeforeRender: !0
};
let Fce = Kx;
const Qc = {};
Re.handle(G.BlendMode, t => {
    if (!t.name) throw new Error("BlendMode extension must have a name property");
    Qc[t.name] = t.ref
}, t => {
    delete Qc[t.name]
});
class _$ {
    constructor(e) {
        this._isAdvanced = !1, this._filterHash = Object.create(null), this._renderer = e, this._renderer.runners.prerender.add(this)
    }
    prerender() {
        this._activeBlendMode = "normal", this._isAdvanced = !1
    }
    setBlendMode(e, n, r) {
        if (this._activeBlendMode === n) {
            this._isAdvanced && this._renderableList.push(e);
            return
        }
        this._activeBlendMode = n, this._isAdvanced && this._endAdvancedBlendMode(r), this._isAdvanced = !!Qc[n], this._isAdvanced && (this._beginAdvancedBlendMode(r), this._renderableList.push(e))
    }
    _beginAdvancedBlendMode(e) {
        this._renderer.renderPipes.batch.break(e);
        const n = this._activeBlendMode;
        if (!Qc[n]) {
            Oe(`Unable to assign BlendMode: '${n}'. You may want to include: import 'pixi.js/advanced-blend-modes'`);
            return
        }
        let r = this._filterHash[n];
        r || (r = this._filterHash[n] = new Ph, r.filters = [new Qc[n]]);
        const i = {
            renderPipeId: "filter",
            action: "pushFilter",
            renderables: [],
            filterEffect: r,
            canBundle: !1
        };
        this._renderableList = i.renderables, e.add(i)
    }
    _endAdvancedBlendMode(e) {
        this._renderableList = null, this._renderer.renderPipes.batch.break(e), e.add({
            renderPipeId: "filter",
            action: "popFilter",
            canBundle: !1
        })
    }
    buildStart() {
        this._isAdvanced = !1
    }
    buildEnd(e) {
        this._isAdvanced && this._endAdvancedBlendMode(e)
    }
    destroy() {
        this._renderer = null, this._renderableList = null;
        for (const e in this._filterHash) this._filterHash[e].destroy();
        this._filterHash = null
    }
}
_$.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "blendMode"
};
const zg = {
        png: "image/png",
        jpg: "image/jpeg",
        webp: "image/webp"
    },
    Jx = class b$ {
        constructor(e) {
            this._renderer = e
        }
        _normalizeOptions(e, n = {}) {
            return e instanceof er || e instanceof we ? {
                target: e,
                ...n
            } : { ...n,
                ...e
            }
        }
        async image(e) {
            const n = new Image;
            return n.src = await this.base64(e), n
        }
        async base64(e) {
            e = this._normalizeOptions(e, b$.defaultImageOptions);
            const {
                format: n,
                quality: r
            } = e, i = this.canvas(e);
            if (i.toBlob !== void 0) return new Promise((s, o) => {
                i.toBlob(a => {
                    if (!a) {
                        o(new Error("ICanvas.toBlob failed!"));
                        return
                    }
                    const l = new FileReader;
                    l.onload = () => s(l.result), l.onerror = o, l.readAsDataURL(a)
                }, zg[n], r)
            });
            if (i.toDataURL !== void 0) return i.toDataURL(zg[n], r);
            if (i.convertToBlob !== void 0) {
                const s = await i.convertToBlob({
                    type: zg[n],
                    quality: r
                });
                return new Promise((o, a) => {
                    const l = new FileReader;
                    l.onload = () => o(l.result), l.onerror = a, l.readAsDataURL(s)
                })
            }
            throw new Error("Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented")
        }
        canvas(e) {
            e = this._normalizeOptions(e);
            const n = e.target,
                r = this._renderer;
            if (n instanceof we) return r.texture.generateCanvas(n);
            const i = r.textureGenerator.generateTexture(e),
                s = r.texture.generateCanvas(i);
            return i.destroy(!0), s
        }
        pixels(e) {
            e = this._normalizeOptions(e);
            const n = e.target,
                r = this._renderer,
                i = n instanceof we ? n : r.textureGenerator.generateTexture(e),
                s = r.texture.getPixels(i);
            return n instanceof er && i.destroy(!0), s
        }
        texture(e) {
            return e = this._normalizeOptions(e), e.target instanceof we ? e.target : this._renderer.textureGenerator.generateTexture(e)
        }
        download(e) {
            e = this._normalizeOptions(e);
            const n = this.canvas(e),
                r = document.createElement("a");
            r.download = e.filename ? ? "image.png", r.href = n.toDataURL("image/png"), document.body.appendChild(r), r.click(), document.body.removeChild(r)
        }
        log(e) {
            const n = e.width ? ? 200;
            e = this._normalizeOptions(e);
            const r = this.canvas(e),
                i = r.toDataURL();
            console.log(`[Pixi Texture] ${r.width}px ${r.height}px`);
            const s = ["font-size: 1px;", `padding: ${n}px 300px;`, `background: url(${i}) no-repeat;`, "background-size: contain;"].join(" ");
            console.log("%c ", s)
        }
        destroy() {
            this._renderer = null
        }
    };
Jx.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "extract"
};
Jx.defaultImageOptions = {
    format: "png",
    quality: 1
};
let Lce = Jx;
class Zx extends we {
    static create(e) {
        return new Zx({
            source: new Wt(e)
        })
    }
    resize(e, n, r) {
        return this.source.resize(e, n, r), this
    }
}
const Nce = new it,
    Uce = new rn,
    Gce = [0, 0, 0, 0];
class x$ {
    constructor(e) {
        this._renderer = e
    }
    generateTexture(e) {
        var c;
        e instanceof er && (e = {
            target: e,
            frame: void 0,
            textureSourceOptions: {},
            resolution: void 0
        });
        const n = e.resolution || this._renderer.resolution,
            r = e.antialias || this._renderer.view.antialias,
            i = e.target;
        let s = e.clearColor;
        s ? s = Array.isArray(s) && s.length === 4 ? s : tt.shared.setValue(s).toArray() : s = Gce;
        const o = ((c = e.frame) == null ? void 0 : c.copyTo(Nce)) || _x(i, Uce).rectangle;
        o.width = Math.max(o.width, 1 / n) | 0, o.height = Math.max(o.height, 1 / n) | 0;
        const a = Zx.create({ ...e.textureSourceOptions,
                width: o.width,
                height: o.height,
                resolution: n,
                antialias: r
            }),
            l = Te.shared.translate(-o.x, -o.y);
        return this._renderer.render({
            container: i,
            transform: l,
            target: a,
            clearColor: s
        }), a.source.updateMipmaps(), a
    }
    destroy() {
        this._renderer = null
    }
}
x$.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "textureGenerator"
};

function vd(t, e, n) {
    const r = (t >> 24 & 255) / 255;
    e[n++] = (t & 255) / 255 * r, e[n++] = (t >> 8 & 255) / 255 * r, e[n++] = (t >> 16 & 255) / 255 * r, e[n++] = r
}
class w$ {
    constructor(e) {
        this._stackIndex = 0, this._globalUniformDataStack = [], this._uniformsPool = [], this._activeUniforms = [], this._bindGroupPool = [], this._activeBindGroups = [], this._renderer = e
    }
    reset() {
        this._stackIndex = 0;
        for (let e = 0; e < this._activeUniforms.length; e++) this._uniformsPool.push(this._activeUniforms[e]);
        for (let e = 0; e < this._activeBindGroups.length; e++) this._bindGroupPool.push(this._activeBindGroups[e]);
        this._activeUniforms.length = 0, this._activeBindGroups.length = 0
    }
    start(e) {
        this.reset(), this.push(e)
    }
    bind({
        size: e,
        projectionMatrix: n,
        worldTransformMatrix: r,
        worldColor: i,
        offset: s
    }) {
        const o = this._renderer.renderTarget.renderTarget,
            a = this._stackIndex ? this._globalUniformDataStack[this._stackIndex - 1] : {
                projectionData: o,
                worldTransformMatrix: new Te,
                worldColor: 4294967295,
                offset: new dt
            },
            l = {
                projectionMatrix: n || this._renderer.renderTarget.projectionMatrix,
                resolution: e || o.size,
                worldTransformMatrix: r || a.worldTransformMatrix,
                worldColor: i || a.worldColor,
                offset: s || a.offset,
                bindGroup: null
            },
            c = this._uniformsPool.pop() || this._createUniforms();
        this._activeUniforms.push(c);
        const u = c.uniforms;
        u.uProjectionMatrix = l.projectionMatrix, u.uResolution = l.resolution, u.uWorldTransformMatrix.copyFrom(l.worldTransformMatrix), u.uWorldTransformMatrix.tx -= l.offset.x, u.uWorldTransformMatrix.ty -= l.offset.y, vd(l.worldColor, u.uWorldColorAlpha, 0), c.update();
        let d;
        this._renderer.renderPipes.uniformBatch ? d = this._renderer.renderPipes.uniformBatch.getUniformBindGroup(c, !1) : (d = this._bindGroupPool.pop() || new Gi, this._activeBindGroups.push(d), d.setResource(c, 0)), l.bindGroup = d, this._currentGlobalUniformData = l
    }
    push(e) {
        this.bind(e), this._globalUniformDataStack[this._stackIndex++] = this._currentGlobalUniformData
    }
    pop() {
        this._currentGlobalUniformData = this._globalUniformDataStack[--this._stackIndex - 1], this._renderer.type === tr.WEBGL && this._currentGlobalUniformData.bindGroup.resources[0].update()
    }
    get bindGroup() {
        return this._currentGlobalUniformData.bindGroup
    }
    get globalUniformData() {
        return this._currentGlobalUniformData
    }
    get uniformGroup() {
        return this._currentGlobalUniformData.bindGroup.resources[0]
    }
    _createUniforms() {
        return new Pn({
            uProjectionMatrix: {
                value: new Te,
                type: "mat3x3<f32>"
            },
            uWorldTransformMatrix: {
                value: new Te,
                type: "mat3x3<f32>"
            },
            uWorldColorAlpha: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uResolution: {
                value: [0, 0],
                type: "vec2<f32>"
            }
        }, {
            isStatic: !0
        })
    }
    destroy() {
        this._renderer = null
    }
}
w$.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "globalUniforms"
};
let Hce = 1;
class E$ {
    constructor() {
        this._tasks = [], this._offset = 0
    }
    init() {
        bn.system.add(this._update, this)
    }
    repeat(e, n, r = !0) {
        const i = Hce++;
        let s = 0;
        return r && (this._offset += 1e3, s = this._offset), this._tasks.push({
            func: e,
            duration: n,
            start: performance.now(),
            offset: s,
            last: performance.now(),
            repeat: !0,
            id: i
        }), i
    }
    cancel(e) {
        for (let n = 0; n < this._tasks.length; n++)
            if (this._tasks[n].id === e) {
                this._tasks.splice(n, 1);
                return
            }
    }
    _update() {
        const e = performance.now();
        for (let n = 0; n < this._tasks.length; n++) {
            const r = this._tasks[n];
            if (e - r.offset - r.last >= r.duration) {
                const i = e - r.start;
                r.func(i), r.last = e
            }
        }
    }
    destroy() {
        bn.system.remove(this._update, this), this._tasks.length = 0
    }
}
E$.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "scheduler",
    priority: 0
};
let LC = !1;

function zce(t) {
    if (!LC) {
        if (Ge.get().getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
            const e = [`%c  %c  %c  %c  %c PixiJS %c v${Mh} (${t}) http://www.pixijs.com/

`, "background: #E72264; padding:5px 0;", "background: #6CA2EA; padding:5px 0;", "background: #B5D33D; padding:5px 0;", "background: #FED23F; padding:5px 0;", "color: #FFFFFF; background: #E72264; padding:5px 0;", "color: #E72264; background: #FFFFFF; padding:5px 0;"];
            globalThis.console.log(...e)
        } else globalThis.console && globalThis.console.log(`PixiJS ${Mh} - ${t} - http://www.pixijs.com/`);
        LC = !0
    }
}
class Qx {
    constructor(e) {
        this._renderer = e
    }
    init(e) {
        if (e.hello) {
            let n = this._renderer.name;
            this._renderer.type === tr.WEBGL && (n += ` ${this._renderer.context.webGLVersion}`), zce(n)
        }
    }
}
Qx.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "hello",
    priority: -2
};
Qx.defaultOptions = {
    hello: !1
};

function jce(t) {
    let e = !1;
    for (const r in t)
        if (t[r] == null) {
            e = !0;
            break
        }
    if (!e) return t;
    const n = Object.create(null);
    for (const r in t) {
        const i = t[r];
        i && (n[r] = i)
    }
    return n
}

function Vce(t) {
    let e = 0;
    for (let n = 0; n < t.length; n++) t[n] == null ? e++ : t[n - e] = t[n];
    return t.length -= e, t
}
let Wce = 0;
const ew = class S$ {
    constructor(e) {
        this._managedRenderables = [], this._managedHashes = [], this._managedArrays = [], this._renderer = e
    }
    init(e) {
        e = { ...S$.defaultOptions,
            ...e
        }, this.maxUnusedTime = e.renderableGCMaxUnusedTime, this._frequency = e.renderableGCFrequency, this.enabled = e.renderableGCActive
    }
    get enabled() {
        return !!this._handler
    }
    set enabled(e) {
        this.enabled !== e && (e ? (this._handler = this._renderer.scheduler.repeat(() => this.run(), this._frequency, !1), this._hashHandler = this._renderer.scheduler.repeat(() => {
            for (const n of this._managedHashes) n.context[n.hash] = jce(n.context[n.hash])
        }, this._frequency), this._arrayHandler = this._renderer.scheduler.repeat(() => {
            for (const n of this._managedArrays) Vce(n.context[n.hash])
        }, this._frequency)) : (this._renderer.scheduler.cancel(this._handler), this._renderer.scheduler.cancel(this._hashHandler), this._renderer.scheduler.cancel(this._arrayHandler)))
    }
    addManagedHash(e, n) {
        this._managedHashes.push({
            context: e,
            hash: n
        })
    }
    addManagedArray(e, n) {
        this._managedArrays.push({
            context: e,
            hash: n
        })
    }
    prerender({
        container: e
    }) {
        this._now = performance.now(), e.renderGroup.gcTick = Wce++, this._updateInstructionGCTick(e.renderGroup, e.renderGroup.gcTick)
    }
    addRenderable(e) {
        this.enabled && (e._lastUsed === -1 && (this._managedRenderables.push(e), e.once("destroyed", this._removeRenderable, this)), e._lastUsed = this._now)
    }
    run() {
        var s;
        const e = this._now,
            n = this._managedRenderables,
            r = this._renderer.renderPipes;
        let i = 0;
        for (let o = 0; o < n.length; o++) {
            const a = n[o];
            if (a === null) {
                i++;
                continue
            }
            const l = a.renderGroup ? ? a.parentRenderGroup,
                c = ((s = l == null ? void 0 : l.instructionSet) == null ? void 0 : s.gcTick) ? ? -1;
            if (((l == null ? void 0 : l.gcTick) ? ? 0) === c && (a._lastUsed = e), e - a._lastUsed > this.maxUnusedTime) {
                if (!a.destroyed) {
                    const u = r;
                    l && (l.structureDidChange = !0), u[a.renderPipeId].destroyRenderable(a)
                }
                a._lastUsed = -1, i++, a.off("destroyed", this._removeRenderable, this)
            } else n[o - i] = a
        }
        n.length -= i
    }
    destroy() {
        this.enabled = !1, this._renderer = null, this._managedRenderables.length = 0, this._managedHashes.length = 0, this._managedArrays.length = 0
    }
    _removeRenderable(e) {
        const n = this._managedRenderables.indexOf(e);
        n >= 0 && (e.off("destroyed", this._removeRenderable, this), this._managedRenderables[n] = null)
    }
    _updateInstructionGCTick(e, n) {
        e.instructionSet.gcTick = n;
        for (const r of e.renderGroupChildren) this._updateInstructionGCTick(r, n)
    }
};
ew.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "renderableGC",
    priority: 0
};
ew.defaultOptions = {
    renderableGCActive: !0,
    renderableGCMaxUnusedTime: 6e4,
    renderableGCFrequency: 3e4
};
let Yce = ew;
const tw = class T$ {
    constructor(e) {
        this._renderer = e, this.count = 0, this.checkCount = 0
    }
    init(e) {
        e = { ...T$.defaultOptions,
            ...e
        }, this.checkCountMax = e.textureGCCheckCountMax, this.maxIdle = e.textureGCAMaxIdle ? ? e.textureGCMaxIdle, this.active = e.textureGCActive
    }
    postrender() {
        this._renderer.renderingToScreen && (this.count++, this.active && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())))
    }
    run() {
        const e = this._renderer.texture.managedTextures;
        for (let n = 0; n < e.length; n++) {
            const r = e[n];
            r.autoGarbageCollect && r.resource && r._touched > -1 && this.count - r._touched > this.maxIdle && (r._touched = -1, r.unload())
        }
    }
    destroy() {
        this._renderer = null
    }
};
tw.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem],
    name: "textureGC"
};
tw.defaultOptions = {
    textureGCActive: !0,
    textureGCAMaxIdle: null,
    textureGCMaxIdle: 60 * 60,
    textureGCCheckCountMax: 600
};
let Xce = tw;
const nw = class C$ {
    get autoDensity() {
        return this.texture.source.autoDensity
    }
    set autoDensity(e) {
        this.texture.source.autoDensity = e
    }
    get resolution() {
        return this.texture.source._resolution
    }
    set resolution(e) {
        this.texture.source.resize(this.texture.source.width, this.texture.source.height, e)
    }
    init(e) {
        e = { ...C$.defaultOptions,
            ...e
        }, e.view && (Ie(Ye, "ViewSystem.view has been renamed to ViewSystem.canvas"), e.canvas = e.view), this.screen = new it(0, 0, e.width, e.height), this.canvas = e.canvas || Ge.get().createCanvas(), this.antialias = !!e.antialias, this.texture = ZD(this.canvas, e), this.renderTarget = new B0({
            colorTextures: [this.texture],
            depth: !!e.depth,
            isRoot: !0
        }), this.texture.source.transparent = e.backgroundAlpha < 1, this.resolution = e.resolution
    }
    resize(e, n, r) {
        this.texture.source.resize(e, n, r), this.screen.width = this.texture.frame.width, this.screen.height = this.texture.frame.height
    }
    destroy(e = !1) {
        (typeof e == "boolean" ? e : !!(e != null && e.removeView)) && this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)
    }
};
nw.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "view",
    priority: 0
};
nw.defaultOptions = {
    width: 800,
    height: 600,
    autoDensity: !1,
    antialias: !1
};
let qce = nw;
const P$ = [Fce, w$, Qx, qce, g$, Xce, x$, Lce, NB, Yce, E$],
    A$ = [_$, kD, y$, h$, BD, $D, DD, f$],
    Kce = [...P$, JD, Wle, Gle, VD, FD, c$, n$, GD, o$, s$, jD, bce, WD, zD],
    Jce = [...A$],
    Zce = [ID, d$, u$],
    O$ = [],
    I$ = [],
    M$ = [];
Re.handleByNamedList(G.WebGLSystem, O$);
Re.handleByNamedList(G.WebGLPipes, I$);
Re.handleByNamedList(G.WebGLPipesAdaptor, M$);
Re.add(...Kce, ...Jce, ...Zce);
class Qce extends em {
    constructor() {
        const e = {
            name: "webgl",
            type: tr.WEBGL,
            systems: O$,
            renderPipes: I$,
            renderPipeAdaptors: M$
        };
        super(e)
    }
}
const eue = Object.freeze(Object.defineProperty({
    __proto__: null,
    WebGLRenderer: Qce
}, Symbol.toStringTag, {
    value: "Module"
}));
class R$ {
    constructor(e) {
        this._hash = Object.create(null), this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_hash")
    }
    contextChange(e) {
        this._gpu = e
    }
    getBindGroup(e, n, r) {
        return e._updateKey(), this._hash[e._key] || this._createBindGroup(e, n, r)
    }
    _createBindGroup(e, n, r) {
        const i = this._gpu.device,
            s = n.layout[r],
            o = [],
            a = this._renderer;
        for (const u in s) {
            const d = e.resources[u] ? ? e.resources[s[u]];
            let f;
            if (d._resourceType === "uniformGroup") {
                const h = d;
                a.ubo.updateUniformGroup(h);
                const p = h.buffer;
                f = {
                    buffer: a.buffer.getGPUBuffer(p),
                    offset: 0,
                    size: p.descriptor.size
                }
            } else if (d._resourceType === "buffer") {
                const h = d;
                f = {
                    buffer: a.buffer.getGPUBuffer(h),
                    offset: 0,
                    size: h.descriptor.size
                }
            } else if (d._resourceType === "bufferResource") {
                const h = d;
                f = {
                    buffer: a.buffer.getGPUBuffer(h.buffer),
                    offset: h.offset,
                    size: h.size
                }
            } else if (d._resourceType === "textureSampler") {
                const h = d;
                f = a.texture.getGpuSampler(h)
            } else if (d._resourceType === "textureSource") {
                const h = d;
                f = a.texture.getGpuSource(h).createView({})
            }
            o.push({
                binding: s[u],
                resource: f
            })
        }
        const l = a.shader.getProgramData(n).bindGroups[r],
            c = i.createBindGroup({
                layout: l,
                entries: o
            });
        return this._hash[e._key] = c, c
    }
    destroy() {
        for (const e of Object.keys(this._hash)) this._hash[e] = null;
        this._hash = null, this._renderer = null
    }
}
R$.extension = {
    type: [G.WebGPUSystem],
    name: "bindGroup"
};
class k$ {
    constructor(e) {
        this._gpuBuffers = Object.create(null), this._managedBuffers = [], e.renderableGC.addManagedHash(this, "_gpuBuffers")
    }
    contextChange(e) {
        this._gpu = e
    }
    getGPUBuffer(e) {
        return this._gpuBuffers[e.uid] || this.createGPUBuffer(e)
    }
    updateBuffer(e) {
        const n = this._gpuBuffers[e.uid] || this.createGPUBuffer(e),
            r = e.data;
        return e._updateID && r && (e._updateID = 0, this._gpu.device.queue.writeBuffer(n, 0, r.buffer, 0, (e._updateSize || r.byteLength) + 3 & -4)), n
    }
    destroyAll() {
        for (const e in this._gpuBuffers) this._gpuBuffers[e].destroy();
        this._gpuBuffers = {}
    }
    createGPUBuffer(e) {
        this._gpuBuffers[e.uid] || (e.on("update", this.updateBuffer, this), e.on("change", this.onBufferChange, this), e.on("destroy", this.onBufferDestroy, this), this._managedBuffers.push(e));
        const n = this._gpu.device.createBuffer(e.descriptor);
        return e._updateID = 0, e.data && (T0(e.data.buffer, n.getMappedRange()), n.unmap()), this._gpuBuffers[e.uid] = n, n
    }
    onBufferChange(e) {
        this._gpuBuffers[e.uid].destroy(), e._updateID = 0, this._gpuBuffers[e.uid] = this.createGPUBuffer(e)
    }
    onBufferDestroy(e) {
        this._managedBuffers.splice(this._managedBuffers.indexOf(e), 1), this._destroyBuffer(e)
    }
    destroy() {
        this._managedBuffers.forEach(e => this._destroyBuffer(e)), this._managedBuffers = null, this._gpuBuffers = null
    }
    _destroyBuffer(e) {
        this._gpuBuffers[e.uid].destroy(), e.off("update", this.updateBuffer, this), e.off("change", this.onBufferChange, this), e.off("destroy", this.onBufferDestroy, this), this._gpuBuffers[e.uid] = null
    }
}
k$.extension = {
    type: [G.WebGPUSystem],
    name: "buffer"
};
class tue {
    constructor({
        minUniformOffsetAlignment: e
    }) {
        this._minUniformOffsetAlignment = 256, this.byteIndex = 0, this._minUniformOffsetAlignment = e, this.data = new Float32Array(65535)
    }
    clear() {
        this.byteIndex = 0
    }
    addEmptyGroup(e) {
        if (e > this._minUniformOffsetAlignment / 4) throw new Error(`UniformBufferBatch: array is too large: ${e*4}`);
        const n = this.byteIndex;
        let r = n + e * 4;
        if (r = Math.ceil(r / this._minUniformOffsetAlignment) * this._minUniformOffsetAlignment, r > this.data.length * 4) throw new Error("UniformBufferBatch: ubo batch got too big");
        return this.byteIndex = r, n
    }
    addGroup(e) {
        const n = this.addEmptyGroup(e.length);
        for (let r = 0; r < e.length; r++) this.data[n / 4 + r] = e[r];
        return n
    }
    destroy() {
        this.data = null
    }
}
class B$ {
    constructor(e) {
        this._colorMaskCache = 15, this._renderer = e
    }
    setMask(e) {
        this._colorMaskCache !== e && (this._colorMaskCache = e, this._renderer.pipeline.setColorMask(e))
    }
    destroy() {
        this._renderer = null, this._colorMaskCache = null
    }
}
B$.extension = {
    type: [G.WebGPUSystem],
    name: "colorMask"
};
class rw {
    constructor(e) {
        this._renderer = e
    }
    async init(e) {
        return this._initPromise ? this._initPromise : (this._initPromise = this._createDeviceAndAdaptor(e).then(n => {
            this.gpu = n, this._renderer.runners.contextChange.emit(this.gpu)
        }), this._initPromise)
    }
    contextChange(e) {
        this._renderer.gpu = e
    }
    async _createDeviceAndAdaptor(e) {
        const n = await Ge.get().getNavigator().gpu.requestAdapter({
                powerPreference: e.powerPreference,
                forceFallbackAdapter: e.forceFallbackAdapter
            }),
            r = ["texture-compression-bc", "texture-compression-astc", "texture-compression-etc2"].filter(s => n.features.has(s)),
            i = await n.requestDevice({
                requiredFeatures: r
            });
        return {
            adapter: n,
            device: i
        }
    }
    destroy() {
        this.gpu = null, this._renderer = null
    }
}
rw.extension = {
    type: [G.WebGPUSystem],
    name: "device"
};
rw.defaultOptions = {
    powerPreference: void 0,
    forceFallbackAdapter: !1
};
class D$ {
    constructor(e) {
        this._boundBindGroup = Object.create(null), this._boundVertexBuffer = Object.create(null), this._renderer = e
    }
    renderStart() {
        this.commandFinished = new Promise(e => {
            this._resolveCommandFinished = e
        }), this.commandEncoder = this._renderer.gpu.device.createCommandEncoder()
    }
    beginRenderPass(e) {
        this.endRenderPass(), this._clearCache(), this.renderPassEncoder = this.commandEncoder.beginRenderPass(e.descriptor)
    }
    endRenderPass() {
        this.renderPassEncoder && this.renderPassEncoder.end(), this.renderPassEncoder = null
    }
    setViewport(e) {
        this.renderPassEncoder.setViewport(e.x, e.y, e.width, e.height, 0, 1)
    }
    setPipelineFromGeometryProgramAndState(e, n, r, i) {
        const s = this._renderer.pipeline.getPipeline(e, n, r, i);
        this.setPipeline(s)
    }
    setPipeline(e) {
        this._boundPipeline !== e && (this._boundPipeline = e, this.renderPassEncoder.setPipeline(e))
    }
    _setVertexBuffer(e, n) {
        this._boundVertexBuffer[e] !== n && (this._boundVertexBuffer[e] = n, this.renderPassEncoder.setVertexBuffer(e, this._renderer.buffer.updateBuffer(n)))
    }
    _setIndexBuffer(e) {
        if (this._boundIndexBuffer === e) return;
        this._boundIndexBuffer = e;
        const n = e.data.BYTES_PER_ELEMENT === 2 ? "uint16" : "uint32";
        this.renderPassEncoder.setIndexBuffer(this._renderer.buffer.updateBuffer(e), n)
    }
    resetBindGroup(e) {
        this._boundBindGroup[e] = null
    }
    setBindGroup(e, n, r) {
        if (this._boundBindGroup[e] === n) return;
        this._boundBindGroup[e] = n, n._touch(this._renderer.textureGC.count);
        const i = this._renderer.bindGroup.getBindGroup(n, r, e);
        this.renderPassEncoder.setBindGroup(e, i)
    }
    setGeometry(e, n) {
        const r = this._renderer.pipeline.getBufferNamesToBind(e, n);
        for (const i in r) this._setVertexBuffer(i, e.attributes[r[i]].buffer);
        e.indexBuffer && this._setIndexBuffer(e.indexBuffer)
    }
    _setShaderBindGroups(e, n) {
        for (const r in e.groups) {
            const i = e.groups[r];
            n || this._syncBindGroup(i), this.setBindGroup(r, i, e.gpuProgram)
        }
    }
    _syncBindGroup(e) {
        for (const n in e.resources) {
            const r = e.resources[n];
            r.isUniformGroup && this._renderer.ubo.updateUniformGroup(r)
        }
    }
    draw(e) {
        const {
            geometry: n,
            shader: r,
            state: i,
            topology: s,
            size: o,
            start: a,
            instanceCount: l,
            skipSync: c
        } = e;
        this.setPipelineFromGeometryProgramAndState(n, r.gpuProgram, i, s), this.setGeometry(n, r.gpuProgram), this._setShaderBindGroups(r, c), n.indexBuffer ? this.renderPassEncoder.drawIndexed(o || n.indexBuffer.data.length, l ? ? n.instanceCount, a || 0) : this.renderPassEncoder.draw(o || n.getSize(), l ? ? n.instanceCount, a || 0)
    }
    finishRenderPass() {
        this.renderPassEncoder && (this.renderPassEncoder.end(), this.renderPassEncoder = null)
    }
    postrender() {
        this.finishRenderPass(), this._gpu.device.queue.submit([this.commandEncoder.finish()]), this._resolveCommandFinished(), this.commandEncoder = null
    }
    restoreRenderPass() {
        const e = this._renderer.renderTarget.adaptor.getDescriptor(this._renderer.renderTarget.renderTarget, !1, [0, 0, 0, 1]);
        this.renderPassEncoder = this.commandEncoder.beginRenderPass(e);
        const n = this._boundPipeline,
            r = { ...this._boundVertexBuffer
            },
            i = this._boundIndexBuffer,
            s = { ...this._boundBindGroup
            };
        this._clearCache();
        const o = this._renderer.renderTarget.viewport;
        this.renderPassEncoder.setViewport(o.x, o.y, o.width, o.height, 0, 1), this.setPipeline(n);
        for (const a in r) this._setVertexBuffer(a, r[a]);
        for (const a in s) this.setBindGroup(a, s[a], null);
        this._setIndexBuffer(i)
    }
    _clearCache() {
        for (let e = 0; e < 16; e++) this._boundBindGroup[e] = null, this._boundVertexBuffer[e] = null;
        this._boundIndexBuffer = null, this._boundPipeline = null
    }
    destroy() {
        this._renderer = null, this._gpu = null, this._boundBindGroup = null, this._boundVertexBuffer = null, this._boundIndexBuffer = null, this._boundPipeline = null
    }
    contextChange(e) {
        this._gpu = e
    }
}
D$.extension = {
    type: [G.WebGPUSystem],
    name: "encoder",
    priority: 1
};
class $$ {
    constructor(e) {
        this._renderer = e
    }
    contextChange() {
        this.maxTextures = this._renderer.device.gpu.device.limits.maxSampledTexturesPerShaderStage, this.maxBatchableTextures = this.maxTextures
    }
    destroy() {}
}
$$.extension = {
    type: [G.WebGPUSystem],
    name: "limits"
};
class F$ {
    constructor(e) {
        this._renderTargetStencilState = Object.create(null), this._renderer = e, e.renderTarget.onRenderTargetChange.add(this)
    }
    onRenderTargetChange(e) {
        let n = this._renderTargetStencilState[e.uid];
        n || (n = this._renderTargetStencilState[e.uid] = {
            stencilMode: Bt.DISABLED,
            stencilReference: 0
        }), this._activeRenderTarget = e, this.setStencilMode(n.stencilMode, n.stencilReference)
    }
    setStencilMode(e, n) {
        const r = this._renderTargetStencilState[this._activeRenderTarget.uid];
        r.stencilMode = e, r.stencilReference = n;
        const i = this._renderer;
        i.pipeline.setStencilMode(e), i.encoder.renderPassEncoder.setStencilReference(n)
    }
    destroy() {
        this._renderer.renderTarget.onRenderTargetChange.remove(this), this._renderer = null, this._activeRenderTarget = null, this._renderTargetStencilState = null
    }
}
F$.extension = {
    type: [G.WebGPUSystem],
    name: "stencil"
};
const Kf = {
    i32: {
        align: 4,
        size: 4
    },
    u32: {
        align: 4,
        size: 4
    },
    f32: {
        align: 4,
        size: 4
    },
    f16: {
        align: 2,
        size: 2
    },
    "vec2<i32>": {
        align: 8,
        size: 8
    },
    "vec2<u32>": {
        align: 8,
        size: 8
    },
    "vec2<f32>": {
        align: 8,
        size: 8
    },
    "vec2<f16>": {
        align: 4,
        size: 4
    },
    "vec3<i32>": {
        align: 16,
        size: 12
    },
    "vec3<u32>": {
        align: 16,
        size: 12
    },
    "vec3<f32>": {
        align: 16,
        size: 12
    },
    "vec3<f16>": {
        align: 8,
        size: 6
    },
    "vec4<i32>": {
        align: 16,
        size: 16
    },
    "vec4<u32>": {
        align: 16,
        size: 16
    },
    "vec4<f32>": {
        align: 16,
        size: 16
    },
    "vec4<f16>": {
        align: 8,
        size: 8
    },
    "mat2x2<f32>": {
        align: 8,
        size: 16
    },
    "mat2x2<f16>": {
        align: 4,
        size: 8
    },
    "mat3x2<f32>": {
        align: 8,
        size: 24
    },
    "mat3x2<f16>": {
        align: 4,
        size: 12
    },
    "mat4x2<f32>": {
        align: 8,
        size: 32
    },
    "mat4x2<f16>": {
        align: 4,
        size: 16
    },
    "mat2x3<f32>": {
        align: 16,
        size: 32
    },
    "mat2x3<f16>": {
        align: 8,
        size: 16
    },
    "mat3x3<f32>": {
        align: 16,
        size: 48
    },
    "mat3x3<f16>": {
        align: 8,
        size: 24
    },
    "mat4x3<f32>": {
        align: 16,
        size: 64
    },
    "mat4x3<f16>": {
        align: 8,
        size: 32
    },
    "mat2x4<f32>": {
        align: 16,
        size: 32
    },
    "mat2x4<f16>": {
        align: 8,
        size: 16
    },
    "mat3x4<f32>": {
        align: 16,
        size: 48
    },
    "mat3x4<f16>": {
        align: 8,
        size: 24
    },
    "mat4x4<f32>": {
        align: 16,
        size: 64
    },
    "mat4x4<f16>": {
        align: 8,
        size: 32
    }
};

function nue(t) {
    const e = t.map(r => ({
        data: r,
        offset: 0,
        size: 0
    }));
    let n = 0;
    for (let r = 0; r < e.length; r++) {
        const i = e[r];
        let s = Kf[i.data.type].size;
        const o = Kf[i.data.type].align;
        if (!Kf[i.data.type]) throw new Error(`[Pixi.js] WebGPU UniformBuffer: Unknown type ${i.data.type}`);
        i.data.size > 1 && (s = Math.max(s, o) * i.data.size), n = Math.ceil(n / o) * o, i.size = s, i.offset = n, n += s
    }
    return n = Math.ceil(n / 16) * 16, {
        uboElements: e,
        size: n
    }
}

function rue(t, e) {
    const {
        size: n,
        align: r
    } = Kf[t.data.type], i = (r - n) / 4, s = t.data.type.indexOf("i32") >= 0 ? "dataInt32" : "data";
    return `
         v = uv.${t.data.name};
         ${e!==0?`offset += ${e};`:""}

         arrayOffset = offset;

         t = 0;

         for(var i=0; i < ${t.data.size*(n/4)}; i++)
         {
             for(var j = 0; j < ${n/4}; j++)
             {
                 ${s}[arrayOffset++] = v[t++];
             }
             ${i!==0?`arrayOffset += ${i};`:""}
         }
     `
}

function iue(t) {
    return qD(t, "uboWgsl", rue, qle)
}
class L$ extends YD {
    constructor() {
        super({
            createUboElements: nue,
            generateUboSync: iue
        })
    }
}
L$.extension = {
    type: [G.WebGPUSystem],
    name: "ubo"
};
const ms = 128;
class N$ {
    constructor(e) {
        this._bindGroupHash = Object.create(null), this._buffers = [], this._bindGroups = [], this._bufferResources = [], this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_bindGroupHash"), this._batchBuffer = new tue({
            minUniformOffsetAlignment: ms
        });
        const n = 256 / ms;
        for (let r = 0; r < n; r++) {
            let i = Xe.UNIFORM | Xe.COPY_DST;
            r === 0 && (i |= Xe.COPY_SRC), this._buffers.push(new Jn({
                data: this._batchBuffer.data,
                usage: i
            }))
        }
    }
    renderEnd() {
        this._uploadBindGroups(), this._resetBindGroups()
    }
    _resetBindGroups() {
        for (const e in this._bindGroupHash) this._bindGroupHash[e] = null;
        this._batchBuffer.clear()
    }
    getUniformBindGroup(e, n) {
        if (!n && this._bindGroupHash[e.uid]) return this._bindGroupHash[e.uid];
        this._renderer.ubo.ensureUniformGroup(e);
        const r = e.buffer.data,
            i = this._batchBuffer.addEmptyGroup(r.length);
        return this._renderer.ubo.syncUniformGroup(e, this._batchBuffer.data, i / 4), this._bindGroupHash[e.uid] = this._getBindGroup(i / ms), this._bindGroupHash[e.uid]
    }
    getUboResource(e) {
        this._renderer.ubo.updateUniformGroup(e);
        const n = e.buffer.data,
            r = this._batchBuffer.addGroup(n);
        return this._getBufferResource(r / ms)
    }
    getArrayBindGroup(e) {
        const n = this._batchBuffer.addGroup(e);
        return this._getBindGroup(n / ms)
    }
    getArrayBufferResource(e) {
        const r = this._batchBuffer.addGroup(e) / ms;
        return this._getBufferResource(r)
    }
    _getBufferResource(e) {
        if (!this._bufferResources[e]) {
            const n = this._buffers[e % 2];
            this._bufferResources[e] = new qx({
                buffer: n,
                offset: (e / 2 | 0) * 256,
                size: ms
            })
        }
        return this._bufferResources[e]
    }
    _getBindGroup(e) {
        if (!this._bindGroups[e]) {
            const n = new Gi({
                0: this._getBufferResource(e)
            });
            this._bindGroups[e] = n
        }
        return this._bindGroups[e]
    }
    _uploadBindGroups() {
        const e = this._renderer.buffer,
            n = this._buffers[0];
        n.update(this._batchBuffer.byteIndex), e.updateBuffer(n);
        const r = this._renderer.gpu.device.createCommandEncoder();
        for (let i = 1; i < this._buffers.length; i++) {
            const s = this._buffers[i];
            r.copyBufferToBuffer(e.getGPUBuffer(n), ms, e.getGPUBuffer(s), 0, this._batchBuffer.byteIndex)
        }
        this._renderer.gpu.device.queue.submit([r.finish()])
    }
    destroy() {
        for (let e = 0; e < this._bindGroups.length; e++) this._bindGroups[e].destroy();
        this._bindGroups = null, this._bindGroupHash = null;
        for (let e = 0; e < this._buffers.length; e++) this._buffers[e].destroy();
        this._buffers = null;
        for (let e = 0; e < this._bufferResources.length; e++) this._bufferResources[e].destroy();
        this._bufferResources = null, this._batchBuffer.destroy(), this._bindGroupHash = null, this._renderer = null
    }
}
N$.extension = {
    type: [G.WebGPUPipes],
    name: "uniformBatch"
};
const sue = {
    "point-list": 0,
    "line-list": 1,
    "line-strip": 2,
    "triangle-list": 3,
    "triangle-strip": 4
};

function oue(t, e, n, r, i) {
    return t << 24 | e << 16 | n << 10 | r << 5 | i
}

function aue(t, e, n, r) {
    return n << 6 | t << 3 | r << 1 | e
}
class U$ {
    constructor(e) {
        this._moduleCache = Object.create(null), this._bufferLayoutsCache = Object.create(null), this._bindingNamesCache = Object.create(null), this._pipeCache = Object.create(null), this._pipeStateCaches = Object.create(null), this._colorMask = 15, this._multisampleCount = 1, this._renderer = e
    }
    contextChange(e) {
        this._gpu = e, this.setStencilMode(Bt.DISABLED), this._updatePipeHash()
    }
    setMultisampleCount(e) {
        this._multisampleCount !== e && (this._multisampleCount = e, this._updatePipeHash())
    }
    setRenderTarget(e) {
        this._multisampleCount = e.msaaSamples, this._depthStencilAttachment = e.descriptor.depthStencilAttachment ? 1 : 0, this._updatePipeHash()
    }
    setColorMask(e) {
        this._colorMask !== e && (this._colorMask = e, this._updatePipeHash())
    }
    setStencilMode(e) {
        this._stencilMode !== e && (this._stencilMode = e, this._stencilState = so[e], this._updatePipeHash())
    }
    setPipeline(e, n, r, i) {
        const s = this.getPipeline(e, n, r);
        i.setPipeline(s)
    }
    getPipeline(e, n, r, i) {
        e._layoutKey || (ND(e, n.attributeData), this._generateBufferKey(e)), i || (i = e.topology);
        const s = oue(e._layoutKey, n._layoutKey, r.data, r._blendModeId, sue[i]);
        return this._pipeCache[s] ? this._pipeCache[s] : (this._pipeCache[s] = this._createPipeline(e, n, r, i), this._pipeCache[s])
    }
    _createPipeline(e, n, r, i) {
        const s = this._gpu.device,
            o = this._createVertexBufferLayouts(e, n),
            a = this._renderer.state.getColorTargets(r);
        a[0].writeMask = this._stencilMode === Bt.RENDERING_MASK_ADD ? 0 : this._colorMask;
        const l = this._renderer.shader.getProgramData(n).pipeline,
            c = {
                vertex: {
                    module: this._getModule(n.vertex.source),
                    entryPoint: n.vertex.entryPoint,
                    buffers: o
                },
                fragment: {
                    module: this._getModule(n.fragment.source),
                    entryPoint: n.fragment.entryPoint,
                    targets: a
                },
                primitive: {
                    topology: i,
                    cullMode: r.cullMode
                },
                layout: l,
                multisample: {
                    count: this._multisampleCount
                },
                label: "PIXI Pipeline"
            };
        return this._depthStencilAttachment && (c.depthStencil = { ...this._stencilState,
            format: "depth24plus-stencil8",
            depthWriteEnabled: r.depthTest,
            depthCompare: r.depthTest ? "less" : "always"
        }), s.createRenderPipeline(c)
    }
    _getModule(e) {
        return this._moduleCache[e] || this._createModule(e)
    }
    _createModule(e) {
        const n = this._gpu.device;
        return this._moduleCache[e] = n.createShaderModule({
            code: e
        }), this._moduleCache[e]
    }
    _generateBufferKey(e) {
        const n = [];
        let r = 0;
        const i = Object.keys(e.attributes).sort();
        for (let o = 0; o < i.length; o++) {
            const a = e.attributes[i[o]];
            n[r++] = a.offset, n[r++] = a.format, n[r++] = a.stride, n[r++] = a.instance
        }
        const s = n.join("|");
        return e._layoutKey = Ou(s, "geometry"), e._layoutKey
    }
    _generateAttributeLocationsKey(e) {
        const n = [];
        let r = 0;
        const i = Object.keys(e.attributeData).sort();
        for (let o = 0; o < i.length; o++) {
            const a = e.attributeData[i[o]];
            n[r++] = a.location
        }
        const s = n.join("|");
        return e._attributeLocationsKey = Ou(s, "programAttributes"), e._attributeLocationsKey
    }
    getBufferNamesToBind(e, n) {
        const r = e._layoutKey << 16 | n._attributeLocationsKey;
        if (this._bindingNamesCache[r]) return this._bindingNamesCache[r];
        const i = this._createVertexBufferLayouts(e, n),
            s = Object.create(null),
            o = n.attributeData;
        for (let a = 0; a < i.length; a++) {
            const c = Object.values(i[a].attributes)[0].shaderLocation;
            for (const u in o)
                if (o[u].location === c) {
                    s[a] = u;
                    break
                }
        }
        return this._bindingNamesCache[r] = s, s
    }
    _createVertexBufferLayouts(e, n) {
        n._attributeLocationsKey || this._generateAttributeLocationsKey(n);
        const r = e._layoutKey << 16 | n._attributeLocationsKey;
        if (this._bufferLayoutsCache[r]) return this._bufferLayoutsCache[r];
        const i = [];
        return e.buffers.forEach(s => {
            const o = {
                    arrayStride: 0,
                    stepMode: "vertex",
                    attributes: []
                },
                a = o.attributes;
            for (const l in n.attributeData) {
                const c = e.attributes[l];
                (c.divisor ? ? 1) !== 1 && Oe(`Attribute ${l} has an invalid divisor value of '${c.divisor}'. WebGPU only supports a divisor value of 1`), c.buffer === s && (o.arrayStride = c.stride, o.stepMode = c.instance ? "instance" : "vertex", a.push({
                    shaderLocation: n.attributeData[l].location,
                    offset: c.offset,
                    format: c.format
                }))
            }
            a.length && i.push(o)
        }), this._bufferLayoutsCache[r] = i, i
    }
    _updatePipeHash() {
        const e = aue(this._stencilMode, this._multisampleCount, this._colorMask, this._depthStencilAttachment);
        this._pipeStateCaches[e] || (this._pipeStateCaches[e] = Object.create(null)), this._pipeCache = this._pipeStateCaches[e]
    }
    destroy() {
        this._renderer = null, this._bufferLayoutsCache = null
    }
}
U$.extension = {
    type: [G.WebGPUSystem],
    name: "pipeline"
};
class lue {
    constructor() {
        this.contexts = [], this.msaaTextures = [], this.msaaSamples = 1
    }
}
class cue {
    init(e, n) {
        this._renderer = e, this._renderTargetSystem = n
    }
    copyToTexture(e, n, r, i, s) {
        const o = this._renderer,
            a = this._getGpuColorTexture(e),
            l = o.texture.getGpuSource(n.source);
        return o.encoder.commandEncoder.copyTextureToTexture({
            texture: a,
            origin: r
        }, {
            texture: l,
            origin: s
        }, i), n
    }
    startRenderPass(e, n = !0, r, i) {
        const o = this._renderTargetSystem.getGpuRenderTarget(e),
            a = this.getDescriptor(e, n, r);
        o.descriptor = a, this._renderer.pipeline.setRenderTarget(o), this._renderer.encoder.beginRenderPass(o), this._renderer.encoder.setViewport(i)
    }
    finishRenderPass() {
        this._renderer.encoder.endRenderPass()
    }
    _getGpuColorTexture(e) {
        const n = this._renderTargetSystem.getGpuRenderTarget(e);
        return n.contexts[0] ? n.contexts[0].getCurrentTexture() : this._renderer.texture.getGpuSource(e.colorTextures[0].source)
    }
    getDescriptor(e, n, r) {
        typeof n == "boolean" && (n = n ? Yn.ALL : Yn.NONE);
        const i = this._renderTargetSystem,
            s = i.getGpuRenderTarget(e),
            o = e.colorTextures.map((c, u) => {
                const d = s.contexts[u];
                let f, h;
                d ? f = d.getCurrentTexture().createView() : f = this._renderer.texture.getGpuSource(c).createView({
                    mipLevelCount: 1
                }), s.msaaTextures[u] && (h = f, f = this._renderer.texture.getTextureView(s.msaaTextures[u]));
                const p = n & Yn.COLOR ? "clear" : "load";
                return r ? ? (r = i.defaultClearColor), {
                    view: f,
                    resolveTarget: h,
                    clearValue: r,
                    storeOp: "store",
                    loadOp: p
                }
            });
        let a;
        if ((e.stencil || e.depth) && !e.depthStencilTexture && (e.ensureDepthStencilTexture(), e.depthStencilTexture.source.sampleCount = s.msaa ? 4 : 1), e.depthStencilTexture) {
            const c = n & Yn.STENCIL ? "clear" : "load",
                u = n & Yn.DEPTH ? "clear" : "load";
            a = {
                view: this._renderer.texture.getGpuSource(e.depthStencilTexture.source).createView(),
                stencilStoreOp: "store",
                stencilLoadOp: c,
                depthClearValue: 1,
                depthLoadOp: u,
                depthStoreOp: "store"
            }
        }
        return {
            colorAttachments: o,
            depthStencilAttachment: a
        }
    }
    clear(e, n = !0, r, i) {
        if (!n) return;
        const {
            gpu: s,
            encoder: o
        } = this._renderer, a = s.device;
        if (o.commandEncoder === null) {
            const c = a.createCommandEncoder(),
                u = this.getDescriptor(e, n, r),
                d = c.beginRenderPass(u);
            d.setViewport(i.x, i.y, i.width, i.height, 0, 1), d.end();
            const f = c.finish();
            a.queue.submit([f])
        } else this.startRenderPass(e, n, r, i)
    }
    initGpuRenderTarget(e) {
        e.isRoot = !0;
        const n = new lue;
        return e.colorTextures.forEach((r, i) => {
            if (r instanceof oi) {
                const s = r.resource.getContext("webgpu"),
                    o = r.transparent ? "premultiplied" : "opaque";
                try {
                    s.configure({
                        device: this._renderer.gpu.device,
                        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
                        format: "bgra8unorm",
                        alphaMode: o
                    })
                } catch (a) {
                    console.error(a)
                }
                n.contexts[i] = s
            }
            if (n.msaa = r.source.antialias, r.source.antialias) {
                const s = new Wt({
                    width: 0,
                    height: 0,
                    sampleCount: 4
                });
                n.msaaTextures[i] = s
            }
        }), n.msaa && (n.msaaSamples = 4, e.depthStencilTexture && (e.depthStencilTexture.source.sampleCount = 4)), n
    }
    destroyGpuRenderTarget(e) {
        e.contexts.forEach(n => {
            n.unconfigure()
        }), e.msaaTextures.forEach(n => {
            n.destroy()
        }), e.msaaTextures.length = 0, e.contexts.length = 0
    }
    ensureDepthStencilTexture(e) {
        const n = this._renderTargetSystem.getGpuRenderTarget(e);
        e.depthStencilTexture && n.msaa && (e.depthStencilTexture.source.sampleCount = 4)
    }
    resizeGpuRenderTarget(e) {
        const n = this._renderTargetSystem.getGpuRenderTarget(e);
        n.width = e.width, n.height = e.height, n.msaa && e.colorTextures.forEach((r, i) => {
            const s = n.msaaTextures[i];
            s == null || s.resize(r.source.width, r.source.height, r.source._resolution)
        })
    }
}
class G$ extends t$ {
    constructor(e) {
        super(e), this.adaptor = new cue, this.adaptor.init(e, this)
    }
}
G$.extension = {
    type: [G.WebGPUSystem],
    name: "renderTarget"
};
class H$ {
    constructor() {
        this._gpuProgramData = Object.create(null)
    }
    contextChange(e) {
        this._gpu = e
    }
    getProgramData(e) {
        return this._gpuProgramData[e._layoutKey] || this._createGPUProgramData(e)
    }
    _createGPUProgramData(e) {
        const n = this._gpu.device,
            r = e.gpuLayout.map(s => n.createBindGroupLayout({
                entries: s
            })),
            i = {
                bindGroupLayouts: r
            };
        return this._gpuProgramData[e._layoutKey] = {
            bindGroups: r,
            pipeline: n.createPipelineLayout(i)
        }, this._gpuProgramData[e._layoutKey]
    }
    destroy() {
        this._gpu = null, this._gpuProgramData = null
    }
}
H$.extension = {
    type: [G.WebGPUSystem],
    name: "shader"
};
const Gn = {};
Gn.normal = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    }
};
Gn.add = {
    alpha: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
    }
};
Gn.multiply = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "dst",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    }
};
Gn.screen = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
    }
};
Gn.overlay = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "one",
        dstFactor: "one-minus-src",
        operation: "add"
    }
};
Gn.none = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "zero",
        dstFactor: "zero",
        operation: "add"
    }
};
Gn["normal-npm"] = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    }
};
Gn["add-npm"] = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "add"
    },
    color: {
        srcFactor: "src-alpha",
        dstFactor: "one",
        operation: "add"
    }
};
Gn["screen-npm"] = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "src-alpha",
        dstFactor: "one-minus-src",
        operation: "add"
    }
};
Gn.erase = {
    alpha: {
        srcFactor: "zero",
        dstFactor: "one-minus-src-alpha",
        operation: "add"
    },
    color: {
        srcFactor: "zero",
        dstFactor: "one-minus-src",
        operation: "add"
    }
};
Gn.min = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "min"
    },
    color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "min"
    }
};
Gn.max = {
    alpha: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "max"
    },
    color: {
        srcFactor: "one",
        dstFactor: "one",
        operation: "max"
    }
};
class z$ {
    constructor() {
        this.defaultState = new Fr, this.defaultState.blend = !0
    }
    contextChange(e) {
        this.gpu = e
    }
    getColorTargets(e) {
        return [{
            format: "bgra8unorm",
            writeMask: 0,
            blend: Gn[e.blendMode] || Gn.normal
        }]
    }
    destroy() {
        this.gpu = null
    }
}
z$.extension = {
    type: [G.WebGPUSystem],
    name: "state"
};
const uue = {
        type: "image",
        upload(t, e, n) {
            const r = t.resource,
                i = (t.pixelWidth | 0) * (t.pixelHeight | 0),
                s = r.byteLength / i;
            n.device.queue.writeTexture({
                texture: e
            }, r, {
                offset: 0,
                rowsPerImage: t.pixelHeight,
                bytesPerRow: t.pixelHeight * s
            }, {
                width: t.pixelWidth,
                height: t.pixelHeight,
                depthOrArrayLayers: 1
            })
        }
    },
    j$ = {
        "bc1-rgba-unorm": {
            blockBytes: 8,
            blockWidth: 4,
            blockHeight: 4
        },
        "bc2-rgba-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "bc3-rgba-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "bc7-rgba-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "etc1-rgb-unorm": {
            blockBytes: 8,
            blockWidth: 4,
            blockHeight: 4
        },
        "etc2-rgba8unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        },
        "astc-4x4-unorm": {
            blockBytes: 16,
            blockWidth: 4,
            blockHeight: 4
        }
    },
    due = {
        blockBytes: 4,
        blockWidth: 1,
        blockHeight: 1
    },
    fue = {
        type: "compressed",
        upload(t, e, n) {
            let r = t.pixelWidth,
                i = t.pixelHeight;
            const s = j$[t.format] || due;
            for (let o = 0; o < t.resource.length; o++) {
                const a = t.resource[o],
                    l = Math.ceil(r / s.blockWidth) * s.blockBytes;
                n.device.queue.writeTexture({
                    texture: e,
                    mipLevel: o
                }, a, {
                    offset: 0,
                    bytesPerRow: l
                }, {
                    width: Math.ceil(r / s.blockWidth) * s.blockWidth,
                    height: Math.ceil(i / s.blockHeight) * s.blockHeight,
                    depthOrArrayLayers: 1
                }), r = Math.max(r >> 1, 1), i = Math.max(i >> 1, 1)
            }
        }
    },
    V$ = {
        type: "image",
        upload(t, e, n) {
            const r = t.resource;
            if (!r) return;
            if (globalThis.HTMLImageElement && r instanceof HTMLImageElement) {
                const a = Ge.get().createCanvas(r.width, r.height);
                a.getContext("2d").drawImage(r, 0, 0, r.width, r.height), t.resource = a, Oe("ImageSource: Image element passed, converting to canvas and replacing resource.")
            }
            const i = Math.min(e.width, t.resourceWidth || t.pixelWidth),
                s = Math.min(e.height, t.resourceHeight || t.pixelHeight),
                o = t.alphaMode === "premultiply-alpha-on-upload";
            n.device.queue.copyExternalImageToTexture({
                source: r
            }, {
                texture: e,
                premultipliedAlpha: o
            }, {
                width: i,
                height: s
            })
        }
    },
    hue = {
        type: "video",
        upload(t, e, n) {
            V$.upload(t, e, n)
        }
    };
class pue {
    constructor(e) {
        this.device = e, this.sampler = e.createSampler({
            minFilter: "linear"
        }), this.pipelines = {}
    }
    _getMipmapPipeline(e) {
        let n = this.pipelines[e];
        return n || (this.mipmapShaderModule || (this.mipmapShaderModule = this.device.createShaderModule({
            code: `
                        var<private> pos : array<vec2<f32>, 3> = array<vec2<f32>, 3>(
                        vec2<f32>(-1.0, -1.0), vec2<f32>(-1.0, 3.0), vec2<f32>(3.0, -1.0));

                        struct VertexOutput {
                        @builtin(position) position : vec4<f32>,
                        @location(0) texCoord : vec2<f32>,
                        };

                        @vertex
                        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var output : VertexOutput;
                        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
                        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                        return output;
                        }

                        @group(0) @binding(0) var imgSampler : sampler;
                        @group(0) @binding(1) var img : texture_2d<f32>;

                        @fragment
                        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
                        return textureSample(img, imgSampler, texCoord);
                        }
                    `
        })), n = this.device.createRenderPipeline({
            layout: "auto",
            vertex: {
                module: this.mipmapShaderModule,
                entryPoint: "vertexMain"
            },
            fragment: {
                module: this.mipmapShaderModule,
                entryPoint: "fragmentMain",
                targets: [{
                    format: e
                }]
            }
        }), this.pipelines[e] = n), n
    }
    generateMipmap(e) {
        const n = this._getMipmapPipeline(e.format);
        if (e.dimension === "3d" || e.dimension === "1d") throw new Error("Generating mipmaps for non-2d textures is currently unsupported!");
        let r = e;
        const i = e.depthOrArrayLayers || 1,
            s = e.usage & GPUTextureUsage.RENDER_ATTACHMENT;
        if (!s) {
            const l = {
                size: {
                    width: Math.ceil(e.width / 2),
                    height: Math.ceil(e.height / 2),
                    depthOrArrayLayers: i
                },
                format: e.format,
                usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_SRC | GPUTextureUsage.RENDER_ATTACHMENT,
                mipLevelCount: e.mipLevelCount - 1
            };
            r = this.device.createTexture(l)
        }
        const o = this.device.createCommandEncoder({}),
            a = n.getBindGroupLayout(0);
        for (let l = 0; l < i; ++l) {
            let c = e.createView({
                    baseMipLevel: 0,
                    mipLevelCount: 1,
                    dimension: "2d",
                    baseArrayLayer: l,
                    arrayLayerCount: 1
                }),
                u = s ? 1 : 0;
            for (let d = 1; d < e.mipLevelCount; ++d) {
                const f = r.createView({
                        baseMipLevel: u++,
                        mipLevelCount: 1,
                        dimension: "2d",
                        baseArrayLayer: l,
                        arrayLayerCount: 1
                    }),
                    h = o.beginRenderPass({
                        colorAttachments: [{
                            view: f,
                            storeOp: "store",
                            loadOp: "clear",
                            clearValue: {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 0
                            }
                        }]
                    }),
                    p = this.device.createBindGroup({
                        layout: a,
                        entries: [{
                            binding: 0,
                            resource: this.sampler
                        }, {
                            binding: 1,
                            resource: c
                        }]
                    });
                h.setPipeline(n), h.setBindGroup(0, p), h.draw(3, 1, 0, 0), h.end(), c = f
            }
        }
        if (!s) {
            const l = {
                width: Math.ceil(e.width / 2),
                height: Math.ceil(e.height / 2),
                depthOrArrayLayers: i
            };
            for (let c = 1; c < e.mipLevelCount; ++c) o.copyTextureToTexture({
                texture: r,
                mipLevel: c - 1
            }, {
                texture: e,
                mipLevel: c
            }, l), l.width = Math.ceil(l.width / 2), l.height = Math.ceil(l.height / 2)
        }
        return this.device.queue.submit([o.finish()]), s || r.destroy(), e
    }
}
class W$ {
    constructor(e) {
        this.managedTextures = [], this._gpuSources = Object.create(null), this._gpuSamplers = Object.create(null), this._bindGroupHash = Object.create(null), this._textureViewHash = Object.create(null), this._uploads = {
            image: V$,
            buffer: uue,
            video: hue,
            compressed: fue
        }, this._renderer = e, e.renderableGC.addManagedHash(this, "_gpuSources"), e.renderableGC.addManagedHash(this, "_gpuSamplers"), e.renderableGC.addManagedHash(this, "_bindGroupHash"), e.renderableGC.addManagedHash(this, "_textureViewHash")
    }
    contextChange(e) {
        this._gpu = e
    }
    initSource(e) {
        if (e.autoGenerateMipmaps) {
            const l = Math.max(e.pixelWidth, e.pixelHeight);
            e.mipLevelCount = Math.floor(Math.log2(l)) + 1
        }
        let n = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
        e.uploadMethodId !== "compressed" && (n |= GPUTextureUsage.RENDER_ATTACHMENT, n |= GPUTextureUsage.COPY_SRC);
        const r = j$[e.format] || {
                blockBytes: 4,
                blockWidth: 1,
                blockHeight: 1
            },
            i = Math.ceil(e.pixelWidth / r.blockWidth) * r.blockWidth,
            s = Math.ceil(e.pixelHeight / r.blockHeight) * r.blockHeight,
            o = {
                label: e.label,
                size: {
                    width: i,
                    height: s
                },
                format: e.format,
                sampleCount: e.sampleCount,
                mipLevelCount: e.mipLevelCount,
                dimension: e.dimension,
                usage: n
            },
            a = this._gpu.device.createTexture(o);
        return this._gpuSources[e.uid] = a, this.managedTextures.includes(e) || (e.on("update", this.onSourceUpdate, this), e.on("resize", this.onSourceResize, this), e.on("destroy", this.onSourceDestroy, this), e.on("unload", this.onSourceUnload, this), e.on("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.push(e)), this.onSourceUpdate(e), a
    }
    onSourceUpdate(e) {
        const n = this.getGpuSource(e);
        n && (this._uploads[e.uploadMethodId] && this._uploads[e.uploadMethodId].upload(e, n, this._gpu), e.autoGenerateMipmaps && e.mipLevelCount > 1 && this.onUpdateMipmaps(e))
    }
    onSourceUnload(e) {
        const n = this._gpuSources[e.uid];
        n && (this._gpuSources[e.uid] = null, n.destroy())
    }
    onUpdateMipmaps(e) {
        this._mipmapGenerator || (this._mipmapGenerator = new pue(this._gpu.device));
        const n = this.getGpuSource(e);
        this._mipmapGenerator.generateMipmap(n)
    }
    onSourceDestroy(e) {
        e.off("update", this.onSourceUpdate, this), e.off("unload", this.onSourceUnload, this), e.off("destroy", this.onSourceDestroy, this), e.off("resize", this.onSourceResize, this), e.off("updateMipmaps", this.onUpdateMipmaps, this), this.managedTextures.splice(this.managedTextures.indexOf(e), 1), this.onSourceUnload(e)
    }
    onSourceResize(e) {
        const n = this._gpuSources[e.uid];
        n ? (n.width !== e.pixelWidth || n.height !== e.pixelHeight) && (this._textureViewHash[e.uid] = null, this._bindGroupHash[e.uid] = null, this.onSourceUnload(e), this.initSource(e)) : this.initSource(e)
    }
    _initSampler(e) {
        return this._gpuSamplers[e._resourceId] = this._gpu.device.createSampler(e), this._gpuSamplers[e._resourceId]
    }
    getGpuSampler(e) {
        return this._gpuSamplers[e._resourceId] || this._initSampler(e)
    }
    getGpuSource(e) {
        return this._gpuSources[e.uid] || this.initSource(e)
    }
    getTextureBindGroup(e) {
        return this._bindGroupHash[e.uid] ? ? this._createTextureBindGroup(e)
    }
    _createTextureBindGroup(e) {
        const n = e.source;
        return this._bindGroupHash[e.uid] = new Gi({
            0: n,
            1: n.style,
            2: new Pn({
                uTextureMatrix: {
                    type: "mat3x3<f32>",
                    value: e.textureMatrix.mapCoord
                }
            })
        }), this._bindGroupHash[e.uid]
    }
    getTextureView(e) {
        const n = e.source;
        return this._textureViewHash[n.uid] ? ? this._createTextureView(n)
    }
    _createTextureView(e) {
        return this._textureViewHash[e.uid] = this.getGpuSource(e).createView(), this._textureViewHash[e.uid]
    }
    generateCanvas(e) {
        const n = this._renderer,
            r = n.gpu.device.createCommandEncoder(),
            i = Ge.get().createCanvas();
        i.width = e.source.pixelWidth, i.height = e.source.pixelHeight;
        const s = i.getContext("webgpu");
        return s.configure({
            device: n.gpu.device,
            usage: GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC,
            format: Ge.get().getNavigator().gpu.getPreferredCanvasFormat(),
            alphaMode: "premultiplied"
        }), r.copyTextureToTexture({
            texture: n.texture.getGpuSource(e.source),
            origin: {
                x: 0,
                y: 0
            }
        }, {
            texture: s.getCurrentTexture()
        }, {
            width: i.width,
            height: i.height
        }), n.gpu.device.queue.submit([r.finish()]), i
    }
    getPixels(e) {
        const n = this.generateCanvas(e),
            r = qs.getOptimalCanvasAndContext(n.width, n.height),
            i = r.context;
        i.drawImage(n, 0, 0);
        const {
            width: s,
            height: o
        } = n, a = i.getImageData(0, 0, s, o), l = new Uint8ClampedArray(a.data.buffer);
        return qs.returnCanvasAndContext(r), {
            pixels: l,
            width: s,
            height: o
        }
    }
    destroy() {
        this.managedTextures.slice().forEach(e => this.onSourceDestroy(e)), this.managedTextures = null;
        for (const e of Object.keys(this._bindGroupHash)) {
            const n = Number(e),
                r = this._bindGroupHash[n];
            r == null || r.destroy(), this._bindGroupHash[n] = null
        }
        this._gpu = null, this._mipmapGenerator = null, this._gpuSources = null, this._bindGroupHash = null, this._textureViewHash = null, this._gpuSamplers = null
    }
}
W$.extension = {
    type: [G.WebGPUSystem],
    name: "texture"
};
class Y$ {
    constructor() {
        this._maxTextures = 0
    }
    contextChange(e) {
        const n = new Pn({
            uTransformMatrix: {
                value: new Te,
                type: "mat3x3<f32>"
            },
            uColor: {
                value: new Float32Array([1, 1, 1, 1]),
                type: "vec4<f32>"
            },
            uRound: {
                value: 0,
                type: "f32"
            }
        });
        this._maxTextures = e.limits.maxBatchableTextures;
        const r = pd({
            name: "graphics",
            bits: [Ax, Ix(this._maxTextures), Dle, gd]
        });
        this.shader = new br({
            gpuProgram: r,
            resources: {
                localUniforms: n
            }
        })
    }
    execute(e, n) {
        const r = n.context,
            i = r.customShader || this.shader,
            s = e.renderer,
            o = s.graphicsContext,
            {
                batcher: a,
                instructions: l
            } = o.getContextRenderData(r),
            c = s.encoder;
        c.setGeometry(a.geometry, i.gpuProgram);
        const u = s.globalUniforms.bindGroup;
        c.setBindGroup(0, u, i.gpuProgram);
        const d = s.renderPipes.uniformBatch.getUniformBindGroup(i.resources.localUniforms, !0);
        c.setBindGroup(2, d, i.gpuProgram);
        const f = l.instructions;
        let h = null;
        for (let p = 0; p < l.instructionSize; p++) {
            const b = f[p];
            if (b.topology !== h && (h = b.topology, c.setPipelineFromGeometryProgramAndState(a.geometry, i.gpuProgram, e.state, b.topology)), i.groups[1] = b.bindGroup, !b.gpuBindGroup) {
                const y = b.textures;
                b.bindGroup = Px(y.textures, y.count, this._maxTextures), b.gpuBindGroup = s.bindGroup.getBindGroup(b.bindGroup, i.gpuProgram, 1)
            }
            c.setBindGroup(1, b.bindGroup, i.gpuProgram), c.renderPassEncoder.drawIndexed(b.size, 1, b.start)
        }
    }
    destroy() {
        this.shader.destroy(!0), this.shader = null
    }
}
Y$.extension = {
    type: [G.WebGPUPipesAdaptor],
    name: "graphics"
};
class X$ {
    init() {
        const e = pd({
            name: "mesh",
            bits: [Zc, $le, gd]
        });
        this._shader = new br({
            gpuProgram: e,
            resources: {
                uTexture: we.EMPTY._source,
                uSampler: we.EMPTY._source.style,
                textureUniforms: {
                    uTextureMatrix: {
                        type: "mat3x3<f32>",
                        value: new Te
                    }
                }
            }
        })
    }
    execute(e, n) {
        const r = e.renderer;
        let i = n._shader;
        if (!i) i = this._shader, i.groups[2] = r.texture.getTextureBindGroup(n.texture);
        else if (!i.gpuProgram) {
            Oe("Mesh shader has no gpuProgram", n.shader);
            return
        }
        const s = i.gpuProgram;
        if (s.autoAssignGlobalUniforms && (i.groups[0] = r.globalUniforms.bindGroup), s.autoAssignLocalUniforms) {
            const o = e.localUniforms;
            i.groups[1] = r.renderPipes.uniformBatch.getUniformBindGroup(o, !0)
        }
        r.encoder.draw({
            geometry: n._geometry,
            shader: i,
            state: n.state
        })
    }
    destroy() {
        this._shader.destroy(!0), this._shader = null
    }
}
X$.extension = {
    type: [G.WebGPUPipesAdaptor],
    name: "mesh"
};
const mue = [...P$, L$, D$, rw, $$, k$, W$, G$, H$, z$, U$, B$, F$, R$],
    gue = [...A$, N$],
    yue = [MD, X$, Y$],
    q$ = [],
    K$ = [],
    J$ = [];
Re.handleByNamedList(G.WebGPUSystem, q$);
Re.handleByNamedList(G.WebGPUPipes, K$);
Re.handleByNamedList(G.WebGPUPipesAdaptor, J$);
Re.add(...mue, ...gue, ...yue);
class vue extends em {
    constructor() {
        const e = {
            name: "webgpu",
            type: tr.WEBGPU,
            systems: q$,
            renderPipes: K$,
            renderPipeAdaptors: J$
        };
        super(e)
    }
}
const _ue = Object.freeze(Object.defineProperty({
    __proto__: null,
    WebGPURenderer: vue
}, Symbol.toStringTag, {
    value: "Module"
}));
class bue {
    constructor() {
        this.batches = [], this.batched = !1
    }
    destroy() {
        this.batches.forEach(e => {
            nn.return(e)
        }), this.batches.length = 0
    }
}
class Z$ {
    constructor(e, n) {
        this.state = Fr.for2d(), this.renderer = e, this._adaptor = n, this.renderer.runners.contextChange.add(this)
    }
    contextChange() {
        this._adaptor.contextChange(this.renderer)
    }
    validateRenderable(e) {
        const n = e.context,
            r = !!e._gpuData,
            i = this.renderer.graphicsContext.updateGpuContext(n);
        return !!(i.isBatchable || r !== i.isBatchable)
    }
    addRenderable(e, n) {
        const r = this.renderer.graphicsContext.updateGpuContext(e.context);
        e.didViewUpdate && this._rebuild(e), r.isBatchable ? this._addToBatcher(e, n) : (this.renderer.renderPipes.batch.break(n), n.add(e))
    }
    updateRenderable(e) {
        const r = this._getGpuDataForRenderable(e).batches;
        for (let i = 0; i < r.length; i++) {
            const s = r[i];
            s._batcher.updateElement(s)
        }
    }
    execute(e) {
        if (!e.isRenderable) return;
        const n = this.renderer,
            r = e.context;
        if (!n.graphicsContext.getGpuContext(r).batches.length) return;
        const s = r.customShader || this._adaptor.shader;
        this.state.blendMode = e.groupBlendMode;
        const o = s.resources.localUniforms.uniforms;
        o.uTransformMatrix = e.groupTransform, o.uRound = n._roundPixels | e._roundPixels, vd(e.groupColorAlpha, o.uColor, 0), this._adaptor.execute(this, e)
    }
    _rebuild(e) {
        const n = this._getGpuDataForRenderable(e),
            r = this.renderer.graphicsContext.updateGpuContext(e.context);
        n.destroy(), r.isBatchable && this._updateBatchesForRenderable(e, n)
    }
    _addToBatcher(e, n) {
        const r = this.renderer.renderPipes.batch,
            i = this._getGpuDataForRenderable(e).batches;
        for (let s = 0; s < i.length; s++) {
            const o = i[s];
            r.addToBatch(o, n)
        }
    }
    _getGpuDataForRenderable(e) {
        return e._gpuData[this.renderer.uid] || this._initGpuDataForRenderable(e)
    }
    _initGpuDataForRenderable(e) {
        const n = new bue;
        return e._gpuData[this.renderer.uid] = n, n
    }
    _updateBatchesForRenderable(e, n) {
        const r = e.context,
            i = this.renderer.graphicsContext.getGpuContext(r),
            s = this.renderer._roundPixels | e._roundPixels;
        n.batches = i.batches.map(o => {
            const a = nn.get(Bx);
            return o.copyTo(a), a.renderable = e, a.roundPixels = s, a
        })
    }
    destroy() {
        this.renderer = null, this._adaptor.destroy(), this._adaptor = null, this.state = null
    }
}
Z$.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "graphics"
};
const Q$ = class eF extends zx {
    constructor(...e) {
        super({});
        let n = e[0] ? ? {};
        typeof n == "number" && (Ie(Ye, "PlaneGeometry constructor changed please use { width, height, verticesX, verticesY } instead"), n = {
            width: n,
            height: e[1],
            verticesX: e[2],
            verticesY: e[3]
        }), this.build(n)
    }
    build(e) {
        e = { ...eF.defaultOptions,
            ...e
        }, this.verticesX = this.verticesX ? ? e.verticesX, this.verticesY = this.verticesY ? ? e.verticesY, this.width = this.width ? ? e.width, this.height = this.height ? ? e.height;
        const n = this.verticesX * this.verticesY,
            r = [],
            i = [],
            s = [],
            o = this.verticesX - 1,
            a = this.verticesY - 1,
            l = this.width / o,
            c = this.height / a;
        for (let d = 0; d < n; d++) {
            const f = d % this.verticesX,
                h = d / this.verticesX | 0;
            r.push(f * l, h * c), i.push(f / o, h / a)
        }
        const u = o * a;
        for (let d = 0; d < u; d++) {
            const f = d % o,
                h = d / o | 0,
                p = h * this.verticesX + f,
                b = h * this.verticesX + f + 1,
                y = (h + 1) * this.verticesX + f,
                m = (h + 1) * this.verticesX + f + 1;
            s.push(p, b, y, b, m, y)
        }
        this.buffers[0].data = new Float32Array(r), this.buffers[1].data = new Float32Array(i), this.indexBuffer.data = new Uint32Array(s), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update()
    }
};
Q$.defaultOptions = {
    width: 100,
    height: 100,
    verticesX: 10,
    verticesY: 10
};
let xue = Q$;
class iw {
    constructor() {
        this.batcherName = "default", this.packAsQuad = !1, this.indexOffset = 0, this.attributeOffset = 0, this.roundPixels = 0, this._batcher = null, this._batch = null, this._textureMatrixUpdateId = -1, this._uvUpdateId = -1
    }
    get blendMode() {
        return this.renderable.groupBlendMode
    }
    get topology() {
        return this._topology || this.geometry.topology
    }
    set topology(e) {
        this._topology = e
    }
    reset() {
        this.renderable = null, this.texture = null, this._batcher = null, this._batch = null, this.geometry = null, this._uvUpdateId = -1, this._textureMatrixUpdateId = -1
    }
    setTexture(e) {
        this.texture !== e && (this.texture = e, this._textureMatrixUpdateId = -1)
    }
    get uvs() {
        const n = this.geometry.getBuffer("aUV"),
            r = n.data;
        let i = r;
        const s = this.texture.textureMatrix;
        return s.isSimple || (i = this._transformedUvs, (this._textureMatrixUpdateId !== s._updateID || this._uvUpdateId !== n._updateID) && ((!i || i.length < r.length) && (i = this._transformedUvs = new Float32Array(r.length)), this._textureMatrixUpdateId = s._updateID, this._uvUpdateId = n._updateID, s.multiplyUvs(r, i))), i
    }
    get positions() {
        return this.geometry.positions
    }
    get indices() {
        return this.geometry.indices
    }
    get color() {
        return this.renderable.groupColorAlpha
    }
    get groupTransform() {
        return this.renderable.groupTransform
    }
    get attributeSize() {
        return this.geometry.positions.length / 2
    }
    get indexSize() {
        return this.geometry.indices.length
    }
}
class NC {
    destroy() {}
}
class tF {
    constructor(e, n) {
        this.localUniforms = new Pn({
            uTransformMatrix: {
                value: new Te,
                type: "mat3x3<f32>"
            },
            uColor: {
                value: new Float32Array([1, 1, 1, 1]),
                type: "vec4<f32>"
            },
            uRound: {
                value: 0,
                type: "f32"
            }
        }), this.localUniformsBindGroup = new Gi({
            0: this.localUniforms
        }), this.renderer = e, this._adaptor = n, this._adaptor.init()
    }
    validateRenderable(e) {
        const n = this._getMeshData(e),
            r = n.batched,
            i = e.batched;
        if (n.batched = i, r !== i) return !0;
        if (i) {
            const s = e._geometry;
            if (s.indices.length !== n.indexSize || s.positions.length !== n.vertexSize) return n.indexSize = s.indices.length, n.vertexSize = s.positions.length, !0;
            const o = this._getBatchableMesh(e);
            return o.texture.uid !== e._texture.uid && (o._textureMatrixUpdateId = -1), !o._batcher.checkAndUpdateTexture(o, e._texture)
        }
        return !1
    }
    addRenderable(e, n) {
        const r = this.renderer.renderPipes.batch,
            {
                batched: i
            } = this._getMeshData(e);
        if (i) {
            const s = this._getBatchableMesh(e);
            s.setTexture(e._texture), s.geometry = e._geometry, r.addToBatch(s, n)
        } else r.break(n), n.add(e)
    }
    updateRenderable(e) {
        if (e.batched) {
            const n = this._getBatchableMesh(e);
            n.setTexture(e._texture), n.geometry = e._geometry, n._batcher.updateElement(n)
        }
    }
    execute(e) {
        if (!e.isRenderable) return;
        e.state.blendMode = ku(e.groupBlendMode, e.texture._source);
        const n = this.localUniforms;
        n.uniforms.uTransformMatrix = e.groupTransform, n.uniforms.uRound = this.renderer._roundPixels | e._roundPixels, n.update(), vd(e.groupColorAlpha, n.uniforms.uColor, 0), this._adaptor.execute(this, e)
    }
    _getMeshData(e) {
        var n, r;
        return (n = e._gpuData)[r = this.renderer.uid] || (n[r] = new NC), e._gpuData[this.renderer.uid].meshData || this._initMeshData(e)
    }
    _initMeshData(e) {
        var n, r;
        return e._gpuData[this.renderer.uid].meshData = {
            batched: e.batched,
            indexSize: (n = e._geometry.indices) == null ? void 0 : n.length,
            vertexSize: (r = e._geometry.positions) == null ? void 0 : r.length
        }, e._gpuData[this.renderer.uid].meshData
    }
    _getBatchableMesh(e) {
        var n, r;
        return (n = e._gpuData)[r = this.renderer.uid] || (n[r] = new NC), e._gpuData[this.renderer.uid].batchableMesh || this._initBatchableMesh(e)
    }
    _initBatchableMesh(e) {
        const n = new iw;
        return n.renderable = e, n.setTexture(e._texture), n.transform = e.groupTransform, n.roundPixels = this.renderer._roundPixels | e._roundPixels, e._gpuData[this.renderer.uid].batchableMesh = n, n
    }
    destroy() {
        this.localUniforms = null, this.localUniformsBindGroup = null, this._adaptor.destroy(), this._adaptor = null, this.renderer = null
    }
}
tF.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "mesh"
};
class wue {
    execute(e, n) {
        const r = e.state,
            i = e.renderer,
            s = n.shader || e.defaultShader;
        s.resources.uTexture = n.texture._source, s.resources.uniforms = e.localUniforms;
        const o = i.gl,
            a = e.getBuffers(n);
        i.shader.bind(s), i.state.set(r), i.geometry.bind(a.geometry, s.glProgram);
        const c = a.geometry.indexBuffer.data.BYTES_PER_ELEMENT === 2 ? o.UNSIGNED_SHORT : o.UNSIGNED_INT;
        o.drawElements(o.TRIANGLES, n.particleChildren.length * 6, c, 0)
    }
}
class Eue {
    execute(e, n) {
        const r = e.renderer,
            i = n.shader || e.defaultShader;
        i.groups[0] = r.renderPipes.uniformBatch.getUniformBindGroup(e.localUniforms, !0), i.groups[1] = r.texture.getTextureBindGroup(n.texture);
        const s = e.state,
            o = e.getBuffers(n);
        r.encoder.draw({
            geometry: o.geometry,
            shader: n.shader || e.defaultShader,
            state: s,
            size: n.particleChildren.length * 6
        })
    }
}

function UC(t, e = null) {
    const n = t * 6;
    if (n > 65535 ? e || (e = new Uint32Array(n)) : e || (e = new Uint16Array(n)), e.length !== n) throw new Error(`Out buffer length is incorrect, got ${e.length} and expected ${n}`);
    for (let r = 0, i = 0; r < n; r += 6, i += 4) e[r + 0] = i + 0, e[r + 1] = i + 1, e[r + 2] = i + 2, e[r + 3] = i + 0, e[r + 4] = i + 2, e[r + 5] = i + 3;
    return e
}

function Sue(t) {
    return {
        dynamicUpdate: GC(t, !0),
        staticUpdate: GC(t, !1)
    }
}

function GC(t, e) {
    const n = [];
    n.push(`

        var index = 0;

        for (let i = 0; i < ps.length; ++i)
        {
            const p = ps[i];

            `);
    let r = 0;
    for (const s in t) {
        const o = t[s];
        if (e !== o.dynamic) continue;
        n.push(`offset = index + ${r}`), n.push(o.code);
        const a = Xs(o.format);
        r += a.stride / 4
    }
    n.push(`
            index += stride * 4;
        }
    `), n.unshift(`
        var stride = ${r};
    `);
    const i = n.join(`
`);
    return new Function("ps", "f32v", "u32v", i)
}
class Tue {
    constructor(e) {
        this._size = 0, this._generateParticleUpdateCache = {};
        const n = this._size = e.size ? ? 1e3,
            r = e.properties;
        let i = 0,
            s = 0;
        for (const u in r) {
            const d = r[u],
                f = Xs(d.format);
            d.dynamic ? s += f.stride : i += f.stride
        }
        this._dynamicStride = s / 4, this._staticStride = i / 4, this.staticAttributeBuffer = new Za(n * 4 * i), this.dynamicAttributeBuffer = new Za(n * 4 * s), this.indexBuffer = UC(n);
        const o = new hd;
        let a = 0,
            l = 0;
        this._staticBuffer = new Jn({
            data: new Float32Array(1),
            label: "static-particle-buffer",
            shrinkToFit: !1,
            usage: Xe.VERTEX | Xe.COPY_DST
        }), this._dynamicBuffer = new Jn({
            data: new Float32Array(1),
            label: "dynamic-particle-buffer",
            shrinkToFit: !1,
            usage: Xe.VERTEX | Xe.COPY_DST
        });
        for (const u in r) {
            const d = r[u],
                f = Xs(d.format);
            d.dynamic ? (o.addAttribute(d.attributeName, {
                buffer: this._dynamicBuffer,
                stride: this._dynamicStride * 4,
                offset: a * 4,
                format: d.format
            }), a += f.size) : (o.addAttribute(d.attributeName, {
                buffer: this._staticBuffer,
                stride: this._staticStride * 4,
                offset: l * 4,
                format: d.format
            }), l += f.size)
        }
        o.addIndex(this.indexBuffer);
        const c = this.getParticleUpdate(r);
        this._dynamicUpload = c.dynamicUpdate, this._staticUpload = c.staticUpdate, this.geometry = o
    }
    getParticleUpdate(e) {
        const n = Cue(e);
        return this._generateParticleUpdateCache[n] ? this._generateParticleUpdateCache[n] : (this._generateParticleUpdateCache[n] = this.generateParticleUpdate(e), this._generateParticleUpdateCache[n])
    }
    generateParticleUpdate(e) {
        return Sue(e)
    }
    update(e, n) {
        e.length > this._size && (n = !0, this._size = Math.max(e.length, this._size * 1.5 | 0), this.staticAttributeBuffer = new Za(this._size * this._staticStride * 4 * 4), this.dynamicAttributeBuffer = new Za(this._size * this._dynamicStride * 4 * 4), this.indexBuffer = UC(this._size), this.geometry.indexBuffer.setDataWithSize(this.indexBuffer, this.indexBuffer.byteLength, !0));
        const r = this.dynamicAttributeBuffer;
        if (this._dynamicUpload(e, r.float32View, r.uint32View), this._dynamicBuffer.setDataWithSize(this.dynamicAttributeBuffer.float32View, e.length * this._dynamicStride * 4, !0), n) {
            const i = this.staticAttributeBuffer;
            this._staticUpload(e, i.float32View, i.uint32View), this._staticBuffer.setDataWithSize(i.float32View, e.length * this._staticStride * 4, !0)
        }
    }
    destroy() {
        this._staticBuffer.destroy(), this._dynamicBuffer.destroy(), this.geometry.destroy()
    }
}

function Cue(t) {
    const e = [];
    for (const n in t) {
        const r = t[n];
        e.push(n, r.code, r.dynamic ? "d" : "s")
    }
    return e.join("_")
}
var Pue = `varying vec2 vUV;
varying vec4 vColor;

uniform sampler2D uTexture;

void main(void){
    vec4 color = texture2D(uTexture, vUV) * vColor;
    gl_FragColor = color;
}`,
    Aue = `attribute vec2 aVertex;
attribute vec2 aUV;
attribute vec4 aColor;

attribute vec2 aPosition;
attribute float aRotation;

uniform mat3 uTranslationMatrix;
uniform float uRound;
uniform vec2 uResolution;
uniform vec4 uColor;

varying vec2 vUV;
varying vec4 vColor;

vec2 roundPixels(vec2 position, vec2 targetSize)
{       
    return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;
}

void main(void){
    float cosRotation = cos(aRotation);
    float sinRotation = sin(aRotation);
    float x = aVertex.x * cosRotation - aVertex.y * sinRotation;
    float y = aVertex.x * sinRotation + aVertex.y * cosRotation;

    vec2 v = vec2(x, y);
    v = v + aPosition;

    gl_Position = vec4((uTranslationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    if(uRound == 1.0)
    {
        gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
    }

    vUV = aUV;
    vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uColor;
}
`,
    HC = `
struct ParticleUniforms {
  uProjectionMatrix:mat3x3<f32>,
  uColor:vec4<f32>,
  uResolution:vec2<f32>,
  uRoundPixels:f32,
};

@group(0) @binding(0) var<uniform> uniforms: ParticleUniforms;

@group(1) @binding(0) var uTexture: texture_2d<f32>;
@group(1) @binding(1) var uSampler : sampler;

struct VSOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) uv : vec2<f32>,
    @location(1) color : vec4<f32>,
  };
@vertex
fn mainVertex(
  @location(0) aVertex: vec2<f32>,
  @location(1) aPosition: vec2<f32>,
  @location(2) aUV: vec2<f32>,
  @location(3) aColor: vec4<f32>,
  @location(4) aRotation: f32,
) -> VSOutput {
  
   let v = vec2(
       aVertex.x * cos(aRotation) - aVertex.y * sin(aRotation),
       aVertex.x * sin(aRotation) + aVertex.y * cos(aRotation)
   ) + aPosition;

   let position = vec4((uniforms.uProjectionMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    let vColor = vec4(aColor.rgb * aColor.a, aColor.a) * uniforms.uColor;

  return VSOutput(
   position,
   aUV,
   vColor,
  );
}

@fragment
fn mainFragment(
  @location(0) uv: vec2<f32>,
  @location(1) color: vec4<f32>,
  @builtin(position) position: vec4<f32>,
) -> @location(0) vec4<f32> {

    var sample = textureSample(uTexture, uSampler, uv) * color;
   
    return sample;
}`;
class Oue extends br {
    constructor() {
        const e = wa.from({
                vertex: Aue,
                fragment: Pue
            }),
            n = io.from({
                fragment: {
                    source: HC,
                    entryPoint: "mainFragment"
                },
                vertex: {
                    source: HC,
                    entryPoint: "mainVertex"
                }
            });
        super({
            glProgram: e,
            gpuProgram: n,
            resources: {
                uTexture: we.WHITE.source,
                uSampler: new Zi({}),
                uniforms: {
                    uTranslationMatrix: {
                        value: new Te,
                        type: "mat3x3<f32>"
                    },
                    uColor: {
                        value: new tt(16777215),
                        type: "vec4<f32>"
                    },
                    uRound: {
                        value: 1,
                        type: "f32"
                    },
                    uResolution: {
                        value: [0, 0],
                        type: "vec2<f32>"
                    }
                }
            }
        })
    }
}
class nF {
    constructor(e, n) {
        this.state = Fr.for2d(), this.localUniforms = new Pn({
            uTranslationMatrix: {
                value: new Te,
                type: "mat3x3<f32>"
            },
            uColor: {
                value: new Float32Array(4),
                type: "vec4<f32>"
            },
            uRound: {
                value: 1,
                type: "f32"
            },
            uResolution: {
                value: [0, 0],
                type: "vec2<f32>"
            }
        }), this.renderer = e, this.adaptor = n, this.defaultShader = new Oue, this.state = Fr.for2d()
    }
    validateRenderable(e) {
        return !1
    }
    addRenderable(e, n) {
        this.renderer.renderPipes.batch.break(n), n.add(e)
    }
    getBuffers(e) {
        return e._gpuData[this.renderer.uid] || this._initBuffer(e)
    }
    _initBuffer(e) {
        return e._gpuData[this.renderer.uid] = new Tue({
            size: e.particleChildren.length,
            properties: e._properties
        }), e._gpuData[this.renderer.uid]
    }
    updateRenderable(e) {}
    execute(e) {
        const n = e.particleChildren;
        if (n.length === 0) return;
        const r = this.renderer,
            i = this.getBuffers(e);
        e.texture || (e.texture = n[0].texture);
        const s = this.state;
        i.update(n, e._childrenDirty), e._childrenDirty = !1, s.blendMode = ku(e.blendMode, e.texture._source);
        const o = this.localUniforms.uniforms,
            a = o.uTranslationMatrix;
        e.worldTransform.copyTo(a), a.prepend(r.globalUniforms.globalUniformData.projectionMatrix), o.uResolution = r.globalUniforms.globalUniformData.resolution, o.uRound = r._roundPixels | e._roundPixels, vd(e.groupColorAlpha, o.uColor, 0), this.adaptor.execute(this, e)
    }
    destroy() {
        this.defaultShader && (this.defaultShader.destroy(), this.defaultShader = null)
    }
}
class rF extends nF {
    constructor(e) {
        super(e, new wue)
    }
}
rF.extension = {
    type: [G.WebGLPipes],
    name: "particle"
};
class iF extends nF {
    constructor(e) {
        super(e, new Eue)
    }
}
iF.extension = {
    type: [G.WebGPUPipes],
    name: "particle"
};
const sF = class L0 {
    constructor(e) {
        if (e instanceof we) this.texture = e, p0(this, L0.defaultOptions, {});
        else {
            const n = { ...L0.defaultOptions,
                ...e
            };
            p0(this, n, {})
        }
    }
    get alpha() {
        return this._alpha
    }
    set alpha(e) {
        this._alpha = Math.min(Math.max(e, 0), 1), this._updateColor()
    }
    get tint() {
        return Yc(this._tint)
    }
    set tint(e) {
        this._tint = tt.shared.setValue(e ? ? 16777215).toBgrNumber(), this._updateColor()
    }
    _updateColor() {
        this.color = this._tint + ((this._alpha * 255 | 0) << 24)
    }
};
sF.defaultOptions = {
    anchorX: 0,
    anchorY: 0,
    x: 0,
    y: 0,
    scaleX: 1,
    scaleY: 1,
    rotation: 0,
    tint: 16777215,
    alpha: 1
};
let xwe = sF;
const zC = {
        vertex: {
            attributeName: "aVertex",
            format: "float32x2",
            code: `
            const texture = p.texture;
            const sx = p.scaleX;
            const sy = p.scaleY;
            const ax = p.anchorX;
            const ay = p.anchorY;
            const trim = texture.trim;
            const orig = texture.orig;

            if (trim)
            {
                w1 = trim.x - (ax * orig.width);
                w0 = w1 + trim.width;

                h1 = trim.y - (ay * orig.height);
                h0 = h1 + trim.height;
            }
            else
            {
                w1 = -ax * (orig.width);
                w0 = w1 + orig.width;

                h1 = -ay * (orig.height);
                h0 = h1 + orig.height;
            }

            f32v[offset] = w1 * sx;
            f32v[offset + 1] = h1 * sy;

            f32v[offset + stride] = w0 * sx;
            f32v[offset + stride + 1] = h1 * sy;

            f32v[offset + (stride * 2)] = w0 * sx;
            f32v[offset + (stride * 2) + 1] = h0 * sy;

            f32v[offset + (stride * 3)] = w1 * sx;
            f32v[offset + (stride * 3) + 1] = h0 * sy;
        `,
            dynamic: !1
        },
        position: {
            attributeName: "aPosition",
            format: "float32x2",
            code: `
            var x = p.x;
            var y = p.y;

            f32v[offset] = x;
            f32v[offset + 1] = y;

            f32v[offset + stride] = x;
            f32v[offset + stride + 1] = y;

            f32v[offset + (stride * 2)] = x;
            f32v[offset + (stride * 2) + 1] = y;

            f32v[offset + (stride * 3)] = x;
            f32v[offset + (stride * 3) + 1] = y;
        `,
            dynamic: !0
        },
        rotation: {
            attributeName: "aRotation",
            format: "float32",
            code: `
            var rotation = p.rotation;

            f32v[offset] = rotation;
            f32v[offset + stride] = rotation;
            f32v[offset + (stride * 2)] = rotation;
            f32v[offset + (stride * 3)] = rotation;
        `,
            dynamic: !1
        },
        uvs: {
            attributeName: "aUV",
            format: "float32x2",
            code: `
            var uvs = p.texture.uvs;

            f32v[offset] = uvs.x0;
            f32v[offset + 1] = uvs.y0;

            f32v[offset + stride] = uvs.x1;
            f32v[offset + stride + 1] = uvs.y1;

            f32v[offset + (stride * 2)] = uvs.x2;
            f32v[offset + (stride * 2) + 1] = uvs.y2;

            f32v[offset + (stride * 3)] = uvs.x3;
            f32v[offset + (stride * 3) + 1] = uvs.y3;
        `,
            dynamic: !1
        },
        color: {
            attributeName: "aColor",
            format: "unorm8x4",
            code: `
            const c = p.color;

            u32v[offset] = c;
            u32v[offset + stride] = c;
            u32v[offset + (stride * 2)] = c;
            u32v[offset + (stride * 3)] = c;
        `,
            dynamic: !1
        }
    },
    Iue = new rn(0, 0, 0, 0),
    oF = class N0 extends dd {
        constructor(e = {}) {
            e = { ...N0.defaultOptions,
                ...e,
                dynamicProperties: { ...N0.defaultOptions.dynamicProperties,
                    ...e == null ? void 0 : e.dynamicProperties
                }
            };
            const {
                dynamicProperties: n,
                shader: r,
                roundPixels: i,
                texture: s,
                particles: o,
                ...a
            } = e;
            super({
                label: "ParticleContainer",
                ...a
            }), this.renderPipeId = "particle", this.batched = !1, this._childrenDirty = !1, this.texture = s || null, this.shader = r, this._properties = {};
            for (const l in zC) {
                const c = zC[l],
                    u = n[l];
                this._properties[l] = { ...c,
                    dynamic: u
                }
            }
            this.allowChildren = !0, this.roundPixels = i ? ? !1, this.particleChildren = o ? ? []
        }
        addParticle(...e) {
            for (let n = 0; n < e.length; n++) this.particleChildren.push(e[n]);
            return this.onViewUpdate(), e[0]
        }
        removeParticle(...e) {
            let n = !1;
            for (let r = 0; r < e.length; r++) {
                const i = this.particleChildren.indexOf(e[r]);
                i > -1 && (this.particleChildren.splice(i, 1), n = !0)
            }
            return n && this.onViewUpdate(), e[0]
        }
        update() {
            this._childrenDirty = !0
        }
        onViewUpdate() {
            this._childrenDirty = !0, super.onViewUpdate()
        }
        get bounds() {
            return Iue
        }
        updateBounds() {}
        destroy(e = !1) {
            var r, i;
            if (super.destroy(e), typeof e == "boolean" ? e : e == null ? void 0 : e.texture) {
                const s = typeof e == "boolean" ? e : e == null ? void 0 : e.textureSource,
                    o = this.texture ? ? ((r = this.particleChildren[0]) == null ? void 0 : r.texture);
                o && o.destroy(s)
            }
            this.texture = null, (i = this.shader) == null || i.destroy()
        }
        removeParticles(e, n) {
            e ? ? (e = 0), n ? ? (n = this.particleChildren.length);
            const r = this.particleChildren.splice(e, n - e);
            return this.onViewUpdate(), r
        }
        removeParticleAt(e) {
            const n = this.particleChildren.splice(e, 1);
            return this.onViewUpdate(), n[0]
        }
        addParticleAt(e, n) {
            return this.particleChildren.splice(n, 0, e), this.onViewUpdate(), e
        }
        addChild(...e) {
            throw new Error("ParticleContainer.addChild() is not available. Please use ParticleContainer.addParticle()")
        }
        removeChild(...e) {
            throw new Error("ParticleContainer.removeChild() is not available. Please use ParticleContainer.removeParticle()")
        }
        removeChildren(e, n) {
            throw new Error("ParticleContainer.removeChildren() is not available. Please use ParticleContainer.removeParticles()")
        }
        removeChildAt(e) {
            throw new Error("ParticleContainer.removeChildAt() is not available. Please use ParticleContainer.removeParticleAt()")
        }
        getChildAt(e) {
            throw new Error("ParticleContainer.getChildAt() is not available. Please use ParticleContainer.getParticleAt()")
        }
        setChildIndex(e, n) {
            throw new Error("ParticleContainer.setChildIndex() is not available. Please use ParticleContainer.setParticleIndex()")
        }
        getChildIndex(e) {
            throw new Error("ParticleContainer.getChildIndex() is not available. Please use ParticleContainer.getParticleIndex()")
        }
        addChildAt(e, n) {
            throw new Error("ParticleContainer.addChildAt() is not available. Please use ParticleContainer.addParticleAt()")
        }
        swapChildren(e, n) {
            throw new Error("ParticleContainer.swapChildren() is not available. Please use ParticleContainer.swapParticles()")
        }
        reparentChild(...e) {
            throw new Error("ParticleContainer.reparentChild() is not available with the particle container")
        }
        reparentChildAt(e, n) {
            throw new Error("ParticleContainer.reparentChildAt() is not available with the particle container")
        }
    };
oF.defaultOptions = {
    dynamicProperties: {
        vertex: !1,
        position: !0,
        rotation: !1,
        uvs: !1,
        color: !1
    },
    roundPixels: !1
};
let wwe = oF;
const aF = class lF extends xue {
    constructor(e = {}) {
        e = { ...lF.defaultOptions,
            ...e
        }, super({
            width: e.width,
            height: e.height,
            verticesX: 4,
            verticesY: 4
        }), this.update(e)
    }
    update(e) {
        var n, r;
        this.width = e.width ? ? this.width, this.height = e.height ? ? this.height, this._originalWidth = e.originalWidth ? ? this._originalWidth, this._originalHeight = e.originalHeight ? ? this._originalHeight, this._leftWidth = e.leftWidth ? ? this._leftWidth, this._rightWidth = e.rightWidth ? ? this._rightWidth, this._topHeight = e.topHeight ? ? this._topHeight, this._bottomHeight = e.bottomHeight ? ? this._bottomHeight, this._anchorX = (n = e.anchor) == null ? void 0 : n.x, this._anchorY = (r = e.anchor) == null ? void 0 : r.y, this.updateUvs(), this.updatePositions()
    }
    updatePositions() {
        const e = this.positions,
            {
                width: n,
                height: r,
                _leftWidth: i,
                _rightWidth: s,
                _topHeight: o,
                _bottomHeight: a,
                _anchorX: l,
                _anchorY: c
            } = this,
            u = i + s,
            d = n > u ? 1 : n / u,
            f = o + a,
            h = r > f ? 1 : r / f,
            p = Math.min(d, h),
            b = l * n,
            y = c * r;
        e[0] = e[8] = e[16] = e[24] = -b, e[2] = e[10] = e[18] = e[26] = i * p - b, e[4] = e[12] = e[20] = e[28] = n - s * p - b, e[6] = e[14] = e[22] = e[30] = n - b, e[1] = e[3] = e[5] = e[7] = -y, e[9] = e[11] = e[13] = e[15] = o * p - y, e[17] = e[19] = e[21] = e[23] = r - a * p - y, e[25] = e[27] = e[29] = e[31] = r - y, this.getBuffer("aPosition").update()
    }
    updateUvs() {
        const e = this.uvs;
        e[0] = e[8] = e[16] = e[24] = 0, e[1] = e[3] = e[5] = e[7] = 0, e[6] = e[14] = e[22] = e[30] = 1, e[25] = e[27] = e[29] = e[31] = 1;
        const n = 1 / this._originalWidth,
            r = 1 / this._originalHeight;
        e[2] = e[10] = e[18] = e[26] = n * this._leftWidth, e[9] = e[11] = e[13] = e[15] = r * this._topHeight, e[4] = e[12] = e[20] = e[28] = 1 - n * this._rightWidth, e[17] = e[19] = e[21] = e[23] = 1 - r * this._bottomHeight, this.getBuffer("aUV").update()
    }
};
aF.defaultOptions = {
    width: 100,
    height: 100,
    leftWidth: 10,
    topHeight: 10,
    rightWidth: 10,
    bottomHeight: 10,
    originalWidth: 100,
    originalHeight: 100
};
let Mue = aF;
class Rue extends iw {
    constructor() {
        super(), this.geometry = new Mue
    }
    destroy() {
        this.geometry.destroy()
    }
}
class cF {
    constructor(e) {
        this._renderer = e
    }
    addRenderable(e, n) {
        const r = this._getGpuSprite(e);
        e.didViewUpdate && this._updateBatchableSprite(e, r), this._renderer.renderPipes.batch.addToBatch(r, n)
    }
    updateRenderable(e) {
        const n = this._getGpuSprite(e);
        e.didViewUpdate && this._updateBatchableSprite(e, n), n._batcher.updateElement(n)
    }
    validateRenderable(e) {
        const n = this._getGpuSprite(e);
        return !n._batcher.checkAndUpdateTexture(n, e._texture)
    }
    _updateBatchableSprite(e, n) {
        n.geometry.update(e), n.setTexture(e._texture)
    }
    _getGpuSprite(e) {
        return e._gpuData[this._renderer.uid] || this._initGPUSprite(e)
    }
    _initGPUSprite(e) {
        const n = e._gpuData[this._renderer.uid] = new Rue,
            r = n;
        return r.renderable = e, r.transform = e.groupTransform, r.texture = e._texture, r.roundPixels = this._renderer._roundPixels | e._roundPixels, e.didViewUpdate || this._updateBatchableSprite(e, r), n
    }
    destroy() {
        this._renderer = null
    }
}
cF.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "nineSliceSprite"
};
const kue = {
        name: "tiling-bit",
        vertex: {
            header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
            main: `
            uv = (tilingUniforms.uTextureTransform * vec3(uv, 1.0)).xy;

            position = (position - tilingUniforms.uSizeAnchor.zw) * tilingUniforms.uSizeAnchor.xy;
        `
        },
        fragment: {
            header: `
            struct TilingUniforms {
                uMapCoord:mat3x3<f32>,
                uClampFrame:vec4<f32>,
                uClampOffset:vec2<f32>,
                uTextureTransform:mat3x3<f32>,
                uSizeAnchor:vec4<f32>
            };

            @group(2) @binding(0) var<uniform> tilingUniforms: TilingUniforms;
            @group(2) @binding(1) var uTexture: texture_2d<f32>;
            @group(2) @binding(2) var uSampler: sampler;
        `,
            main: `

            var coord = vUV + ceil(tilingUniforms.uClampOffset - vUV);
            coord = (tilingUniforms.uMapCoord * vec3(coord, 1.0)).xy;
            var unclamped = coord;
            coord = clamp(coord, tilingUniforms.uClampFrame.xy, tilingUniforms.uClampFrame.zw);

            var bias = 0.;

            if(unclamped.x == coord.x && unclamped.y == coord.y)
            {
                bias = -32.;
            }

            outColor = textureSampleBias(uTexture, uSampler, coord, bias);
        `
        }
    },
    Bue = {
        name: "tiling-bit",
        vertex: {
            header: `
            uniform mat3 uTextureTransform;
            uniform vec4 uSizeAnchor;

        `,
            main: `
            uv = (uTextureTransform * vec3(aUV, 1.0)).xy;

            position = (position - uSizeAnchor.zw) * uSizeAnchor.xy;
        `
        },
        fragment: {
            header: `
            uniform sampler2D uTexture;
            uniform mat3 uMapCoord;
            uniform vec4 uClampFrame;
            uniform vec2 uClampOffset;
        `,
            main: `

        vec2 coord = vUV + ceil(uClampOffset - vUV);
        coord = (uMapCoord * vec3(coord, 1.0)).xy;
        vec2 unclamped = coord;
        coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

        outColor = texture(uTexture, coord, unclamped == coord ? 0.0 : -32.0);// lod-bias very negative to force lod 0

        `
        }
    };
let jg, Vg;
class Due extends br {
    constructor() {
        jg ? ? (jg = pd({
            name: "tiling-sprite-shader",
            bits: [Zc, kue, gd]
        })), Vg ? ? (Vg = md({
            name: "tiling-sprite-shader",
            bits: [Wx, Bue, yd]
        }));
        const e = new Pn({
            uMapCoord: {
                value: new Te,
                type: "mat3x3<f32>"
            },
            uClampFrame: {
                value: new Float32Array([0, 0, 1, 1]),
                type: "vec4<f32>"
            },
            uClampOffset: {
                value: new Float32Array([0, 0]),
                type: "vec2<f32>"
            },
            uTextureTransform: {
                value: new Te,
                type: "mat3x3<f32>"
            },
            uSizeAnchor: {
                value: new Float32Array([100, 100, .5, .5]),
                type: "vec4<f32>"
            }
        });
        super({
            glProgram: Vg,
            gpuProgram: jg,
            resources: {
                localUniforms: new Pn({
                    uTransformMatrix: {
                        value: new Te,
                        type: "mat3x3<f32>"
                    },
                    uColor: {
                        value: new Float32Array([1, 1, 1, 1]),
                        type: "vec4<f32>"
                    },
                    uRound: {
                        value: 0,
                        type: "f32"
                    }
                }),
                tilingUniforms: e,
                uTexture: we.EMPTY.source,
                uSampler: we.EMPTY.source.style
            }
        })
    }
    updateUniforms(e, n, r, i, s, o) {
        const a = this.resources.tilingUniforms,
            l = o.width,
            c = o.height,
            u = o.textureMatrix,
            d = a.uniforms.uTextureTransform;
        d.set(r.a * l / e, r.b * l / n, r.c * c / e, r.d * c / n, r.tx / e, r.ty / n), d.invert(), a.uniforms.uMapCoord = u.mapCoord, a.uniforms.uClampFrame = u.uClampFrame, a.uniforms.uClampOffset = u.uClampOffset, a.uniforms.uTextureTransform = d, a.uniforms.uSizeAnchor[0] = e, a.uniforms.uSizeAnchor[1] = n, a.uniforms.uSizeAnchor[2] = i, a.uniforms.uSizeAnchor[3] = s, o && (this.resources.uTexture = o.source, this.resources.uSampler = o.source.style)
    }
}
class $ue extends zx {
    constructor() {
        super({
            positions: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            uvs: new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            indices: new Uint32Array([0, 1, 2, 0, 2, 3])
        })
    }
}

function Fue(t, e) {
    const n = t.anchor.x,
        r = t.anchor.y;
    e[0] = -n * t.width, e[1] = -r * t.height, e[2] = (1 - n) * t.width, e[3] = -r * t.height, e[4] = (1 - n) * t.width, e[5] = (1 - r) * t.height, e[6] = -n * t.width, e[7] = (1 - r) * t.height
}

function Lue(t, e, n, r) {
    let i = 0;
    const s = t.length / (e || 2),
        o = r.a,
        a = r.b,
        l = r.c,
        c = r.d,
        u = r.tx,
        d = r.ty;
    for (n *= e; i < s;) {
        const f = t[n],
            h = t[n + 1];
        t[n] = o * f + l * h + u, t[n + 1] = a * f + c * h + d, n += e, i++
    }
}

function Nue(t, e) {
    const n = t.texture,
        r = n.frame.width,
        i = n.frame.height;
    let s = 0,
        o = 0;
    t.applyAnchorToTexture && (s = t.anchor.x, o = t.anchor.y), e[0] = e[6] = -s, e[2] = e[4] = 1 - s, e[1] = e[3] = -o, e[5] = e[7] = 1 - o;
    const a = Te.shared;
    a.copyFrom(t._tileTransform.matrix), a.tx /= t.width, a.ty /= t.height, a.invert(), a.scale(t.width / r, t.height / i), Lue(e, 2, 0, a)
}
const Jf = new $ue;
class Uue {
    constructor() {
        this.canBatch = !0, this.geometry = new zx({
            indices: Jf.indices.slice(),
            positions: Jf.positions.slice(),
            uvs: Jf.uvs.slice()
        })
    }
    destroy() {
        var e;
        this.geometry.destroy(), (e = this.shader) == null || e.destroy()
    }
}
class uF {
    constructor(e) {
        this._state = Fr.default2d, this._renderer = e
    }
    validateRenderable(e) {
        const n = this._getTilingSpriteData(e),
            r = n.canBatch;
        this._updateCanBatch(e);
        const i = n.canBatch;
        if (i && i === r) {
            const {
                batchableMesh: s
            } = n;
            return !s._batcher.checkAndUpdateTexture(s, e.texture)
        }
        return r !== i
    }
    addRenderable(e, n) {
        const r = this._renderer.renderPipes.batch;
        this._updateCanBatch(e);
        const i = this._getTilingSpriteData(e),
            {
                geometry: s,
                canBatch: o
            } = i;
        if (o) {
            i.batchableMesh || (i.batchableMesh = new iw);
            const a = i.batchableMesh;
            e.didViewUpdate && (this._updateBatchableMesh(e), a.geometry = s, a.renderable = e, a.transform = e.groupTransform, a.setTexture(e._texture)), a.roundPixels = this._renderer._roundPixels | e._roundPixels, r.addToBatch(a, n)
        } else r.break(n), i.shader || (i.shader = new Due), this.updateRenderable(e), n.add(e)
    }
    execute(e) {
        const {
            shader: n
        } = this._getTilingSpriteData(e);
        n.groups[0] = this._renderer.globalUniforms.bindGroup;
        const r = n.resources.localUniforms.uniforms;
        r.uTransformMatrix = e.groupTransform, r.uRound = this._renderer._roundPixels | e._roundPixels, vd(e.groupColorAlpha, r.uColor, 0), this._state.blendMode = ku(e.groupBlendMode, e.texture._source), this._renderer.encoder.draw({
            geometry: Jf,
            shader: n,
            state: this._state
        })
    }
    updateRenderable(e) {
        const n = this._getTilingSpriteData(e),
            {
                canBatch: r
            } = n;
        if (r) {
            const {
                batchableMesh: i
            } = n;
            e.didViewUpdate && this._updateBatchableMesh(e), i._batcher.updateElement(i)
        } else if (e.didViewUpdate) {
            const {
                shader: i
            } = n;
            i.updateUniforms(e.width, e.height, e._tileTransform.matrix, e.anchor.x, e.anchor.y, e.texture)
        }
    }
    _getTilingSpriteData(e) {
        return e._gpuData[this._renderer.uid] || this._initTilingSpriteData(e)
    }
    _initTilingSpriteData(e) {
        const n = new Uue;
        return n.renderable = e, e._gpuData[this._renderer.uid] = n, n
    }
    _updateBatchableMesh(e) {
        const n = this._getTilingSpriteData(e),
            {
                geometry: r
            } = n,
            i = e.texture.source.style;
        i.addressMode !== "repeat" && (i.addressMode = "repeat", i.update()), Nue(e, r.uvs), Fue(e, r.positions)
    }
    destroy() {
        this._renderer = null
    }
    _updateCanBatch(e) {
        const n = this._getTilingSpriteData(e),
            r = e.texture;
        let i = !0;
        return this._renderer.type === tr.WEBGL && (i = this._renderer.context.supports.nonPowOf2wrapping), n.canBatch = r.textureMatrix.isSimple && (i || r.source.isPowerOfTwo), n.canBatch
    }
}
uF.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "tilingSprite"
};
const Gue = {
        name: "local-uniform-msdf-bit",
        vertex: {
            header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32,
                uRound:f32,
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
        `,
            main: `
            vColor *= localUniforms.uColor;
            modelMatrix *= localUniforms.uTransformMatrix;
        `,
            end: `
            if(localUniforms.uRound == 1)
            {
                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);
            }
        `
        },
        fragment: {
            header: `
            struct LocalUniforms {
                uColor:vec4<f32>,
                uTransformMatrix:mat3x3<f32>,
                uDistance: f32
            }

            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;
         `,
            main: `
            outColor = vec4<f32>(calculateMSDFAlpha(outColor, localUniforms.uColor, localUniforms.uDistance));
        `
        }
    },
    Hue = {
        name: "local-uniform-msdf-bit",
        vertex: {
            header: `
            uniform mat3 uTransformMatrix;
            uniform vec4 uColor;
            uniform float uRound;
        `,
            main: `
            vColor *= uColor;
            modelMatrix *= uTransformMatrix;
        `,
            end: `
            if(uRound == 1.)
            {
                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);
            }
        `
        },
        fragment: {
            header: `
            uniform float uDistance;
         `,
            main: `
            outColor = vec4(calculateMSDFAlpha(outColor, vColor, uDistance));
        `
        }
    },
    zue = {
        name: "msdf-bit",
        fragment: {
            header: `
            fn calculateMSDFAlpha(msdfColor:vec4<f32>, shapeColor:vec4<f32>, distance:f32) -> f32 {

                // MSDF
                var median = msdfColor.r + msdfColor.g + msdfColor.b -
                    min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                    max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                var screenPxDistance = distance * (median - 0.5);
                var alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);
                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                var luma: f32 = dot(shapeColor.rgb, vec3<f32>(0.299, 0.587, 0.114));
                var gamma: f32 = mix(1.0, 1.0 / 2.2, luma);
                var coverage: f32 = pow(shapeColor.a * alpha, gamma);

                return coverage;

            }
        `
        }
    },
    jue = {
        name: "msdf-bit",
        fragment: {
            header: `
            float calculateMSDFAlpha(vec4 msdfColor, vec4 shapeColor, float distance) {

                // MSDF
                float median = msdfColor.r + msdfColor.g + msdfColor.b -
                                min(msdfColor.r, min(msdfColor.g, msdfColor.b)) -
                                max(msdfColor.r, max(msdfColor.g, msdfColor.b));

                // SDF
                median = min(median, msdfColor.a);

                float screenPxDistance = distance * (median - 0.5);
                float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);

                if (median < 0.01) {
                    alpha = 0.0;
                } else if (median > 0.99) {
                    alpha = 1.0;
                }

                // Gamma correction for coverage-like alpha
                float luma = dot(shapeColor.rgb, vec3(0.299, 0.587, 0.114));
                float gamma = mix(1.0, 1.0 / 2.2, luma);
                float coverage = pow(shapeColor.a * alpha, gamma);

                return coverage;
            }
        `
        }
    };
let Wg, Yg;
class Vue extends br {
    constructor(e) {
        const n = new Pn({
            uColor: {
                value: new Float32Array([1, 1, 1, 1]),
                type: "vec4<f32>"
            },
            uTransformMatrix: {
                value: new Te,
                type: "mat3x3<f32>"
            },
            uDistance: {
                value: 4,
                type: "f32"
            },
            uRound: {
                value: 0,
                type: "f32"
            }
        });
        Wg ? ? (Wg = pd({
            name: "sdf-shader",
            bits: [Ax, Ix(e), Gue, zue, gd]
        })), Yg ? ? (Yg = md({
            name: "sdf-shader",
            bits: [Ox, Mx(e), Hue, jue, yd]
        })), super({
            glProgram: Yg,
            gpuProgram: Wg,
            resources: {
                localUniforms: n,
                batchSamplers: Rx(e)
            }
        })
    }
}
class Wue extends $h {
    destroy() {
        this.context.customShader && this.context.customShader.destroy(), super.destroy()
    }
}
class dF {
    constructor(e) {
        this._renderer = e, this._renderer.renderableGC.addManagedHash(this, "_gpuBitmapText")
    }
    validateRenderable(e) {
        const n = this._getGpuBitmapText(e);
        return e._didTextUpdate && (e._didTextUpdate = !1, this._updateContext(e, n)), this._renderer.renderPipes.graphics.validateRenderable(n)
    }
    addRenderable(e, n) {
        const r = this._getGpuBitmapText(e);
        jC(e, r), e._didTextUpdate && (e._didTextUpdate = !1, this._updateContext(e, r)), this._renderer.renderPipes.graphics.addRenderable(r, n), r.context.customShader && this._updateDistanceField(e)
    }
    updateRenderable(e) {
        const n = this._getGpuBitmapText(e);
        jC(e, n), this._renderer.renderPipes.graphics.updateRenderable(n), n.context.customShader && this._updateDistanceField(e)
    }
    _updateContext(e, n) {
        const {
            context: r
        } = n, i = I0.getFont(e.text, e._style);
        r.clear(), i.distanceField.type !== "none" && (r.customShader || (r.customShader = new Vue(this._renderer.limits.maxBatchableTextures)));
        const s = Ir.graphemeSegmenter(e.text),
            o = e._style;
        let a = i.baseLineOffset;
        const l = uD(s, o, i, !0),
            c = o.padding,
            u = l.scale;
        let d = l.width,
            f = l.height + l.offsetY;
        o._stroke && (d += o._stroke.width / u, f += o._stroke.width / u), r.translate(-e._anchor._x * d - c, -e._anchor._y * f - c).scale(u, u);
        const h = i.applyFillAsTint ? o._fill.color : 16777215;
        for (let p = 0; p < l.lines.length; p++) {
            const b = l.lines[p];
            for (let y = 0; y < b.charPositions.length; y++) {
                const m = b.chars[y],
                    g = i.chars[m];
                g != null && g.texture && r.texture(g.texture, h || "black", Math.round(b.charPositions[y] + g.xOffset), Math.round(a + g.yOffset))
            }
            a += i.lineHeight
        }
    }
    _getGpuBitmapText(e) {
        return e._gpuData[this._renderer.uid] || this.initGpuText(e)
    }
    initGpuText(e) {
        const n = new Wue;
        return e._gpuData[this._renderer.uid] = n, this._updateContext(e, n), n
    }
    _updateDistanceField(e) {
        const n = this._getGpuBitmapText(e).context,
            r = e._style.fontFamily,
            i = ut.get(`${r}-bitmap`),
            {
                a: s,
                b: o,
                c: a,
                d: l
            } = e.groupTransform,
            c = Math.sqrt(s * s + o * o),
            u = Math.sqrt(a * a + l * l),
            d = (Math.abs(c) + Math.abs(u)) / 2,
            f = i.baseRenderedFontSize / e._style.fontSize,
            h = d * i.distanceField.range * (1 / f);
        n.customShader.resources.localUniforms.uniforms.uDistance = h
    }
    destroy() {
        this._renderer = null
    }
}
dF.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "bitmapText"
};

function jC(t, e) {
    e.groupTransform = t.groupTransform, e.groupColorAlpha = t.groupColorAlpha, e.groupColor = t.groupColor, e.groupBlendMode = t.groupBlendMode, e.globalDisplayStatus = t.globalDisplayStatus, e.groupTransform = t.groupTransform, e.localDisplayStatus = t.localDisplayStatus, e.groupAlpha = t.groupAlpha, e._roundPixels = t._roundPixels
}
class Yue extends rm {
    constructor(e) {
        super(), this.generatingTexture = !1, this._renderer = e, e.runners.resolutionChange.add(this)
    }
    resolutionChange() {
        const e = this.renderable;
        e._autoResolution && e.onViewUpdate()
    }
    destroy() {
        this._renderer.htmlText.returnTexturePromise(this.texturePromise), this.texturePromise = null, this._renderer = null
    }
}

function U0(t, e) {
    const {
        texture: n,
        bounds: r
    } = t, i = e._style._getFinalPadding();
    Qk(r, e._anchor, n);
    const s = e._anchor._x * i * 2,
        o = e._anchor._y * i * 2;
    r.minX -= i - s, r.minY -= i - o, r.maxX -= i - s, r.maxY -= i - o
}
class fF {
    constructor(e) {
        this._renderer = e
    }
    validateRenderable(e) {
        return e._didTextUpdate
    }
    addRenderable(e, n) {
        const r = this._getGpuText(e);
        e._didTextUpdate && (this._updateGpuText(e).catch(i => {
            console.error(i)
        }), e._didTextUpdate = !1, U0(r, e)), this._renderer.renderPipes.batch.addToBatch(r, n)
    }
    updateRenderable(e) {
        const n = this._getGpuText(e);
        n._batcher.updateElement(n)
    }
    async _updateGpuText(e) {
        e._didTextUpdate = !1;
        const n = this._getGpuText(e);
        if (n.generatingTexture) return;
        n.texturePromise && (this._renderer.htmlText.returnTexturePromise(n.texturePromise), n.texturePromise = null), n.generatingTexture = !0, e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution;
        const r = this._renderer.htmlText.getTexturePromise(e);
        n.texturePromise = r, n.texture = await r;
        const i = e.renderGroup || e.parentRenderGroup;
        i && (i.structureDidChange = !0), n.generatingTexture = !1, U0(n, e)
    }
    _getGpuText(e) {
        return e._gpuData[this._renderer.uid] || this.initGpuText(e)
    }
    initGpuText(e) {
        const n = new Yue(this._renderer);
        return n.renderable = e, n.transform = e.groupTransform, n.texture = we.EMPTY, n.bounds = {
            minX: 0,
            maxX: 1,
            minY: 0,
            maxY: 0
        }, n.roundPixels = this._renderer._roundPixels | e._roundPixels, e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution, e._gpuData[this._renderer.uid] = n, n
    }
    destroy() {
        this._renderer = null
    }
}
fF.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "htmlText"
};

function Xue() {
    const {
        userAgent: t
    } = Ge.get().getNavigator();
    return /^((?!chrome|android).)*safari/i.test(t)
}
const que = new rn;

function hF(t, e, n, r) {
    const i = que;
    i.minX = 0, i.minY = 0, i.maxX = t.width / r | 0, i.maxY = t.height / r | 0;
    const s = Ft.getOptimalTexture(i.width, i.height, r, !1);
    return s.source.uploadMethodId = "image", s.source.resource = t, s.source.alphaMode = "premultiply-alpha-on-upload", s.frame.width = e / r, s.frame.height = n / r, s.source.emit("update", s.source), s.updateUvs(), s
}

function Kue(t, e) {
    const n = e.fontFamily,
        r = [],
        i = {},
        s = /font-family:([^;"\s]+)/g,
        o = t.match(s);

    function a(l) {
        i[l] || (r.push(l), i[l] = !0)
    }
    if (Array.isArray(n))
        for (let l = 0; l < n.length; l++) a(n[l]);
    else a(n);
    o && o.forEach(l => {
        const c = l.split(":")[1].trim();
        a(c)
    });
    for (const l in e.tagStyles) {
        const c = e.tagStyles[l].fontFamily;
        a(c)
    }
    return r
}
async function Jue(t) {
    const n = await (await Ge.get().fetch(t)).blob(),
        r = new FileReader;
    return await new Promise((s, o) => {
        r.onloadend = () => s(r.result), r.onerror = o, r.readAsDataURL(n)
    })
}
async function VC(t, e) {
    const n = await Jue(e);
    return `@font-face {
        font-family: "${t.fontFamily}";
        src: url('${n}');
        font-weight: ${t.fontWeight};
        font-style: ${t.fontStyle};
    }`
}
const Sf = new Map;
async function Zue(t, e, n) {
    const r = t.filter(i => ut.has(`${i}-and-url`)).map((i, s) => {
        if (!Sf.has(i)) {
            const {
                url: o
            } = ut.get(`${i}-and-url`);
            s === 0 ? Sf.set(i, VC({
                fontWeight: e.fontWeight,
                fontStyle: e.fontStyle,
                fontFamily: i
            }, o)) : Sf.set(i, VC({
                fontWeight: n.fontWeight,
                fontStyle: n.fontStyle,
                fontFamily: i
            }, o))
        }
        return Sf.get(i)
    });
    return (await Promise.all(r)).join(`
`)
}

function Que(t, e, n, r, i) {
    const {
        domElement: s,
        styleElement: o,
        svgRoot: a
    } = i;
    s.innerHTML = `<style>${e.cssStyle}</style><div style='padding:0;'>${t}</div>`, s.setAttribute("style", `transform: scale(${n});transform-origin: top left; display: inline-block`), o.textContent = r;
    const {
        width: l,
        height: c
    } = i.image;
    return a.setAttribute("width", l.toString()), a.setAttribute("height", c.toString()), new XMLSerializer().serializeToString(a)
}

function ede(t, e) {
    const n = qs.getOptimalCanvasAndContext(t.width, t.height, e),
        {
            context: r
        } = n;
    return r.clearRect(0, 0, t.width, t.height), r.drawImage(t, 0, 0), n
}

function tde(t, e, n) {
    return new Promise(async r => {
        n && await new Promise(i => setTimeout(i, 100)), t.onload = () => {
            r()
        }, t.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(e)}`, t.crossOrigin = "anonymous"
    })
}
class pF {
    constructor(e) {
        this._renderer = e, this._createCanvas = e.type === tr.WEBGPU
    }
    getTexture(e) {
        return this.getTexturePromise(e)
    }
    getTexturePromise(e) {
        return this._buildTexturePromise(e)
    }
    async _buildTexturePromise(e) {
        const {
            text: n,
            style: r,
            resolution: i,
            textureStyle: s
        } = e, o = nn.get(OD), a = Kue(n, r), l = await Zue(a, r, jx.defaultTextStyle), c = Ble(n, r, l, o), u = Math.ceil(Math.ceil(Math.max(1, c.width) + r.padding * 2) * i), d = Math.ceil(Math.ceil(Math.max(1, c.height) + r.padding * 2) * i), f = o.image, h = 2;
        f.width = (u | 0) + h, f.height = (d | 0) + h;
        const p = Que(n, r, i, l, o);
        await tde(f, p, Xue() && a.length > 0);
        const b = f;
        let y;
        this._createCanvas && (y = ede(f, i));
        const m = hF(y ? y.canvas : b, f.width - h, f.height - h, i);
        return s && (m.source.style = s), this._createCanvas && (this._renderer.texture.initSource(m.source), qs.returnCanvasAndContext(y)), nn.return(o), m
    }
    returnTexturePromise(e) {
        e.then(n => {
            this._cleanUp(n)
        }).catch(() => {
            Oe("HTMLTextSystem: Failed to clean texture")
        })
    }
    _cleanUp(e) {
        Ft.returnTexture(e, !0), e.source.resource = null, e.source.uploadMethodId = "unknown"
    }
    destroy() {
        this._renderer = null
    }
}
pF.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "htmlText"
};
class nde extends rm {
    constructor(e) {
        super(), this._renderer = e, e.runners.resolutionChange.add(this)
    }
    resolutionChange() {
        const e = this.renderable;
        e._autoResolution && e.onViewUpdate()
    }
    destroy() {
        this._renderer.canvasText.returnTexture(this.texture), this._renderer = null
    }
}
class mF {
    constructor(e) {
        this._renderer = e
    }
    validateRenderable(e) {
        return e._didTextUpdate
    }
    addRenderable(e, n) {
        const r = this._getGpuText(e);
        e._didTextUpdate && (this._updateGpuText(e), e._didTextUpdate = !1), this._renderer.renderPipes.batch.addToBatch(r, n)
    }
    updateRenderable(e) {
        const n = this._getGpuText(e);
        n._batcher.updateElement(n)
    }
    _updateGpuText(e) {
        const n = this._getGpuText(e);
        n.texture && this._renderer.canvasText.returnTexture(n.texture), e._resolution = e._autoResolution ? this._renderer.resolution : e.resolution, n.texture = n.texture = this._renderer.canvasText.getTexture(e), U0(n, e)
    }
    _getGpuText(e) {
        return e._gpuData[this._renderer.uid] || this.initGpuText(e)
    }
    initGpuText(e) {
        const n = new nde(this._renderer);
        return n.renderable = e, n.transform = e.groupTransform, n.bounds = {
            minX: 0,
            maxX: 1,
            minY: 0,
            maxY: 0
        }, n.roundPixels = this._renderer._roundPixels | e._roundPixels, e._gpuData[this._renderer.uid] = n, n
    }
    destroy() {
        this._renderer = null
    }
}
mF.extension = {
    type: [G.WebGLPipes, G.WebGPUPipes, G.CanvasPipes],
    name: "text"
};
class gF {
    constructor(e) {
        this._renderer = e
    }
    getTexture(e, n, r, i) {
        typeof e == "string" && (Ie("8.0.0", "CanvasTextSystem.getTexture: Use object TextOptions instead of separate arguments"), e = {
            text: e,
            style: r,
            resolution: n
        }), e.style instanceof es || (e.style = new es(e.style)), e.textureStyle instanceof Zi || (e.textureStyle = new Zi(e.textureStyle)), typeof e.text != "string" && (e.text = e.text.toString());
        const {
            text: s,
            style: o,
            textureStyle: a
        } = e, l = e.resolution ? ? this._renderer.resolution, {
            frame: c,
            canvasAndContext: u
        } = Jc.getCanvasAndContext({
            text: s,
            style: o,
            resolution: l
        }), d = hF(u.canvas, c.width, c.height, l);
        if (a && (d.source.style = a), o.trim && (c.pad(o.padding), d.frame.copyFrom(c), d.updateUvs()), o.filters) {
            const f = this._applyFilters(d, o.filters);
            return this.returnTexture(d), Jc.returnCanvasAndContext(u), f
        }
        return this._renderer.texture.initSource(d._source), Jc.returnCanvasAndContext(u), d
    }
    returnTexture(e) {
        const n = e.source;
        n.resource = null, n.uploadMethodId = "unknown", n.alphaMode = "no-premultiply-alpha", Ft.returnTexture(e, !0)
    }
    renderTextToCanvas() {
        Ie("8.10.0", "CanvasTextSystem.renderTextToCanvas: no longer supported, use CanvasTextSystem.getTexture instead")
    }
    _applyFilters(e, n) {
        const r = this._renderer.renderTarget.renderTarget,
            i = this._renderer.filter.generateFilteredTexture({
                texture: e,
                filters: n
            });
        return this._renderer.renderTarget.bind(r, !1), i
    }
    destroy() {
        this._renderer = null
    }
}
gF.extension = {
    type: [G.WebGLSystem, G.WebGPUSystem, G.CanvasSystem],
    name: "canvasText"
};
Re.add(Cre, Pre);
var Vo = {},
    yF = {},
    Hi = {};
Object.defineProperty(Hi, "__esModule", {
    value: !0
});
Hi.loop = Hi.conditional = Hi.parse = void 0;
var rde = function t(e, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
        i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : r;
    if (Array.isArray(n)) n.forEach(function(o) {
        return t(e, o, r, i)
    });
    else if (typeof n == "function") n(e, r, i, t);
    else {
        var s = Object.keys(n)[0];
        Array.isArray(n[s]) ? (i[s] = {}, t(e, n[s], r, i[s])) : i[s] = n[s](e, r, i, t)
    }
    return r
};
Hi.parse = rde;
var ide = function(e, n) {
    return function(r, i, s, o) {
        n(r, i, s) && o(r, e, i, s)
    }
};
Hi.conditional = ide;
var sde = function(e, n) {
    return function(r, i, s, o) {
        for (var a = [], l = r.pos; n(r, i, s);) {
            var c = {};
            if (o(r, e, i, c), r.pos === l) break;
            l = r.pos, a.push(c)
        }
        return a
    }
};
Hi.loop = sde;
var kt = {};
Object.defineProperty(kt, "__esModule", {
    value: !0
});
kt.readBits = kt.readArray = kt.readUnsigned = kt.readString = kt.peekBytes = kt.readBytes = kt.peekByte = kt.readByte = kt.buildStream = void 0;
var ode = function(e) {
    return {
        data: e,
        pos: 0
    }
};
kt.buildStream = ode;
var vF = function() {
    return function(e) {
        return e.data[e.pos++]
    }
};
kt.readByte = vF;
var ade = function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return function(n) {
        return n.data[n.pos + e]
    }
};
kt.peekByte = ade;
var im = function(e) {
    return function(n) {
        return n.data.subarray(n.pos, n.pos += e)
    }
};
kt.readBytes = im;
var lde = function(e) {
    return function(n) {
        return n.data.subarray(n.pos, n.pos + e)
    }
};
kt.peekBytes = lde;
var cde = function(e) {
    return function(n) {
        return Array.from(im(e)(n)).map(function(r) {
            return String.fromCharCode(r)
        }).join("")
    }
};
kt.readString = cde;
var ude = function(e) {
    return function(n) {
        var r = im(2)(n);
        return e ? (r[1] << 8) + r[0] : (r[0] << 8) + r[1]
    }
};
kt.readUnsigned = ude;
var dde = function(e, n) {
    return function(r, i, s) {
        for (var o = typeof n == "function" ? n(r, i, s) : n, a = im(e), l = new Array(o), c = 0; c < o; c++) l[c] = a(r);
        return l
    }
};
kt.readArray = dde;
var fde = function(e, n, r) {
        for (var i = 0, s = 0; s < r; s++) i += e[n + s] && Math.pow(2, r - s - 1);
        return i
    },
    hde = function(e) {
        return function(n) {
            for (var r = vF()(n), i = new Array(8), s = 0; s < 8; s++) i[7 - s] = !!(r & 1 << s);
            return Object.keys(e).reduce(function(o, a) {
                var l = e[a];
                return l.length ? o[a] = fde(i, l.index, l.length) : o[a] = i[l.index], o
            }, {})
        }
    };
kt.readBits = hde;
(function(t) {
    Object.defineProperty(t, "__esModule", {
        value: !0
    }), t.default = void 0;
    var e = Hi,
        n = kt,
        r = {
            blocks: function(f) {
                for (var h = 0, p = [], b = f.data.length, y = 0, m = (0, n.readByte)()(f); m !== h && m; m = (0, n.readByte)()(f)) {
                    if (f.pos + m >= b) {
                        var g = b - f.pos;
                        p.push((0, n.readBytes)(g)(f)), y += g;
                        break
                    }
                    p.push((0, n.readBytes)(m)(f)), y += m
                }
                for (var v = new Uint8Array(y), _ = 0, x = 0; x < p.length; x++) v.set(p[x], _), _ += p[x].length;
                return v
            }
        },
        i = (0, e.conditional)({
            gce: [{
                codes: (0, n.readBytes)(2)
            }, {
                byteSize: (0, n.readByte)()
            }, {
                extras: (0, n.readBits)({
                    future: {
                        index: 0,
                        length: 3
                    },
                    disposal: {
                        index: 3,
                        length: 3
                    },
                    userInput: {
                        index: 6
                    },
                    transparentColorGiven: {
                        index: 7
                    }
                })
            }, {
                delay: (0, n.readUnsigned)(!0)
            }, {
                transparentColorIndex: (0, n.readByte)()
            }, {
                terminator: (0, n.readByte)()
            }]
        }, function(d) {
            var f = (0, n.peekBytes)(2)(d);
            return f[0] === 33 && f[1] === 249
        }),
        s = (0, e.conditional)({
            image: [{
                code: (0, n.readByte)()
            }, {
                descriptor: [{
                    left: (0, n.readUnsigned)(!0)
                }, {
                    top: (0, n.readUnsigned)(!0)
                }, {
                    width: (0, n.readUnsigned)(!0)
                }, {
                    height: (0, n.readUnsigned)(!0)
                }, {
                    lct: (0, n.readBits)({
                        exists: {
                            index: 0
                        },
                        interlaced: {
                            index: 1
                        },
                        sort: {
                            index: 2
                        },
                        future: {
                            index: 3,
                            length: 2
                        },
                        size: {
                            index: 5,
                            length: 3
                        }
                    })
                }]
            }, (0, e.conditional)({
                lct: (0, n.readArray)(3, function(d, f, h) {
                    return Math.pow(2, h.descriptor.lct.size + 1)
                })
            }, function(d, f, h) {
                return h.descriptor.lct.exists
            }), {
                data: [{
                    minCodeSize: (0, n.readByte)()
                }, r]
            }]
        }, function(d) {
            return (0, n.peekByte)()(d) === 44
        }),
        o = (0, e.conditional)({
            text: [{
                codes: (0, n.readBytes)(2)
            }, {
                blockSize: (0, n.readByte)()
            }, {
                preData: function(f, h, p) {
                    return (0, n.readBytes)(p.text.blockSize)(f)
                }
            }, r]
        }, function(d) {
            var f = (0, n.peekBytes)(2)(d);
            return f[0] === 33 && f[1] === 1
        }),
        a = (0, e.conditional)({
            application: [{
                codes: (0, n.readBytes)(2)
            }, {
                blockSize: (0, n.readByte)()
            }, {
                id: function(f, h, p) {
                    return (0, n.readString)(p.blockSize)(f)
                }
            }, r]
        }, function(d) {
            var f = (0, n.peekBytes)(2)(d);
            return f[0] === 33 && f[1] === 255
        }),
        l = (0, e.conditional)({
            comment: [{
                codes: (0, n.readBytes)(2)
            }, r]
        }, function(d) {
            var f = (0, n.peekBytes)(2)(d);
            return f[0] === 33 && f[1] === 254
        }),
        c = [{
            header: [{
                signature: (0, n.readString)(3)
            }, {
                version: (0, n.readString)(3)
            }]
        }, {
            lsd: [{
                width: (0, n.readUnsigned)(!0)
            }, {
                height: (0, n.readUnsigned)(!0)
            }, {
                gct: (0, n.readBits)({
                    exists: {
                        index: 0
                    },
                    resolution: {
                        index: 1,
                        length: 3
                    },
                    sort: {
                        index: 4
                    },
                    size: {
                        index: 5,
                        length: 3
                    }
                })
            }, {
                backgroundColorIndex: (0, n.readByte)()
            }, {
                pixelAspectRatio: (0, n.readByte)()
            }]
        }, (0, e.conditional)({
            gct: (0, n.readArray)(3, function(d, f) {
                return Math.pow(2, f.lsd.gct.size + 1)
            })
        }, function(d, f) {
            return f.lsd.gct.exists
        }), {
            frames: (0, e.loop)([i, a, l, s, o], function(d) {
                var f = (0, n.peekByte)()(d);
                return f === 33 || f === 44
            })
        }],
        u = c;
    t.default = u
})(yF);
var sm = {};
Object.defineProperty(sm, "__esModule", {
    value: !0
});
sm.deinterlace = void 0;
var pde = function(e, n) {
    for (var r = new Array(e.length), i = e.length / n, s = function(f, h) {
            var p = e.slice(h * n, (h + 1) * n);
            r.splice.apply(r, [f * n, n].concat(p))
        }, o = [0, 4, 2, 1], a = [8, 8, 4, 2], l = 0, c = 0; c < 4; c++)
        for (var u = o[c]; u < i; u += a[c]) s(u, l), l++;
    return r
};
sm.deinterlace = pde;
var om = {};
Object.defineProperty(om, "__esModule", {
    value: !0
});
om.lzw = void 0;
var mde = function(e, n, r) {
    var i = 4096,
        s = -1,
        o = r,
        a, l, c, u, d, f, h, w, p, b, x, y, E, C, T, A, m = new Array(r),
        g = new Array(i),
        v = new Array(i),
        _ = new Array(i + 1);
    for (y = e, l = 1 << y, d = l + 1, a = l + 2, h = s, u = y + 1, c = (1 << u) - 1, p = 0; p < l; p++) g[p] = 0, v[p] = p;
    var x, w, E, C, A, T;
    for (x = w = E = C = A = T = 0, b = 0; b < o;) {
        if (C === 0) {
            if (w < u) {
                x += n[T] << w, w += 8, T++;
                continue
            }
            if (p = x & c, x >>= u, w -= u, p > a || p == d) break;
            if (p == l) {
                u = y + 1, c = (1 << u) - 1, a = l + 2, h = s;
                continue
            }
            if (h == s) {
                _[C++] = v[p], h = p, E = p;
                continue
            }
            for (f = p, p == a && (_[C++] = E, p = h); p > l;) _[C++] = v[p], p = g[p];
            E = v[p] & 255, _[C++] = E, a < i && (g[a] = h, v[a] = E, a++, !(a & c) && a < i && (u++, c += a)), h = f
        }
        C--, m[A++] = _[C], b++
    }
    for (b = A; b < o; b++) m[b] = 0;
    return m
};
om.lzw = mde;
Object.defineProperty(Vo, "__esModule", {
    value: !0
});
var _F = Vo.decompressFrames = Vo.decompressFrame = bF = Vo.parseGIF = void 0,
    gde = xde(yF),
    yde = Hi,
    vde = kt,
    _de = sm,
    bde = om;

function xde(t) {
    return t && t.__esModule ? t : {
        default: t
    }
}
var wde = function(e) {
        var n = new Uint8Array(e);
        return (0, yde.parse)((0, vde.buildStream)(n), gde.default)
    },
    bF = Vo.parseGIF = wde,
    Ede = function(e) {
        for (var n = e.pixels.length, r = new Uint8ClampedArray(n * 4), i = 0; i < n; i++) {
            var s = i * 4,
                o = e.pixels[i],
                a = e.colorTable[o] || [0, 0, 0];
            r[s] = a[0], r[s + 1] = a[1], r[s + 2] = a[2], r[s + 3] = o !== e.transparentIndex ? 255 : 0
        }
        return r
    },
    xF = function(e, n, r) {
        if (!e.image) {
            console.warn("gif frame does not have associated image.");
            return
        }
        var i = e.image,
            s = i.descriptor.width * i.descriptor.height,
            o = (0, bde.lzw)(i.data.minCodeSize, i.data.blocks, s);
        i.descriptor.lct.interlaced && (o = (0, _de.deinterlace)(o, i.descriptor.width));
        var a = {
            pixels: o,
            dims: {
                top: e.image.descriptor.top,
                left: e.image.descriptor.left,
                width: e.image.descriptor.width,
                height: e.image.descriptor.height
            }
        };
        return i.descriptor.lct && i.descriptor.lct.exists ? a.colorTable = i.lct : a.colorTable = n, e.gce && (a.delay = (e.gce.delay || 10) * 10, a.disposalType = e.gce.extras.disposal, e.gce.extras.transparentColorGiven && (a.transparentIndex = e.gce.transparentColorIndex)), r && (a.patch = Ede(a)), a
    };
Vo.decompressFrame = xF;
var Sde = function(e, n) {
    return e.frames.filter(function(r) {
        return r.image
    }).map(function(r) {
        return xF(r, e.gct, n)
    })
};
_F = Vo.decompressFrames = Sde;
class am {
    constructor(e) {
        if (!e || !e.length) throw new Error("Invalid frames");
        const [{
            texture: {
                width: n,
                height: r
            }
        }] = e;
        this.width = n, this.height = r, this.frames = e, this.textures = this.frames.map(i => i.texture), this.totalFrames = this.frames.length, this.duration = this.frames[this.totalFrames - 1].end
    }
    destroy() {
        for (const e of this.textures) e.destroy(!0);
        for (const e of this.frames) e.texture = null;
        this.frames.length = 0, this.textures.length = 0, Object.assign(this, {
            frames: null,
            textures: null,
            width: 0,
            height: 0,
            duration: 0,
            totalFrames: 0
        })
    }
    static from(e, n) {
        if (!e || e.byteLength === 0) throw new Error("Invalid buffer");
        const r = y => {
                let m = null;
                for (const g of y.frames) m = g.gce ? ? m, "image" in g && !("gce" in g) && (g.gce = m)
            },
            i = bF(e);
        r(i);
        const s = _F(i, !0),
            o = [],
            a = i.lsd.width,
            l = i.lsd.height,
            c = Ge.get().createCanvas(a, l),
            u = c.getContext("2d", {
                willReadFrequently: !0
            }),
            d = Ge.get().createCanvas(),
            f = d.getContext("2d");
        let h = 0,
            p = null;
        const b = 1e3 / ((n == null ? void 0 : n.fps) ? ? 30);
        for (let y = 0; y < s.length; y++) {
            const {
                disposalType: m = 2,
                delay: g = b,
                patch: v,
                dims: {
                    width: _,
                    height: x,
                    left: w,
                    top: E
                }
            } = s[y];
            d.width = _, d.height = x, f.clearRect(0, 0, _, x);
            const C = f.createImageData(_, x);
            C.data.set(v), f.putImageData(C, 0, 0), m === 3 && (p = u.getImageData(0, 0, a, l)), u.drawImage(d, w, E);
            const A = u.getImageData(0, 0, a, l);
            m === 2 ? u.clearRect(0, 0, a, l) : m === 3 && u.putImageData(p, 0, 0);
            const T = Ge.get().createCanvas(A.width, A.height);
            T.getContext("2d").putImageData(A, 0, 0), o.push({
                start: h,
                end: h + g,
                texture: new we({
                    source: new oi({
                        resource: T
                    })
                })
            }), h += g
        }
        return c.width = c.height = 0, d.width = d.height = 0, new am(o)
    }
}
const Tde = {
        extension: G.Asset,
        detection: {
            test: async () => !0,
            add: async t => [...t, "gif"],
            remove: async t => t.filter(e => e !== "gif")
        },
        loader: {
            name: "gifLoader",
            test: t => Ln.extname(t) === ".gif" || t.startsWith("data:image/gif"),
            load: async (t, e) => {
                const r = await (await Ge.get().fetch(t)).arrayBuffer();
                return am.from(r, e == null ? void 0 : e.data)
            },
            unload: async t => {
                t.destroy()
            }
        }
    },
    wF = class G0 extends ra {
        constructor(...e) {
            const n = e[0] instanceof am ? {
                    source: e[0]
                } : e[0],
                {
                    scaleMode: r,
                    source: i,
                    fps: s,
                    loop: o,
                    animationSpeed: a,
                    autoPlay: l,
                    autoUpdate: c,
                    onComplete: u,
                    onFrameChange: d,
                    onLoop: f,
                    ...h
                } = Object.assign({}, G0.defaultOptions, n);
            super({
                texture: we.EMPTY,
                ...h
            }), this.animationSpeed = 1, this.loop = !0, this.duration = 0, this.autoPlay = !0, this.dirty = !1, this._currentFrame = 0, this._autoUpdate = !1, this._isConnectedToTicker = !1, this._playing = !1, this._currentTime = 0, this.onRender = () => this._updateFrame(), this.texture = i.textures[0], this.duration = i.frames[i.frames.length - 1].end, this._source = i, this._playing = !1, this._currentTime = 0, this._isConnectedToTicker = !1, Object.assign(this, {
                fps: s,
                loop: o,
                animationSpeed: a,
                autoPlay: l,
                autoUpdate: c,
                onComplete: u,
                onFrameChange: d,
                onLoop: f
            }), this.currentFrame = 0, l && this.play()
        }
        stop() {
            this._playing && (this._playing = !1, this._autoUpdate && this._isConnectedToTicker && (bn.shared.remove(this.update, this), this._isConnectedToTicker = !1))
        }
        play() {
            this._playing || (this._playing = !0, this._autoUpdate && !this._isConnectedToTicker && (bn.shared.add(this.update, this, Tl.HIGH), this._isConnectedToTicker = !0), !this.loop && this.currentFrame === this._source.frames.length - 1 && (this._currentTime = 0))
        }
        get progress() {
            return this._currentTime / this.duration
        }
        get playing() {
            return this._playing
        }
        update(e) {
            var o, a;
            if (!this._playing) return;
            const n = this.animationSpeed * e.deltaTime / bn.targetFPMS,
                r = this._currentTime + n,
                i = r % this.duration,
                s = this._source.frames.findIndex(l => l.start <= i && l.end > i);
            r >= this.duration ? this.loop ? (this._currentTime = i, this._updateFrameIndex(s), (o = this.onLoop) == null || o.call(this)) : (this._currentTime = this.duration, this._updateFrameIndex(this.totalFrames - 1), (a = this.onComplete) == null || a.call(this), this.stop()) : (this._currentTime = i, this._updateFrameIndex(s))
        }
        _updateFrame() {
            this.dirty && (this.texture = this._source.frames[this._currentFrame].texture, this.dirty = !1)
        }
        get autoUpdate() {
            return this._autoUpdate
        }
        set autoUpdate(e) {
            e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (bn.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._playing && (bn.shared.add(this.update, this), this._isConnectedToTicker = !0))
        }
        get currentFrame() {
            return this._currentFrame
        }
        set currentFrame(e) {
            this._updateFrameIndex(e), this._currentTime = this._source.frames[e].start
        }
        get source() {
            return this._source
        }
        _updateFrameIndex(e) {
            var n;
            if (e < 0 || e >= this.totalFrames) throw new Error(`Frame index out of range, expecting 0 to ${this.totalFrames}, got ${e}`);
            this._currentFrame !== e && (this._currentFrame = e, this.dirty = !0, (n = this.onFrameChange) == null || n.call(this, e))
        }
        get totalFrames() {
            return this._source.totalFrames
        }
        destroy(e = !1) {
            this.stop(), super.destroy(), e && this._source.destroy();
            const n = null;
            this._source = n, this.onComplete = n, this.onFrameChange = n, this.onLoop = n
        }
        clone() {
            const e = new G0({
                source: this._source,
                autoUpdate: this._autoUpdate,
                loop: this.loop,
                autoPlay: this.autoPlay,
                scaleMode: this.texture.source.scaleMode,
                animationSpeed: this.animationSpeed,
                onComplete: this.onComplete,
                onFrameChange: this.onFrameChange,
                onLoop: this.onLoop
            });
            return e.dirty = !0, e
        }
    };
wF.defaultOptions = {
    scaleMode: "linear",
    fps: 30,
    loop: !0,
    animationSpeed: 1,
    autoPlay: !0,
    autoUpdate: !0,
    onComplete: null,
    onFrameChange: null,
    onLoop: null
};
let Ewe = wF;
Re.add(Tde);
const Cde = () => {};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EF = function(t) {
        const e = [];
        let n = 0;
        for (let r = 0; r < t.length; r++) {
            let i = t.charCodeAt(r);
            i < 128 ? e[n++] = i : i < 2048 ? (e[n++] = i >> 6 | 192, e[n++] = i & 63 | 128) : (i & 64512) === 55296 && r + 1 < t.length && (t.charCodeAt(r + 1) & 64512) === 56320 ? (i = 65536 + ((i & 1023) << 10) + (t.charCodeAt(++r) & 1023), e[n++] = i >> 18 | 240, e[n++] = i >> 12 & 63 | 128, e[n++] = i >> 6 & 63 | 128, e[n++] = i & 63 | 128) : (e[n++] = i >> 12 | 224, e[n++] = i >> 6 & 63 | 128, e[n++] = i & 63 | 128)
        }
        return e
    },
    Pde = function(t) {
        const e = [];
        let n = 0,
            r = 0;
        for (; n < t.length;) {
            const i = t[n++];
            if (i < 128) e[r++] = String.fromCharCode(i);
            else if (i > 191 && i < 224) {
                const s = t[n++];
                e[r++] = String.fromCharCode((i & 31) << 6 | s & 63)
            } else if (i > 239 && i < 365) {
                const s = t[n++],
                    o = t[n++],
                    a = t[n++],
                    l = ((i & 7) << 18 | (s & 63) << 12 | (o & 63) << 6 | a & 63) - 65536;
                e[r++] = String.fromCharCode(55296 + (l >> 10)), e[r++] = String.fromCharCode(56320 + (l & 1023))
            } else {
                const s = t[n++],
                    o = t[n++];
                e[r++] = String.fromCharCode((i & 15) << 12 | (s & 63) << 6 | o & 63)
            }
        }
        return e.join("")
    },
    SF = {
        byteToCharMap_: null,
        charToByteMap_: null,
        byteToCharMapWebSafe_: null,
        charToByteMapWebSafe_: null,
        ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
        get ENCODED_VALS() {
            return this.ENCODED_VALS_BASE + "+/="
        },
        get ENCODED_VALS_WEBSAFE() {
            return this.ENCODED_VALS_BASE + "-_."
        },
        HAS_NATIVE_SUPPORT: typeof atob == "function",
        encodeByteArray(t, e) {
            if (!Array.isArray(t)) throw Error("encodeByteArray takes an array as a parameter");
            this.init_();
            const n = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
                r = [];
            for (let i = 0; i < t.length; i += 3) {
                const s = t[i],
                    o = i + 1 < t.length,
                    a = o ? t[i + 1] : 0,
                    l = i + 2 < t.length,
                    c = l ? t[i + 2] : 0,
                    u = s >> 2,
                    d = (s & 3) << 4 | a >> 4;
                let f = (a & 15) << 2 | c >> 6,
                    h = c & 63;
                l || (h = 64, o || (f = 64)), r.push(n[u], n[d], n[f], n[h])
            }
            return r.join("")
        },
        encodeString(t, e) {
            return this.HAS_NATIVE_SUPPORT && !e ? btoa(t) : this.encodeByteArray(EF(t), e)
        },
        decodeString(t, e) {
            return this.HAS_NATIVE_SUPPORT && !e ? atob(t) : Pde(this.decodeStringToByteArray(t, e))
        },
        decodeStringToByteArray(t, e) {
            this.init_();
            const n = e ? this.charToByteMapWebSafe_ : this.charToByteMap_,
                r = [];
            for (let i = 0; i < t.length;) {
                const s = n[t.charAt(i++)],
                    a = i < t.length ? n[t.charAt(i)] : 0;
                ++i;
                const c = i < t.length ? n[t.charAt(i)] : 64;
                ++i;
                const d = i < t.length ? n[t.charAt(i)] : 64;
                if (++i, s == null || a == null || c == null || d == null) throw new Ade;
                const f = s << 2 | a >> 4;
                if (r.push(f), c !== 64) {
                    const h = a << 4 & 240 | c >> 2;
                    if (r.push(h), d !== 64) {
                        const p = c << 6 & 192 | d;
                        r.push(p)
                    }
                }
            }
            return r
        },
        init_() {
            if (!this.byteToCharMap_) {
                this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
                for (let t = 0; t < this.ENCODED_VALS.length; t++) this.byteToCharMap_[t] = this.ENCODED_VALS.charAt(t), this.charToByteMap_[this.byteToCharMap_[t]] = t, this.byteToCharMapWebSafe_[t] = this.ENCODED_VALS_WEBSAFE.charAt(t), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[t]] = t, t >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(t)] = t, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(t)] = t)
            }
        }
    };
class Ade extends Error {
    constructor() {
        super(...arguments), this.name = "DecodeBase64StringError"
    }
}
const Ode = function(t) {
        const e = EF(t);
        return SF.encodeByteArray(e, !0)
    },
    TF = function(t) {
        return Ode(t).replace(/\./g, "")
    },
    Ide = function(t) {
        try {
            return SF.decodeString(t, !0)
        } catch (e) {
            console.error("base64Decode failed: ", e)
        }
        return null
    };
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Mde() {
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof global < "u") return global;
    throw new Error("Unable to locate global object.")
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Rde = () => Mde().__FIREBASE_DEFAULTS__,
    kde = () => {
        if (typeof process > "u" || typeof process.env > "u") return;
        const t = {}.__FIREBASE_DEFAULTS__;
        if (t) return JSON.parse(t)
    },
    Bde = () => {
        if (typeof document > "u") return;
        let t;
        try {
            t = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)
        } catch {
            return
        }
        const e = t && Ide(t[1]);
        return e && JSON.parse(e)
    },
    Dde = () => {
        try {
            return Cde() || Rde() || kde() || Bde()
        } catch (t) {
            console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${t}`);
            return
        }
    },
    CF = () => {
        var t;
        return (t = Dde()) === null || t === void 0 ? void 0 : t.config
    };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $de {
    constructor() {
        this.reject = () => {}, this.resolve = () => {}, this.promise = new Promise((e, n) => {
            this.resolve = e, this.reject = n
        })
    }
    wrapCallback(e) {
        return (n, r) => {
            n ? this.reject(n) : this.resolve(r), typeof e == "function" && (this.promise.catch(() => {}), e.length === 1 ? e(n) : e(n, r))
        }
    }
}

function PF() {
    try {
        return typeof indexedDB == "object"
    } catch {
        return !1
    }
}

function AF() {
    return new Promise((t, e) => {
        try {
            let n = !0;
            const r = "validate-browser-context-for-indexeddb-analytics-module",
                i = self.indexedDB.open(r);
            i.onsuccess = () => {
                i.result.close(), n || self.indexedDB.deleteDatabase(r), t(!0)
            }, i.onupgradeneeded = () => {
                n = !1
            }, i.onerror = () => {
                var s;
                e(((s = i.error) === null || s === void 0 ? void 0 : s.message) || "")
            }
        } catch (n) {
            e(n)
        }
    })
}

function Fde() {
    return !(typeof navigator > "u" || !navigator.cookieEnabled)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Lde = "FirebaseError";
class Zl extends Error {
    constructor(e, n, r) {
        super(n), this.code = e, this.customData = r, this.name = Lde, Object.setPrototypeOf(this, Zl.prototype), Error.captureStackTrace && Error.captureStackTrace(this, lm.prototype.create)
    }
}
class lm {
    constructor(e, n, r) {
        this.service = e, this.serviceName = n, this.errors = r
    }
    create(e, ...n) {
        const r = n[0] || {},
            i = `${this.service}/${e}`,
            s = this.errors[e],
            o = s ? Nde(s, r) : "Error",
            a = `${this.serviceName}: ${o} (${i}).`;
        return new Zl(i, a, r)
    }
}

function Nde(t, e) {
    return t.replace(Ude, (n, r) => {
        const i = e[r];
        return i != null ? String(i) : `<${r}?>`
    })
}
const Ude = /\{\$([^}]+)}/g;

function H0(t, e) {
    if (t === e) return !0;
    const n = Object.keys(t),
        r = Object.keys(e);
    for (const i of n) {
        if (!r.includes(i)) return !1;
        const s = t[i],
            o = e[i];
        if (WC(s) && WC(o)) {
            if (!H0(s, o)) return !1
        } else if (s !== o) return !1
    }
    for (const i of r)
        if (!n.includes(i)) return !1;
    return !0
}

function WC(t) {
    return t !== null && typeof t == "object"
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function sw(t) {
    return t && t._delegate ? t._delegate : t
}
class Ks {
    constructor(e, n, r) {
        this.name = e, this.instanceFactory = n, this.type = r, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null
    }
    setInstantiationMode(e) {
        return this.instantiationMode = e, this
    }
    setMultipleInstances(e) {
        return this.multipleInstances = e, this
    }
    setServiceProps(e) {
        return this.serviceProps = e, this
    }
    setInstanceCreatedCallback(e) {
        return this.onInstanceCreated = e, this
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wo = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Gde {
    constructor(e, n) {
        this.name = e, this.container = n, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map
    }
    get(e) {
        const n = this.normalizeInstanceIdentifier(e);
        if (!this.instancesDeferred.has(n)) {
            const r = new $de;
            if (this.instancesDeferred.set(n, r), this.isInitialized(n) || this.shouldAutoInitialize()) try {
                const i = this.getOrInitializeService({
                    instanceIdentifier: n
                });
                i && r.resolve(i)
            } catch {}
        }
        return this.instancesDeferred.get(n).promise
    }
    getImmediate(e) {
        var n;
        const r = this.normalizeInstanceIdentifier(e == null ? void 0 : e.identifier),
            i = (n = e == null ? void 0 : e.optional) !== null && n !== void 0 ? n : !1;
        if (this.isInitialized(r) || this.shouldAutoInitialize()) try {
            return this.getOrInitializeService({
                instanceIdentifier: r
            })
        } catch (s) {
            if (i) return null;
            throw s
        } else {
            if (i) return null;
            throw Error(`Service ${this.name} is not available`)
        }
    }
    getComponent() {
        return this.component
    }
    setComponent(e) {
        if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
        if (this.component) throw Error(`Component for ${this.name} has already been provided`);
        if (this.component = e, !!this.shouldAutoInitialize()) {
            if (zde(e)) try {
                this.getOrInitializeService({
                    instanceIdentifier: wo
                })
            } catch {}
            for (const [n, r] of this.instancesDeferred.entries()) {
                const i = this.normalizeInstanceIdentifier(n);
                try {
                    const s = this.getOrInitializeService({
                        instanceIdentifier: i
                    });
                    r.resolve(s)
                } catch {}
            }
        }
    }
    clearInstance(e = wo) {
        this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e)
    }
    async delete() {
        const e = Array.from(this.instances.values());
        await Promise.all([...e.filter(n => "INTERNAL" in n).map(n => n.INTERNAL.delete()), ...e.filter(n => "_delete" in n).map(n => n._delete())])
    }
    isComponentSet() {
        return this.component != null
    }
    isInitialized(e = wo) {
        return this.instances.has(e)
    }
    getOptions(e = wo) {
        return this.instancesOptions.get(e) || {}
    }
    initialize(e = {}) {
        const {
            options: n = {}
        } = e, r = this.normalizeInstanceIdentifier(e.instanceIdentifier);
        if (this.isInitialized(r)) throw Error(`${this.name}(${r}) has already been initialized`);
        if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`);
        const i = this.getOrInitializeService({
            instanceIdentifier: r,
            options: n
        });
        for (const [s, o] of this.instancesDeferred.entries()) {
            const a = this.normalizeInstanceIdentifier(s);
            r === a && o.resolve(i)
        }
        return i
    }
    onInit(e, n) {
        var r;
        const i = this.normalizeInstanceIdentifier(n),
            s = (r = this.onInitCallbacks.get(i)) !== null && r !== void 0 ? r : new Set;
        s.add(e), this.onInitCallbacks.set(i, s);
        const o = this.instances.get(i);
        return o && e(o, i), () => {
            s.delete(e)
        }
    }
    invokeOnInitCallbacks(e, n) {
        const r = this.onInitCallbacks.get(n);
        if (r)
            for (const i of r) try {
                i(e, n)
            } catch {}
    }
    getOrInitializeService({
        instanceIdentifier: e,
        options: n = {}
    }) {
        let r = this.instances.get(e);
        if (!r && this.component && (r = this.component.instanceFactory(this.container, {
                instanceIdentifier: Hde(e),
                options: n
            }), this.instances.set(e, r), this.instancesOptions.set(e, n), this.invokeOnInitCallbacks(r, e), this.component.onInstanceCreated)) try {
            this.component.onInstanceCreated(this.container, e, r)
        } catch {}
        return r || null
    }
    normalizeInstanceIdentifier(e = wo) {
        return this.component ? this.component.multipleInstances ? e : wo : e
    }
    shouldAutoInitialize() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT"
    }
}

function Hde(t) {
    return t === wo ? void 0 : t
}

function zde(t) {
    return t.instantiationMode === "EAGER"
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jde {
    constructor(e) {
        this.name = e, this.providers = new Map
    }
    addComponent(e) {
        const n = this.getProvider(e.name);
        if (n.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
        n.setComponent(e)
    }
    addOrOverwriteComponent(e) {
        this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e)
    }
    getProvider(e) {
        if (this.providers.has(e)) return this.providers.get(e);
        const n = new Gde(e, this);
        return this.providers.set(e, n), n
    }
    getProviders() {
        return Array.from(this.providers.values())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var pt;
(function(t) {
    t[t.DEBUG = 0] = "DEBUG", t[t.VERBOSE = 1] = "VERBOSE", t[t.INFO = 2] = "INFO", t[t.WARN = 3] = "WARN", t[t.ERROR = 4] = "ERROR", t[t.SILENT = 5] = "SILENT"
})(pt || (pt = {}));
const Vde = {
        debug: pt.DEBUG,
        verbose: pt.VERBOSE,
        info: pt.INFO,
        warn: pt.WARN,
        error: pt.ERROR,
        silent: pt.SILENT
    },
    Wde = pt.INFO,
    Yde = {
        [pt.DEBUG]: "log",
        [pt.VERBOSE]: "log",
        [pt.INFO]: "info",
        [pt.WARN]: "warn",
        [pt.ERROR]: "error"
    },
    Xde = (t, e, ...n) => {
        if (e < t.logLevel) return;
        const r = new Date().toISOString(),
            i = Yde[e];
        if (i) console[i](`[${r}]  ${t.name}:`, ...n);
        else throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`)
    };
class qde {
    constructor(e) {
        this.name = e, this._logLevel = Wde, this._logHandler = Xde, this._userLogHandler = null
    }
    get logLevel() {
        return this._logLevel
    }
    set logLevel(e) {
        if (!(e in pt)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
        this._logLevel = e
    }
    setLogLevel(e) {
        this._logLevel = typeof e == "string" ? Vde[e] : e
    }
    get logHandler() {
        return this._logHandler
    }
    set logHandler(e) {
        if (typeof e != "function") throw new TypeError("Value assigned to `logHandler` must be a function");
        this._logHandler = e
    }
    get userLogHandler() {
        return this._userLogHandler
    }
    set userLogHandler(e) {
        this._userLogHandler = e
    }
    debug(...e) {
        this._userLogHandler && this._userLogHandler(this, pt.DEBUG, ...e), this._logHandler(this, pt.DEBUG, ...e)
    }
    log(...e) {
        this._userLogHandler && this._userLogHandler(this, pt.VERBOSE, ...e), this._logHandler(this, pt.VERBOSE, ...e)
    }
    info(...e) {
        this._userLogHandler && this._userLogHandler(this, pt.INFO, ...e), this._logHandler(this, pt.INFO, ...e)
    }
    warn(...e) {
        this._userLogHandler && this._userLogHandler(this, pt.WARN, ...e), this._logHandler(this, pt.WARN, ...e)
    }
    error(...e) {
        this._userLogHandler && this._userLogHandler(this, pt.ERROR, ...e), this._logHandler(this, pt.ERROR, ...e)
    }
}
const Kde = (t, e) => e.some(n => t instanceof n);
let YC, XC;

function Jde() {
    return YC || (YC = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
}

function Zde() {
    return XC || (XC = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])
}
const OF = new WeakMap,
    z0 = new WeakMap,
    IF = new WeakMap,
    Xg = new WeakMap,
    ow = new WeakMap;

function Qde(t) {
    const e = new Promise((n, r) => {
        const i = () => {
                t.removeEventListener("success", s), t.removeEventListener("error", o)
            },
            s = () => {
                n(zi(t.result)), i()
            },
            o = () => {
                r(t.error), i()
            };
        t.addEventListener("success", s), t.addEventListener("error", o)
    });
    return e.then(n => {
        n instanceof IDBCursor && OF.set(n, t)
    }).catch(() => {}), ow.set(e, t), e
}

function efe(t) {
    if (z0.has(t)) return;
    const e = new Promise((n, r) => {
        const i = () => {
                t.removeEventListener("complete", s), t.removeEventListener("error", o), t.removeEventListener("abort", o)
            },
            s = () => {
                n(), i()
            },
            o = () => {
                r(t.error || new DOMException("AbortError", "AbortError")), i()
            };
        t.addEventListener("complete", s), t.addEventListener("error", o), t.addEventListener("abort", o)
    });
    z0.set(t, e)
}
let j0 = {
    get(t, e, n) {
        if (t instanceof IDBTransaction) {
            if (e === "done") return z0.get(t);
            if (e === "objectStoreNames") return t.objectStoreNames || IF.get(t);
            if (e === "store") return n.objectStoreNames[1] ? void 0 : n.objectStore(n.objectStoreNames[0])
        }
        return zi(t[e])
    },
    set(t, e, n) {
        return t[e] = n, !0
    },
    has(t, e) {
        return t instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in t
    }
};

function tfe(t) {
    j0 = t(j0)
}

function nfe(t) {
    return t === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...n) {
        const r = t.call(qg(this), e, ...n);
        return IF.set(r, e.sort ? e.sort() : [e]), zi(r)
    } : Zde().includes(t) ? function(...e) {
        return t.apply(qg(this), e), zi(OF.get(this))
    } : function(...e) {
        return zi(t.apply(qg(this), e))
    }
}

function rfe(t) {
    return typeof t == "function" ? nfe(t) : (t instanceof IDBTransaction && efe(t), Kde(t, Jde()) ? new Proxy(t, j0) : t)
}

function zi(t) {
    if (t instanceof IDBRequest) return Qde(t);
    if (Xg.has(t)) return Xg.get(t);
    const e = rfe(t);
    return e !== t && (Xg.set(t, e), ow.set(e, t)), e
}
const qg = t => ow.get(t);

function cm(t, e, {
    blocked: n,
    upgrade: r,
    blocking: i,
    terminated: s
} = {}) {
    const o = indexedDB.open(t, e),
        a = zi(o);
    return r && o.addEventListener("upgradeneeded", l => {
        r(zi(o.result), l.oldVersion, l.newVersion, zi(o.transaction), l)
    }), n && o.addEventListener("blocked", l => n(l.oldVersion, l.newVersion, l)), a.then(l => {
        s && l.addEventListener("close", () => s()), i && l.addEventListener("versionchange", c => i(c.oldVersion, c.newVersion, c))
    }).catch(() => {}), a
}

function Kg(t, {
    blocked: e
} = {}) {
    const n = indexedDB.deleteDatabase(t);
    return e && n.addEventListener("blocked", r => e(r.oldVersion, r)), zi(n).then(() => {})
}
const ife = ["get", "getKey", "getAll", "getAllKeys", "count"],
    sfe = ["put", "add", "delete", "clear"],
    Jg = new Map;

function qC(t, e) {
    if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string")) return;
    if (Jg.get(e)) return Jg.get(e);
    const n = e.replace(/FromIndex$/, ""),
        r = e !== n,
        i = sfe.includes(n);
    if (!(n in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || ife.includes(n))) return;
    const s = async function(o, ...a) {
        const l = this.transaction(o, i ? "readwrite" : "readonly");
        let c = l.store;
        return r && (c = c.index(a.shift())), (await Promise.all([c[n](...a), i && l.done]))[0]
    };
    return Jg.set(e, s), s
}
tfe(t => ({ ...t,
    get: (e, n, r) => qC(e, n) || t.get(e, n, r),
    has: (e, n) => !!qC(e, n) || t.has(e, n)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ofe {
    constructor(e) {
        this.container = e
    }
    getPlatformInfoString() {
        return this.container.getProviders().map(n => {
            if (afe(n)) {
                const r = n.getImmediate();
                return `${r.library}/${r.version}`
            } else return null
        }).filter(n => n).join(" ")
    }
}

function afe(t) {
    const e = t.getComponent();
    return (e == null ? void 0 : e.type) === "VERSION"
}
const V0 = "@firebase/app",
    KC = "0.13.2";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ts = new qde("@firebase/app"),
    lfe = "@firebase/app-compat",
    cfe = "@firebase/analytics-compat",
    ufe = "@firebase/analytics",
    dfe = "@firebase/app-check-compat",
    ffe = "@firebase/app-check",
    hfe = "@firebase/auth",
    pfe = "@firebase/auth-compat",
    mfe = "@firebase/database",
    gfe = "@firebase/data-connect",
    yfe = "@firebase/database-compat",
    vfe = "@firebase/functions",
    _fe = "@firebase/functions-compat",
    bfe = "@firebase/installations",
    xfe = "@firebase/installations-compat",
    wfe = "@firebase/messaging",
    Efe = "@firebase/messaging-compat",
    Sfe = "@firebase/performance",
    Tfe = "@firebase/performance-compat",
    Cfe = "@firebase/remote-config",
    Pfe = "@firebase/remote-config-compat",
    Afe = "@firebase/storage",
    Ofe = "@firebase/storage-compat",
    Ife = "@firebase/firestore",
    Mfe = "@firebase/ai",
    Rfe = "@firebase/firestore-compat",
    kfe = "firebase";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const W0 = "[DEFAULT]",
    Bfe = {
        [V0]: "fire-core",
        [lfe]: "fire-core-compat",
        [ufe]: "fire-analytics",
        [cfe]: "fire-analytics-compat",
        [ffe]: "fire-app-check",
        [dfe]: "fire-app-check-compat",
        [hfe]: "fire-auth",
        [pfe]: "fire-auth-compat",
        [mfe]: "fire-rtdb",
        [gfe]: "fire-data-connect",
        [yfe]: "fire-rtdb-compat",
        [vfe]: "fire-fn",
        [_fe]: "fire-fn-compat",
        [bfe]: "fire-iid",
        [xfe]: "fire-iid-compat",
        [wfe]: "fire-fcm",
        [Efe]: "fire-fcm-compat",
        [Sfe]: "fire-perf",
        [Tfe]: "fire-perf-compat",
        [Cfe]: "fire-rc",
        [Pfe]: "fire-rc-compat",
        [Afe]: "fire-gcs",
        [Ofe]: "fire-gcs-compat",
        [Ife]: "fire-fst",
        [Rfe]: "fire-fst-compat",
        [Mfe]: "fire-vertex",
        "fire-js": "fire-js",
        [kfe]: "fire-js-all"
    };
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Fh = new Map,
    Dfe = new Map,
    Y0 = new Map;

function JC(t, e) {
    try {
        t.container.addComponent(e)
    } catch (n) {
        ts.debug(`Component ${e.name} failed to register with FirebaseApp ${t.name}`, n)
    }
}

function oa(t) {
    const e = t.name;
    if (Y0.has(e)) return ts.debug(`There were multiple attempts to register component ${e}.`), !1;
    Y0.set(e, t);
    for (const n of Fh.values()) JC(n, t);
    for (const n of Dfe.values()) JC(n, t);
    return !0
}

function aw(t, e) {
    const n = t.container.getProvider("heartbeat").getImmediate({
        optional: !0
    });
    return n && n.triggerHeartbeat(), t.container.getProvider(e)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $fe = {
        "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
        "bad-app-name": "Illegal App name: '{$appName}'",
        "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
        "app-deleted": "Firebase App named '{$appName}' already deleted",
        "server-app-deleted": "Firebase Server App has been deleted",
        "no-options": "Need to provide options, when not being deployed to hosting via source.",
        "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
        "invalid-log-argument": "First argument to `onLog` must be null or a function.",
        "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
        "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
        "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
        "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.",
        "finalization-registry-not-supported": "FirebaseServerApp deleteOnDeref field defined but the JS runtime does not support FinalizationRegistry.",
        "invalid-server-app-environment": "FirebaseServerApp is not for use in browser environments."
    },
    Ls = new lm("app", "Firebase", $fe);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ffe {
    constructor(e, n, r) {
        this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, n), this._name = n.name, this._automaticDataCollectionEnabled = n.automaticDataCollectionEnabled, this._container = r, this.container.addComponent(new Ks("app", () => this, "PUBLIC"))
    }
    get automaticDataCollectionEnabled() {
        return this.checkDestroyed(), this._automaticDataCollectionEnabled
    }
    set automaticDataCollectionEnabled(e) {
        this.checkDestroyed(), this._automaticDataCollectionEnabled = e
    }
    get name() {
        return this.checkDestroyed(), this._name
    }
    get options() {
        return this.checkDestroyed(), this._options
    }
    get config() {
        return this.checkDestroyed(), this._config
    }
    get container() {
        return this._container
    }
    get isDeleted() {
        return this._isDeleted
    }
    set isDeleted(e) {
        this._isDeleted = e
    }
    checkDestroyed() {
        if (this.isDeleted) throw Ls.create("app-deleted", {
            appName: this._name
        })
    }
}

function Lfe(t, e = {}) {
    let n = t;
    typeof e != "object" && (e = {
        name: e
    });
    const r = Object.assign({
            name: W0,
            automaticDataCollectionEnabled: !0
        }, e),
        i = r.name;
    if (typeof i != "string" || !i) throw Ls.create("bad-app-name", {
        appName: String(i)
    });
    if (n || (n = CF()), !n) throw Ls.create("no-options");
    const s = Fh.get(i);
    if (s) {
        if (H0(n, s.options) && H0(r, s.config)) return s;
        throw Ls.create("duplicate-app", {
            appName: i
        })
    }
    const o = new jde(i);
    for (const l of Y0.values()) o.addComponent(l);
    const a = new Ffe(n, r, o);
    return Fh.set(i, a), a
}

function Nfe(t = W0) {
    const e = Fh.get(t);
    if (!e && t === W0 && CF()) return Lfe();
    if (!e) throw Ls.create("no-app", {
        appName: t
    });
    return e
}

function Ns(t, e, n) {
    var r;
    let i = (r = Bfe[t]) !== null && r !== void 0 ? r : t;
    n && (i += `-${n}`);
    const s = i.match(/\s|\//),
        o = e.match(/\s|\//);
    if (s || o) {
        const a = [`Unable to register library "${i}" with version "${e}":`];
        s && a.push(`library name "${i}" contains illegal characters (whitespace or "/")`), s && o && a.push("and"), o && a.push(`version name "${e}" contains illegal characters (whitespace or "/")`), ts.warn(a.join(" "));
        return
    }
    oa(new Ks(`${i}-version`, () => ({
        library: i,
        version: e
    }), "VERSION"))
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ufe = "firebase-heartbeat-database",
    Gfe = 1,
    Du = "firebase-heartbeat-store";
let Zg = null;

function MF() {
    return Zg || (Zg = cm(Ufe, Gfe, {
        upgrade: (t, e) => {
            switch (e) {
                case 0:
                    try {
                        t.createObjectStore(Du)
                    } catch (n) {
                        console.warn(n)
                    }
            }
        }
    }).catch(t => {
        throw Ls.create("idb-open", {
            originalErrorMessage: t.message
        })
    })), Zg
}
async function Hfe(t) {
    try {
        const n = (await MF()).transaction(Du),
            r = await n.objectStore(Du).get(RF(t));
        return await n.done, r
    } catch (e) {
        if (e instanceof Zl) ts.warn(e.message);
        else {
            const n = Ls.create("idb-get", {
                originalErrorMessage: e == null ? void 0 : e.message
            });
            ts.warn(n.message)
        }
    }
}
async function ZC(t, e) {
    try {
        const r = (await MF()).transaction(Du, "readwrite");
        await r.objectStore(Du).put(e, RF(t)), await r.done
    } catch (n) {
        if (n instanceof Zl) ts.warn(n.message);
        else {
            const r = Ls.create("idb-set", {
                originalErrorMessage: n == null ? void 0 : n.message
            });
            ts.warn(r.message)
        }
    }
}

function RF(t) {
    return `${t.name}!${t.options.appId}`
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const zfe = 1024,
    jfe = 30;
class Vfe {
    constructor(e) {
        this.container = e, this._heartbeatsCache = null;
        const n = this.container.getProvider("app").getImmediate();
        this._storage = new Yfe(n), this._heartbeatsCachePromise = this._storage.read().then(r => (this._heartbeatsCache = r, r))
    }
    async triggerHeartbeat() {
        var e, n;
        try {
            const i = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(),
                s = QC();
            if (((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null && (this._heartbeatsCache = await this._heartbeatsCachePromise, ((n = this._heartbeatsCache) === null || n === void 0 ? void 0 : n.heartbeats) == null) || this._heartbeatsCache.lastSentHeartbeatDate === s || this._heartbeatsCache.heartbeats.some(o => o.date === s)) return;
            if (this._heartbeatsCache.heartbeats.push({
                    date: s,
                    agent: i
                }), this._heartbeatsCache.heartbeats.length > jfe) {
                const o = Xfe(this._heartbeatsCache.heartbeats);
                this._heartbeatsCache.heartbeats.splice(o, 1)
            }
            return this._storage.overwrite(this._heartbeatsCache)
        } catch (r) {
            ts.warn(r)
        }
    }
    async getHeartbeatsHeader() {
        var e;
        try {
            if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, ((e = this._heartbeatsCache) === null || e === void 0 ? void 0 : e.heartbeats) == null || this._heartbeatsCache.heartbeats.length === 0) return "";
            const n = QC(),
                {
                    heartbeatsToSend: r,
                    unsentEntries: i
                } = Wfe(this._heartbeatsCache.heartbeats),
                s = TF(JSON.stringify({
                    version: 2,
                    heartbeats: r
                }));
            return this._heartbeatsCache.lastSentHeartbeatDate = n, i.length > 0 ? (this._heartbeatsCache.heartbeats = i, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), s
        } catch (n) {
            return ts.warn(n), ""
        }
    }
}

function QC() {
    return new Date().toISOString().substring(0, 10)
}

function Wfe(t, e = zfe) {
    const n = [];
    let r = t.slice();
    for (const i of t) {
        const s = n.find(o => o.agent === i.agent);
        if (s) {
            if (s.dates.push(i.date), eP(n) > e) {
                s.dates.pop();
                break
            }
        } else if (n.push({
                agent: i.agent,
                dates: [i.date]
            }), eP(n) > e) {
            n.pop();
            break
        }
        r = r.slice(1)
    }
    return {
        heartbeatsToSend: n,
        unsentEntries: r
    }
}
class Yfe {
    constructor(e) {
        this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck()
    }
    async runIndexedDBEnvironmentCheck() {
        return PF() ? AF().then(() => !0).catch(() => !1) : !1
    }
    async read() {
        if (await this._canUseIndexedDBPromise) {
            const n = await Hfe(this.app);
            return n != null && n.heartbeats ? n : {
                heartbeats: []
            }
        } else return {
            heartbeats: []
        }
    }
    async overwrite(e) {
        var n;
        if (await this._canUseIndexedDBPromise) {
            const i = await this.read();
            return ZC(this.app, {
                lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
                heartbeats: e.heartbeats
            })
        } else return
    }
    async add(e) {
        var n;
        if (await this._canUseIndexedDBPromise) {
            const i = await this.read();
            return ZC(this.app, {
                lastSentHeartbeatDate: (n = e.lastSentHeartbeatDate) !== null && n !== void 0 ? n : i.lastSentHeartbeatDate,
                heartbeats: [...i.heartbeats, ...e.heartbeats]
            })
        } else return
    }
}

function eP(t) {
    return TF(JSON.stringify({
        version: 2,
        heartbeats: t
    })).length
}

function Xfe(t) {
    if (t.length === 0) return -1;
    let e = 0,
        n = t[0].date;
    for (let r = 1; r < t.length; r++) t[r].date < n && (n = t[r].date, e = r);
    return e
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function qfe(t) {
    oa(new Ks("platform-logger", e => new ofe(e), "PRIVATE")), oa(new Ks("heartbeat", e => new Vfe(e), "PRIVATE")), Ns(V0, KC, t), Ns(V0, KC, "esm2017"), Ns("fire-js", "")
}
qfe("");
var Kfe = "firebase",
    Jfe = "11.10.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Ns(Kfe, Jfe, "app");
const kF = "@firebase/installations",
    lw = "0.6.18";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const BF = 1e4,
    DF = `w:${lw}`,
    $F = "FIS_v2",
    Zfe = "https://firebaseinstallations.googleapis.com/v1",
    Qfe = 60 * 60 * 1e3,
    ehe = "installations",
    the = "Installations";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const nhe = {
        "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
        "not-registered": "Firebase Installation is not registered.",
        "installation-not-found": "Firebase Installation not found.",
        "request-failed": '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"',
        "app-offline": "Could not process request. Application offline.",
        "delete-pending-registration": "Can't delete installation while there is a pending registration request."
    },
    aa = new lm(ehe, the, nhe);

function FF(t) {
    return t instanceof Zl && t.code.includes("request-failed")
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function LF({
    projectId: t
}) {
    return `${Zfe}/projects/${t}/installations`
}

function NF(t) {
    return {
        token: t.token,
        requestStatus: 2,
        expiresIn: ihe(t.expiresIn),
        creationTime: Date.now()
    }
}
async function UF(t, e) {
    const r = (await e.json()).error;
    return aa.create("request-failed", {
        requestName: t,
        serverCode: r.code,
        serverMessage: r.message,
        serverStatus: r.status
    })
}

function GF({
    apiKey: t
}) {
    return new Headers({
        "Content-Type": "application/json",
        Accept: "application/json",
        "x-goog-api-key": t
    })
}

function rhe(t, {
    refreshToken: e
}) {
    const n = GF(t);
    return n.append("Authorization", she(e)), n
}
async function HF(t) {
    const e = await t();
    return e.status >= 500 && e.status < 600 ? t() : e
}

function ihe(t) {
    return Number(t.replace("s", "000"))
}

function she(t) {
    return `${$F} ${t}`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function ohe({
    appConfig: t,
    heartbeatServiceProvider: e
}, {
    fid: n
}) {
    const r = LF(t),
        i = GF(t),
        s = e.getImmediate({
            optional: !0
        });
    if (s) {
        const c = await s.getHeartbeatsHeader();
        c && i.append("x-firebase-client", c)
    }
    const o = {
            fid: n,
            authVersion: $F,
            appId: t.appId,
            sdkVersion: DF
        },
        a = {
            method: "POST",
            headers: i,
            body: JSON.stringify(o)
        },
        l = await HF(() => fetch(r, a));
    if (l.ok) {
        const c = await l.json();
        return {
            fid: c.fid || n,
            registrationStatus: 2,
            refreshToken: c.refreshToken,
            authToken: NF(c.authToken)
        }
    } else throw await UF("Create Installation", l)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function zF(t) {
    return new Promise(e => {
        setTimeout(e, t)
    })
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ahe(t) {
    return btoa(String.fromCharCode(...t)).replace(/\+/g, "-").replace(/\//g, "_")
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const lhe = /^[cdef][\w-]{21}$/,
    X0 = "";

function che() {
    try {
        const t = new Uint8Array(17);
        (self.crypto || self.msCrypto).getRandomValues(t), t[0] = 112 + t[0] % 16;
        const n = uhe(t);
        return lhe.test(n) ? n : X0
    } catch {
        return X0
    }
}

function uhe(t) {
    return ahe(t).substr(0, 22)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function um(t) {
    return `${t.appName}!${t.appId}`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const jF = new Map;

function VF(t, e) {
    const n = um(t);
    WF(n, e), dhe(n, e)
}

function WF(t, e) {
    const n = jF.get(t);
    if (n)
        for (const r of n) r(e)
}

function dhe(t, e) {
    const n = fhe();
    n && n.postMessage({
        key: t,
        fid: e
    }), hhe()
}
let Bo = null;

function fhe() {
    return !Bo && "BroadcastChannel" in self && (Bo = new BroadcastChannel("[Firebase] FID Change"), Bo.onmessage = t => {
        WF(t.data.key, t.data.fid)
    }), Bo
}

function hhe() {
    jF.size === 0 && Bo && (Bo.close(), Bo = null)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const phe = "firebase-installations-database",
    mhe = 1,
    la = "firebase-installations-store";
let Qg = null;

function cw() {
    return Qg || (Qg = cm(phe, mhe, {
        upgrade: (t, e) => {
            switch (e) {
                case 0:
                    t.createObjectStore(la)
            }
        }
    })), Qg
}
async function Lh(t, e) {
    const n = um(t),
        i = (await cw()).transaction(la, "readwrite"),
        s = i.objectStore(la),
        o = await s.get(n);
    return await s.put(e, n), await i.done, (!o || o.fid !== e.fid) && VF(t, e.fid), e
}
async function YF(t) {
    const e = um(t),
        r = (await cw()).transaction(la, "readwrite");
    await r.objectStore(la).delete(e), await r.done
}
async function dm(t, e) {
    const n = um(t),
        i = (await cw()).transaction(la, "readwrite"),
        s = i.objectStore(la),
        o = await s.get(n),
        a = e(o);
    return a === void 0 ? await s.delete(n) : await s.put(a, n), await i.done, a && (!o || o.fid !== a.fid) && VF(t, a.fid), a
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function uw(t) {
    let e;
    const n = await dm(t.appConfig, r => {
        const i = ghe(r),
            s = yhe(t, i);
        return e = s.registrationPromise, s.installationEntry
    });
    return n.fid === X0 ? {
        installationEntry: await e
    } : {
        installationEntry: n,
        registrationPromise: e
    }
}

function ghe(t) {
    const e = t || {
        fid: che(),
        registrationStatus: 0
    };
    return XF(e)
}

function yhe(t, e) {
    if (e.registrationStatus === 0) {
        if (!navigator.onLine) {
            const i = Promise.reject(aa.create("app-offline"));
            return {
                installationEntry: e,
                registrationPromise: i
            }
        }
        const n = {
                fid: e.fid,
                registrationStatus: 1,
                registrationTime: Date.now()
            },
            r = vhe(t, n);
        return {
            installationEntry: n,
            registrationPromise: r
        }
    } else return e.registrationStatus === 1 ? {
        installationEntry: e,
        registrationPromise: _he(t)
    } : {
        installationEntry: e
    }
}
async function vhe(t, e) {
    try {
        const n = await ohe(t, e);
        return Lh(t.appConfig, n)
    } catch (n) {
        throw FF(n) && n.customData.serverCode === 409 ? await YF(t.appConfig) : await Lh(t.appConfig, {
            fid: e.fid,
            registrationStatus: 0
        }), n
    }
}
async function _he(t) {
    let e = await tP(t.appConfig);
    for (; e.registrationStatus === 1;) await zF(100), e = await tP(t.appConfig);
    if (e.registrationStatus === 0) {
        const {
            installationEntry: n,
            registrationPromise: r
        } = await uw(t);
        return r || n
    }
    return e
}

function tP(t) {
    return dm(t, e => {
        if (!e) throw aa.create("installation-not-found");
        return XF(e)
    })
}

function XF(t) {
    return bhe(t) ? {
        fid: t.fid,
        registrationStatus: 0
    } : t
}

function bhe(t) {
    return t.registrationStatus === 1 && t.registrationTime + BF < Date.now()
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function xhe({
    appConfig: t,
    heartbeatServiceProvider: e
}, n) {
    const r = whe(t, n),
        i = rhe(t, n),
        s = e.getImmediate({
            optional: !0
        });
    if (s) {
        const c = await s.getHeartbeatsHeader();
        c && i.append("x-firebase-client", c)
    }
    const o = {
            installation: {
                sdkVersion: DF,
                appId: t.appId
            }
        },
        a = {
            method: "POST",
            headers: i,
            body: JSON.stringify(o)
        },
        l = await HF(() => fetch(r, a));
    if (l.ok) {
        const c = await l.json();
        return NF(c)
    } else throw await UF("Generate Auth Token", l)
}

function whe(t, {
    fid: e
}) {
    return `${LF(t)}/${e}/authTokens:generate`
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function dw(t, e = !1) {
    let n;
    const r = await dm(t.appConfig, s => {
        if (!qF(s)) throw aa.create("not-registered");
        const o = s.authToken;
        if (!e && The(o)) return s;
        if (o.requestStatus === 1) return n = Ehe(t, e), s; {
            if (!navigator.onLine) throw aa.create("app-offline");
            const a = Phe(s);
            return n = She(t, a), a
        }
    });
    return n ? await n : r.authToken
}
async function Ehe(t, e) {
    let n = await nP(t.appConfig);
    for (; n.authToken.requestStatus === 1;) await zF(100), n = await nP(t.appConfig);
    const r = n.authToken;
    return r.requestStatus === 0 ? dw(t, e) : r
}

function nP(t) {
    return dm(t, e => {
        if (!qF(e)) throw aa.create("not-registered");
        const n = e.authToken;
        return Ahe(n) ? Object.assign(Object.assign({}, e), {
            authToken: {
                requestStatus: 0
            }
        }) : e
    })
}
async function She(t, e) {
    try {
        const n = await xhe(t, e),
            r = Object.assign(Object.assign({}, e), {
                authToken: n
            });
        return await Lh(t.appConfig, r), n
    } catch (n) {
        if (FF(n) && (n.customData.serverCode === 401 || n.customData.serverCode === 404)) await YF(t.appConfig);
        else {
            const r = Object.assign(Object.assign({}, e), {
                authToken: {
                    requestStatus: 0
                }
            });
            await Lh(t.appConfig, r)
        }
        throw n
    }
}

function qF(t) {
    return t !== void 0 && t.registrationStatus === 2
}

function The(t) {
    return t.requestStatus === 2 && !Che(t)
}

function Che(t) {
    const e = Date.now();
    return e < t.creationTime || t.creationTime + t.expiresIn < e + Qfe
}

function Phe(t) {
    const e = {
        requestStatus: 1,
        requestTime: Date.now()
    };
    return Object.assign(Object.assign({}, t), {
        authToken: e
    })
}

function Ahe(t) {
    return t.requestStatus === 1 && t.requestTime + BF < Date.now()
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Ohe(t) {
    const e = t,
        {
            installationEntry: n,
            registrationPromise: r
        } = await uw(e);
    return r ? r.catch(console.error) : dw(e).catch(console.error), n.fid
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Ihe(t, e = !1) {
    const n = t;
    return await Mhe(n), (await dw(n, e)).token
}
async function Mhe(t) {
    const {
        registrationPromise: e
    } = await uw(t);
    e && await e
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Rhe(t) {
    if (!t || !t.options) throw ey("App Configuration");
    if (!t.name) throw ey("App Name");
    const e = ["projectId", "apiKey", "appId"];
    for (const n of e)
        if (!t.options[n]) throw ey(n);
    return {
        appName: t.name,
        projectId: t.options.projectId,
        apiKey: t.options.apiKey,
        appId: t.options.appId
    }
}

function ey(t) {
    return aa.create("missing-app-config-values", {
        valueName: t
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const KF = "installations",
    khe = "installations-internal",
    Bhe = t => {
        const e = t.getProvider("app").getImmediate(),
            n = Rhe(e),
            r = aw(e, "heartbeat");
        return {
            app: e,
            appConfig: n,
            heartbeatServiceProvider: r,
            _delete: () => Promise.resolve()
        }
    },
    Dhe = t => {
        const e = t.getProvider("app").getImmediate(),
            n = aw(e, KF).getImmediate();
        return {
            getId: () => Ohe(n),
            getToken: i => Ihe(n, i)
        }
    };

function $he() {
    oa(new Ks(KF, Bhe, "PUBLIC")), oa(new Ks(khe, Dhe, "PRIVATE"))
}
$he();
Ns(kF, lw);
Ns(kF, lw, "esm2017");
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Fhe = "/firebase-messaging-sw.js",
    Lhe = "/firebase-cloud-messaging-push-scope",
    JF = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4",
    Nhe = "https://fcmregistrations.googleapis.com/v1",
    ZF = "google.c.a.c_id",
    Uhe = "google.c.a.c_l",
    Ghe = "google.c.a.ts",
    Hhe = "google.c.a.e",
    rP = 1e4;
var iP;
(function(t) {
    t[t.DATA_MESSAGE = 1] = "DATA_MESSAGE", t[t.DISPLAY_NOTIFICATION = 3] = "DISPLAY_NOTIFICATION"
})(iP || (iP = {}));
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
var $u;
(function(t) {
    t.PUSH_RECEIVED = "push-received", t.NOTIFICATION_CLICKED = "notification-clicked"
})($u || ($u = {}));
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ai(t) {
    const e = new Uint8Array(t);
    return btoa(String.fromCharCode(...e)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_")
}

function zhe(t) {
    const e = "=".repeat((4 - t.length % 4) % 4),
        n = (t + e).replace(/\-/g, "+").replace(/_/g, "/"),
        r = atob(n),
        i = new Uint8Array(r.length);
    for (let s = 0; s < r.length; ++s) i[s] = r.charCodeAt(s);
    return i
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ty = "fcm_token_details_db",
    jhe = 5,
    sP = "fcm_token_object_Store";
async function Vhe(t) {
    if ("databases" in indexedDB && !(await indexedDB.databases()).map(s => s.name).includes(ty)) return null;
    let e = null;
    return (await cm(ty, jhe, {
        upgrade: async (r, i, s, o) => {
            var a;
            if (i < 2 || !r.objectStoreNames.contains(sP)) return;
            const l = o.objectStore(sP),
                c = await l.index("fcmSenderId").get(t);
            if (await l.clear(), !!c) {
                if (i === 2) {
                    const u = c;
                    if (!u.auth || !u.p256dh || !u.endpoint) return;
                    e = {
                        token: u.fcmToken,
                        createTime: (a = u.createTime) !== null && a !== void 0 ? a : Date.now(),
                        subscriptionOptions: {
                            auth: u.auth,
                            p256dh: u.p256dh,
                            endpoint: u.endpoint,
                            swScope: u.swScope,
                            vapidKey: typeof u.vapidKey == "string" ? u.vapidKey : Ai(u.vapidKey)
                        }
                    }
                } else if (i === 3) {
                    const u = c;
                    e = {
                        token: u.fcmToken,
                        createTime: u.createTime,
                        subscriptionOptions: {
                            auth: Ai(u.auth),
                            p256dh: Ai(u.p256dh),
                            endpoint: u.endpoint,
                            swScope: u.swScope,
                            vapidKey: Ai(u.vapidKey)
                        }
                    }
                } else if (i === 4) {
                    const u = c;
                    e = {
                        token: u.fcmToken,
                        createTime: u.createTime,
                        subscriptionOptions: {
                            auth: Ai(u.auth),
                            p256dh: Ai(u.p256dh),
                            endpoint: u.endpoint,
                            swScope: u.swScope,
                            vapidKey: Ai(u.vapidKey)
                        }
                    }
                }
            }
        }
    })).close(), await Kg(ty), await Kg("fcm_vapid_details_db"), await Kg("undefined"), Whe(e) ? e : null
}

function Whe(t) {
    if (!t || !t.subscriptionOptions) return !1;
    const {
        subscriptionOptions: e
    } = t;
    return typeof t.createTime == "number" && t.createTime > 0 && typeof t.token == "string" && t.token.length > 0 && typeof e.auth == "string" && e.auth.length > 0 && typeof e.p256dh == "string" && e.p256dh.length > 0 && typeof e.endpoint == "string" && e.endpoint.length > 0 && typeof e.swScope == "string" && e.swScope.length > 0 && typeof e.vapidKey == "string" && e.vapidKey.length > 0
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Yhe = "firebase-messaging-database",
    Xhe = 1,
    Fu = "firebase-messaging-store";
let ny = null;

function QF() {
    return ny || (ny = cm(Yhe, Xhe, {
        upgrade: (t, e) => {
            switch (e) {
                case 0:
                    t.createObjectStore(Fu)
            }
        }
    })), ny
}
async function qhe(t) {
    const e = eL(t),
        r = await (await QF()).transaction(Fu).objectStore(Fu).get(e);
    if (r) return r; {
        const i = await Vhe(t.appConfig.senderId);
        if (i) return await fw(t, i), i
    }
}
async function fw(t, e) {
    const n = eL(t),
        i = (await QF()).transaction(Fu, "readwrite");
    return await i.objectStore(Fu).put(e, n), await i.done, e
}

function eL({
    appConfig: t
}) {
    return t.appId
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Khe = {
        "missing-app-config-values": 'Missing App configuration value: "{$valueName}"',
        "only-available-in-window": "This method is available in a Window context.",
        "only-available-in-sw": "This method is available in a service worker context.",
        "permission-default": "The notification permission was not granted and dismissed instead.",
        "permission-blocked": "The notification permission was not granted and blocked instead.",
        "unsupported-browser": "This browser doesn't support the API's required to use the Firebase SDK.",
        "indexed-db-unsupported": "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)",
        "failed-service-worker-registration": "We are unable to register the default service worker. {$browserErrorMessage}",
        "token-subscribe-failed": "A problem occurred while subscribing the user to FCM: {$errorInfo}",
        "token-subscribe-no-token": "FCM returned no token when subscribing the user to push.",
        "token-unsubscribe-failed": "A problem occurred while unsubscribing the user from FCM: {$errorInfo}",
        "token-update-failed": "A problem occurred while updating the user from FCM: {$errorInfo}",
        "token-update-no-token": "FCM returned no token when updating the user to push.",
        "use-sw-after-get-token": "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.",
        "invalid-sw-registration": "The input to useServiceWorker() must be a ServiceWorkerRegistration.",
        "invalid-bg-handler": "The input to setBackgroundMessageHandler() must be a function.",
        "invalid-vapid-key": "The public VAPID key must be a string.",
        "use-vapid-key-after-get-token": "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used."
    },
    fn = new lm("messaging", "Messaging", Khe);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function Jhe(t, e) {
    const n = await pw(t),
        r = tL(e),
        i = {
            method: "POST",
            headers: n,
            body: JSON.stringify(r)
        };
    let s;
    try {
        s = await (await fetch(hw(t.appConfig), i)).json()
    } catch (o) {
        throw fn.create("token-subscribe-failed", {
            errorInfo: o == null ? void 0 : o.toString()
        })
    }
    if (s.error) {
        const o = s.error.message;
        throw fn.create("token-subscribe-failed", {
            errorInfo: o
        })
    }
    if (!s.token) throw fn.create("token-subscribe-no-token");
    return s.token
}
async function Zhe(t, e) {
    const n = await pw(t),
        r = tL(e.subscriptionOptions),
        i = {
            method: "PATCH",
            headers: n,
            body: JSON.stringify(r)
        };
    let s;
    try {
        s = await (await fetch(`${hw(t.appConfig)}/${e.token}`, i)).json()
    } catch (o) {
        throw fn.create("token-update-failed", {
            errorInfo: o == null ? void 0 : o.toString()
        })
    }
    if (s.error) {
        const o = s.error.message;
        throw fn.create("token-update-failed", {
            errorInfo: o
        })
    }
    if (!s.token) throw fn.create("token-update-no-token");
    return s.token
}
async function Qhe(t, e) {
    const r = {
        method: "DELETE",
        headers: await pw(t)
    };
    try {
        const s = await (await fetch(`${hw(t.appConfig)}/${e}`, r)).json();
        if (s.error) {
            const o = s.error.message;
            throw fn.create("token-unsubscribe-failed", {
                errorInfo: o
            })
        }
    } catch (i) {
        throw fn.create("token-unsubscribe-failed", {
            errorInfo: i == null ? void 0 : i.toString()
        })
    }
}

function hw({
    projectId: t
}) {
    return `${Nhe}/projects/${t}/registrations`
}
async function pw({
    appConfig: t,
    installations: e
}) {
    const n = await e.getToken();
    return new Headers({
        "Content-Type": "application/json",
        Accept: "application/json",
        "x-goog-api-key": t.apiKey,
        "x-goog-firebase-installations-auth": `FIS ${n}`
    })
}

function tL({
    p256dh: t,
    auth: e,
    endpoint: n,
    vapidKey: r
}) {
    const i = {
        web: {
            endpoint: n,
            auth: e,
            p256dh: t
        }
    };
    return r !== JF && (i.web.applicationPubKey = r), i
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const epe = 7 * 24 * 60 * 60 * 1e3;
async function tpe(t) {
    const e = await rpe(t.swRegistration, t.vapidKey),
        n = {
            vapidKey: t.vapidKey,
            swScope: t.swRegistration.scope,
            endpoint: e.endpoint,
            auth: Ai(e.getKey("auth")),
            p256dh: Ai(e.getKey("p256dh"))
        },
        r = await qhe(t.firebaseDependencies);
    if (r) {
        if (ipe(r.subscriptionOptions, n)) return Date.now() >= r.createTime + epe ? npe(t, {
            token: r.token,
            createTime: Date.now(),
            subscriptionOptions: n
        }) : r.token;
        try {
            await Qhe(t.firebaseDependencies, r.token)
        } catch (i) {
            console.warn(i)
        }
        return oP(t.firebaseDependencies, n)
    } else return oP(t.firebaseDependencies, n)
}
async function npe(t, e) {
    try {
        const n = await Zhe(t.firebaseDependencies, e),
            r = Object.assign(Object.assign({}, e), {
                token: n,
                createTime: Date.now()
            });
        return await fw(t.firebaseDependencies, r), n
    } catch (n) {
        throw n
    }
}
async function oP(t, e) {
    const r = {
        token: await Jhe(t, e),
        createTime: Date.now(),
        subscriptionOptions: e
    };
    return await fw(t, r), r.token
}
async function rpe(t, e) {
    const n = await t.pushManager.getSubscription();
    return n || t.pushManager.subscribe({
        userVisibleOnly: !0,
        applicationServerKey: zhe(e)
    })
}

function ipe(t, e) {
    const n = e.vapidKey === t.vapidKey,
        r = e.endpoint === t.endpoint,
        i = e.auth === t.auth,
        s = e.p256dh === t.p256dh;
    return n && r && i && s
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function aP(t) {
    const e = {
        from: t.from,
        collapseKey: t.collapse_key,
        messageId: t.fcmMessageId
    };
    return spe(e, t), ope(e, t), ape(e, t), e
}

function spe(t, e) {
    if (!e.notification) return;
    t.notification = {};
    const n = e.notification.title;
    n && (t.notification.title = n);
    const r = e.notification.body;
    r && (t.notification.body = r);
    const i = e.notification.image;
    i && (t.notification.image = i);
    const s = e.notification.icon;
    s && (t.notification.icon = s)
}

function ope(t, e) {
    e.data && (t.data = e.data)
}

function ape(t, e) {
    var n, r, i, s, o;
    if (!e.fcmOptions && !(!((n = e.notification) === null || n === void 0) && n.click_action)) return;
    t.fcmOptions = {};
    const a = (i = (r = e.fcmOptions) === null || r === void 0 ? void 0 : r.link) !== null && i !== void 0 ? i : (s = e.notification) === null || s === void 0 ? void 0 : s.click_action;
    a && (t.fcmOptions.link = a);
    const l = (o = e.fcmOptions) === null || o === void 0 ? void 0 : o.analytics_label;
    l && (t.fcmOptions.analyticsLabel = l)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function lpe(t) {
    return typeof t == "object" && !!t && ZF in t
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
cpe("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4");

function cpe(t, e) {
    const n = [];
    for (let r = 0; r < t.length; r++) n.push(t.charAt(r)), r < e.length && n.push(e.charAt(r));
    return n.join("")
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function upe(t) {
    if (!t || !t.options) throw ry("App Configuration Object");
    if (!t.name) throw ry("App Name");
    const e = ["projectId", "apiKey", "appId", "messagingSenderId"],
        {
            options: n
        } = t;
    for (const r of e)
        if (!n[r]) throw ry(r);
    return {
        appName: t.name,
        projectId: n.projectId,
        apiKey: n.apiKey,
        appId: n.appId,
        senderId: n.messagingSenderId
    }
}

function ry(t) {
    return fn.create("missing-app-config-values", {
        valueName: t
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dpe {
    constructor(e, n, r) {
        this.deliveryMetricsExportedToBigQueryEnabled = !1, this.onBackgroundMessageHandler = null, this.onMessageHandler = null, this.logEvents = [], this.isLogServiceStarted = !1;
        const i = upe(e);
        this.firebaseDependencies = {
            app: e,
            appConfig: i,
            installations: n,
            analyticsProvider: r
        }
    }
    _delete() {
        return Promise.resolve()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function fpe(t) {
    try {
        t.swRegistration = await navigator.serviceWorker.register(Fhe, {
            scope: Lhe
        }), t.swRegistration.update().catch(() => {}), await hpe(t.swRegistration)
    } catch (e) {
        throw fn.create("failed-service-worker-registration", {
            browserErrorMessage: e == null ? void 0 : e.message
        })
    }
}
async function hpe(t) {
    return new Promise((e, n) => {
        const r = setTimeout(() => n(new Error(`Service worker not registered after ${rP} ms`)), rP),
            i = t.installing || t.waiting;
        t.active ? (clearTimeout(r), e()) : i ? i.onstatechange = s => {
            var o;
            ((o = s.target) === null || o === void 0 ? void 0 : o.state) === "activated" && (i.onstatechange = null, clearTimeout(r), e())
        } : (clearTimeout(r), n(new Error("No incoming service worker found.")))
    })
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function ppe(t, e) {
    if (!e && !t.swRegistration && await fpe(t), !(!e && t.swRegistration)) {
        if (!(e instanceof ServiceWorkerRegistration)) throw fn.create("invalid-sw-registration");
        t.swRegistration = e
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function mpe(t, e) {
    e ? t.vapidKey = e : t.vapidKey || (t.vapidKey = JF)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function nL(t, e) {
    if (!navigator) throw fn.create("only-available-in-window");
    if (Notification.permission === "default" && await Notification.requestPermission(), Notification.permission !== "granted") throw fn.create("permission-blocked");
    return await mpe(t, e == null ? void 0 : e.vapidKey), await ppe(t, e == null ? void 0 : e.serviceWorkerRegistration), tpe(t)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function gpe(t, e, n) {
    const r = ype(e);
    (await t.firebaseDependencies.analyticsProvider.get()).logEvent(r, {
        message_id: n[ZF],
        message_name: n[Uhe],
        message_time: n[Ghe],
        message_device_time: Math.floor(Date.now() / 1e3)
    })
}

function ype(t) {
    switch (t) {
        case $u.NOTIFICATION_CLICKED:
            return "notification_open";
        case $u.PUSH_RECEIVED:
            return "notification_foreground";
        default:
            throw new Error
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function vpe(t, e) {
    const n = e.data;
    if (!n.isFirebaseMessaging) return;
    t.onMessageHandler && n.messageType === $u.PUSH_RECEIVED && (typeof t.onMessageHandler == "function" ? t.onMessageHandler(aP(n)) : t.onMessageHandler.next(aP(n)));
    const r = n.data;
    lpe(r) && r[Hhe] === "1" && await gpe(t, n.messageType, r)
}
const lP = "@firebase/messaging",
    cP = "0.12.22";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _pe = t => {
        const e = new dpe(t.getProvider("app").getImmediate(), t.getProvider("installations-internal").getImmediate(), t.getProvider("analytics-internal"));
        return navigator.serviceWorker.addEventListener("message", n => vpe(e, n)), e
    },
    bpe = t => {
        const e = t.getProvider("messaging").getImmediate();
        return {
            getToken: r => nL(e, r)
        }
    };

function xpe() {
    oa(new Ks("messaging", _pe, "PUBLIC")), oa(new Ks("messaging-internal", bpe, "PRIVATE")), Ns(lP, cP), Ns(lP, cP, "esm2017")
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function wpe() {
    try {
        await AF()
    } catch {
        return !1
    }
    return typeof window < "u" && PF() && Fde() && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey")
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Epe(t, e) {
    if (!navigator) throw fn.create("only-available-in-window");
    return t.onMessageHandler = e, () => {
        t.onMessageHandler = null
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Swe(t = Nfe()) {
    return wpe().then(e => {
        if (!e) throw fn.create("unsupported-browser")
    }, e => {
        throw fn.create("indexed-db-unsupported")
    }), aw(sw(t), "messaging").getImmediate()
}
async function Twe(t, e) {
    return t = sw(t), nL(t, e)
}

function Cwe(t, e) {
    return t = sw(t), Epe(t, e)
}
xpe();
var _d = {},
    Spe = function() {
        return typeof Promise == "function" && Promise.prototype && Promise.prototype.then
    },
    rL = {},
    sr = {};
let mw;
const Tpe = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
sr.getSymbolSize = function(e) {
    if (!e) throw new Error('"version" cannot be null or undefined');
    if (e < 1 || e > 40) throw new Error('"version" should be in range from 1 to 40');
    return e * 4 + 17
};
sr.getSymbolTotalCodewords = function(e) {
    return Tpe[e]
};
sr.getBCHDigit = function(t) {
    let e = 0;
    for (; t !== 0;) e++, t >>>= 1;
    return e
};
sr.setToSJISFunction = function(e) {
    if (typeof e != "function") throw new Error('"toSJISFunc" is not a valid function.');
    mw = e
};
sr.isKanjiModeEnabled = function() {
    return typeof mw < "u"
};
sr.toSJIS = function(e) {
    return mw(e)
};
var fm = {};
(function(t) {
    t.L = {
        bit: 1
    }, t.M = {
        bit: 0
    }, t.Q = {
        bit: 3
    }, t.H = {
        bit: 2
    };

    function e(n) {
        if (typeof n != "string") throw new Error("Param is not a string");
        switch (n.toLowerCase()) {
            case "l":
            case "low":
                return t.L;
            case "m":
            case "medium":
                return t.M;
            case "q":
            case "quartile":
                return t.Q;
            case "h":
            case "high":
                return t.H;
            default:
                throw new Error("Unknown EC Level: " + n)
        }
    }
    t.isValid = function(r) {
        return r && typeof r.bit < "u" && r.bit >= 0 && r.bit < 4
    }, t.from = function(r, i) {
        if (t.isValid(r)) return r;
        try {
            return e(r)
        } catch {
            return i
        }
    }
})(fm);

function iL() {
    this.buffer = [], this.length = 0
}
iL.prototype = {
    get: function(t) {
        const e = Math.floor(t / 8);
        return (this.buffer[e] >>> 7 - t % 8 & 1) === 1
    },
    put: function(t, e) {
        for (let n = 0; n < e; n++) this.putBit((t >>> e - n - 1 & 1) === 1)
    },
    getLengthInBits: function() {
        return this.length
    },
    putBit: function(t) {
        const e = Math.floor(this.length / 8);
        this.buffer.length <= e && this.buffer.push(0), t && (this.buffer[e] |= 128 >>> this.length % 8), this.length++
    }
};
var Cpe = iL;

function bd(t) {
    if (!t || t < 1) throw new Error("BitMatrix size must be defined and greater than 0");
    this.size = t, this.data = new Uint8Array(t * t), this.reservedBit = new Uint8Array(t * t)
}
bd.prototype.set = function(t, e, n, r) {
    const i = t * this.size + e;
    this.data[i] = n, r && (this.reservedBit[i] = !0)
};
bd.prototype.get = function(t, e) {
    return this.data[t * this.size + e]
};
bd.prototype.xor = function(t, e, n) {
    this.data[t * this.size + e] ^= n
};
bd.prototype.isReserved = function(t, e) {
    return this.reservedBit[t * this.size + e]
};
var Ppe = bd,
    sL = {};
(function(t) {
    const e = sr.getSymbolSize;
    t.getRowColCoords = function(r) {
        if (r === 1) return [];
        const i = Math.floor(r / 7) + 2,
            s = e(r),
            o = s === 145 ? 26 : Math.ceil((s - 13) / (2 * i - 2)) * 2,
            a = [s - 7];
        for (let l = 1; l < i - 1; l++) a[l] = a[l - 1] - o;
        return a.push(6), a.reverse()
    }, t.getPositions = function(r) {
        const i = [],
            s = t.getRowColCoords(r),
            o = s.length;
        for (let a = 0; a < o; a++)
            for (let l = 0; l < o; l++) a === 0 && l === 0 || a === 0 && l === o - 1 || a === o - 1 && l === 0 || i.push([s[a], s[l]]);
        return i
    }
})(sL);
var oL = {};
const Ape = sr.getSymbolSize,
    uP = 7;
oL.getPositions = function(e) {
    const n = Ape(e);
    return [
        [0, 0],
        [n - uP, 0],
        [0, n - uP]
    ]
};
var aL = {};
(function(t) {
    t.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
    };
    const e = {
        N1: 3,
        N2: 3,
        N3: 40,
        N4: 10
    };
    t.isValid = function(i) {
        return i != null && i !== "" && !isNaN(i) && i >= 0 && i <= 7
    }, t.from = function(i) {
        return t.isValid(i) ? parseInt(i, 10) : void 0
    }, t.getPenaltyN1 = function(i) {
        const s = i.size;
        let o = 0,
            a = 0,
            l = 0,
            c = null,
            u = null;
        for (let d = 0; d < s; d++) {
            a = l = 0, c = u = null;
            for (let f = 0; f < s; f++) {
                let h = i.get(d, f);
                h === c ? a++ : (a >= 5 && (o += e.N1 + (a - 5)), c = h, a = 1), h = i.get(f, d), h === u ? l++ : (l >= 5 && (o += e.N1 + (l - 5)), u = h, l = 1)
            }
            a >= 5 && (o += e.N1 + (a - 5)), l >= 5 && (o += e.N1 + (l - 5))
        }
        return o
    }, t.getPenaltyN2 = function(i) {
        const s = i.size;
        let o = 0;
        for (let a = 0; a < s - 1; a++)
            for (let l = 0; l < s - 1; l++) {
                const c = i.get(a, l) + i.get(a, l + 1) + i.get(a + 1, l) + i.get(a + 1, l + 1);
                (c === 4 || c === 0) && o++
            }
        return o * e.N2
    }, t.getPenaltyN3 = function(i) {
        const s = i.size;
        let o = 0,
            a = 0,
            l = 0;
        for (let c = 0; c < s; c++) {
            a = l = 0;
            for (let u = 0; u < s; u++) a = a << 1 & 2047 | i.get(c, u), u >= 10 && (a === 1488 || a === 93) && o++, l = l << 1 & 2047 | i.get(u, c), u >= 10 && (l === 1488 || l === 93) && o++
        }
        return o * e.N3
    }, t.getPenaltyN4 = function(i) {
        let s = 0;
        const o = i.data.length;
        for (let l = 0; l < o; l++) s += i.data[l];
        return Math.abs(Math.ceil(s * 100 / o / 5) - 10) * e.N4
    };

    function n(r, i, s) {
        switch (r) {
            case t.Patterns.PATTERN000:
                return (i + s) % 2 === 0;
            case t.Patterns.PATTERN001:
                return i % 2 === 0;
            case t.Patterns.PATTERN010:
                return s % 3 === 0;
            case t.Patterns.PATTERN011:
                return (i + s) % 3 === 0;
            case t.Patterns.PATTERN100:
                return (Math.floor(i / 2) + Math.floor(s / 3)) % 2 === 0;
            case t.Patterns.PATTERN101:
                return i * s % 2 + i * s % 3 === 0;
            case t.Patterns.PATTERN110:
                return (i * s % 2 + i * s % 3) % 2 === 0;
            case t.Patterns.PATTERN111:
                return (i * s % 3 + (i + s) % 2) % 2 === 0;
            default:
                throw new Error("bad maskPattern:" + r)
        }
    }
    t.applyMask = function(i, s) {
        const o = s.size;
        for (let a = 0; a < o; a++)
            for (let l = 0; l < o; l++) s.isReserved(l, a) || s.xor(l, a, n(i, l, a))
    }, t.getBestMask = function(i, s) {
        const o = Object.keys(t.Patterns).length;
        let a = 0,
            l = 1 / 0;
        for (let c = 0; c < o; c++) {
            s(c), t.applyMask(c, i);
            const u = t.getPenaltyN1(i) + t.getPenaltyN2(i) + t.getPenaltyN3(i) + t.getPenaltyN4(i);
            t.applyMask(c, i), u < l && (l = u, a = c)
        }
        return a
    }
})(aL);
var hm = {};
const Ps = fm,
    Tf = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81],
    Cf = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
hm.getBlocksCount = function(e, n) {
    switch (n) {
        case Ps.L:
            return Tf[(e - 1) * 4 + 0];
        case Ps.M:
            return Tf[(e - 1) * 4 + 1];
        case Ps.Q:
            return Tf[(e - 1) * 4 + 2];
        case Ps.H:
            return Tf[(e - 1) * 4 + 3];
        default:
            return
    }
};
hm.getTotalCodewordsCount = function(e, n) {
    switch (n) {
        case Ps.L:
            return Cf[(e - 1) * 4 + 0];
        case Ps.M:
            return Cf[(e - 1) * 4 + 1];
        case Ps.Q:
            return Cf[(e - 1) * 4 + 2];
        case Ps.H:
            return Cf[(e - 1) * 4 + 3];
        default:
            return
    }
};
var lL = {},
    pm = {};
const eu = new Uint8Array(512),
    Nh = new Uint8Array(256);
(function() {
    let e = 1;
    for (let n = 0; n < 255; n++) eu[n] = e, Nh[e] = n, e <<= 1, e & 256 && (e ^= 285);
    for (let n = 255; n < 512; n++) eu[n] = eu[n - 255]
})();
pm.log = function(e) {
    if (e < 1) throw new Error("log(" + e + ")");
    return Nh[e]
};
pm.exp = function(e) {
    return eu[e]
};
pm.mul = function(e, n) {
    return e === 0 || n === 0 ? 0 : eu[Nh[e] + Nh[n]]
};
(function(t) {
    const e = pm;
    t.mul = function(r, i) {
        const s = new Uint8Array(r.length + i.length - 1);
        for (let o = 0; o < r.length; o++)
            for (let a = 0; a < i.length; a++) s[o + a] ^= e.mul(r[o], i[a]);
        return s
    }, t.mod = function(r, i) {
        let s = new Uint8Array(r);
        for (; s.length - i.length >= 0;) {
            const o = s[0];
            for (let l = 0; l < i.length; l++) s[l] ^= e.mul(i[l], o);
            let a = 0;
            for (; a < s.length && s[a] === 0;) a++;
            s = s.slice(a)
        }
        return s
    }, t.generateECPolynomial = function(r) {
        let i = new Uint8Array([1]);
        for (let s = 0; s < r; s++) i = t.mul(i, new Uint8Array([1, e.exp(s)]));
        return i
    }
})(lL);
const cL = lL;

function gw(t) {
    this.genPoly = void 0, this.degree = t, this.degree && this.initialize(this.degree)
}
gw.prototype.initialize = function(e) {
    this.degree = e, this.genPoly = cL.generateECPolynomial(this.degree)
};
gw.prototype.encode = function(e) {
    if (!this.genPoly) throw new Error("Encoder not initialized");
    const n = new Uint8Array(e.length + this.degree);
    n.set(e);
    const r = cL.mod(n, this.genPoly),
        i = this.degree - r.length;
    if (i > 0) {
        const s = new Uint8Array(this.degree);
        return s.set(r, i), s
    }
    return r
};
var Ope = gw,
    uL = {},
    oo = {},
    yw = {};
yw.isValid = function(e) {
    return !isNaN(e) && e >= 1 && e <= 40
};
var yi = {};
const dL = "[0-9]+",
    Ipe = "[A-Z $%*+\\-./:]+";
let Lu = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
Lu = Lu.replace(/u/g, "\\u");
const Mpe = "(?:(?![A-Z0-9 $%*+\\-./:]|" + Lu + `)(?:.|[\r
]))+`;
yi.KANJI = new RegExp(Lu, "g");
yi.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
yi.BYTE = new RegExp(Mpe, "g");
yi.NUMERIC = new RegExp(dL, "g");
yi.ALPHANUMERIC = new RegExp(Ipe, "g");
const Rpe = new RegExp("^" + Lu + "$"),
    kpe = new RegExp("^" + dL + "$"),
    Bpe = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
yi.testKanji = function(e) {
    return Rpe.test(e)
};
yi.testNumeric = function(e) {
    return kpe.test(e)
};
yi.testAlphanumeric = function(e) {
    return Bpe.test(e)
};
(function(t) {
    const e = yw,
        n = yi;
    t.NUMERIC = {
        id: "Numeric",
        bit: 1,
        ccBits: [10, 12, 14]
    }, t.ALPHANUMERIC = {
        id: "Alphanumeric",
        bit: 2,
        ccBits: [9, 11, 13]
    }, t.BYTE = {
        id: "Byte",
        bit: 4,
        ccBits: [8, 16, 16]
    }, t.KANJI = {
        id: "Kanji",
        bit: 8,
        ccBits: [8, 10, 12]
    }, t.MIXED = {
        bit: -1
    }, t.getCharCountIndicator = function(s, o) {
        if (!s.ccBits) throw new Error("Invalid mode: " + s);
        if (!e.isValid(o)) throw new Error("Invalid version: " + o);
        return o >= 1 && o < 10 ? s.ccBits[0] : o < 27 ? s.ccBits[1] : s.ccBits[2]
    }, t.getBestModeForData = function(s) {
        return n.testNumeric(s) ? t.NUMERIC : n.testAlphanumeric(s) ? t.ALPHANUMERIC : n.testKanji(s) ? t.KANJI : t.BYTE
    }, t.toString = function(s) {
        if (s && s.id) return s.id;
        throw new Error("Invalid mode")
    }, t.isValid = function(s) {
        return s && s.bit && s.ccBits
    };

    function r(i) {
        if (typeof i != "string") throw new Error("Param is not a string");
        switch (i.toLowerCase()) {
            case "numeric":
                return t.NUMERIC;
            case "alphanumeric":
                return t.ALPHANUMERIC;
            case "kanji":
                return t.KANJI;
            case "byte":
                return t.BYTE;
            default:
                throw new Error("Unknown mode: " + i)
        }
    }
    t.from = function(s, o) {
        if (t.isValid(s)) return s;
        try {
            return r(s)
        } catch {
            return o
        }
    }
})(oo);
(function(t) {
    const e = sr,
        n = hm,
        r = fm,
        i = oo,
        s = yw,
        o = 7973,
        a = e.getBCHDigit(o);

    function l(f, h, p) {
        for (let b = 1; b <= 40; b++)
            if (h <= t.getCapacity(b, p, f)) return b
    }

    function c(f, h) {
        return i.getCharCountIndicator(f, h) + 4
    }

    function u(f, h) {
        let p = 0;
        return f.forEach(function(b) {
            const y = c(b.mode, h);
            p += y + b.getBitsLength()
        }), p
    }

    function d(f, h) {
        for (let p = 1; p <= 40; p++)
            if (u(f, p) <= t.getCapacity(p, h, i.MIXED)) return p
    }
    t.from = function(h, p) {
        return s.isValid(h) ? parseInt(h, 10) : p
    }, t.getCapacity = function(h, p, b) {
        if (!s.isValid(h)) throw new Error("Invalid QR Code version");
        typeof b > "u" && (b = i.BYTE);
        const y = e.getSymbolTotalCodewords(h),
            m = n.getTotalCodewordsCount(h, p),
            g = (y - m) * 8;
        if (b === i.MIXED) return g;
        const v = g - c(b, h);
        switch (b) {
            case i.NUMERIC:
                return Math.floor(v / 10 * 3);
            case i.ALPHANUMERIC:
                return Math.floor(v / 11 * 2);
            case i.KANJI:
                return Math.floor(v / 13);
            case i.BYTE:
            default:
                return Math.floor(v / 8)
        }
    }, t.getBestVersionForData = function(h, p) {
        let b;
        const y = r.from(p, r.M);
        if (Array.isArray(h)) {
            if (h.length > 1) return d(h, y);
            if (h.length === 0) return 1;
            b = h[0]
        } else b = h;
        return l(b.mode, b.getLength(), y)
    }, t.getEncodedBits = function(h) {
        if (!s.isValid(h) || h < 7) throw new Error("Invalid QR Code version");
        let p = h << 12;
        for (; e.getBCHDigit(p) - a >= 0;) p ^= o << e.getBCHDigit(p) - a;
        return h << 12 | p
    }
})(uL);
var fL = {};
const q0 = sr,
    hL = 1335,
    Dpe = 21522,
    dP = q0.getBCHDigit(hL);
fL.getEncodedBits = function(e, n) {
    const r = e.bit << 3 | n;
    let i = r << 10;
    for (; q0.getBCHDigit(i) - dP >= 0;) i ^= hL << q0.getBCHDigit(i) - dP;
    return (r << 10 | i) ^ Dpe
};
var pL = {};
const $pe = oo;

function Ol(t) {
    this.mode = $pe.NUMERIC, this.data = t.toString()
}
Ol.getBitsLength = function(e) {
    return 10 * Math.floor(e / 3) + (e % 3 ? e % 3 * 3 + 1 : 0)
};
Ol.prototype.getLength = function() {
    return this.data.length
};
Ol.prototype.getBitsLength = function() {
    return Ol.getBitsLength(this.data.length)
};
Ol.prototype.write = function(e) {
    let n, r, i;
    for (n = 0; n + 3 <= this.data.length; n += 3) r = this.data.substr(n, 3), i = parseInt(r, 10), e.put(i, 10);
    const s = this.data.length - n;
    s > 0 && (r = this.data.substr(n), i = parseInt(r, 10), e.put(i, s * 3 + 1))
};
var Fpe = Ol;
const Lpe = oo,
    iy = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];

function Il(t) {
    this.mode = Lpe.ALPHANUMERIC, this.data = t
}
Il.getBitsLength = function(e) {
    return 11 * Math.floor(e / 2) + 6 * (e % 2)
};
Il.prototype.getLength = function() {
    return this.data.length
};
Il.prototype.getBitsLength = function() {
    return Il.getBitsLength(this.data.length)
};
Il.prototype.write = function(e) {
    let n;
    for (n = 0; n + 2 <= this.data.length; n += 2) {
        let r = iy.indexOf(this.data[n]) * 45;
        r += iy.indexOf(this.data[n + 1]), e.put(r, 11)
    }
    this.data.length % 2 && e.put(iy.indexOf(this.data[n]), 6)
};
var Npe = Il;
const Upe = oo;

function Ml(t) {
    this.mode = Upe.BYTE, typeof t == "string" ? this.data = new TextEncoder().encode(t) : this.data = new Uint8Array(t)
}
Ml.getBitsLength = function(e) {
    return e * 8
};
Ml.prototype.getLength = function() {
    return this.data.length
};
Ml.prototype.getBitsLength = function() {
    return Ml.getBitsLength(this.data.length)
};
Ml.prototype.write = function(t) {
    for (let e = 0, n = this.data.length; e < n; e++) t.put(this.data[e], 8)
};
var Gpe = Ml;
const Hpe = oo,
    zpe = sr;

function Rl(t) {
    this.mode = Hpe.KANJI, this.data = t
}
Rl.getBitsLength = function(e) {
    return e * 13
};
Rl.prototype.getLength = function() {
    return this.data.length
};
Rl.prototype.getBitsLength = function() {
    return Rl.getBitsLength(this.data.length)
};
Rl.prototype.write = function(t) {
    let e;
    for (e = 0; e < this.data.length; e++) {
        let n = zpe.toSJIS(this.data[e]);
        if (n >= 33088 && n <= 40956) n -= 33088;
        else if (n >= 57408 && n <= 60351) n -= 49472;
        else throw new Error("Invalid SJIS character: " + this.data[e] + `
Make sure your charset is UTF-8`);
        n = (n >>> 8 & 255) * 192 + (n & 255), t.put(n, 13)
    }
};
var jpe = Rl,
    mL = {
        exports: {}
    };
(function(t) {
    var e = {
        single_source_shortest_paths: function(n, r, i) {
            var s = {},
                o = {};
            o[r] = 0;
            var a = e.PriorityQueue.make();
            a.push(r, 0);
            for (var l, c, u, d, f, h, p, b, y; !a.empty();) {
                l = a.pop(), c = l.value, d = l.cost, f = n[c] || {};
                for (u in f) f.hasOwnProperty(u) && (h = f[u], p = d + h, b = o[u], y = typeof o[u] > "u", (y || b > p) && (o[u] = p, a.push(u, p), s[u] = c))
            }
            if (typeof i < "u" && typeof o[i] > "u") {
                var m = ["Could not find a path from ", r, " to ", i, "."].join("");
                throw new Error(m)
            }
            return s
        },
        extract_shortest_path_from_predecessor_list: function(n, r) {
            for (var i = [], s = r; s;) i.push(s), n[s], s = n[s];
            return i.reverse(), i
        },
        find_path: function(n, r, i) {
            var s = e.single_source_shortest_paths(n, r, i);
            return e.extract_shortest_path_from_predecessor_list(s, i)
        },
        PriorityQueue: {
            make: function(n) {
                var r = e.PriorityQueue,
                    i = {},
                    s;
                n = n || {};
                for (s in r) r.hasOwnProperty(s) && (i[s] = r[s]);
                return i.queue = [], i.sorter = n.sorter || r.default_sorter, i
            },
            default_sorter: function(n, r) {
                return n.cost - r.cost
            },
            push: function(n, r) {
                var i = {
                    value: n,
                    cost: r
                };
                this.queue.push(i), this.queue.sort(this.sorter)
            },
            pop: function() {
                return this.queue.shift()
            },
            empty: function() {
                return this.queue.length === 0
            }
        }
    };
    t.exports = e
})(mL);
var Vpe = mL.exports;
(function(t) {
    const e = oo,
        n = Fpe,
        r = Npe,
        i = Gpe,
        s = jpe,
        o = yi,
        a = sr,
        l = Vpe;

    function c(m) {
        return unescape(encodeURIComponent(m)).length
    }

    function u(m, g, v) {
        const _ = [];
        let x;
        for (;
            (x = m.exec(v)) !== null;) _.push({
            data: x[0],
            index: x.index,
            mode: g,
            length: x[0].length
        });
        return _
    }

    function d(m) {
        const g = u(o.NUMERIC, e.NUMERIC, m),
            v = u(o.ALPHANUMERIC, e.ALPHANUMERIC, m);
        let _, x;
        return a.isKanjiModeEnabled() ? (_ = u(o.BYTE, e.BYTE, m), x = u(o.KANJI, e.KANJI, m)) : (_ = u(o.BYTE_KANJI, e.BYTE, m), x = []), g.concat(v, _, x).sort(function(E, C) {
            return E.index - C.index
        }).map(function(E) {
            return {
                data: E.data,
                mode: E.mode,
                length: E.length
            }
        })
    }

    function f(m, g) {
        switch (g) {
            case e.NUMERIC:
                return n.getBitsLength(m);
            case e.ALPHANUMERIC:
                return r.getBitsLength(m);
            case e.KANJI:
                return s.getBitsLength(m);
            case e.BYTE:
                return i.getBitsLength(m)
        }
    }

    function h(m) {
        return m.reduce(function(g, v) {
            const _ = g.length - 1 >= 0 ? g[g.length - 1] : null;
            return _ && _.mode === v.mode ? (g[g.length - 1].data += v.data, g) : (g.push(v), g)
        }, [])
    }

    function p(m) {
        const g = [];
        for (let v = 0; v < m.length; v++) {
            const _ = m[v];
            switch (_.mode) {
                case e.NUMERIC:
                    g.push([_, {
                        data: _.data,
                        mode: e.ALPHANUMERIC,
                        length: _.length
                    }, {
                        data: _.data,
                        mode: e.BYTE,
                        length: _.length
                    }]);
                    break;
                case e.ALPHANUMERIC:
                    g.push([_, {
                        data: _.data,
                        mode: e.BYTE,
                        length: _.length
                    }]);
                    break;
                case e.KANJI:
                    g.push([_, {
                        data: _.data,
                        mode: e.BYTE,
                        length: c(_.data)
                    }]);
                    break;
                case e.BYTE:
                    g.push([{
                        data: _.data,
                        mode: e.BYTE,
                        length: c(_.data)
                    }])
            }
        }
        return g
    }

    function b(m, g) {
        const v = {},
            _ = {
                start: {}
            };
        let x = ["start"];
        for (let w = 0; w < m.length; w++) {
            const E = m[w],
                C = [];
            for (let A = 0; A < E.length; A++) {
                const T = E[A],
                    S = "" + w + A;
                C.push(S), v[S] = {
                    node: T,
                    lastCount: 0
                }, _[S] = {};
                for (let P = 0; P < x.length; P++) {
                    const R = x[P];
                    v[R] && v[R].node.mode === T.mode ? (_[R][S] = f(v[R].lastCount + T.length, T.mode) - f(v[R].lastCount, T.mode), v[R].lastCount += T.length) : (v[R] && (v[R].lastCount = T.length), _[R][S] = f(T.length, T.mode) + 4 + e.getCharCountIndicator(T.mode, g))
                }
            }
            x = C
        }
        for (let w = 0; w < x.length; w++) _[x[w]].end = 0;
        return {
            map: _,
            table: v
        }
    }

    function y(m, g) {
        let v;
        const _ = e.getBestModeForData(m);
        if (v = e.from(g, _), v !== e.BYTE && v.bit < _.bit) throw new Error('"' + m + '" cannot be encoded with mode ' + e.toString(v) + `.
 Suggested mode is: ` + e.toString(_));
        switch (v === e.KANJI && !a.isKanjiModeEnabled() && (v = e.BYTE), v) {
            case e.NUMERIC:
                return new n(m);
            case e.ALPHANUMERIC:
                return new r(m);
            case e.KANJI:
                return new s(m);
            case e.BYTE:
                return new i(m)
        }
    }
    t.fromArray = function(g) {
        return g.reduce(function(v, _) {
            return typeof _ == "string" ? v.push(y(_, null)) : _.data && v.push(y(_.data, _.mode)), v
        }, [])
    }, t.fromString = function(g, v) {
        const _ = d(g, a.isKanjiModeEnabled()),
            x = p(_),
            w = b(x, v),
            E = l.find_path(w.map, "start", "end"),
            C = [];
        for (let A = 1; A < E.length - 1; A++) C.push(w.table[E[A]].node);
        return t.fromArray(h(C))
    }, t.rawSplit = function(g) {
        return t.fromArray(d(g, a.isKanjiModeEnabled()))
    }
})(pL);
const mm = sr,
    sy = fm,
    Wpe = Cpe,
    Ype = Ppe,
    Xpe = sL,
    qpe = oL,
    K0 = aL,
    J0 = hm,
    Kpe = Ope,
    Uh = uL,
    Jpe = fL,
    Zpe = oo,
    oy = pL;

function Qpe(t, e) {
    const n = t.size,
        r = qpe.getPositions(e);
    for (let i = 0; i < r.length; i++) {
        const s = r[i][0],
            o = r[i][1];
        for (let a = -1; a <= 7; a++)
            if (!(s + a <= -1 || n <= s + a))
                for (let l = -1; l <= 7; l++) o + l <= -1 || n <= o + l || (a >= 0 && a <= 6 && (l === 0 || l === 6) || l >= 0 && l <= 6 && (a === 0 || a === 6) || a >= 2 && a <= 4 && l >= 2 && l <= 4 ? t.set(s + a, o + l, !0, !0) : t.set(s + a, o + l, !1, !0))
    }
}

function eme(t) {
    const e = t.size;
    for (let n = 8; n < e - 8; n++) {
        const r = n % 2 === 0;
        t.set(n, 6, r, !0), t.set(6, n, r, !0)
    }
}

function tme(t, e) {
    const n = Xpe.getPositions(e);
    for (let r = 0; r < n.length; r++) {
        const i = n[r][0],
            s = n[r][1];
        for (let o = -2; o <= 2; o++)
            for (let a = -2; a <= 2; a++) o === -2 || o === 2 || a === -2 || a === 2 || o === 0 && a === 0 ? t.set(i + o, s + a, !0, !0) : t.set(i + o, s + a, !1, !0)
    }
}

function nme(t, e) {
    const n = t.size,
        r = Uh.getEncodedBits(e);
    let i, s, o;
    for (let a = 0; a < 18; a++) i = Math.floor(a / 3), s = a % 3 + n - 8 - 3, o = (r >> a & 1) === 1, t.set(i, s, o, !0), t.set(s, i, o, !0)
}

function ay(t, e, n) {
    const r = t.size,
        i = Jpe.getEncodedBits(e, n);
    let s, o;
    for (s = 0; s < 15; s++) o = (i >> s & 1) === 1, s < 6 ? t.set(s, 8, o, !0) : s < 8 ? t.set(s + 1, 8, o, !0) : t.set(r - 15 + s, 8, o, !0), s < 8 ? t.set(8, r - s - 1, o, !0) : s < 9 ? t.set(8, 15 - s - 1 + 1, o, !0) : t.set(8, 15 - s - 1, o, !0);
    t.set(r - 8, 8, 1, !0)
}

function rme(t, e) {
    const n = t.size;
    let r = -1,
        i = n - 1,
        s = 7,
        o = 0;
    for (let a = n - 1; a > 0; a -= 2)
        for (a === 6 && a--;;) {
            for (let l = 0; l < 2; l++)
                if (!t.isReserved(i, a - l)) {
                    let c = !1;
                    o < e.length && (c = (e[o] >>> s & 1) === 1), t.set(i, a - l, c), s--, s === -1 && (o++, s = 7)
                }
            if (i += r, i < 0 || n <= i) {
                i -= r, r = -r;
                break
            }
        }
}

function ime(t, e, n) {
    const r = new Wpe;
    n.forEach(function(l) {
        r.put(l.mode.bit, 4), r.put(l.getLength(), Zpe.getCharCountIndicator(l.mode, t)), l.write(r)
    });
    const i = mm.getSymbolTotalCodewords(t),
        s = J0.getTotalCodewordsCount(t, e),
        o = (i - s) * 8;
    for (r.getLengthInBits() + 4 <= o && r.put(0, 4); r.getLengthInBits() % 8 !== 0;) r.putBit(0);
    const a = (o - r.getLengthInBits()) / 8;
    for (let l = 0; l < a; l++) r.put(l % 2 ? 17 : 236, 8);
    return sme(r, t, e)
}

function sme(t, e, n) {
    const r = mm.getSymbolTotalCodewords(e),
        i = J0.getTotalCodewordsCount(e, n),
        s = r - i,
        o = J0.getBlocksCount(e, n),
        a = r % o,
        l = o - a,
        c = Math.floor(r / o),
        u = Math.floor(s / o),
        d = u + 1,
        f = c - u,
        h = new Kpe(f);
    let p = 0;
    const b = new Array(o),
        y = new Array(o);
    let m = 0;
    const g = new Uint8Array(t.buffer);
    for (let E = 0; E < o; E++) {
        const C = E < l ? u : d;
        b[E] = g.slice(p, p + C), y[E] = h.encode(b[E]), p += C, m = Math.max(m, C)
    }
    const v = new Uint8Array(r);
    let _ = 0,
        x, w;
    for (x = 0; x < m; x++)
        for (w = 0; w < o; w++) x < b[w].length && (v[_++] = b[w][x]);
    for (x = 0; x < f; x++)
        for (w = 0; w < o; w++) v[_++] = y[w][x];
    return v
}

function ome(t, e, n, r) {
    let i;
    if (Array.isArray(t)) i = oy.fromArray(t);
    else if (typeof t == "string") {
        let c = e;
        if (!c) {
            const u = oy.rawSplit(t);
            c = Uh.getBestVersionForData(u, n)
        }
        i = oy.fromString(t, c || 40)
    } else throw new Error("Invalid data");
    const s = Uh.getBestVersionForData(i, n);
    if (!s) throw new Error("The amount of data is too big to be stored in a QR Code");
    if (!e) e = s;
    else if (e < s) throw new Error(`
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + s + `.
`);
    const o = ime(e, n, i),
        a = mm.getSymbolSize(e),
        l = new Ype(a);
    return Qpe(l, e), eme(l), tme(l, e), ay(l, n, 0), e >= 7 && nme(l, e), rme(l, o), isNaN(r) && (r = K0.getBestMask(l, ay.bind(null, l, n))), K0.applyMask(r, l), ay(l, n, r), {
        modules: l,
        version: e,
        errorCorrectionLevel: n,
        maskPattern: r,
        segments: i
    }
}
rL.create = function(e, n) {
    if (typeof e > "u" || e === "") throw new Error("No input text");
    let r = sy.M,
        i, s;
    return typeof n < "u" && (r = sy.from(n.errorCorrectionLevel, sy.M), i = Uh.from(n.version), s = K0.from(n.maskPattern), n.toSJISFunc && mm.setToSJISFunction(n.toSJISFunc)), ome(e, i, r, s)
};
var gL = {},
    vw = {};
(function(t) {
    function e(n) {
        if (typeof n == "number" && (n = n.toString()), typeof n != "string") throw new Error("Color should be defined as hex string");
        let r = n.slice().replace("#", "").split("");
        if (r.length < 3 || r.length === 5 || r.length > 8) throw new Error("Invalid hex color: " + n);
        (r.length === 3 || r.length === 4) && (r = Array.prototype.concat.apply([], r.map(function(s) {
            return [s, s]
        }))), r.length === 6 && r.push("F", "F");
        const i = parseInt(r.join(""), 16);
        return {
            r: i >> 24 & 255,
            g: i >> 16 & 255,
            b: i >> 8 & 255,
            a: i & 255,
            hex: "#" + r.slice(0, 6).join("")
        }
    }
    t.getOptions = function(r) {
        r || (r = {}), r.color || (r.color = {});
        const i = typeof r.margin > "u" || r.margin === null || r.margin < 0 ? 4 : r.margin,
            s = r.width && r.width >= 21 ? r.width : void 0,
            o = r.scale || 4;
        return {
            width: s,
            scale: s ? 4 : o,
            margin: i,
            color: {
                dark: e(r.color.dark || "#000000ff"),
                light: e(r.color.light || "#ffffffff")
            },
            type: r.type,
            rendererOpts: r.rendererOpts || {}
        }
    }, t.getScale = function(r, i) {
        return i.width && i.width >= r + i.margin * 2 ? i.width / (r + i.margin * 2) : i.scale
    }, t.getImageWidth = function(r, i) {
        const s = t.getScale(r, i);
        return Math.floor((r + i.margin * 2) * s)
    }, t.qrToImageData = function(r, i, s) {
        const o = i.modules.size,
            a = i.modules.data,
            l = t.getScale(o, s),
            c = Math.floor((o + s.margin * 2) * l),
            u = s.margin * l,
            d = [s.color.light, s.color.dark];
        for (let f = 0; f < c; f++)
            for (let h = 0; h < c; h++) {
                let p = (f * c + h) * 4,
                    b = s.color.light;
                if (f >= u && h >= u && f < c - u && h < c - u) {
                    const y = Math.floor((f - u) / l),
                        m = Math.floor((h - u) / l);
                    b = d[a[y * o + m] ? 1 : 0]
                }
                r[p++] = b.r, r[p++] = b.g, r[p++] = b.b, r[p] = b.a
            }
    }
})(vw);
(function(t) {
    const e = vw;

    function n(i, s, o) {
        i.clearRect(0, 0, s.width, s.height), s.style || (s.style = {}), s.height = o, s.width = o, s.style.height = o + "px", s.style.width = o + "px"
    }

    function r() {
        try {
            return document.createElement("canvas")
        } catch {
            throw new Error("You need to specify a canvas element")
        }
    }
    t.render = function(s, o, a) {
        let l = a,
            c = o;
        typeof l > "u" && (!o || !o.getContext) && (l = o, o = void 0), o || (c = r()), l = e.getOptions(l);
        const u = e.getImageWidth(s.modules.size, l),
            d = c.getContext("2d"),
            f = d.createImageData(u, u);
        return e.qrToImageData(f.data, s, l), n(d, c, u), d.putImageData(f, 0, 0), c
    }, t.renderToDataURL = function(s, o, a) {
        let l = a;
        typeof l > "u" && (!o || !o.getContext) && (l = o, o = void 0), l || (l = {});
        const c = t.render(s, o, l),
            u = l.type || "image/png",
            d = l.rendererOpts || {};
        return c.toDataURL(u, d.quality)
    }
})(gL);
var yL = {};
const ame = vw;

function fP(t, e) {
    const n = t.a / 255,
        r = e + '="' + t.hex + '"';
    return n < 1 ? r + " " + e + '-opacity="' + n.toFixed(2).slice(1) + '"' : r
}

function ly(t, e, n) {
    let r = t + e;
    return typeof n < "u" && (r += " " + n), r
}

function lme(t, e, n) {
    let r = "",
        i = 0,
        s = !1,
        o = 0;
    for (let a = 0; a < t.length; a++) {
        const l = Math.floor(a % e),
            c = Math.floor(a / e);
        !l && !s && (s = !0), t[a] ? (o++, a > 0 && l > 0 && t[a - 1] || (r += s ? ly("M", l + n, .5 + c + n) : ly("m", i, 0), i = 0, s = !1), l + 1 < e && t[a + 1] || (r += ly("h", o), o = 0)) : i++
    }
    return r
}
yL.render = function(e, n, r) {
    const i = ame.getOptions(n),
        s = e.modules.size,
        o = e.modules.data,
        a = s + i.margin * 2,
        l = i.color.light.a ? "<path " + fP(i.color.light, "fill") + ' d="M0 0h' + a + "v" + a + 'H0z"/>' : "",
        c = "<path " + fP(i.color.dark, "stroke") + ' d="' + lme(o, s, i.margin) + '"/>',
        u = 'viewBox="0 0 ' + a + " " + a + '"',
        f = '<svg xmlns="http://www.w3.org/2000/svg" ' + (i.width ? 'width="' + i.width + '" height="' + i.width + '" ' : "") + u + ' shape-rendering="crispEdges">' + l + c + `</svg>
`;
    return typeof r == "function" && r(null, f), f
};
const cme = Spe,
    Z0 = rL,
    vL = gL,
    ume = yL;

function _w(t, e, n, r, i) {
    const s = [].slice.call(arguments, 1),
        o = s.length,
        a = typeof s[o - 1] == "function";
    if (!a && !cme()) throw new Error("Callback required as last argument");
    if (a) {
        if (o < 2) throw new Error("Too few arguments provided");
        o === 2 ? (i = n, n = e, e = r = void 0) : o === 3 && (e.getContext && typeof i > "u" ? (i = r, r = void 0) : (i = r, r = n, n = e, e = void 0))
    } else {
        if (o < 1) throw new Error("Too few arguments provided");
        return o === 1 ? (n = e, e = r = void 0) : o === 2 && !e.getContext && (r = n, n = e, e = void 0), new Promise(function(l, c) {
            try {
                const u = Z0.create(n, r);
                l(t(u, e, r))
            } catch (u) {
                c(u)
            }
        })
    }
    try {
        const l = Z0.create(n, r);
        i(null, t(l, e, r))
    } catch (l) {
        i(l)
    }
}
_d.create = Z0.create;
_d.toCanvas = _w.bind(null, vL.render);
_d.toDataURL = _w.bind(null, vL.renderToDataURL);
_d.toString = _w.bind(null, function(t, e, n) {
    return ume.render(t, n)
});

function Pwe(t, e) {
    const n = XR(t),
        r = q("");
    return he(n, async i => {
        n.value && Ws && (r.value = await _d.toDataURL(i, e))
    }, {
        immediate: !0
    }), r
}

function hP(t) {
    return t !== null && typeof t == "object" && "constructor" in t && t.constructor === Object
}

function bw(t = {}, e = {}) {
    Object.keys(e).forEach(n => {
        typeof t[n] > "u" ? t[n] = e[n] : hP(e[n]) && hP(t[n]) && Object.keys(e[n]).length > 0 && bw(t[n], e[n])
    })
}
const _L = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
        blur() {},
        nodeName: ""
    },
    querySelector() {
        return null
    },
    querySelectorAll() {
        return []
    },
    getElementById() {
        return null
    },
    createEvent() {
        return {
            initEvent() {}
        }
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName() {
                return []
            }
        }
    },
    createElementNS() {
        return {}
    },
    importNode() {
        return null
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};

function hn() {
    const t = typeof document < "u" ? document : {};
    return bw(t, _L), t
}
const dme = {
    document: _L,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {}
    },
    CustomEvent: function() {
        return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle() {
        return {
            getPropertyValue() {
                return ""
            }
        }
    },
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia() {
        return {}
    },
    requestAnimationFrame(t) {
        return typeof setTimeout > "u" ? (t(), null) : setTimeout(t, 0)
    },
    cancelAnimationFrame(t) {
        typeof setTimeout > "u" || clearTimeout(t)
    }
};

function Qt() {
    const t = typeof window < "u" ? window : {};
    return bw(t, dme), t
}

function fme(t) {
    const e = t.__proto__;
    Object.defineProperty(t, "__proto__", {
        get() {
            return e
        },
        set(n) {
            e.__proto__ = n
        }
    })
}
class As extends Array {
    constructor(e) {
        typeof e == "number" ? super(e) : (super(...e || []), fme(this))
    }
}

function xd(t = []) {
    const e = [];
    return t.forEach(n => {
        Array.isArray(n) ? e.push(...xd(n)) : e.push(n)
    }), e
}

function bL(t, e) {
    return Array.prototype.filter.call(t, e)
}

function hme(t) {
    const e = [];
    for (let n = 0; n < t.length; n += 1) e.indexOf(t[n]) === -1 && e.push(t[n]);
    return e
}

function pme(t, e) {
    if (typeof t != "string") return [t];
    const n = [],
        r = e.querySelectorAll(t);
    for (let i = 0; i < r.length; i += 1) n.push(r[i]);
    return n
}

function Se(t, e) {
    const n = Qt(),
        r = hn();
    let i = [];
    if (!e && t instanceof As) return t;
    if (!t) return new As(i);
    if (typeof t == "string") {
        const s = t.trim();
        if (s.indexOf("<") >= 0 && s.indexOf(">") >= 0) {
            let o = "div";
            s.indexOf("<li") === 0 && (o = "ul"), s.indexOf("<tr") === 0 && (o = "tbody"), (s.indexOf("<td") === 0 || s.indexOf("<th") === 0) && (o = "tr"), s.indexOf("<tbody") === 0 && (o = "table"), s.indexOf("<option") === 0 && (o = "select");
            const a = r.createElement(o);
            a.innerHTML = s;
            for (let l = 0; l < a.childNodes.length; l += 1) i.push(a.childNodes[l])
        } else i = pme(t.trim(), e || r)
    } else if (t.nodeType || t === n || t === r) i.push(t);
    else if (Array.isArray(t)) {
        if (t instanceof As) return t;
        i = t
    }
    return new As(hme(i))
}
Se.fn = As.prototype;

function mme(...t) {
    const e = xd(t.map(n => n.split(" ")));
    return this.forEach(n => {
        n.classList.add(...e)
    }), this
}

function gme(...t) {
    const e = xd(t.map(n => n.split(" ")));
    return this.forEach(n => {
        n.classList.remove(...e)
    }), this
}

function yme(...t) {
    const e = xd(t.map(n => n.split(" ")));
    this.forEach(n => {
        e.forEach(r => {
            n.classList.toggle(r)
        })
    })
}

function vme(...t) {
    const e = xd(t.map(n => n.split(" ")));
    return bL(this, n => e.filter(r => n.classList.contains(r)).length > 0).length > 0
}

function _me(t, e) {
    if (arguments.length === 1 && typeof t == "string") return this[0] ? this[0].getAttribute(t) : void 0;
    for (let n = 0; n < this.length; n += 1)
        if (arguments.length === 2) this[n].setAttribute(t, e);
        else
            for (const r in t) this[n][r] = t[r], this[n].setAttribute(r, t[r]);
    return this
}

function bme(t) {
    for (let e = 0; e < this.length; e += 1) this[e].removeAttribute(t);
    return this
}

function xme(t) {
    for (let e = 0; e < this.length; e += 1) this[e].style.transform = t;
    return this
}

function wme(t) {
    for (let e = 0; e < this.length; e += 1) this[e].style.transitionDuration = typeof t != "string" ? `${t}ms` : t;
    return this
}

function Eme(...t) {
    let [e, n, r, i] = t;
    typeof t[1] == "function" && ([e, r, i] = t, n = void 0), i || (i = !1);

    function s(c) {
        const u = c.target;
        if (!u) return;
        const d = c.target.dom7EventData || [];
        if (d.indexOf(c) < 0 && d.unshift(c), Se(u).is(n)) r.apply(u, d);
        else {
            const f = Se(u).parents();
            for (let h = 0; h < f.length; h += 1) Se(f[h]).is(n) && r.apply(f[h], d)
        }
    }

    function o(c) {
        const u = c && c.target ? c.target.dom7EventData || [] : [];
        u.indexOf(c) < 0 && u.unshift(c), r.apply(this, u)
    }
    const a = e.split(" ");
    let l;
    for (let c = 0; c < this.length; c += 1) {
        const u = this[c];
        if (n)
            for (l = 0; l < a.length; l += 1) {
                const d = a[l];
                u.dom7LiveListeners || (u.dom7LiveListeners = {}), u.dom7LiveListeners[d] || (u.dom7LiveListeners[d] = []), u.dom7LiveListeners[d].push({
                    listener: r,
                    proxyListener: s
                }), u.addEventListener(d, s, i)
            } else
                for (l = 0; l < a.length; l += 1) {
                    const d = a[l];
                    u.dom7Listeners || (u.dom7Listeners = {}), u.dom7Listeners[d] || (u.dom7Listeners[d] = []), u.dom7Listeners[d].push({
                        listener: r,
                        proxyListener: o
                    }), u.addEventListener(d, o, i)
                }
    }
    return this
}

function Sme(...t) {
    let [e, n, r, i] = t;
    typeof t[1] == "function" && ([e, r, i] = t, n = void 0), i || (i = !1);
    const s = e.split(" ");
    for (let o = 0; o < s.length; o += 1) {
        const a = s[o];
        for (let l = 0; l < this.length; l += 1) {
            const c = this[l];
            let u;
            if (!n && c.dom7Listeners ? u = c.dom7Listeners[a] : n && c.dom7LiveListeners && (u = c.dom7LiveListeners[a]), u && u.length)
                for (let d = u.length - 1; d >= 0; d -= 1) {
                    const f = u[d];
                    r && f.listener === r || r && f.listener && f.listener.dom7proxy && f.listener.dom7proxy === r ? (c.removeEventListener(a, f.proxyListener, i), u.splice(d, 1)) : r || (c.removeEventListener(a, f.proxyListener, i), u.splice(d, 1))
                }
        }
    }
    return this
}

function Tme(...t) {
    const e = Qt(),
        n = t[0].split(" "),
        r = t[1];
    for (let i = 0; i < n.length; i += 1) {
        const s = n[i];
        for (let o = 0; o < this.length; o += 1) {
            const a = this[o];
            if (e.CustomEvent) {
                const l = new e.CustomEvent(s, {
                    detail: r,
                    bubbles: !0,
                    cancelable: !0
                });
                a.dom7EventData = t.filter((c, u) => u > 0), a.dispatchEvent(l), a.dom7EventData = [], delete a.dom7EventData
            }
        }
    }
    return this
}

function Cme(t) {
    const e = this;

    function n(r) {
        r.target === this && (t.call(this, r), e.off("transitionend", n))
    }
    return t && e.on("transitionend", n), this
}

function Pme(t) {
    if (this.length > 0) {
        if (t) {
            const e = this.styles();
            return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left"))
        }
        return this[0].offsetWidth
    }
    return null
}

function Ame(t) {
    if (this.length > 0) {
        if (t) {
            const e = this.styles();
            return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom"))
        }
        return this[0].offsetHeight
    }
    return null
}

function Ome() {
    if (this.length > 0) {
        const t = Qt(),
            e = hn(),
            n = this[0],
            r = n.getBoundingClientRect(),
            i = e.body,
            s = n.clientTop || i.clientTop || 0,
            o = n.clientLeft || i.clientLeft || 0,
            a = n === t ? t.scrollY : n.scrollTop,
            l = n === t ? t.scrollX : n.scrollLeft;
        return {
            top: r.top + a - s,
            left: r.left + l - o
        }
    }
    return null
}

function Ime() {
    const t = Qt();
    return this[0] ? t.getComputedStyle(this[0], null) : {}
}

function Mme(t, e) {
    const n = Qt();
    let r;
    if (arguments.length === 1)
        if (typeof t == "string") {
            if (this[0]) return n.getComputedStyle(this[0], null).getPropertyValue(t)
        } else {
            for (r = 0; r < this.length; r += 1)
                for (const i in t) this[r].style[i] = t[i];
            return this
        }
    if (arguments.length === 2 && typeof t == "string") {
        for (r = 0; r < this.length; r += 1) this[r].style[t] = e;
        return this
    }
    return this
}

function Rme(t) {
    return t ? (this.forEach((e, n) => {
        t.apply(e, [e, n])
    }), this) : this
}

function kme(t) {
    const e = bL(this, t);
    return Se(e)
}

function Bme(t) {
    if (typeof t > "u") return this[0] ? this[0].innerHTML : null;
    for (let e = 0; e < this.length; e += 1) this[e].innerHTML = t;
    return this
}

function Dme(t) {
    if (typeof t > "u") return this[0] ? this[0].textContent.trim() : null;
    for (let e = 0; e < this.length; e += 1) this[e].textContent = t;
    return this
}

function $me(t) {
    const e = Qt(),
        n = hn(),
        r = this[0];
    let i, s;
    if (!r || typeof t > "u") return !1;
    if (typeof t == "string") {
        if (r.matches) return r.matches(t);
        if (r.webkitMatchesSelector) return r.webkitMatchesSelector(t);
        if (r.msMatchesSelector) return r.msMatchesSelector(t);
        for (i = Se(t), s = 0; s < i.length; s += 1)
            if (i[s] === r) return !0;
        return !1
    }
    if (t === n) return r === n;
    if (t === e) return r === e;
    if (t.nodeType || t instanceof As) {
        for (i = t.nodeType ? [t] : t, s = 0; s < i.length; s += 1)
            if (i[s] === r) return !0;
        return !1
    }
    return !1
}

function Fme() {
    let t = this[0],
        e;
    if (t) {
        for (e = 0;
            (t = t.previousSibling) !== null;) t.nodeType === 1 && (e += 1);
        return e
    }
}

function Lme(t) {
    if (typeof t > "u") return this;
    const e = this.length;
    if (t > e - 1) return Se([]);
    if (t < 0) {
        const n = e + t;
        return n < 0 ? Se([]) : Se([this[n]])
    }
    return Se([this[t]])
}

function Nme(...t) {
    let e;
    const n = hn();
    for (let r = 0; r < t.length; r += 1) {
        e = t[r];
        for (let i = 0; i < this.length; i += 1)
            if (typeof e == "string") {
                const s = n.createElement("div");
                for (s.innerHTML = e; s.firstChild;) this[i].appendChild(s.firstChild)
            } else if (e instanceof As)
            for (let s = 0; s < e.length; s += 1) this[i].appendChild(e[s]);
        else this[i].appendChild(e)
    }
    return this
}

function Ume(t) {
    const e = hn();
    let n, r;
    for (n = 0; n < this.length; n += 1)
        if (typeof t == "string") {
            const i = e.createElement("div");
            for (i.innerHTML = t, r = i.childNodes.length - 1; r >= 0; r -= 1) this[n].insertBefore(i.childNodes[r], this[n].childNodes[0])
        } else if (t instanceof As)
        for (r = 0; r < t.length; r += 1) this[n].insertBefore(t[r], this[n].childNodes[0]);
    else this[n].insertBefore(t, this[n].childNodes[0]);
    return this
}

function Gme(t) {
    return this.length > 0 ? t ? this[0].nextElementSibling && Se(this[0].nextElementSibling).is(t) ? Se([this[0].nextElementSibling]) : Se([]) : this[0].nextElementSibling ? Se([this[0].nextElementSibling]) : Se([]) : Se([])
}

function Hme(t) {
    const e = [];
    let n = this[0];
    if (!n) return Se([]);
    for (; n.nextElementSibling;) {
        const r = n.nextElementSibling;
        t ? Se(r).is(t) && e.push(r) : e.push(r), n = r
    }
    return Se(e)
}

function zme(t) {
    if (this.length > 0) {
        const e = this[0];
        return t ? e.previousElementSibling && Se(e.previousElementSibling).is(t) ? Se([e.previousElementSibling]) : Se([]) : e.previousElementSibling ? Se([e.previousElementSibling]) : Se([])
    }
    return Se([])
}

function jme(t) {
    const e = [];
    let n = this[0];
    if (!n) return Se([]);
    for (; n.previousElementSibling;) {
        const r = n.previousElementSibling;
        t ? Se(r).is(t) && e.push(r) : e.push(r), n = r
    }
    return Se(e)
}

function Vme(t) {
    const e = [];
    for (let n = 0; n < this.length; n += 1) this[n].parentNode !== null && (t ? Se(this[n].parentNode).is(t) && e.push(this[n].parentNode) : e.push(this[n].parentNode));
    return Se(e)
}

function Wme(t) {
    const e = [];
    for (let n = 0; n < this.length; n += 1) {
        let r = this[n].parentNode;
        for (; r;) t ? Se(r).is(t) && e.push(r) : e.push(r), r = r.parentNode
    }
    return Se(e)
}

function Yme(t) {
    let e = this;
    return typeof t > "u" ? Se([]) : (e.is(t) || (e = e.parents(t).eq(0)), e)
}

function Xme(t) {
    const e = [];
    for (let n = 0; n < this.length; n += 1) {
        const r = this[n].querySelectorAll(t);
        for (let i = 0; i < r.length; i += 1) e.push(r[i])
    }
    return Se(e)
}

function qme(t) {
    const e = [];
    for (let n = 0; n < this.length; n += 1) {
        const r = this[n].children;
        for (let i = 0; i < r.length; i += 1)(!t || Se(r[i]).is(t)) && e.push(r[i])
    }
    return Se(e)
}

function Kme() {
    for (let t = 0; t < this.length; t += 1) this[t].parentNode && this[t].parentNode.removeChild(this[t]);
    return this
}
const pP = {
    addClass: mme,
    removeClass: gme,
    hasClass: vme,
    toggleClass: yme,
    attr: _me,
    removeAttr: bme,
    transform: xme,
    transition: wme,
    on: Eme,
    off: Sme,
    trigger: Tme,
    transitionEnd: Cme,
    outerWidth: Pme,
    outerHeight: Ame,
    styles: Ime,
    offset: Ome,
    css: Mme,
    each: Rme,
    html: Bme,
    text: Dme,
    is: $me,
    index: Fme,
    eq: Lme,
    append: Nme,
    prepend: Ume,
    next: Gme,
    nextAll: Hme,
    prev: zme,
    prevAll: jme,
    parent: Vme,
    parents: Wme,
    closest: Yme,
    find: Xme,
    children: qme,
    filter: kme,
    remove: Kme
};
Object.keys(pP).forEach(t => {
    Object.defineProperty(Se.fn, t, {
        value: pP[t],
        writable: !0
    })
});

function Jme(t) {
    const e = t;
    Object.keys(e).forEach(n => {
        try {
            e[n] = null
        } catch {}
        try {
            delete e[n]
        } catch {}
    })
}

function Gh(t, e = 0) {
    return setTimeout(t, e)
}

function Nu() {
    return Date.now()
}

function Zme(t) {
    const e = Qt();
    let n;
    return e.getComputedStyle && (n = e.getComputedStyle(t, null)), !n && t.currentStyle && (n = t.currentStyle), n || (n = t.style), n
}

function Qme(t, e = "x") {
    const n = Qt();
    let r, i, s;
    const o = Zme(t);
    return n.WebKitCSSMatrix ? (i = o.transform || o.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map(a => a.replace(",", ".")).join(", ")), s = new n.WebKitCSSMatrix(i === "none" ? "" : i)) : (s = o.MozTransform || o.OTransform || o.MsTransform || o.msTransform || o.transform || o.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), r = s.toString().split(",")), e === "x" && (n.WebKitCSSMatrix ? i = s.m41 : r.length === 16 ? i = parseFloat(r[12]) : i = parseFloat(r[4])), e === "y" && (n.WebKitCSSMatrix ? i = s.m42 : r.length === 16 ? i = parseFloat(r[13]) : i = parseFloat(r[5])), i || 0
}

function Pf(t) {
    return typeof t == "object" && t !== null && t.constructor && Object.prototype.toString.call(t).slice(8, -1) === "Object"
}

function ege(t) {
    return typeof window < "u" && typeof window.HTMLElement < "u" ? t instanceof HTMLElement : t && (t.nodeType === 1 || t.nodeType === 11)
}

function Wn(...t) {
    const e = Object(t[0]),
        n = ["__proto__", "constructor", "prototype"];
    for (let r = 1; r < t.length; r += 1) {
        const i = t[r];
        if (i != null && !ege(i)) {
            const s = Object.keys(Object(i)).filter(o => n.indexOf(o) < 0);
            for (let o = 0, a = s.length; o < a; o += 1) {
                const l = s[o],
                    c = Object.getOwnPropertyDescriptor(i, l);
                c !== void 0 && c.enumerable && (Pf(e[l]) && Pf(i[l]) ? i[l].__swiper__ ? e[l] = i[l] : Wn(e[l], i[l]) : !Pf(e[l]) && Pf(i[l]) ? (e[l] = {}, i[l].__swiper__ ? e[l] = i[l] : Wn(e[l], i[l])) : e[l] = i[l])
            }
        }
    }
    return e
}

function Af(t, e, n) {
    t.style.setProperty(e, n)
}

function xL({
    swiper: t,
    targetPosition: e,
    side: n
}) {
    const r = Qt(),
        i = -t.translate;
    let s = null,
        o;
    const a = t.params.speed;
    t.wrapperEl.style.scrollSnapType = "none", r.cancelAnimationFrame(t.cssModeFrameID);
    const l = e > i ? "next" : "prev",
        c = (d, f) => l === "next" && d >= f || l === "prev" && d <= f,
        u = () => {
            o = new Date().getTime(), s === null && (s = o);
            const d = Math.max(Math.min((o - s) / a, 1), 0),
                f = .5 - Math.cos(d * Math.PI) / 2;
            let h = i + f * (e - i);
            if (c(h, e) && (h = e), t.wrapperEl.scrollTo({
                    [n]: h
                }), c(h, e)) {
                t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
                    t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({
                        [n]: h
                    })
                }), r.cancelAnimationFrame(t.cssModeFrameID);
                return
            }
            t.cssModeFrameID = r.requestAnimationFrame(u)
        };
    u()
}
let cy;

function tge() {
    const t = Qt(),
        e = hn();
    return {
        smoothScroll: e.documentElement && "scrollBehavior" in e.documentElement.style,
        touch: !!("ontouchstart" in t || t.DocumentTouch && e instanceof t.DocumentTouch),
        passiveListener: function() {
            let r = !1;
            try {
                const i = Object.defineProperty({}, "passive", {
                    get() {
                        r = !0
                    }
                });
                t.addEventListener("testPassiveListener", null, i)
            } catch {}
            return r
        }(),
        gestures: function() {
            return "ongesturestart" in t
        }()
    }
}

function wL() {
    return cy || (cy = tge()), cy
}
let uy;

function nge({
    userAgent: t
} = {}) {
    const e = wL(),
        n = Qt(),
        r = n.navigator.platform,
        i = t || n.navigator.userAgent,
        s = {
            ios: !1,
            android: !1
        },
        o = n.screen.width,
        a = n.screen.height,
        l = i.match(/(Android);?[\s\/]+([\d.]+)?/);
    let c = i.match(/(iPad).*OS\s([\d_]+)/);
    const u = i.match(/(iPod)(.*OS\s([\d_]+))?/),
        d = !c && i.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
        f = r === "Win32";
    let h = r === "MacIntel";
    const p = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    return !c && h && e.touch && p.indexOf(`${o}x${a}`) >= 0 && (c = i.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), h = !1), l && !f && (s.os = "android", s.android = !0), (c || d || u) && (s.os = "ios", s.ios = !0), s
}

function rge(t = {}) {
    return uy || (uy = nge(t)), uy
}
let dy;

function ige() {
    const t = Qt();

    function e() {
        const n = t.navigator.userAgent.toLowerCase();
        return n.indexOf("safari") >= 0 && n.indexOf("chrome") < 0 && n.indexOf("android") < 0
    }
    return {
        isSafari: e(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent)
    }
}

function sge() {
    return dy || (dy = ige()), dy
}

function oge({
    swiper: t,
    on: e,
    emit: n
}) {
    const r = Qt();
    let i = null,
        s = null;
    const o = () => {
            !t || t.destroyed || !t.initialized || (n("beforeResize"), n("resize"))
        },
        a = () => {
            !t || t.destroyed || !t.initialized || (i = new ResizeObserver(u => {
                s = r.requestAnimationFrame(() => {
                    const {
                        width: d,
                        height: f
                    } = t;
                    let h = d,
                        p = f;
                    u.forEach(({
                        contentBoxSize: b,
                        contentRect: y,
                        target: m
                    }) => {
                        m && m !== t.el || (h = y ? y.width : (b[0] || b).inlineSize, p = y ? y.height : (b[0] || b).blockSize)
                    }), (h !== d || p !== f) && o()
                })
            }), i.observe(t.el))
        },
        l = () => {
            s && r.cancelAnimationFrame(s), i && i.unobserve && t.el && (i.unobserve(t.el), i = null)
        },
        c = () => {
            !t || t.destroyed || !t.initialized || n("orientationchange")
        };
    e("init", () => {
        if (t.params.resizeObserver && typeof r.ResizeObserver < "u") {
            a();
            return
        }
        r.addEventListener("resize", o), r.addEventListener("orientationchange", c)
    }), e("destroy", () => {
        l(), r.removeEventListener("resize", o), r.removeEventListener("orientationchange", c)
    })
}

function age({
    swiper: t,
    extendParams: e,
    on: n,
    emit: r
}) {
    const i = [],
        s = Qt(),
        o = (c, u = {}) => {
            const d = s.MutationObserver || s.WebkitMutationObserver,
                f = new d(h => {
                    if (h.length === 1) {
                        r("observerUpdate", h[0]);
                        return
                    }
                    const p = function() {
                        r("observerUpdate", h[0])
                    };
                    s.requestAnimationFrame ? s.requestAnimationFrame(p) : s.setTimeout(p, 0)
                });
            f.observe(c, {
                attributes: typeof u.attributes > "u" ? !0 : u.attributes,
                childList: typeof u.childList > "u" ? !0 : u.childList,
                characterData: typeof u.characterData > "u" ? !0 : u.characterData
            }), i.push(f)
        },
        a = () => {
            if (t.params.observer) {
                if (t.params.observeParents) {
                    const c = t.$el.parents();
                    for (let u = 0; u < c.length; u += 1) o(c[u])
                }
                o(t.$el[0], {
                    childList: t.params.observeSlideChildren
                }), o(t.$wrapperEl[0], {
                    attributes: !1
                })
            }
        },
        l = () => {
            i.forEach(c => {
                c.disconnect()
            }), i.splice(0, i.length)
        };
    e({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }), n("init", a), n("destroy", l)
}
const lge = {
    on(t, e, n) {
        const r = this;
        if (!r.eventsListeners || r.destroyed || typeof e != "function") return r;
        const i = n ? "unshift" : "push";
        return t.split(" ").forEach(s => {
            r.eventsListeners[s] || (r.eventsListeners[s] = []), r.eventsListeners[s][i](e)
        }), r
    },
    once(t, e, n) {
        const r = this;
        if (!r.eventsListeners || r.destroyed || typeof e != "function") return r;

        function i(...s) {
            r.off(t, i), i.__emitterProxy && delete i.__emitterProxy, e.apply(r, s)
        }
        return i.__emitterProxy = e, r.on(t, i, n)
    },
    onAny(t, e) {
        const n = this;
        if (!n.eventsListeners || n.destroyed || typeof t != "function") return n;
        const r = e ? "unshift" : "push";
        return n.eventsAnyListeners.indexOf(t) < 0 && n.eventsAnyListeners[r](t), n
    },
    offAny(t) {
        const e = this;
        if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e;
        const n = e.eventsAnyListeners.indexOf(t);
        return n >= 0 && e.eventsAnyListeners.splice(n, 1), e
    },
    off(t, e) {
        const n = this;
        return !n.eventsListeners || n.destroyed || !n.eventsListeners || t.split(" ").forEach(r => {
            typeof e > "u" ? n.eventsListeners[r] = [] : n.eventsListeners[r] && n.eventsListeners[r].forEach((i, s) => {
                (i === e || i.__emitterProxy && i.__emitterProxy === e) && n.eventsListeners[r].splice(s, 1)
            })
        }), n
    },
    emit(...t) {
        const e = this;
        if (!e.eventsListeners || e.destroyed || !e.eventsListeners) return e;
        let n, r, i;
        return typeof t[0] == "string" || Array.isArray(t[0]) ? (n = t[0], r = t.slice(1, t.length), i = e) : (n = t[0].events, r = t[0].data, i = t[0].context || e), r.unshift(i), (Array.isArray(n) ? n : n.split(" ")).forEach(o => {
            e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach(a => {
                a.apply(i, [o, ...r])
            }), e.eventsListeners && e.eventsListeners[o] && e.eventsListeners[o].forEach(a => {
                a.apply(i, r)
            })
        }), e
    }
};

function cge() {
    const t = this;
    let e, n;
    const r = t.$el;
    typeof t.params.width < "u" && t.params.width !== null ? e = t.params.width : e = r[0].clientWidth, typeof t.params.height < "u" && t.params.height !== null ? n = t.params.height : n = r[0].clientHeight, !(e === 0 && t.isHorizontal() || n === 0 && t.isVertical()) && (e = e - parseInt(r.css("padding-left") || 0, 10) - parseInt(r.css("padding-right") || 0, 10), n = n - parseInt(r.css("padding-top") || 0, 10) - parseInt(r.css("padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(n) && (n = 0), Object.assign(t, {
        width: e,
        height: n,
        size: t.isHorizontal() ? e : n
    }))
}

function uge() {
    const t = this;

    function e(T) {
        return t.isHorizontal() ? T : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[T]
    }

    function n(T, S) {
        return parseFloat(T.getPropertyValue(e(S)) || 0)
    }
    const r = t.params,
        {
            $wrapperEl: i,
            size: s,
            rtlTranslate: o,
            wrongRTL: a
        } = t,
        l = t.virtual && r.virtual.enabled,
        c = l ? t.virtual.slides.length : t.slides.length,
        u = i.children(`.${t.params.slideClass}`),
        d = l ? t.virtual.slides.length : u.length;
    let f = [];
    const h = [],
        p = [];
    let b = r.slidesOffsetBefore;
    typeof b == "function" && (b = r.slidesOffsetBefore.call(t));
    let y = r.slidesOffsetAfter;
    typeof y == "function" && (y = r.slidesOffsetAfter.call(t));
    const m = t.snapGrid.length,
        g = t.slidesGrid.length;
    let v = r.spaceBetween,
        _ = -b,
        x = 0,
        w = 0;
    if (typeof s > "u") return;
    typeof v == "string" && v.indexOf("%") >= 0 && (v = parseFloat(v.replace("%", "")) / 100 * s), t.virtualSize = -v, o ? u.css({
        marginLeft: "",
        marginBottom: "",
        marginTop: ""
    }) : u.css({
        marginRight: "",
        marginBottom: "",
        marginTop: ""
    }), r.centeredSlides && r.cssMode && (Af(t.wrapperEl, "--swiper-centered-offset-before", ""), Af(t.wrapperEl, "--swiper-centered-offset-after", ""));
    const E = r.grid && r.grid.rows > 1 && t.grid;
    E && t.grid.initSlides(d);
    let C;
    const A = r.slidesPerView === "auto" && r.breakpoints && Object.keys(r.breakpoints).filter(T => typeof r.breakpoints[T].slidesPerView < "u").length > 0;
    for (let T = 0; T < d; T += 1) {
        C = 0;
        const S = u.eq(T);
        if (E && t.grid.updateSlide(T, S, d, e), S.css("display") !== "none") {
            if (r.slidesPerView === "auto") {
                A && (u[T].style[e("width")] = "");
                const P = getComputedStyle(S[0]),
                    R = S[0].style.transform,
                    D = S[0].style.webkitTransform;
                if (R && (S[0].style.transform = "none"), D && (S[0].style.webkitTransform = "none"), r.roundLengths) C = t.isHorizontal() ? S.outerWidth(!0) : S.outerHeight(!0);
                else {
                    const H = n(P, "width"),
                        B = n(P, "padding-left"),
                        N = n(P, "padding-right"),
                        V = n(P, "margin-left"),
                        Y = n(P, "margin-right"),
                        le = P.getPropertyValue("box-sizing");
                    if (le && le === "border-box") C = H + V + Y;
                    else {
                        const {
                            clientWidth: ae,
                            offsetWidth: W
                        } = S[0];
                        C = H + B + N + V + Y + (W - ae)
                    }
                }
                R && (S[0].style.transform = R), D && (S[0].style.webkitTransform = D), r.roundLengths && (C = Math.floor(C))
            } else C = (s - (r.slidesPerView - 1) * v) / r.slidesPerView, r.roundLengths && (C = Math.floor(C)), u[T] && (u[T].style[e("width")] = `${C}px`);
            u[T] && (u[T].swiperSlideSize = C), p.push(C), r.centeredSlides ? (_ = _ + C / 2 + x / 2 + v, x === 0 && T !== 0 && (_ = _ - s / 2 - v), T === 0 && (_ = _ - s / 2 - v), Math.abs(_) < 1 / 1e3 && (_ = 0), r.roundLengths && (_ = Math.floor(_)), w % r.slidesPerGroup === 0 && f.push(_), h.push(_)) : (r.roundLengths && (_ = Math.floor(_)), (w - Math.min(t.params.slidesPerGroupSkip, w)) % t.params.slidesPerGroup === 0 && f.push(_), h.push(_), _ = _ + C + v), t.virtualSize += C + v, x = C, w += 1
        }
    }
    if (t.virtualSize = Math.max(t.virtualSize, s) + y, o && a && (r.effect === "slide" || r.effect === "coverflow") && i.css({
            width: `${t.virtualSize+r.spaceBetween}px`
        }), r.setWrapperSize && i.css({
            [e("width")]: `${t.virtualSize+r.spaceBetween}px`
        }), E && t.grid.updateWrapperSize(C, f, e), !r.centeredSlides) {
        const T = [];
        for (let S = 0; S < f.length; S += 1) {
            let P = f[S];
            r.roundLengths && (P = Math.floor(P)), f[S] <= t.virtualSize - s && T.push(P)
        }
        f = T, Math.floor(t.virtualSize - s) - Math.floor(f[f.length - 1]) > 1 && f.push(t.virtualSize - s)
    }
    if (f.length === 0 && (f = [0]), r.spaceBetween !== 0) {
        const T = t.isHorizontal() && o ? "marginLeft" : e("marginRight");
        u.filter((S, P) => r.cssMode ? P !== u.length - 1 : !0).css({
            [T]: `${v}px`
        })
    }
    if (r.centeredSlides && r.centeredSlidesBounds) {
        let T = 0;
        p.forEach(P => {
            T += P + (r.spaceBetween ? r.spaceBetween : 0)
        }), T -= r.spaceBetween;
        const S = T - s;
        f = f.map(P => P < 0 ? -b : P > S ? S + y : P)
    }
    if (r.centerInsufficientSlides) {
        let T = 0;
        if (p.forEach(S => {
                T += S + (r.spaceBetween ? r.spaceBetween : 0)
            }), T -= r.spaceBetween, T < s) {
            const S = (s - T) / 2;
            f.forEach((P, R) => {
                f[R] = P - S
            }), h.forEach((P, R) => {
                h[R] = P + S
            })
        }
    }
    if (Object.assign(t, {
            slides: u,
            snapGrid: f,
            slidesGrid: h,
            slidesSizesGrid: p
        }), r.centeredSlides && r.cssMode && !r.centeredSlidesBounds) {
        Af(t.wrapperEl, "--swiper-centered-offset-before", `${-f[0]}px`), Af(t.wrapperEl, "--swiper-centered-offset-after", `${t.size/2-p[p.length-1]/2}px`);
        const T = -t.snapGrid[0],
            S = -t.slidesGrid[0];
        t.snapGrid = t.snapGrid.map(P => P + T), t.slidesGrid = t.slidesGrid.map(P => P + S)
    }
    if (d !== c && t.emit("slidesLengthChange"), f.length !== m && (t.params.watchOverflow && t.checkOverflow(), t.emit("snapGridLengthChange")), h.length !== g && t.emit("slidesGridLengthChange"), r.watchSlidesProgress && t.updateSlidesOffset(), !l && !r.cssMode && (r.effect === "slide" || r.effect === "fade")) {
        const T = `${r.containerModifierClass}backface-hidden`,
            S = t.$el.hasClass(T);
        d <= r.maxBackfaceHiddenSlides ? S || t.$el.addClass(T) : S && t.$el.removeClass(T)
    }
}

function dge(t) {
    const e = this,
        n = [],
        r = e.virtual && e.params.virtual.enabled;
    let i = 0,
        s;
    typeof t == "number" ? e.setTransition(t) : t === !0 && e.setTransition(e.params.speed);
    const o = a => r ? e.slides.filter(l => parseInt(l.getAttribute("data-swiper-slide-index"), 10) === a)[0] : e.slides.eq(a)[0];
    if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1)
        if (e.params.centeredSlides)(e.visibleSlides || Se([])).each(a => {
            n.push(a)
        });
        else
            for (s = 0; s < Math.ceil(e.params.slidesPerView); s += 1) {
                const a = e.activeIndex + s;
                if (a > e.slides.length && !r) break;
                n.push(o(a))
            } else n.push(o(e.activeIndex));
    for (s = 0; s < n.length; s += 1)
        if (typeof n[s] < "u") {
            const a = n[s].offsetHeight;
            i = a > i ? a : i
        }(i || i === 0) && e.$wrapperEl.css("height", `${i}px`)
}

function fge() {
    const t = this,
        e = t.slides;
    for (let n = 0; n < e.length; n += 1) e[n].swiperSlideOffset = t.isHorizontal() ? e[n].offsetLeft : e[n].offsetTop
}

function hge(t = this && this.translate || 0) {
    const e = this,
        n = e.params,
        {
            slides: r,
            rtlTranslate: i,
            snapGrid: s
        } = e;
    if (r.length === 0) return;
    typeof r[0].swiperSlideOffset > "u" && e.updateSlidesOffset();
    let o = -t;
    i && (o = t), r.removeClass(n.slideVisibleClass), e.visibleSlidesIndexes = [], e.visibleSlides = [];
    for (let a = 0; a < r.length; a += 1) {
        const l = r[a];
        let c = l.swiperSlideOffset;
        n.cssMode && n.centeredSlides && (c -= r[0].swiperSlideOffset);
        const u = (o + (n.centeredSlides ? e.minTranslate() : 0) - c) / (l.swiperSlideSize + n.spaceBetween),
            d = (o - s[0] + (n.centeredSlides ? e.minTranslate() : 0) - c) / (l.swiperSlideSize + n.spaceBetween),
            f = -(o - c),
            h = f + e.slidesSizesGrid[a];
        (f >= 0 && f < e.size - 1 || h > 1 && h <= e.size || f <= 0 && h >= e.size) && (e.visibleSlides.push(l), e.visibleSlidesIndexes.push(a), r.eq(a).addClass(n.slideVisibleClass)), l.progress = i ? -u : u, l.originalProgress = i ? -d : d
    }
    e.visibleSlides = Se(e.visibleSlides)
}

function pge(t) {
    const e = this;
    if (typeof t > "u") {
        const c = e.rtlTranslate ? -1 : 1;
        t = e && e.translate && e.translate * c || 0
    }
    const n = e.params,
        r = e.maxTranslate() - e.minTranslate();
    let {
        progress: i,
        isBeginning: s,
        isEnd: o
    } = e;
    const a = s,
        l = o;
    r === 0 ? (i = 0, s = !0, o = !0) : (i = (t - e.minTranslate()) / r, s = i <= 0, o = i >= 1), Object.assign(e, {
        progress: i,
        isBeginning: s,
        isEnd: o
    }), (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && e.updateSlidesProgress(t), s && !a && e.emit("reachBeginning toEdge"), o && !l && e.emit("reachEnd toEdge"), (a && !s || l && !o) && e.emit("fromEdge"), e.emit("progress", i)
}

function mge() {
    const t = this,
        {
            slides: e,
            params: n,
            $wrapperEl: r,
            activeIndex: i,
            realIndex: s
        } = t,
        o = t.virtual && n.virtual.enabled;
    e.removeClass(`${n.slideActiveClass} ${n.slideNextClass} ${n.slidePrevClass} ${n.slideDuplicateActiveClass} ${n.slideDuplicateNextClass} ${n.slideDuplicatePrevClass}`);
    let a;
    o ? a = t.$wrapperEl.find(`.${n.slideClass}[data-swiper-slide-index="${i}"]`) : a = e.eq(i), a.addClass(n.slideActiveClass), n.loop && (a.hasClass(n.slideDuplicateClass) ? r.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${s}"]`).addClass(n.slideDuplicateActiveClass) : r.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${s}"]`).addClass(n.slideDuplicateActiveClass));
    let l = a.nextAll(`.${n.slideClass}`).eq(0).addClass(n.slideNextClass);
    n.loop && l.length === 0 && (l = e.eq(0), l.addClass(n.slideNextClass));
    let c = a.prevAll(`.${n.slideClass}`).eq(0).addClass(n.slidePrevClass);
    n.loop && c.length === 0 && (c = e.eq(-1), c.addClass(n.slidePrevClass)), n.loop && (l.hasClass(n.slideDuplicateClass) ? r.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicateNextClass) : r.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicateNextClass), c.hasClass(n.slideDuplicateClass) ? r.children(`.${n.slideClass}:not(.${n.slideDuplicateClass})[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicatePrevClass) : r.children(`.${n.slideClass}.${n.slideDuplicateClass}[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(n.slideDuplicatePrevClass)), t.emitSlidesClasses()
}

function gge(t) {
    const e = this,
        n = e.rtlTranslate ? e.translate : -e.translate,
        {
            slidesGrid: r,
            snapGrid: i,
            params: s,
            activeIndex: o,
            realIndex: a,
            snapIndex: l
        } = e;
    let c = t,
        u;
    if (typeof c > "u") {
        for (let f = 0; f < r.length; f += 1) typeof r[f + 1] < "u" ? n >= r[f] && n < r[f + 1] - (r[f + 1] - r[f]) / 2 ? c = f : n >= r[f] && n < r[f + 1] && (c = f + 1) : n >= r[f] && (c = f);
        s.normalizeSlideIndex && (c < 0 || typeof c > "u") && (c = 0)
    }
    if (i.indexOf(n) >= 0) u = i.indexOf(n);
    else {
        const f = Math.min(s.slidesPerGroupSkip, c);
        u = f + Math.floor((c - f) / s.slidesPerGroup)
    }
    if (u >= i.length && (u = i.length - 1), c === o) {
        u !== l && (e.snapIndex = u, e.emit("snapIndexChange"));
        return
    }
    const d = parseInt(e.slides.eq(c).attr("data-swiper-slide-index") || c, 10);
    Object.assign(e, {
        snapIndex: u,
        realIndex: d,
        previousIndex: o,
        activeIndex: c
    }), e.emit("activeIndexChange"), e.emit("snapIndexChange"), a !== d && e.emit("realIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && e.emit("slideChange")
}

function yge(t) {
    const e = this,
        n = e.params,
        r = Se(t).closest(`.${n.slideClass}`)[0];
    let i = !1,
        s;
    if (r) {
        for (let o = 0; o < e.slides.length; o += 1)
            if (e.slides[o] === r) {
                i = !0, s = o;
                break
            }
    }
    if (r && i) e.clickedSlide = r, e.virtual && e.params.virtual.enabled ? e.clickedIndex = parseInt(Se(r).attr("data-swiper-slide-index"), 10) : e.clickedIndex = s;
    else {
        e.clickedSlide = void 0, e.clickedIndex = void 0;
        return
    }
    n.slideToClickedSlide && e.clickedIndex !== void 0 && e.clickedIndex !== e.activeIndex && e.slideToClickedSlide()
}
const vge = {
    updateSize: cge,
    updateSlides: uge,
    updateAutoHeight: dge,
    updateSlidesOffset: fge,
    updateSlidesProgress: hge,
    updateProgress: pge,
    updateSlidesClasses: mge,
    updateActiveIndex: gge,
    updateClickedSlide: yge
};

function _ge(t = this.isHorizontal() ? "x" : "y") {
    const e = this,
        {
            params: n,
            rtlTranslate: r,
            translate: i,
            $wrapperEl: s
        } = e;
    if (n.virtualTranslate) return r ? -i : i;
    if (n.cssMode) return i;
    let o = Qme(s[0], t);
    return r && (o = -o), o || 0
}

function bge(t, e) {
    const n = this,
        {
            rtlTranslate: r,
            params: i,
            $wrapperEl: s,
            wrapperEl: o,
            progress: a
        } = n;
    let l = 0,
        c = 0;
    const u = 0;
    n.isHorizontal() ? l = r ? -t : t : c = t, i.roundLengths && (l = Math.floor(l), c = Math.floor(c)), i.cssMode ? o[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -l : -c : i.virtualTranslate || s.transform(`translate3d(${l}px, ${c}px, ${u}px)`), n.previousTranslate = n.translate, n.translate = n.isHorizontal() ? l : c;
    let d;
    const f = n.maxTranslate() - n.minTranslate();
    f === 0 ? d = 0 : d = (t - n.minTranslate()) / f, d !== a && n.updateProgress(t), n.emit("setTranslate", n.translate, e)
}

function xge() {
    return -this.snapGrid[0]
}

function wge() {
    return -this.snapGrid[this.snapGrid.length - 1]
}

function Ege(t = 0, e = this.params.speed, n = !0, r = !0, i) {
    const s = this,
        {
            params: o,
            wrapperEl: a
        } = s;
    if (s.animating && o.preventInteractionOnTransition) return !1;
    const l = s.minTranslate(),
        c = s.maxTranslate();
    let u;
    if (r && t > l ? u = l : r && t < c ? u = c : u = t, s.updateProgress(u), o.cssMode) {
        const d = s.isHorizontal();
        if (e === 0) a[d ? "scrollLeft" : "scrollTop"] = -u;
        else {
            if (!s.support.smoothScroll) return xL({
                swiper: s,
                targetPosition: -u,
                side: d ? "left" : "top"
            }), !0;
            a.scrollTo({
                [d ? "left" : "top"]: -u,
                behavior: "smooth"
            })
        }
        return !0
    }
    return e === 0 ? (s.setTransition(0), s.setTranslate(u), n && (s.emit("beforeTransitionStart", e, i), s.emit("transitionEnd"))) : (s.setTransition(e), s.setTranslate(u), n && (s.emit("beforeTransitionStart", e, i), s.emit("transitionStart")), s.animating || (s.animating = !0, s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function(f) {
        !s || s.destroyed || f.target === this && (s.$wrapperEl[0].removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.$wrapperEl[0].removeEventListener("webkitTransitionEnd", s.onTranslateToWrapperTransitionEnd), s.onTranslateToWrapperTransitionEnd = null, delete s.onTranslateToWrapperTransitionEnd, n && s.emit("transitionEnd"))
    }), s.$wrapperEl[0].addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.$wrapperEl[0].addEventListener("webkitTransitionEnd", s.onTranslateToWrapperTransitionEnd))), !0
}
const Sge = {
    getTranslate: _ge,
    setTranslate: bge,
    minTranslate: xge,
    maxTranslate: wge,
    translateTo: Ege
};

function Tge(t, e) {
    const n = this;
    n.params.cssMode || n.$wrapperEl.transition(t), n.emit("setTransition", t, e)
}

function EL({
    swiper: t,
    runCallbacks: e,
    direction: n,
    step: r
}) {
    const {
        activeIndex: i,
        previousIndex: s
    } = t;
    let o = n;
    if (o || (i > s ? o = "next" : i < s ? o = "prev" : o = "reset"), t.emit(`transition${r}`), e && i !== s) {
        if (o === "reset") {
            t.emit(`slideResetTransition${r}`);
            return
        }
        t.emit(`slideChangeTransition${r}`), o === "next" ? t.emit(`slideNextTransition${r}`) : t.emit(`slidePrevTransition${r}`)
    }
}

function Cge(t = !0, e) {
    const n = this,
        {
            params: r
        } = n;
    r.cssMode || (r.autoHeight && n.updateAutoHeight(), EL({
        swiper: n,
        runCallbacks: t,
        direction: e,
        step: "Start"
    }))
}

function Pge(t = !0, e) {
    const n = this,
        {
            params: r
        } = n;
    n.animating = !1, !r.cssMode && (n.setTransition(0), EL({
        swiper: n,
        runCallbacks: t,
        direction: e,
        step: "End"
    }))
}
const Age = {
    setTransition: Tge,
    transitionStart: Cge,
    transitionEnd: Pge
};

function Oge(t = 0, e = this.params.speed, n = !0, r, i) {
    if (typeof t != "number" && typeof t != "string") throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof t}] given.`);
    if (typeof t == "string") {
        const v = parseInt(t, 10);
        if (!isFinite(v)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${t}] given.`);
        t = v
    }
    const s = this;
    let o = t;
    o < 0 && (o = 0);
    const {
        params: a,
        snapGrid: l,
        slidesGrid: c,
        previousIndex: u,
        activeIndex: d,
        rtlTranslate: f,
        wrapperEl: h,
        enabled: p
    } = s;
    if (s.animating && a.preventInteractionOnTransition || !p && !r && !i) return !1;
    const b = Math.min(s.params.slidesPerGroupSkip, o);
    let y = b + Math.floor((o - b) / s.params.slidesPerGroup);
    y >= l.length && (y = l.length - 1);
    const m = -l[y];
    if (a.normalizeSlideIndex)
        for (let v = 0; v < c.length; v += 1) {
            const _ = -Math.floor(m * 100),
                x = Math.floor(c[v] * 100),
                w = Math.floor(c[v + 1] * 100);
            typeof c[v + 1] < "u" ? _ >= x && _ < w - (w - x) / 2 ? o = v : _ >= x && _ < w && (o = v + 1) : _ >= x && (o = v)
        }
    if (s.initialized && o !== d && (!s.allowSlideNext && m < s.translate && m < s.minTranslate() || !s.allowSlidePrev && m > s.translate && m > s.maxTranslate() && (d || 0) !== o)) return !1;
    o !== (u || 0) && n && s.emit("beforeSlideChangeStart"), s.updateProgress(m);
    let g;
    if (o > d ? g = "next" : o < d ? g = "prev" : g = "reset", f && -m === s.translate || !f && m === s.translate) return s.updateActiveIndex(o), a.autoHeight && s.updateAutoHeight(), s.updateSlidesClasses(), a.effect !== "slide" && s.setTranslate(m), g !== "reset" && (s.transitionStart(n, g), s.transitionEnd(n, g)), !1;
    if (a.cssMode) {
        const v = s.isHorizontal(),
            _ = f ? m : -m;
        if (e === 0) {
            const x = s.virtual && s.params.virtual.enabled;
            x && (s.wrapperEl.style.scrollSnapType = "none", s._immediateVirtual = !0), h[v ? "scrollLeft" : "scrollTop"] = _, x && requestAnimationFrame(() => {
                s.wrapperEl.style.scrollSnapType = "", s._swiperImmediateVirtual = !1
            })
        } else {
            if (!s.support.smoothScroll) return xL({
                swiper: s,
                targetPosition: _,
                side: v ? "left" : "top"
            }), !0;
            h.scrollTo({
                [v ? "left" : "top"]: _,
                behavior: "smooth"
            })
        }
        return !0
    }
    return s.setTransition(e), s.setTranslate(m), s.updateActiveIndex(o), s.updateSlidesClasses(), s.emit("beforeTransitionStart", e, r), s.transitionStart(n, g), e === 0 ? s.transitionEnd(n, g) : s.animating || (s.animating = !0, s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function(_) {
        !s || s.destroyed || _.target === this && (s.$wrapperEl[0].removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.$wrapperEl[0].removeEventListener("webkitTransitionEnd", s.onSlideToWrapperTransitionEnd), s.onSlideToWrapperTransitionEnd = null, delete s.onSlideToWrapperTransitionEnd, s.transitionEnd(n, g))
    }), s.$wrapperEl[0].addEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.$wrapperEl[0].addEventListener("webkitTransitionEnd", s.onSlideToWrapperTransitionEnd)), !0
}

function Ige(t = 0, e = this.params.speed, n = !0, r) {
    if (typeof t == "string") {
        const o = parseInt(t, 10);
        if (!isFinite(o)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${t}] given.`);
        t = o
    }
    const i = this;
    let s = t;
    return i.params.loop && (s += i.loopedSlides), i.slideTo(s, e, n, r)
}

function Mge(t = this.params.speed, e = !0, n) {
    const r = this,
        {
            animating: i,
            enabled: s,
            params: o
        } = r;
    if (!s) return r;
    let a = o.slidesPerGroup;
    o.slidesPerView === "auto" && o.slidesPerGroup === 1 && o.slidesPerGroupAuto && (a = Math.max(r.slidesPerViewDynamic("current", !0), 1));
    const l = r.activeIndex < o.slidesPerGroupSkip ? 1 : a;
    if (o.loop) {
        if (i && o.loopPreventsSlide) return !1;
        r.loopFix(), r._clientLeft = r.$wrapperEl[0].clientLeft
    }
    return o.rewind && r.isEnd ? r.slideTo(0, t, e, n) : r.slideTo(r.activeIndex + l, t, e, n)
}

function Rge(t = this.params.speed, e = !0, n) {
    const r = this,
        {
            params: i,
            animating: s,
            snapGrid: o,
            slidesGrid: a,
            rtlTranslate: l,
            enabled: c
        } = r;
    if (!c) return r;
    if (i.loop) {
        if (s && i.loopPreventsSlide) return !1;
        r.loopFix(), r._clientLeft = r.$wrapperEl[0].clientLeft
    }
    const u = l ? r.translate : -r.translate;

    function d(y) {
        return y < 0 ? -Math.floor(Math.abs(y)) : Math.floor(y)
    }
    const f = d(u),
        h = o.map(y => d(y));
    let p = o[h.indexOf(f) - 1];
    if (typeof p > "u" && i.cssMode) {
        let y;
        o.forEach((m, g) => {
            f >= m && (y = g)
        }), typeof y < "u" && (p = o[y > 0 ? y - 1 : y])
    }
    let b = 0;
    if (typeof p < "u" && (b = a.indexOf(p), b < 0 && (b = r.activeIndex - 1), i.slidesPerView === "auto" && i.slidesPerGroup === 1 && i.slidesPerGroupAuto && (b = b - r.slidesPerViewDynamic("previous", !0) + 1, b = Math.max(b, 0))), i.rewind && r.isBeginning) {
        const y = r.params.virtual && r.params.virtual.enabled && r.virtual ? r.virtual.slides.length - 1 : r.slides.length - 1;
        return r.slideTo(y, t, e, n)
    }
    return r.slideTo(b, t, e, n)
}

function kge(t = this.params.speed, e = !0, n) {
    const r = this;
    return r.slideTo(r.activeIndex, t, e, n)
}

function Bge(t = this.params.speed, e = !0, n, r = .5) {
    const i = this;
    let s = i.activeIndex;
    const o = Math.min(i.params.slidesPerGroupSkip, s),
        a = o + Math.floor((s - o) / i.params.slidesPerGroup),
        l = i.rtlTranslate ? i.translate : -i.translate;
    if (l >= i.snapGrid[a]) {
        const c = i.snapGrid[a],
            u = i.snapGrid[a + 1];
        l - c > (u - c) * r && (s += i.params.slidesPerGroup)
    } else {
        const c = i.snapGrid[a - 1],
            u = i.snapGrid[a];
        l - c <= (u - c) * r && (s -= i.params.slidesPerGroup)
    }
    return s = Math.max(s, 0), s = Math.min(s, i.slidesGrid.length - 1), i.slideTo(s, t, e, n)
}

function Dge() {
    const t = this,
        {
            params: e,
            $wrapperEl: n
        } = t,
        r = e.slidesPerView === "auto" ? t.slidesPerViewDynamic() : e.slidesPerView;
    let i = t.clickedIndex,
        s;
    if (e.loop) {
        if (t.animating) return;
        s = parseInt(Se(t.clickedSlide).attr("data-swiper-slide-index"), 10), e.centeredSlides ? i < t.loopedSlides - r / 2 || i > t.slides.length - t.loopedSlides + r / 2 ? (t.loopFix(), i = n.children(`.${e.slideClass}[data-swiper-slide-index="${s}"]:not(.${e.slideDuplicateClass})`).eq(0).index(), Gh(() => {
            t.slideTo(i)
        })) : t.slideTo(i) : i > t.slides.length - r ? (t.loopFix(), i = n.children(`.${e.slideClass}[data-swiper-slide-index="${s}"]:not(.${e.slideDuplicateClass})`).eq(0).index(), Gh(() => {
            t.slideTo(i)
        })) : t.slideTo(i)
    } else t.slideTo(i)
}
const $ge = {
    slideTo: Oge,
    slideToLoop: Ige,
    slideNext: Mge,
    slidePrev: Rge,
    slideReset: kge,
    slideToClosest: Bge,
    slideToClickedSlide: Dge
};

function Fge() {
    const t = this,
        e = hn(),
        {
            params: n,
            $wrapperEl: r
        } = t,
        i = r.children().length > 0 ? Se(r.children()[0].parentNode) : r;
    i.children(`.${n.slideClass}.${n.slideDuplicateClass}`).remove();
    let s = i.children(`.${n.slideClass}`);
    if (n.loopFillGroupWithBlank) {
        const l = n.slidesPerGroup - s.length % n.slidesPerGroup;
        if (l !== n.slidesPerGroup) {
            for (let c = 0; c < l; c += 1) {
                const u = Se(e.createElement("div")).addClass(`${n.slideClass} ${n.slideBlankClass}`);
                i.append(u)
            }
            s = i.children(`.${n.slideClass}`)
        }
    }
    n.slidesPerView === "auto" && !n.loopedSlides && (n.loopedSlides = s.length), t.loopedSlides = Math.ceil(parseFloat(n.loopedSlides || n.slidesPerView, 10)), t.loopedSlides += n.loopAdditionalSlides, t.loopedSlides > s.length && t.params.loopedSlidesLimit && (t.loopedSlides = s.length);
    const o = [],
        a = [];
    s.each((l, c) => {
        Se(l).attr("data-swiper-slide-index", c)
    });
    for (let l = 0; l < t.loopedSlides; l += 1) {
        const c = l - Math.floor(l / s.length) * s.length;
        a.push(s.eq(c)[0]), o.unshift(s.eq(s.length - c - 1)[0])
    }
    for (let l = 0; l < a.length; l += 1) i.append(Se(a[l].cloneNode(!0)).addClass(n.slideDuplicateClass));
    for (let l = o.length - 1; l >= 0; l -= 1) i.prepend(Se(o[l].cloneNode(!0)).addClass(n.slideDuplicateClass))
}

function Lge() {
    const t = this;
    t.emit("beforeLoopFix");
    const {
        activeIndex: e,
        slides: n,
        loopedSlides: r,
        allowSlidePrev: i,
        allowSlideNext: s,
        snapGrid: o,
        rtlTranslate: a
    } = t;
    let l;
    t.allowSlidePrev = !0, t.allowSlideNext = !0;
    const u = -o[e] - t.getTranslate();
    e < r ? (l = n.length - r * 3 + e, l += r, t.slideTo(l, 0, !1, !0) && u !== 0 && t.setTranslate((a ? -t.translate : t.translate) - u)) : e >= n.length - r && (l = -n.length + e + r, l += r, t.slideTo(l, 0, !1, !0) && u !== 0 && t.setTranslate((a ? -t.translate : t.translate) - u)), t.allowSlidePrev = i, t.allowSlideNext = s, t.emit("loopFix")
}

function Nge() {
    const t = this,
        {
            $wrapperEl: e,
            params: n,
            slides: r
        } = t;
    e.children(`.${n.slideClass}.${n.slideDuplicateClass},.${n.slideClass}.${n.slideBlankClass}`).remove(), r.removeAttr("data-swiper-slide-index")
}
const Uge = {
    loopCreate: Fge,
    loopFix: Lge,
    loopDestroy: Nge
};

function Gge(t) {
    const e = this;
    if (e.support.touch || !e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode) return;
    const n = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl;
    n.style.cursor = "move", n.style.cursor = t ? "grabbing" : "grab"
}

function Hge() {
    const t = this;
    t.support.touch || t.params.watchOverflow && t.isLocked || t.params.cssMode || (t[t.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "")
}
const zge = {
    setGrabCursor: Gge,
    unsetGrabCursor: Hge
};

function jge(t, e = this) {
    function n(r) {
        if (!r || r === hn() || r === Qt()) return null;
        r.assignedSlot && (r = r.assignedSlot);
        const i = r.closest(t);
        return !i && !r.getRootNode ? null : i || n(r.getRootNode().host)
    }
    return n(e)
}

function Vge(t) {
    const e = this,
        n = hn(),
        r = Qt(),
        i = e.touchEventsData,
        {
            params: s,
            touches: o,
            enabled: a
        } = e;
    if (!a || e.animating && s.preventInteractionOnTransition) return;
    !e.animating && s.cssMode && s.loop && e.loopFix();
    let l = t;
    l.originalEvent && (l = l.originalEvent);
    let c = Se(l.target);
    if (s.touchEventsTarget === "wrapper" && !c.closest(e.wrapperEl).length || (i.isTouchEvent = l.type === "touchstart", !i.isTouchEvent && "which" in l && l.which === 3) || !i.isTouchEvent && "button" in l && l.button > 0 || i.isTouched && i.isMoved) return;
    const u = !!s.noSwipingClass && s.noSwipingClass !== "",
        d = t.composedPath ? t.composedPath() : t.path;
    u && l.target && l.target.shadowRoot && d && (c = Se(d[0]));
    const f = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`,
        h = !!(l.target && l.target.shadowRoot);
    if (s.noSwiping && (h ? jge(f, c[0]) : c.closest(f)[0])) {
        e.allowClick = !0;
        return
    }
    if (s.swipeHandler && !c.closest(s.swipeHandler)[0]) return;
    o.currentX = l.type === "touchstart" ? l.targetTouches[0].pageX : l.pageX, o.currentY = l.type === "touchstart" ? l.targetTouches[0].pageY : l.pageY;
    const p = o.currentX,
        b = o.currentY,
        y = s.edgeSwipeDetection || s.iOSEdgeSwipeDetection,
        m = s.edgeSwipeThreshold || s.iOSEdgeSwipeThreshold;
    if (y && (p <= m || p >= r.innerWidth - m))
        if (y === "prevent") t.preventDefault();
        else return;
    if (Object.assign(i, {
            isTouched: !0,
            isMoved: !1,
            allowTouchCallbacks: !0,
            isScrolling: void 0,
            startMoving: void 0
        }), o.startX = p, o.startY = b, i.touchStartTime = Nu(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, s.threshold > 0 && (i.allowThresholdMove = !1), l.type !== "touchstart") {
        let g = !0;
        c.is(i.focusableElements) && (g = !1, c[0].nodeName === "SELECT" && (i.isTouched = !1)), n.activeElement && Se(n.activeElement).is(i.focusableElements) && n.activeElement !== c[0] && n.activeElement.blur();
        const v = g && e.allowTouchMove && s.touchStartPreventDefault;
        (s.touchStartForcePreventDefault || v) && !c[0].isContentEditable && l.preventDefault()
    }
    e.params.freeMode && e.params.freeMode.enabled && e.freeMode && e.animating && !s.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", l)
}

function Wge(t) {
    const e = hn(),
        n = this,
        r = n.touchEventsData,
        {
            params: i,
            touches: s,
            rtlTranslate: o,
            enabled: a
        } = n;
    if (!a) return;
    let l = t;
    if (l.originalEvent && (l = l.originalEvent), !r.isTouched) {
        r.startMoving && r.isScrolling && n.emit("touchMoveOpposite", l);
        return
    }
    if (r.isTouchEvent && l.type !== "touchmove") return;
    const c = l.type === "touchmove" && l.targetTouches && (l.targetTouches[0] || l.changedTouches[0]),
        u = l.type === "touchmove" ? c.pageX : l.pageX,
        d = l.type === "touchmove" ? c.pageY : l.pageY;
    if (l.preventedByNestedSwiper) {
        s.startX = u, s.startY = d;
        return
    }
    if (!n.allowTouchMove) {
        Se(l.target).is(r.focusableElements) || (n.allowClick = !1), r.isTouched && (Object.assign(s, {
            startX: u,
            startY: d,
            currentX: u,
            currentY: d
        }), r.touchStartTime = Nu());
        return
    }
    if (r.isTouchEvent && i.touchReleaseOnEdges && !i.loop) {
        if (n.isVertical()) {
            if (d < s.startY && n.translate <= n.maxTranslate() || d > s.startY && n.translate >= n.minTranslate()) {
                r.isTouched = !1, r.isMoved = !1;
                return
            }
        } else if (u < s.startX && n.translate <= n.maxTranslate() || u > s.startX && n.translate >= n.minTranslate()) return
    }
    if (r.isTouchEvent && e.activeElement && l.target === e.activeElement && Se(l.target).is(r.focusableElements)) {
        r.isMoved = !0, n.allowClick = !1;
        return
    }
    if (r.allowTouchCallbacks && n.emit("touchMove", l), l.targetTouches && l.targetTouches.length > 1) return;
    s.currentX = u, s.currentY = d;
    const f = s.currentX - s.startX,
        h = s.currentY - s.startY;
    if (n.params.threshold && Math.sqrt(f ** 2 + h ** 2) < n.params.threshold) return;
    if (typeof r.isScrolling > "u") {
        let m;
        n.isHorizontal() && s.currentY === s.startY || n.isVertical() && s.currentX === s.startX ? r.isScrolling = !1 : f * f + h * h >= 25 && (m = Math.atan2(Math.abs(h), Math.abs(f)) * 180 / Math.PI, r.isScrolling = n.isHorizontal() ? m > i.touchAngle : 90 - m > i.touchAngle)
    }
    if (r.isScrolling && n.emit("touchMoveOpposite", l), typeof r.startMoving > "u" && (s.currentX !== s.startX || s.currentY !== s.startY) && (r.startMoving = !0), r.isScrolling) {
        r.isTouched = !1;
        return
    }
    if (!r.startMoving) return;
    n.allowClick = !1, !i.cssMode && l.cancelable && l.preventDefault(), i.touchMoveStopPropagation && !i.nested && l.stopPropagation(), r.isMoved || (i.loop && !i.cssMode && n.loopFix(), r.startTranslate = n.getTranslate(), n.setTransition(0), n.animating && n.$wrapperEl.trigger("webkitTransitionEnd transitionend"), r.allowMomentumBounce = !1, i.grabCursor && (n.allowSlideNext === !0 || n.allowSlidePrev === !0) && n.setGrabCursor(!0), n.emit("sliderFirstMove", l)), n.emit("sliderMove", l), r.isMoved = !0;
    let p = n.isHorizontal() ? f : h;
    s.diff = p, p *= i.touchRatio, o && (p = -p), n.swipeDirection = p > 0 ? "prev" : "next", r.currentTranslate = p + r.startTranslate;
    let b = !0,
        y = i.resistanceRatio;
    if (i.touchReleaseOnEdges && (y = 0), p > 0 && r.currentTranslate > n.minTranslate() ? (b = !1, i.resistance && (r.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + r.startTranslate + p) ** y)) : p < 0 && r.currentTranslate < n.maxTranslate() && (b = !1, i.resistance && (r.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - r.startTranslate - p) ** y)), b && (l.preventedByNestedSwiper = !0), !n.allowSlideNext && n.swipeDirection === "next" && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate), !n.allowSlidePrev && n.swipeDirection === "prev" && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate), !n.allowSlidePrev && !n.allowSlideNext && (r.currentTranslate = r.startTranslate), i.threshold > 0)
        if (Math.abs(p) > i.threshold || r.allowThresholdMove) {
            if (!r.allowThresholdMove) {
                r.allowThresholdMove = !0, s.startX = s.currentX, s.startY = s.currentY, r.currentTranslate = r.startTranslate, s.diff = n.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY;
                return
            }
        } else {
            r.currentTranslate = r.startTranslate;
            return
        }!i.followFinger || i.cssMode || ((i.freeMode && i.freeMode.enabled && n.freeMode || i.watchSlidesProgress) && (n.updateActiveIndex(), n.updateSlidesClasses()), n.params.freeMode && i.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(), n.updateProgress(r.currentTranslate), n.setTranslate(r.currentTranslate))
}

function Yge(t) {
    const e = this,
        n = e.touchEventsData,
        {
            params: r,
            touches: i,
            rtlTranslate: s,
            slidesGrid: o,
            enabled: a
        } = e;
    if (!a) return;
    let l = t;
    if (l.originalEvent && (l = l.originalEvent), n.allowTouchCallbacks && e.emit("touchEnd", l), n.allowTouchCallbacks = !1, !n.isTouched) {
        n.isMoved && r.grabCursor && e.setGrabCursor(!1), n.isMoved = !1, n.startMoving = !1;
        return
    }
    r.grabCursor && n.isMoved && n.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1);
    const c = Nu(),
        u = c - n.touchStartTime;
    if (e.allowClick) {
        const g = l.path || l.composedPath && l.composedPath();
        e.updateClickedSlide(g && g[0] || l.target), e.emit("tap click", l), u < 300 && c - n.lastClickTime < 300 && e.emit("doubleTap doubleClick", l)
    }
    if (n.lastClickTime = Nu(), Gh(() => {
            e.destroyed || (e.allowClick = !0)
        }), !n.isTouched || !n.isMoved || !e.swipeDirection || i.diff === 0 || n.currentTranslate === n.startTranslate) {
        n.isTouched = !1, n.isMoved = !1, n.startMoving = !1;
        return
    }
    n.isTouched = !1, n.isMoved = !1, n.startMoving = !1;
    let d;
    if (r.followFinger ? d = s ? e.translate : -e.translate : d = -n.currentTranslate, r.cssMode) return;
    if (e.params.freeMode && r.freeMode.enabled) {
        e.freeMode.onTouchEnd({
            currentPos: d
        });
        return
    }
    let f = 0,
        h = e.slidesSizesGrid[0];
    for (let g = 0; g < o.length; g += g < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup) {
        const v = g < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
        typeof o[g + v] < "u" ? d >= o[g] && d < o[g + v] && (f = g, h = o[g + v] - o[g]) : d >= o[g] && (f = g, h = o[o.length - 1] - o[o.length - 2])
    }
    let p = null,
        b = null;
    r.rewind && (e.isBeginning ? b = e.params.virtual && e.params.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (p = 0));
    const y = (d - o[f]) / h,
        m = f < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
    if (u > r.longSwipesMs) {
        if (!r.longSwipes) {
            e.slideTo(e.activeIndex);
            return
        }
        e.swipeDirection === "next" && (y >= r.longSwipesRatio ? e.slideTo(r.rewind && e.isEnd ? p : f + m) : e.slideTo(f)), e.swipeDirection === "prev" && (y > 1 - r.longSwipesRatio ? e.slideTo(f + m) : b !== null && y < 0 && Math.abs(y) > r.longSwipesRatio ? e.slideTo(b) : e.slideTo(f))
    } else {
        if (!r.shortSwipes) {
            e.slideTo(e.activeIndex);
            return
        }
        e.navigation && (l.target === e.navigation.nextEl || l.target === e.navigation.prevEl) ? l.target === e.navigation.nextEl ? e.slideTo(f + m) : e.slideTo(f) : (e.swipeDirection === "next" && e.slideTo(p !== null ? p : f + m), e.swipeDirection === "prev" && e.slideTo(b !== null ? b : f))
    }
}

function mP() {
    const t = this,
        {
            params: e,
            el: n
        } = t;
    if (n && n.offsetWidth === 0) return;
    e.breakpoints && t.setBreakpoint();
    const {
        allowSlideNext: r,
        allowSlidePrev: i,
        snapGrid: s
    } = t;
    t.allowSlideNext = !0, t.allowSlidePrev = !0, t.updateSize(), t.updateSlides(), t.updateSlidesClasses(), (e.slidesPerView === "auto" || e.slidesPerView > 1) && t.isEnd && !t.isBeginning && !t.params.centeredSlides ? t.slideTo(t.slides.length - 1, 0, !1, !0) : t.slideTo(t.activeIndex, 0, !1, !0), t.autoplay && t.autoplay.running && t.autoplay.paused && t.autoplay.run(), t.allowSlidePrev = i, t.allowSlideNext = r, t.params.watchOverflow && s !== t.snapGrid && t.checkOverflow()
}

function Xge(t) {
    const e = this;
    e.enabled && (e.allowClick || (e.params.preventClicks && t.preventDefault(), e.params.preventClicksPropagation && e.animating && (t.stopPropagation(), t.stopImmediatePropagation())))
}

function qge() {
    const t = this,
        {
            wrapperEl: e,
            rtlTranslate: n,
            enabled: r
        } = t;
    if (!r) return;
    t.previousTranslate = t.translate, t.isHorizontal() ? t.translate = -e.scrollLeft : t.translate = -e.scrollTop, t.translate === 0 && (t.translate = 0), t.updateActiveIndex(), t.updateSlidesClasses();
    let i;
    const s = t.maxTranslate() - t.minTranslate();
    s === 0 ? i = 0 : i = (t.translate - t.minTranslate()) / s, i !== t.progress && t.updateProgress(n ? -t.translate : t.translate), t.emit("setTranslate", t.translate, !1)
}
let gP = !1;

function Kge() {}
const SL = (t, e) => {
    const n = hn(),
        {
            params: r,
            touchEvents: i,
            el: s,
            wrapperEl: o,
            device: a,
            support: l
        } = t,
        c = !!r.nested,
        u = e === "on" ? "addEventListener" : "removeEventListener",
        d = e;
    if (!l.touch) s[u](i.start, t.onTouchStart, !1), n[u](i.move, t.onTouchMove, c), n[u](i.end, t.onTouchEnd, !1);
    else {
        const f = i.start === "touchstart" && l.passiveListener && r.passiveListeners ? {
            passive: !0,
            capture: !1
        } : !1;
        s[u](i.start, t.onTouchStart, f), s[u](i.move, t.onTouchMove, l.passiveListener ? {
            passive: !1,
            capture: c
        } : c), s[u](i.end, t.onTouchEnd, f), i.cancel && s[u](i.cancel, t.onTouchEnd, f)
    }(r.preventClicks || r.preventClicksPropagation) && s[u]("click", t.onClick, !0), r.cssMode && o[u]("scroll", t.onScroll), r.updateOnWindowResize ? t[d](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", mP, !0) : t[d]("observerUpdate", mP, !0)
};

function Jge() {
    const t = this,
        e = hn(),
        {
            params: n,
            support: r
        } = t;
    t.onTouchStart = Vge.bind(t), t.onTouchMove = Wge.bind(t), t.onTouchEnd = Yge.bind(t), n.cssMode && (t.onScroll = qge.bind(t)), t.onClick = Xge.bind(t), r.touch && !gP && (e.addEventListener("touchstart", Kge), gP = !0), SL(t, "on")
}

function Zge() {
    SL(this, "off")
}
const Qge = {
        attachEvents: Jge,
        detachEvents: Zge
    },
    yP = (t, e) => t.grid && e.grid && e.grid.rows > 1;

function eye() {
    const t = this,
        {
            activeIndex: e,
            initialized: n,
            loopedSlides: r = 0,
            params: i,
            $el: s
        } = t,
        o = i.breakpoints;
    if (!o || o && Object.keys(o).length === 0) return;
    const a = t.getBreakpoint(o, t.params.breakpointsBase, t.el);
    if (!a || t.currentBreakpoint === a) return;
    const c = (a in o ? o[a] : void 0) || t.originalParams,
        u = yP(t, i),
        d = yP(t, c),
        f = i.enabled;
    u && !d ? (s.removeClass(`${i.containerModifierClass}grid ${i.containerModifierClass}grid-column`), t.emitContainerClasses()) : !u && d && (s.addClass(`${i.containerModifierClass}grid`), (c.grid.fill && c.grid.fill === "column" || !c.grid.fill && i.grid.fill === "column") && s.addClass(`${i.containerModifierClass}grid-column`), t.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach(y => {
        const m = i[y] && i[y].enabled,
            g = c[y] && c[y].enabled;
        m && !g && t[y].disable(), !m && g && t[y].enable()
    });
    const h = c.direction && c.direction !== i.direction,
        p = i.loop && (c.slidesPerView !== i.slidesPerView || h);
    h && n && t.changeDirection(), Wn(t.params, c);
    const b = t.params.enabled;
    Object.assign(t, {
        allowTouchMove: t.params.allowTouchMove,
        allowSlideNext: t.params.allowSlideNext,
        allowSlidePrev: t.params.allowSlidePrev
    }), f && !b ? t.disable() : !f && b && t.enable(), t.currentBreakpoint = a, t.emit("_beforeBreakpoint", c), p && n && (t.loopDestroy(), t.loopCreate(), t.updateSlides(), t.slideTo(e - r + t.loopedSlides, 0, !1)), t.emit("breakpoint", c)
}

function tye(t, e = "window", n) {
    if (!t || e === "container" && !n) return;
    let r = !1;
    const i = Qt(),
        s = e === "window" ? i.innerHeight : n.clientHeight,
        o = Object.keys(t).map(a => {
            if (typeof a == "string" && a.indexOf("@") === 0) {
                const l = parseFloat(a.substr(1));
                return {
                    value: s * l,
                    point: a
                }
            }
            return {
                value: a,
                point: a
            }
        });
    o.sort((a, l) => parseInt(a.value, 10) - parseInt(l.value, 10));
    for (let a = 0; a < o.length; a += 1) {
        const {
            point: l,
            value: c
        } = o[a];
        e === "window" ? i.matchMedia(`(min-width: ${c}px)`).matches && (r = l) : c <= n.clientWidth && (r = l)
    }
    return r || "max"
}
const nye = {
    setBreakpoint: eye,
    getBreakpoint: tye
};

function rye(t, e) {
    const n = [];
    return t.forEach(r => {
        typeof r == "object" ? Object.keys(r).forEach(i => {
            r[i] && n.push(e + i)
        }) : typeof r == "string" && n.push(e + r)
    }), n
}

function iye() {
    const t = this,
        {
            classNames: e,
            params: n,
            rtl: r,
            $el: i,
            device: s,
            support: o
        } = t,
        a = rye(["initialized", n.direction, {
            "pointer-events": !o.touch
        }, {
            "free-mode": t.params.freeMode && n.freeMode.enabled
        }, {
            autoheight: n.autoHeight
        }, {
            rtl: r
        }, {
            grid: n.grid && n.grid.rows > 1
        }, {
            "grid-column": n.grid && n.grid.rows > 1 && n.grid.fill === "column"
        }, {
            android: s.android
        }, {
            ios: s.ios
        }, {
            "css-mode": n.cssMode
        }, {
            centered: n.cssMode && n.centeredSlides
        }, {
            "watch-progress": n.watchSlidesProgress
        }], n.containerModifierClass);
    e.push(...a), i.addClass([...e].join(" ")), t.emitContainerClasses()
}

function sye() {
    const t = this,
        {
            $el: e,
            classNames: n
        } = t;
    e.removeClass(n.join(" ")), t.emitContainerClasses()
}
const oye = {
    addClasses: iye,
    removeClasses: sye
};

function aye(t, e, n, r, i, s) {
    const o = Qt();
    let a;

    function l() {
        s && s()
    }!Se(t).parent("picture")[0] && (!t.complete || !i) && e ? (a = new o.Image, a.onload = l, a.onerror = l, r && (a.sizes = r), n && (a.srcset = n), e && (a.src = e)) : l()
}

function lye() {
    const t = this;
    t.imagesToLoad = t.$el.find("img");

    function e() {
        typeof t > "u" || t === null || !t || t.destroyed || (t.imagesLoaded !== void 0 && (t.imagesLoaded += 1), t.imagesLoaded === t.imagesToLoad.length && (t.params.updateOnImagesReady && t.update(), t.emit("imagesReady")))
    }
    for (let n = 0; n < t.imagesToLoad.length; n += 1) {
        const r = t.imagesToLoad[n];
        t.loadImage(r, r.currentSrc || r.getAttribute("src"), r.srcset || r.getAttribute("srcset"), r.sizes || r.getAttribute("sizes"), !0, e)
    }
}
const cye = {
    loadImage: aye,
    preloadImages: lye
};

function uye() {
    const t = this,
        {
            isLocked: e,
            params: n
        } = t,
        {
            slidesOffsetBefore: r
        } = n;
    if (r) {
        const i = t.slides.length - 1,
            s = t.slidesGrid[i] + t.slidesSizesGrid[i] + r * 2;
        t.isLocked = t.size > s
    } else t.isLocked = t.snapGrid.length === 1;
    n.allowSlideNext === !0 && (t.allowSlideNext = !t.isLocked), n.allowSlidePrev === !0 && (t.allowSlidePrev = !t.isLocked), e && e !== t.isLocked && (t.isEnd = !1), e !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock")
}
const dye = {
        checkOverflow: uye
    },
    vP = {
        init: !0,
        direction: "horizontal",
        touchEventsTarget: "wrapper",
        initialSlide: 0,
        speed: 300,
        cssMode: !1,
        updateOnWindowResize: !0,
        resizeObserver: !0,
        nested: !1,
        createElements: !1,
        enabled: !0,
        focusableElements: "input, select, option, textarea, button, video, label",
        width: null,
        height: null,
        preventInteractionOnTransition: !1,
        userAgent: null,
        url: null,
        edgeSwipeDetection: !1,
        edgeSwipeThreshold: 20,
        autoHeight: !1,
        setWrapperSize: !1,
        virtualTranslate: !1,
        effect: "slide",
        breakpoints: void 0,
        breakpointsBase: "window",
        spaceBetween: 0,
        slidesPerView: 1,
        slidesPerGroup: 1,
        slidesPerGroupSkip: 0,
        slidesPerGroupAuto: !1,
        centeredSlides: !1,
        centeredSlidesBounds: !1,
        slidesOffsetBefore: 0,
        slidesOffsetAfter: 0,
        normalizeSlideIndex: !0,
        centerInsufficientSlides: !1,
        watchOverflow: !0,
        roundLengths: !1,
        touchRatio: 1,
        touchAngle: 45,
        simulateTouch: !0,
        shortSwipes: !0,
        longSwipes: !0,
        longSwipesRatio: .5,
        longSwipesMs: 300,
        followFinger: !0,
        allowTouchMove: !0,
        threshold: 0,
        touchMoveStopPropagation: !1,
        touchStartPreventDefault: !0,
        touchStartForcePreventDefault: !1,
        touchReleaseOnEdges: !1,
        uniqueNavElements: !0,
        resistance: !0,
        resistanceRatio: .85,
        watchSlidesProgress: !1,
        grabCursor: !1,
        preventClicks: !0,
        preventClicksPropagation: !0,
        slideToClickedSlide: !1,
        preloadImages: !0,
        updateOnImagesReady: !0,
        loop: !1,
        loopAdditionalSlides: 0,
        loopedSlides: null,
        loopedSlidesLimit: !0,
        loopFillGroupWithBlank: !1,
        loopPreventsSlide: !0,
        rewind: !1,
        allowSlidePrev: !0,
        allowSlideNext: !0,
        swipeHandler: null,
        noSwiping: !0,
        noSwipingClass: "swiper-no-swiping",
        noSwipingSelector: null,
        passiveListeners: !0,
        maxBackfaceHiddenSlides: 10,
        containerModifierClass: "swiper-",
        slideClass: "swiper-slide",
        slideBlankClass: "swiper-slide-invisible-blank",
        slideActiveClass: "swiper-slide-active",
        slideDuplicateActiveClass: "swiper-slide-duplicate-active",
        slideVisibleClass: "swiper-slide-visible",
        slideDuplicateClass: "swiper-slide-duplicate",
        slideNextClass: "swiper-slide-next",
        slideDuplicateNextClass: "swiper-slide-duplicate-next",
        slidePrevClass: "swiper-slide-prev",
        slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
        wrapperClass: "swiper-wrapper",
        runCallbacksOnInit: !0,
        _emitClasses: !1
    };

function fye(t, e) {
    return function(r = {}) {
        const i = Object.keys(r)[0],
            s = r[i];
        if (typeof s != "object" || s === null) {
            Wn(e, r);
            return
        }
        if (["navigation", "pagination", "scrollbar"].indexOf(i) >= 0 && t[i] === !0 && (t[i] = {
                auto: !0
            }), !(i in t && "enabled" in s)) {
            Wn(e, r);
            return
        }
        t[i] === !0 && (t[i] = {
            enabled: !0
        }), typeof t[i] == "object" && !("enabled" in t[i]) && (t[i].enabled = !0), t[i] || (t[i] = {
            enabled: !1
        }), Wn(e, r)
    }
}
const fy = {
        eventsEmitter: lge,
        update: vge,
        translate: Sge,
        transition: Age,
        slide: $ge,
        loop: Uge,
        grabCursor: zge,
        events: Qge,
        breakpoints: nye,
        checkOverflow: dye,
        classes: oye,
        images: cye
    },
    hy = {};
let kl = class Pi {
    constructor(...e) {
        let n, r;
        if (e.length === 1 && e[0].constructor && Object.prototype.toString.call(e[0]).slice(8, -1) === "Object" ? r = e[0] : [n, r] = e, r || (r = {}), r = Wn({}, r), n && !r.el && (r.el = n), r.el && Se(r.el).length > 1) {
            const a = [];
            return Se(r.el).each(l => {
                const c = Wn({}, r, {
                    el: l
                });
                a.push(new Pi(c))
            }), a
        }
        const i = this;
        i.__swiper__ = !0, i.support = wL(), i.device = rge({
            userAgent: r.userAgent
        }), i.browser = sge(), i.eventsListeners = {}, i.eventsAnyListeners = [], i.modules = [...i.__modules__], r.modules && Array.isArray(r.modules) && i.modules.push(...r.modules);
        const s = {};
        i.modules.forEach(a => {
            a({
                swiper: i,
                extendParams: fye(r, s),
                on: i.on.bind(i),
                once: i.once.bind(i),
                off: i.off.bind(i),
                emit: i.emit.bind(i)
            })
        });
        const o = Wn({}, vP, s);
        return i.params = Wn({}, o, hy, r), i.originalParams = Wn({}, i.params), i.passedParams = Wn({}, r), i.params && i.params.on && Object.keys(i.params.on).forEach(a => {
            i.on(a, i.params.on[a])
        }), i.params && i.params.onAny && i.onAny(i.params.onAny), i.$ = Se, Object.assign(i, {
            enabled: i.params.enabled,
            el: n,
            classNames: [],
            slides: Se(),
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal() {
                return i.params.direction === "horizontal"
            },
            isVertical() {
                return i.params.direction === "vertical"
            },
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            allowSlideNext: i.params.allowSlideNext,
            allowSlidePrev: i.params.allowSlidePrev,
            touchEvents: function() {
                const l = ["touchstart", "touchmove", "touchend", "touchcancel"],
                    c = ["pointerdown", "pointermove", "pointerup"];
                return i.touchEventsTouch = {
                    start: l[0],
                    move: l[1],
                    end: l[2],
                    cancel: l[3]
                }, i.touchEventsDesktop = {
                    start: c[0],
                    move: c[1],
                    end: c[2]
                }, i.support.touch || !i.params.simulateTouch ? i.touchEventsTouch : i.touchEventsDesktop
            }(),
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: i.params.focusableElements,
                lastClickTime: Nu(),
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                isTouchEvent: void 0,
                startMoving: void 0
            },
            allowClick: !0,
            allowTouchMove: i.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        }), i.emit("_swiper"), i.params.init && i.init(), i
    }
    enable() {
        const e = this;
        e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
    }
    disable() {
        const e = this;
        e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
    }
    setProgress(e, n) {
        const r = this;
        e = Math.min(Math.max(e, 0), 1);
        const i = r.minTranslate(),
            o = (r.maxTranslate() - i) * e + i;
        r.translateTo(o, typeof n > "u" ? 0 : n), r.updateActiveIndex(), r.updateSlidesClasses()
    }
    emitContainerClasses() {
        const e = this;
        if (!e.params._emitClasses || !e.el) return;
        const n = e.el.className.split(" ").filter(r => r.indexOf("swiper") === 0 || r.indexOf(e.params.containerModifierClass) === 0);
        e.emit("_containerClasses", n.join(" "))
    }
    getSlideClasses(e) {
        const n = this;
        return n.destroyed ? "" : e.className.split(" ").filter(r => r.indexOf("swiper-slide") === 0 || r.indexOf(n.params.slideClass) === 0).join(" ")
    }
    emitSlidesClasses() {
        const e = this;
        if (!e.params._emitClasses || !e.el) return;
        const n = [];
        e.slides.each(r => {
            const i = e.getSlideClasses(r);
            n.push({
                slideEl: r,
                classNames: i
            }), e.emit("_slideClass", r, i)
        }), e.emit("_slideClasses", n)
    }
    slidesPerViewDynamic(e = "current", n = !1) {
        const r = this,
            {
                params: i,
                slides: s,
                slidesGrid: o,
                slidesSizesGrid: a,
                size: l,
                activeIndex: c
            } = r;
        let u = 1;
        if (i.centeredSlides) {
            let d = s[c].swiperSlideSize,
                f;
            for (let h = c + 1; h < s.length; h += 1) s[h] && !f && (d += s[h].swiperSlideSize, u += 1, d > l && (f = !0));
            for (let h = c - 1; h >= 0; h -= 1) s[h] && !f && (d += s[h].swiperSlideSize, u += 1, d > l && (f = !0))
        } else if (e === "current")
            for (let d = c + 1; d < s.length; d += 1)(n ? o[d] + a[d] - o[c] < l : o[d] - o[c] < l) && (u += 1);
        else
            for (let d = c - 1; d >= 0; d -= 1) o[c] - o[d] < l && (u += 1);
        return u
    }
    update() {
        const e = this;
        if (!e || e.destroyed) return;
        const {
            snapGrid: n,
            params: r
        } = e;
        r.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses();

        function i() {
            const o = e.rtlTranslate ? e.translate * -1 : e.translate,
                a = Math.min(Math.max(o, e.maxTranslate()), e.minTranslate());
            e.setTranslate(a), e.updateActiveIndex(), e.updateSlidesClasses()
        }
        let s;
        e.params.freeMode && e.params.freeMode.enabled ? (i(), e.params.autoHeight && e.updateAutoHeight()) : ((e.params.slidesPerView === "auto" || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? s = e.slideTo(e.slides.length - 1, 0, !1, !0) : s = e.slideTo(e.activeIndex, 0, !1, !0), s || i()), r.watchOverflow && n !== e.snapGrid && e.checkOverflow(), e.emit("update")
    }
    changeDirection(e, n = !0) {
        const r = this,
            i = r.params.direction;
        return e || (e = i === "horizontal" ? "vertical" : "horizontal"), e === i || e !== "horizontal" && e !== "vertical" || (r.$el.removeClass(`${r.params.containerModifierClass}${i}`).addClass(`${r.params.containerModifierClass}${e}`), r.emitContainerClasses(), r.params.direction = e, r.slides.each(s => {
            e === "vertical" ? s.style.width = "" : s.style.height = ""
        }), r.emit("changeDirection"), n && r.update()), r
    }
    changeLanguageDirection(e) {
        const n = this;
        n.rtl && e === "rtl" || !n.rtl && e === "ltr" || (n.rtl = e === "rtl", n.rtlTranslate = n.params.direction === "horizontal" && n.rtl, n.rtl ? (n.$el.addClass(`${n.params.containerModifierClass}rtl`), n.el.dir = "rtl") : (n.$el.removeClass(`${n.params.containerModifierClass}rtl`), n.el.dir = "ltr"), n.update())
    }
    mount(e) {
        const n = this;
        if (n.mounted) return !0;
        const r = Se(e || n.params.el);
        if (e = r[0], !e) return !1;
        e.swiper = n;
        const i = () => `.${(n.params.wrapperClass||"").trim().split(" ").join(".")}`;
        let o = (() => {
            if (e && e.shadowRoot && e.shadowRoot.querySelector) {
                const a = Se(e.shadowRoot.querySelector(i()));
                return a.children = l => r.children(l), a
            }
            return r.children ? r.children(i()) : Se(r).children(i())
        })();
        if (o.length === 0 && n.params.createElements) {
            const l = hn().createElement("div");
            o = Se(l), l.className = n.params.wrapperClass, r.append(l), r.children(`.${n.params.slideClass}`).each(c => {
                o.append(c)
            })
        }
        return Object.assign(n, {
            $el: r,
            el: e,
            $wrapperEl: o,
            wrapperEl: o[0],
            mounted: !0,
            rtl: e.dir.toLowerCase() === "rtl" || r.css("direction") === "rtl",
            rtlTranslate: n.params.direction === "horizontal" && (e.dir.toLowerCase() === "rtl" || r.css("direction") === "rtl"),
            wrongRTL: o.css("display") === "-webkit-box"
        }), !0
    }
    init(e) {
        const n = this;
        return n.initialized || n.mount(e) === !1 || (n.emit("beforeInit"), n.params.breakpoints && n.setBreakpoint(), n.addClasses(), n.params.loop && n.loopCreate(), n.updateSize(), n.updateSlides(), n.params.watchOverflow && n.checkOverflow(), n.params.grabCursor && n.enabled && n.setGrabCursor(), n.params.preloadImages && n.preloadImages(), n.params.loop ? n.slideTo(n.params.initialSlide + n.loopedSlides, 0, n.params.runCallbacksOnInit, !1, !0) : n.slideTo(n.params.initialSlide, 0, n.params.runCallbacksOnInit, !1, !0), n.attachEvents(), n.initialized = !0, n.emit("init"), n.emit("afterInit")), n
    }
    destroy(e = !0, n = !0) {
        const r = this,
            {
                params: i,
                $el: s,
                $wrapperEl: o,
                slides: a
            } = r;
        return typeof r.params > "u" || r.destroyed || (r.emit("beforeDestroy"), r.initialized = !1, r.detachEvents(), i.loop && r.loopDestroy(), n && (r.removeClasses(), s.removeAttr("style"), o.removeAttr("style"), a && a.length && a.removeClass([i.slideVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), r.emit("destroy"), Object.keys(r.eventsListeners).forEach(l => {
            r.off(l)
        }), e !== !1 && (r.$el[0].swiper = null, Jme(r)), r.destroyed = !0), null
    }
    static extendDefaults(e) {
        Wn(hy, e)
    }
    static get extendedDefaults() {
        return hy
    }
    static get defaults() {
        return vP
    }
    static installModule(e) {
        Pi.prototype.__modules__ || (Pi.prototype.__modules__ = []);
        const n = Pi.prototype.__modules__;
        typeof e == "function" && n.indexOf(e) < 0 && n.push(e)
    }
    static use(e) {
        return Array.isArray(e) ? (e.forEach(n => Pi.installModule(n)), Pi) : (Pi.installModule(e), Pi)
    }
};
Object.keys(fy).forEach(t => {
    Object.keys(fy[t]).forEach(e => {
        kl.prototype[e] = fy[t][e]
    })
});
kl.use([oge, age]);

function Awe({
    swiper: t,
    extendParams: e,
    on: n,
    emit: r
}) {
    let i;
    t.autoplay = {
        running: !1,
        paused: !1
    }, e({
        autoplay: {
            enabled: !1,
            delay: 3e3,
            waitForTransition: !0,
            disableOnInteraction: !0,
            stopOnLastSlide: !1,
            reverseDirection: !1,
            pauseOnMouseEnter: !1
        }
    });

    function s() {
        if (!t.size) {
            t.autoplay.running = !1, t.autoplay.paused = !1;
            return
        }
        const b = t.slides.eq(t.activeIndex);
        let y = t.params.autoplay.delay;
        b.attr("data-swiper-autoplay") && (y = b.attr("data-swiper-autoplay") || t.params.autoplay.delay), clearTimeout(i), i = Gh(() => {
            let m;
            t.params.autoplay.reverseDirection ? t.params.loop ? (t.loopFix(), m = t.slidePrev(t.params.speed, !0, !0), r("autoplay")) : t.isBeginning ? t.params.autoplay.stopOnLastSlide ? a() : (m = t.slideTo(t.slides.length - 1, t.params.speed, !0, !0), r("autoplay")) : (m = t.slidePrev(t.params.speed, !0, !0), r("autoplay")) : t.params.loop ? (t.loopFix(), m = t.slideNext(t.params.speed, !0, !0), r("autoplay")) : t.isEnd ? t.params.autoplay.stopOnLastSlide ? a() : (m = t.slideTo(0, t.params.speed, !0, !0), r("autoplay")) : (m = t.slideNext(t.params.speed, !0, !0), r("autoplay")), (t.params.cssMode && t.autoplay.running || m === !1) && s()
        }, y)
    }

    function o() {
        return typeof i < "u" || t.autoplay.running ? !1 : (t.autoplay.running = !0, r("autoplayStart"), s(), !0)
    }

    function a() {
        return !t.autoplay.running || typeof i > "u" ? !1 : (i && (clearTimeout(i), i = void 0), t.autoplay.running = !1, r("autoplayStop"), !0)
    }

    function l(b) {
        t.autoplay.running && (t.autoplay.paused || (i && clearTimeout(i), t.autoplay.paused = !0, b === 0 || !t.params.autoplay.waitForTransition ? (t.autoplay.paused = !1, s()) : ["transitionend", "webkitTransitionEnd"].forEach(y => {
            t.$wrapperEl[0].addEventListener(y, u)
        })))
    }

    function c() {
        const b = hn();
        b.visibilityState === "hidden" && t.autoplay.running && l(), b.visibilityState === "visible" && t.autoplay.paused && (s(), t.autoplay.paused = !1)
    }

    function u(b) {
        !t || t.destroyed || !t.$wrapperEl || b.target === t.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach(y => {
            t.$wrapperEl[0].removeEventListener(y, u)
        }), t.autoplay.paused = !1, t.autoplay.running ? s() : a())
    }

    function d() {
        t.params.autoplay.disableOnInteraction ? a() : (r("autoplayPause"), l()), ["transitionend", "webkitTransitionEnd"].forEach(b => {
            t.$wrapperEl[0].removeEventListener(b, u)
        })
    }

    function f() {
        t.params.autoplay.disableOnInteraction || (t.autoplay.paused = !1, r("autoplayResume"), s())
    }

    function h() {
        t.params.autoplay.pauseOnMouseEnter && (t.$el.on("mouseenter", d), t.$el.on("mouseleave", f))
    }

    function p() {
        t.$el.off("mouseenter", d), t.$el.off("mouseleave", f)
    }
    n("init", () => {
        t.params.autoplay.enabled && (o(), hn().addEventListener("visibilitychange", c), h())
    }), n("beforeTransitionStart", (b, y, m) => {
        t.autoplay.running && (m || !t.params.autoplay.disableOnInteraction ? t.autoplay.pause(y) : a())
    }), n("sliderFirstMove", () => {
        t.autoplay.running && (t.params.autoplay.disableOnInteraction ? a() : l())
    }), n("touchEnd", () => {
        t.params.cssMode && t.autoplay.paused && !t.params.autoplay.disableOnInteraction && s()
    }), n("destroy", () => {
        p(), t.autoplay.running && a(), hn().removeEventListener("visibilitychange", c)
    }), Object.assign(t.autoplay, {
        pause: l,
        run: s,
        start: o,
        stop: a
    })
}

function ca(t) {
    return typeof t == "object" && t !== null && t.constructor && Object.prototype.toString.call(t).slice(8, -1) === "Object"
}

function Os(t, e) {
    const n = ["__proto__", "constructor", "prototype"];
    Object.keys(e).filter(r => n.indexOf(r) < 0).forEach(r => {
        typeof t[r] > "u" ? t[r] = e[r] : ca(e[r]) && ca(t[r]) && Object.keys(e[r]).length > 0 ? e[r].__swiper__ ? t[r] = e[r] : Os(t[r], e[r]) : t[r] = e[r]
    })
}

function TL(t = {}) {
    return t.navigation && typeof t.navigation.nextEl > "u" && typeof t.navigation.prevEl > "u"
}

function CL(t = {}) {
    return t.pagination && typeof t.pagination.el > "u"
}

function PL(t = {}) {
    return t.scrollbar && typeof t.scrollbar.el > "u"
}

function AL(t = "") {
    const e = t.split(" ").map(r => r.trim()).filter(r => !!r),
        n = [];
    return e.forEach(r => {
        n.indexOf(r) < 0 && n.push(r)
    }), n.join(" ")
}
const OL = ["modules", "init", "_direction", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_preloadImages", "updateOnImagesReady", "_loop", "_loopAdditionalSlides", "_loopedSlides", "_loopedSlidesLimit", "_loopFillGroupWithBlank", "loopPreventsSlide", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideBlankClass", "slideActiveClass", "slideDuplicateActiveClass", "slideVisibleClass", "slideDuplicateClass", "slideNextClass", "slideDuplicateNextClass", "slidePrevClass", "slideDuplicatePrevClass", "wrapperClass", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "lazy", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom"];

function _P(t = {}, e = !0) {
    const n = {
            on: {}
        },
        r = {},
        i = {};
    Os(n, kl.defaults), Os(n, kl.extendedDefaults), n._emitClasses = !0, n.init = !1;
    const s = {},
        o = OL.map(l => l.replace(/_/, "")),
        a = Object.assign({}, t);
    return Object.keys(a).forEach(l => {
        typeof t[l] > "u" || (o.indexOf(l) >= 0 ? ca(t[l]) ? (n[l] = {}, i[l] = {}, Os(n[l], t[l]), Os(i[l], t[l])) : (n[l] = t[l], i[l] = t[l]) : l.search(/on[A-Z]/) === 0 && typeof t[l] == "function" ? e ? r[`${l[2].toLowerCase()}${l.substr(3)}`] = t[l] : n.on[`${l[2].toLowerCase()}${l.substr(3)}`] = t[l] : s[l] = t[l])
    }), ["navigation", "pagination", "scrollbar"].forEach(l => {
        n[l] === !0 && (n[l] = {}), n[l] === !1 && delete n[l]
    }), {
        params: n,
        passedParams: i,
        rest: s,
        events: r
    }
}

function hye({
    el: t,
    nextEl: e,
    prevEl: n,
    paginationEl: r,
    scrollbarEl: i,
    swiper: s
}, o) {
    TL(o) && e && n && (s.params.navigation.nextEl = e, s.originalParams.navigation.nextEl = e, s.params.navigation.prevEl = n, s.originalParams.navigation.prevEl = n), CL(o) && r && (s.params.pagination.el = r, s.originalParams.pagination.el = r), PL(o) && i && (s.params.scrollbar.el = i, s.originalParams.scrollbar.el = i), s.init(t)
}
const IL = (t, e) => {
    let n = e.slidesPerView;
    if (e.breakpoints) {
        const i = kl.prototype.getBreakpoint(e.breakpoints),
            s = i in e.breakpoints ? e.breakpoints[i] : void 0;
        s && s.slidesPerView && (n = s.slidesPerView)
    }
    let r = Math.ceil(parseFloat(e.loopedSlides || n, 10));
    return r += e.loopAdditionalSlides, r > t.length && e.loopedSlidesLimit && (r = t.length), r
};

function pye(t, e, n) {
    const r = e.map((l, c) => (l.props || (l.props = {}), l.props.swiperRef = t, l.props["data-swiper-slide-index"] = c, l));

    function i(l, c, u) {
        return l.props || (l.props = {}), Jt(l.type, { ...l.props,
            key: `${l.key}-duplicate-${c}-${u}`,
            class: `${l.props.className||""} ${n.slideDuplicateClass} ${l.props.class||""}`
        }, l.children)
    }
    if (n.loopFillGroupWithBlank) {
        const l = n.slidesPerGroup - r.length % n.slidesPerGroup;
        if (l !== n.slidesPerGroup)
            for (let c = 0; c < l; c += 1) {
                const u = Jt("div", {
                    class: `${n.slideClass} ${n.slideBlankClass}`
                });
                r.push(u)
            }
    }
    n.slidesPerView === "auto" && !n.loopedSlides && (n.loopedSlides = r.length);
    const s = IL(r, n),
        o = [],
        a = [];
    for (let l = 0; l < s; l += 1) {
        const c = l - Math.floor(l / r.length) * r.length;
        a.push(i(r[c], l, "append")), o.unshift(i(r[r.length - c - 1], l, "prepend"))
    }
    return t.value && (t.value.loopedSlides = s), [...o, ...r, ...a]
}

function mye(t, e, n, r, i) {
    const s = [];
    if (!e) return s;
    const o = l => {
        s.indexOf(l) < 0 && s.push(l)
    };
    if (n && r) {
        const l = r.map(i),
            c = n.map(i);
        l.join("") !== c.join("") && o("children"), r.length !== n.length && o("children")
    }
    return OL.filter(l => l[0] === "_").map(l => l.replace(/_/, "")).forEach(l => {
        if (l in t && l in e)
            if (ca(t[l]) && ca(e[l])) {
                const c = Object.keys(t[l]),
                    u = Object.keys(e[l]);
                c.length !== u.length ? o(l) : (c.forEach(d => {
                    t[l][d] !== e[l][d] && o(l)
                }), u.forEach(d => {
                    t[l][d] !== e[l][d] && o(l)
                }))
            } else t[l] !== e[l] && o(l)
    }), s
}

function py(t, e, n) {
    t === void 0 && (t = {});
    const r = [],
        i = {
            "container-start": [],
            "container-end": [],
            "wrapper-start": [],
            "wrapper-end": []
        },
        s = (o, a) => {
            Array.isArray(o) && o.forEach(l => {
                const c = typeof l.type == "symbol";
                a === "default" && (a = "container-end"), c && l.children ? s(l.children, "default") : l.type && (l.type.name === "SwiperSlide" || l.type.name === "AsyncComponentWrapper") ? r.push(l) : i[a] && i[a].push(l)
            })
        };
    return Object.keys(t).forEach(o => {
        if (typeof t[o] != "function") return;
        const a = t[o]();
        s(a, o)
    }), n.value = e.value, e.value = r, {
        slides: r,
        slots: i
    }
}

function gye({
    swiper: t,
    slides: e,
    passedParams: n,
    changedParams: r,
    nextEl: i,
    prevEl: s,
    scrollbarEl: o,
    paginationEl: a
}) {
    const l = r.filter(x => x !== "children" && x !== "direction"),
        {
            params: c,
            pagination: u,
            navigation: d,
            scrollbar: f,
            virtual: h,
            thumbs: p
        } = t;
    let b, y, m, g, v;
    r.includes("thumbs") && n.thumbs && n.thumbs.swiper && c.thumbs && !c.thumbs.swiper && (b = !0), r.includes("controller") && n.controller && n.controller.control && c.controller && !c.controller.control && (y = !0), r.includes("pagination") && n.pagination && (n.pagination.el || a) && (c.pagination || c.pagination === !1) && u && !u.el && (m = !0), r.includes("scrollbar") && n.scrollbar && (n.scrollbar.el || o) && (c.scrollbar || c.scrollbar === !1) && f && !f.el && (g = !0), r.includes("navigation") && n.navigation && (n.navigation.prevEl || s) && (n.navigation.nextEl || i) && (c.navigation || c.navigation === !1) && d && !d.prevEl && !d.nextEl && (v = !0);
    const _ = x => {
        t[x] && (t[x].destroy(), x === "navigation" ? (c[x].prevEl = void 0, c[x].nextEl = void 0, t[x].prevEl = void 0, t[x].nextEl = void 0) : (c[x].el = void 0, t[x].el = void 0))
    };
    l.forEach(x => {
        if (ca(c[x]) && ca(n[x])) Os(c[x], n[x]);
        else {
            const w = n[x];
            (w === !0 || w === !1) && (x === "navigation" || x === "pagination" || x === "scrollbar") ? w === !1 && _(x): c[x] = n[x]
        }
    }), l.includes("controller") && !y && t.controller && t.controller.control && c.controller && c.controller.control && (t.controller.control = c.controller.control), r.includes("children") && e && h && c.virtual.enabled ? (h.slides = e, h.update(!0)) : r.includes("children") && t.lazy && t.params.lazy.enabled && t.lazy.load(), b && p.init() && p.update(!0), y && (t.controller.control = c.controller.control), m && (a && (c.pagination.el = a), u.init(), u.render(), u.update()), g && (o && (c.scrollbar.el = o), f.init(), f.updateSize(), f.setTranslate()), v && (i && (c.navigation.nextEl = i), s && (c.navigation.prevEl = s), d.init(), d.update()), r.includes("allowSlideNext") && (t.allowSlideNext = n.allowSlideNext), r.includes("allowSlidePrev") && (t.allowSlidePrev = n.allowSlidePrev), r.includes("direction") && t.changeDirection(n.direction, !1), t.update()
}

function yye(t, e, n) {
    if (!n) return null;
    const r = t.value.isHorizontal() ? {
        [t.value.rtlTranslate ? "right" : "left"]: `${n.offset}px`
    } : {
        top: `${n.offset}px`
    };
    return e.filter((i, s) => s >= n.from && s <= n.to).map(i => (i.props || (i.props = {}), i.props.style || (i.props.style = {}), i.props.swiperRef = t, i.props.style = r, Jt(i.type, { ...i.props
    }, i.children)))
}
const vye = t => {
        !t || t.destroyed || !t.params.virtual || t.params.virtual && !t.params.virtual.enabled || (t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.lazy && t.params.lazy.enabled && t.lazy.load(), t.parallax && t.params.parallax && t.params.parallax.enabled && t.parallax.setTranslate())
    },
    Owe = {
        name: "Swiper",
        props: {
            tag: {
                type: String,
                default: "div"
            },
            wrapperTag: {
                type: String,
                default: "div"
            },
            modules: {
                type: Array,
                default: void 0
            },
            init: {
                type: Boolean,
                default: void 0
            },
            direction: {
                type: String,
                default: void 0
            },
            touchEventsTarget: {
                type: String,
                default: void 0
            },
            initialSlide: {
                type: Number,
                default: void 0
            },
            speed: {
                type: Number,
                default: void 0
            },
            cssMode: {
                type: Boolean,
                default: void 0
            },
            updateOnWindowResize: {
                type: Boolean,
                default: void 0
            },
            resizeObserver: {
                type: Boolean,
                default: void 0
            },
            nested: {
                type: Boolean,
                default: void 0
            },
            focusableElements: {
                type: String,
                default: void 0
            },
            width: {
                type: Number,
                default: void 0
            },
            height: {
                type: Number,
                default: void 0
            },
            preventInteractionOnTransition: {
                type: Boolean,
                default: void 0
            },
            userAgent: {
                type: String,
                default: void 0
            },
            url: {
                type: String,
                default: void 0
            },
            edgeSwipeDetection: {
                type: [Boolean, String],
                default: void 0
            },
            edgeSwipeThreshold: {
                type: Number,
                default: void 0
            },
            autoHeight: {
                type: Boolean,
                default: void 0
            },
            setWrapperSize: {
                type: Boolean,
                default: void 0
            },
            virtualTranslate: {
                type: Boolean,
                default: void 0
            },
            effect: {
                type: String,
                default: void 0
            },
            breakpoints: {
                type: Object,
                default: void 0
            },
            spaceBetween: {
                type: Number,
                default: void 0
            },
            slidesPerView: {
                type: [Number, String],
                default: void 0
            },
            maxBackfaceHiddenSlides: {
                type: Number,
                default: void 0
            },
            slidesPerGroup: {
                type: Number,
                default: void 0
            },
            slidesPerGroupSkip: {
                type: Number,
                default: void 0
            },
            slidesPerGroupAuto: {
                type: Boolean,
                default: void 0
            },
            centeredSlides: {
                type: Boolean,
                default: void 0
            },
            centeredSlidesBounds: {
                type: Boolean,
                default: void 0
            },
            slidesOffsetBefore: {
                type: Number,
                default: void 0
            },
            slidesOffsetAfter: {
                type: Number,
                default: void 0
            },
            normalizeSlideIndex: {
                type: Boolean,
                default: void 0
            },
            centerInsufficientSlides: {
                type: Boolean,
                default: void 0
            },
            watchOverflow: {
                type: Boolean,
                default: void 0
            },
            roundLengths: {
                type: Boolean,
                default: void 0
            },
            touchRatio: {
                type: Number,
                default: void 0
            },
            touchAngle: {
                type: Number,
                default: void 0
            },
            simulateTouch: {
                type: Boolean,
                default: void 0
            },
            shortSwipes: {
                type: Boolean,
                default: void 0
            },
            longSwipes: {
                type: Boolean,
                default: void 0
            },
            longSwipesRatio: {
                type: Number,
                default: void 0
            },
            longSwipesMs: {
                type: Number,
                default: void 0
            },
            followFinger: {
                type: Boolean,
                default: void 0
            },
            allowTouchMove: {
                type: Boolean,
                default: void 0
            },
            threshold: {
                type: Number,
                default: void 0
            },
            touchMoveStopPropagation: {
                type: Boolean,
                default: void 0
            },
            touchStartPreventDefault: {
                type: Boolean,
                default: void 0
            },
            touchStartForcePreventDefault: {
                type: Boolean,
                default: void 0
            },
            touchReleaseOnEdges: {
                type: Boolean,
                default: void 0
            },
            uniqueNavElements: {
                type: Boolean,
                default: void 0
            },
            resistance: {
                type: Boolean,
                default: void 0
            },
            resistanceRatio: {
                type: Number,
                default: void 0
            },
            watchSlidesProgress: {
                type: Boolean,
                default: void 0
            },
            grabCursor: {
                type: Boolean,
                default: void 0
            },
            preventClicks: {
                type: Boolean,
                default: void 0
            },
            preventClicksPropagation: {
                type: Boolean,
                default: void 0
            },
            slideToClickedSlide: {
                type: Boolean,
                default: void 0
            },
            preloadImages: {
                type: Boolean,
                default: void 0
            },
            updateOnImagesReady: {
                type: Boolean,
                default: void 0
            },
            loop: {
                type: Boolean,
                default: void 0
            },
            loopAdditionalSlides: {
                type: Number,
                default: void 0
            },
            loopedSlides: {
                type: Number,
                default: void 0
            },
            loopedSlidesLimit: {
                type: Boolean,
                default: !0
            },
            loopFillGroupWithBlank: {
                type: Boolean,
                default: void 0
            },
            loopPreventsSlide: {
                type: Boolean,
                default: void 0
            },
            rewind: {
                type: Boolean,
                default: void 0
            },
            allowSlidePrev: {
                type: Boolean,
                default: void 0
            },
            allowSlideNext: {
                type: Boolean,
                default: void 0
            },
            swipeHandler: {
                type: Boolean,
                default: void 0
            },
            noSwiping: {
                type: Boolean,
                default: void 0
            },
            noSwipingClass: {
                type: String,
                default: void 0
            },
            noSwipingSelector: {
                type: String,
                default: void 0
            },
            passiveListeners: {
                type: Boolean,
                default: void 0
            },
            containerModifierClass: {
                type: String,
                default: void 0
            },
            slideClass: {
                type: String,
                default: void 0
            },
            slideBlankClass: {
                type: String,
                default: void 0
            },
            slideActiveClass: {
                type: String,
                default: void 0
            },
            slideDuplicateActiveClass: {
                type: String,
                default: void 0
            },
            slideVisibleClass: {
                type: String,
                default: void 0
            },
            slideDuplicateClass: {
                type: String,
                default: void 0
            },
            slideNextClass: {
                type: String,
                default: void 0
            },
            slideDuplicateNextClass: {
                type: String,
                default: void 0
            },
            slidePrevClass: {
                type: String,
                default: void 0
            },
            slideDuplicatePrevClass: {
                type: String,
                default: void 0
            },
            wrapperClass: {
                type: String,
                default: void 0
            },
            runCallbacksOnInit: {
                type: Boolean,
                default: void 0
            },
            observer: {
                type: Boolean,
                default: void 0
            },
            observeParents: {
                type: Boolean,
                default: void 0
            },
            observeSlideChildren: {
                type: Boolean,
                default: void 0
            },
            a11y: {
                type: [Boolean, Object],
                default: void 0
            },
            autoplay: {
                type: [Boolean, Object],
                default: void 0
            },
            controller: {
                type: Object,
                default: void 0
            },
            coverflowEffect: {
                type: Object,
                default: void 0
            },
            cubeEffect: {
                type: Object,
                default: void 0
            },
            fadeEffect: {
                type: Object,
                default: void 0
            },
            flipEffect: {
                type: Object,
                default: void 0
            },
            creativeEffect: {
                type: Object,
                default: void 0
            },
            cardsEffect: {
                type: Object,
                default: void 0
            },
            hashNavigation: {
                type: [Boolean, Object],
                default: void 0
            },
            history: {
                type: [Boolean, Object],
                default: void 0
            },
            keyboard: {
                type: [Boolean, Object],
                default: void 0
            },
            lazy: {
                type: [Boolean, Object],
                default: void 0
            },
            mousewheel: {
                type: [Boolean, Object],
                default: void 0
            },
            navigation: {
                type: [Boolean, Object],
                default: void 0
            },
            pagination: {
                type: [Boolean, Object],
                default: void 0
            },
            parallax: {
                type: [Boolean, Object],
                default: void 0
            },
            scrollbar: {
                type: [Boolean, Object],
                default: void 0
            },
            thumbs: {
                type: Object,
                default: void 0
            },
            virtual: {
                type: [Boolean, Object],
                default: void 0
            },
            zoom: {
                type: [Boolean, Object],
                default: void 0
            },
            grid: {
                type: [Object],
                default: void 0
            },
            freeMode: {
                type: [Boolean, Object],
                default: void 0
            },
            enabled: {
                type: Boolean,
                default: void 0
            }
        },
        emits: ["_beforeBreakpoint", "_containerClasses", "_slideClass", "_slideClasses", "_swiper", "_freeModeNoMomentumRelease", "activeIndexChange", "afterInit", "autoplay", "autoplayStart", "autoplayStop", "autoplayPause", "autoplayResume", "beforeDestroy", "beforeInit", "beforeLoopFix", "beforeResize", "beforeSlideChangeStart", "beforeTransitionStart", "breakpoint", "changeDirection", "click", "disable", "doubleTap", "doubleClick", "destroy", "enable", "fromEdge", "hashChange", "hashSet", "imagesReady", "init", "keyPress", "lazyImageLoad", "lazyImageReady", "lock", "loopFix", "momentumBounce", "navigationHide", "navigationShow", "navigationPrev", "navigationNext", "observerUpdate", "orientationchange", "paginationHide", "paginationRender", "paginationShow", "paginationUpdate", "progress", "reachBeginning", "reachEnd", "realIndexChange", "resize", "scroll", "scrollbarDragEnd", "scrollbarDragMove", "scrollbarDragStart", "setTransition", "setTranslate", "slideChange", "slideChangeTransitionEnd", "slideChangeTransitionStart", "slideNextTransitionEnd", "slideNextTransitionStart", "slidePrevTransitionEnd", "slidePrevTransitionStart", "slideResetTransitionStart", "slideResetTransitionEnd", "sliderMove", "sliderFirstMove", "slidesLengthChange", "slidesGridLengthChange", "snapGridLengthChange", "snapIndexChange", "swiper", "tap", "toEdge", "touchEnd", "touchMove", "touchMoveOpposite", "touchStart", "transitionEnd", "transitionStart", "unlock", "update", "virtualUpdate", "zoomChange"],
        setup(t, e) {
            let {
                slots: n,
                emit: r
            } = e;
            const {
                tag: i,
                wrapperTag: s
            } = t, o = q("swiper"), a = q(null), l = q(!1), c = q(!1), u = q(null), d = q(null), f = q(null), h = {
                value: []
            }, p = {
                value: []
            }, b = q(null), y = q(null), m = q(null), g = q(null), {
                params: v,
                passedParams: _
            } = _P(t, !1);
            py(n, h, p), f.value = _, p.value = h.value;
            const x = () => {
                py(n, h, p), l.value = !0
            };
            if (v.onAny = function(E) {
                    for (var C = arguments.length, A = new Array(C > 1 ? C - 1 : 0), T = 1; T < C; T++) A[T - 1] = arguments[T];
                    r(E, ...A)
                }, Object.assign(v.on, {
                    _beforeBreakpoint: x,
                    _containerClasses(E, C) {
                        o.value = C
                    }
                }), d.value = new kl(v), d.value.loopCreate = () => {}, d.value.loopDestroy = () => {}, v.loop && (d.value.loopedSlides = IL(h.value, v)), d.value.virtual && d.value.params.virtual.enabled) {
                d.value.virtual.slides = h.value;
                const E = {
                    cache: !1,
                    slides: h.value,
                    renderExternal: C => {
                        a.value = C
                    },
                    renderExternalUpdate: !1
                };
                Os(d.value.params.virtual, E), Os(d.value.originalParams.virtual, E)
            }
            ga(() => {
                !c.value && d.value && (d.value.emitSlidesClasses(), c.value = !0);
                const {
                    passedParams: E
                } = _P(t, !1), C = mye(E, f.value, h.value, p.value, A => A.props && A.props.key);
                f.value = E, (C.length || l.value) && d.value && !d.value.destroyed && gye({
                    swiper: d.value,
                    slides: h.value,
                    passedParams: E,
                    changedParams: C,
                    nextEl: b.value,
                    prevEl: y.value,
                    scrollbarEl: g.value,
                    paginationEl: m.value
                }), l.value = !1
            }), gr("swiper", d), he(a, () => {
                Ue(() => {
                    vye(d.value)
                })
            }), _t(() => {
                u.value && (hye({
                    el: u.value,
                    nextEl: b.value,
                    prevEl: y.value,
                    paginationEl: m.value,
                    scrollbarEl: g.value,
                    swiper: d.value
                }, v), r("swiper", d.value))
            }), nr(() => {
                d.value && !d.value.destroyed && d.value.destroy(!0, !1)
            });

            function w(E) {
                return v.virtual ? yye(d, E, a.value) : !v.loop || d.value && d.value.destroyed ? (E.forEach(C => {
                    C.props || (C.props = {}), C.props.swiperRef = d
                }), E) : pye(d, E, v)
            }
            return () => {
                const {
                    slides: E,
                    slots: C
                } = py(n, h, p);
                return Jt(i, {
                    ref: u,
                    class: AL(o.value)
                }, [C["container-start"], Jt(s, {
                    class: "swiper-wrapper"
                }, [C["wrapper-start"], w(E), C["wrapper-end"]]), TL(t) && [Jt("div", {
                    ref: y,
                    class: "swiper-button-prev"
                }), Jt("div", {
                    ref: b,
                    class: "swiper-button-next"
                })], PL(t) && Jt("div", {
                    ref: g,
                    class: "swiper-scrollbar"
                }), CL(t) && Jt("div", {
                    ref: m,
                    class: "swiper-pagination"
                }), C["container-end"]])
            }
        }
    },
    Iwe = {
        name: "SwiperSlide",
        props: {
            tag: {
                type: String,
                default: "div"
            },
            swiperRef: {
                type: Object,
                required: !1
            },
            zoom: {
                type: Boolean,
                default: void 0
            },
            virtualIndex: {
                type: [String, Number],
                default: void 0
            }
        },
        setup(t, e) {
            let {
                slots: n
            } = e, r = !1;
            const {
                swiperRef: i
            } = t, s = q(null), o = q("swiper-slide");

            function a(c, u, d) {
                u === s.value && (o.value = d)
            }
            _t(() => {
                !i || !i.value || (i.value.on("_slideClass", a), r = !0)
            }), up(() => {
                r || !i || !i.value || (i.value.on("_slideClass", a), r = !0)
            }), ga(() => {
                !s.value || !i || !i.value || i.value.destroyed && o.value !== "swiper-slide" && (o.value = "swiper-slide")
            }), nr(() => {
                !i || !i.value || i.value.off("_slideClass", a)
            });
            const l = te(() => ({
                isActive: o.value.indexOf("swiper-slide-active") >= 0 || o.value.indexOf("swiper-slide-duplicate-active") >= 0,
                isVisible: o.value.indexOf("swiper-slide-visible") >= 0,
                isDuplicate: o.value.indexOf("swiper-slide-duplicate") >= 0,
                isPrev: o.value.indexOf("swiper-slide-prev") >= 0 || o.value.indexOf("swiper-slide-duplicate-prev") >= 0,
                isNext: o.value.indexOf("swiper-slide-next") >= 0 || o.value.indexOf("swiper-slide-duplicate-next") >= 0
            }));
            return gr("swiperSlide", l), () => Jt(t.tag, {
                class: AL(`${o.value}`),
                ref: s,
                "data-swiper-slide-index": t.virtualIndex
            }, t.zoom ? Jt("div", {
                class: "swiper-zoom-container",
                "data-swiper-zoom": typeof t.zoom == "number" ? t.zoom : void 0
            }, n.default && n.default(l.value)) : n.default && n.default(l.value))
        }
    };
var ye = {
    pullStartY: null,
    pullMoveY: null,
    handlers: [],
    styleEl: null,
    events: null,
    dist: 0,
    state: "pending",
    timeout: null,
    distResisted: 0,
    supportsPassive: !1,
    supportsPointerEvents: typeof window < "u" && !!window.PointerEvent
};
try {
    window.addEventListener("test", null, {
        get passive() {
            ye.supportsPassive = !0
        }
    })
} catch {}

function _ye(t) {
    if (!t.ptrElement) {
        var e = document.createElement("div");
        t.mainElement !== document.body ? t.mainElement.parentNode.insertBefore(e, t.mainElement) : document.body.insertBefore(e, document.body.firstChild), e.classList.add(t.classPrefix + "ptr"), e.innerHTML = t.getMarkup().replace(/__PREFIX__/g, t.classPrefix), t.ptrElement = e, typeof t.onInit == "function" && t.onInit(t), ye.styleEl || (ye.styleEl = document.createElement("style"), ye.styleEl.setAttribute("id", "pull-to-refresh-js-style"), document.head.appendChild(ye.styleEl)), ye.styleEl.textContent = t.getStyles().replace(/__PREFIX__/g, t.classPrefix).replace(/\s+/g, " ")
    }
    return t
}

function bye(t) {
    t.ptrElement && (t.ptrElement.classList.remove(t.classPrefix + "refresh"), t.ptrElement.style[t.cssProp] = "0px", setTimeout(function() {
        t.ptrElement && t.ptrElement.parentNode && (t.ptrElement.parentNode.removeChild(t.ptrElement), t.ptrElement = null), ye.state = "pending"
    }, t.refreshTimeout))
}

function xye(t) {
    var e = t.ptrElement.querySelector("." + t.classPrefix + "icon"),
        n = t.ptrElement.querySelector("." + t.classPrefix + "text");
    e && (ye.state === "refreshing" ? e.innerHTML = t.iconRefreshing : e.innerHTML = t.iconArrow), n && (ye.state === "releasing" && (n.innerHTML = t.instructionsReleaseToRefresh), (ye.state === "pulling" || ye.state === "pending") && (n.innerHTML = t.instructionsPullToRefresh), ye.state === "refreshing" && (n.innerHTML = t.instructionsRefreshing))
}
var jn = {
        setupDOM: _ye,
        onReset: bye,
        update: xye
    },
    bP, my = function(e) {
        return ye.pointerEventsEnabled && ye.supportsPointerEvents ? e.screenY : e.touches[0].screenY
    },
    ML = function() {
        var t;

        function e(o) {
            var a = ye.handlers.filter(function(l) {
                return l.contains(o.target)
            })[0];
            ye.enable = !!a, a && ye.state === "pending" && (t = jn.setupDOM(a), a.shouldPullToRefresh() && (ye.pullStartY = my(o)), clearTimeout(ye.timeout), jn.update(a))
        }

        function n(o) {
            if (t && t.ptrElement && ye.enable) {
                if (ye.pullStartY ? ye.pullMoveY = my(o) : t.shouldPullToRefresh() && (ye.pullStartY = my(o)), ye.state === "refreshing") {
                    o.cancelable && t.shouldPullToRefresh() && ye.pullStartY < ye.pullMoveY && o.preventDefault();
                    return
                }
                ye.state === "pending" && (t.ptrElement.classList.add(t.classPrefix + "pull"), ye.state = "pulling", jn.update(t)), ye.pullStartY && ye.pullMoveY && (ye.dist = ye.pullMoveY - ye.pullStartY), ye.distExtra = ye.dist - t.distIgnore, ye.distExtra > 0 && (o.cancelable && o.preventDefault(), t.ptrElement.style[t.cssProp] = ye.distResisted + "px", ye.distResisted = t.resistanceFunction(ye.distExtra / t.distThreshold) * Math.min(t.distMax, ye.distExtra), ye.state === "pulling" && ye.distResisted > t.distThreshold && (t.ptrElement.classList.add(t.classPrefix + "release"), ye.state = "releasing", jn.update(t)), ye.state === "releasing" && ye.distResisted < t.distThreshold && (t.ptrElement.classList.remove(t.classPrefix + "release"), ye.state = "pulling", jn.update(t)))
            }
        }

        function r() {
            if (t && t.ptrElement && ye.enable) {
                if (clearTimeout(bP), bP = setTimeout(function() {
                        t && t.ptrElement && ye.state === "pending" && jn.onReset(t)
                    }, 500), ye.state === "releasing" && ye.distResisted > t.distThreshold) ye.state = "refreshing", t.ptrElement.style[t.cssProp] = t.distReload + "px", t.ptrElement.classList.add(t.classPrefix + "refresh"), ye.timeout = setTimeout(function() {
                    var o = t.onRefresh(function() {
                        return jn.onReset(t)
                    });
                    o && typeof o.then == "function" && o.then(function() {
                        return jn.onReset(t)
                    }), !o && !t.onRefresh.length && jn.onReset(t)
                }, t.refreshTimeout);
                else {
                    if (ye.state === "refreshing") return;
                    t.ptrElement.style[t.cssProp] = "0px", ye.state = "pending"
                }
                jn.update(t), t.ptrElement.classList.remove(t.classPrefix + "release"), t.ptrElement.classList.remove(t.classPrefix + "pull"), ye.pullStartY = ye.pullMoveY = null, ye.dist = ye.distResisted = 0
            }
        }

        function i() {
            t && t.mainElement.classList.toggle(t.classPrefix + "top", t.shouldPullToRefresh())
        }
        var s = ye.supportsPassive ? {
            passive: ye.passive || !1
        } : void 0;
        return ye.pointerEventsEnabled && ye.supportsPointerEvents ? (window.addEventListener("pointerup", r), window.addEventListener("pointerdown", e), window.addEventListener("pointermove", n, s)) : (window.addEventListener("touchend", r), window.addEventListener("touchstart", e), window.addEventListener("touchmove", n, s)), window.addEventListener("scroll", i), {
            onTouchEnd: r,
            onTouchStart: e,
            onTouchMove: n,
            onScroll: i,
            destroy: function() {
                ye.pointerEventsEnabled && ye.supportsPointerEvents ? (window.removeEventListener("pointerdown", e), window.removeEventListener("pointerup", r), window.removeEventListener("pointermove", n, s)) : (window.removeEventListener("touchstart", e), window.removeEventListener("touchend", r), window.removeEventListener("touchmove", n, s)), window.removeEventListener("scroll", i)
            }
        }
    },
    wye = `
<div class="__PREFIX__box">
  <div class="__PREFIX__content">
    <div class="__PREFIX__icon"></div>
    <div class="__PREFIX__text"></div>
  </div>
</div>
`,
    Eye = `
.__PREFIX__ptr {
  box-shadow: inset 0 -3px 5px rgba(0, 0, 0, 0.12);
  pointer-events: none;
  font-size: 0.85em;
  font-weight: bold;
  top: 0;
  height: 0;
  transition: height 0.3s, min-height 0.3s;
  text-align: center;
  width: 100%;
  overflow: hidden;
  display: flex;
  align-items: flex-end;
  align-content: stretch;
}

.__PREFIX__box {
  padding: 10px;
  flex-basis: 100%;
}

.__PREFIX__pull {
  transition: none;
}

.__PREFIX__text {
  margin-top: .33em;
  color: rgba(0, 0, 0, 0.3);
}

.__PREFIX__icon {
  color: rgba(0, 0, 0, 0.3);
  transition: transform .3s;
}

/*
When at the top of the page, disable vertical overscroll so passive touch
listeners can take over.
*/
.__PREFIX__top {
  touch-action: pan-x pan-down pinch-zoom;
}

.__PREFIX__release .__PREFIX__icon {
  transform: rotate(180deg);
}
`,
    gy = {
        distThreshold: 60,
        distMax: 80,
        distReload: 50,
        distIgnore: 0,
        mainElement: "body",
        triggerElement: "body",
        ptrElement: ".ptr",
        classPrefix: "ptr--",
        cssProp: "min-height",
        iconArrow: "&#8675;",
        iconRefreshing: "&hellip;",
        instructionsPullToRefresh: "Pull down to refresh",
        instructionsReleaseToRefresh: "Release to refresh",
        instructionsRefreshing: "Refreshing",
        refreshTimeout: 500,
        getMarkup: function() {
            return wye
        },
        getStyles: function() {
            return Eye
        },
        onInit: function() {},
        onRefresh: function() {
            return location.reload()
        },
        resistanceFunction: function(t) {
            return Math.min(1, t / 2.5)
        },
        shouldPullToRefresh: function() {
            return !window.scrollY
        }
    },
    Sye = ["mainElement", "ptrElement", "triggerElement"],
    xP = function(t) {
        var e = {};
        return Object.keys(gy).forEach(function(n) {
            e[n] = t[n] || gy[n]
        }), e.refreshTimeout = typeof t.refreshTimeout == "number" ? t.refreshTimeout : gy.refreshTimeout, Sye.forEach(function(n) {
            typeof e[n] == "string" && (e[n] = document.querySelector(e[n]))
        }), ye.events || (ye.events = ML()), e.contains = function(n) {
            return e.triggerElement.contains(n)
        }, e.destroy = function() {
            clearTimeout(ye.timeout);
            var n = ye.handlers.indexOf(e);
            ye.handlers.splice(n, 1)
        }, e
    },
    Tye = {
        setPassiveMode: function(e) {
            ye.passive = e
        },
        setPointerEventsMode: function(e) {
            ye.pointerEventsEnabled = e
        },
        destroyAll: function() {
            ye.events && (ye.events.destroy(), ye.events = null), ye.handlers.forEach(function(e) {
                e.destroy()
            })
        },
        init: function(e) {
            e === void 0 && (e = {});
            var n = xP(e);
            return ye.handlers.push(n), n
        },
        _: {
            setupHandler: xP,
            setupEvents: ML,
            setupDOM: jn.setupDOM,
            onReset: jn.onReset,
            update: jn.update
        }
    };
const Mwe = Tye;
var RL = !1;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Bn = function() {
    return Bn = Object.assign || function(t) {
        for (var e, n = 1, r = arguments.length; n < r; n++)
            for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
        return t
    }, Bn.apply(this, arguments)
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Q0 = function(t, e) {
    return Q0 = Object.setPrototypeOf || {
        __proto__: []
    }
    instanceof Array && function(n, r) {
        n.__proto__ = r
    } || function(n, r) {
        for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (n[i] = r[i])
    }, Q0(t, e)
};

function xw(t, e) {
    if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");

    function n() {
        this.constructor = t
    }
    Q0(t, e), t.prototype = e === null ? Object.create(e) : (n.prototype = e.prototype, new n)
}
var ji = function() {
    return ji = Object.assign || function(t) {
        for (var e, n = 1, r = arguments.length; n < r; n++)
            for (var i in e = arguments[n]) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);
        return t
    }, ji.apply(this, arguments)
};

function Vi(t, e, n, r) {
    return new(n || (n = Promise))(function(i, s) {
        function o(c) {
            try {
                l(r.next(c))
            } catch (u) {
                s(u)
            }
        }

        function a(c) {
            try {
                l(r.throw(c))
            } catch (u) {
                s(u)
            }
        }

        function l(c) {
            var u;
            c.done ? i(c.value) : (u = c.value, u instanceof n ? u : new n(function(d) {
                d(u)
            })).then(o, a)
        }
        l((r = r.apply(t, e || [])).next())
    })
}

function Wi(t, e) {
    var n, r, i, s, o = {
        label: 0,
        sent: function() {
            if (1 & i[0]) throw i[1];
            return i[1]
        },
        trys: [],
        ops: []
    };
    return s = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
        return this
    }), s;

    function a(l) {
        return function(c) {
            return function(u) {
                if (n) throw new TypeError("Generator is already executing.");
                for (; o;) try {
                    if (n = 1, r && (i = 2 & u[0] ? r.return : u[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, u[1])).done) return i;
                    switch (r = 0, i && (u = [2 & u[0], i.value]), u[0]) {
                        case 0:
                        case 1:
                            i = u;
                            break;
                        case 4:
                            return o.label++, {
                                value: u[1],
                                done: !1
                            };
                        case 5:
                            o.label++, r = u[1], u = [0];
                            continue;
                        case 7:
                            u = o.ops.pop(), o.trys.pop();
                            continue;
                        default:
                            if (!((i = (i = o.trys).length > 0 && i[i.length - 1]) || u[0] !== 6 && u[0] !== 2)) {
                                o = 0;
                                continue
                            }
                            if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
                                o.label = u[1];
                                break
                            }
                            if (u[0] === 6 && o.label < i[1]) {
                                o.label = i[1], i = u;
                                break
                            }
                            if (i && o.label < i[2]) {
                                o.label = i[2], o.ops.push(u);
                                break
                            }
                            i[2] && o.ops.pop(), o.trys.pop();
                            continue
                    }
                    u = e.call(t, o)
                } catch (d) {
                    u = [6, d], r = 0
                } finally {
                    n = i = 0
                }
                if (5 & u[0]) throw u[1];
                return {
                    value: u[0] ? u[1] : void 0,
                    done: !0
                }
            }([l, c])
        }
    }
}

function Qa(t, e) {
    for (var n = 0, r = e.length, i = t.length; n < r; n++, i++) t[i] = e[n];
    return t
}
Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", {
    value: function(t, e) {
        if (this == null) throw new TypeError('"this" is null or not defined');
        var n = Object(this),
            r = n.length >>> 0;
        if (r === 0) return !1;
        for (var i, s, o = 0 | e, a = Math.max(o >= 0 ? o : r - Math.abs(o), 0); a < r;) {
            if ((i = n[a]) === (s = t) || typeof i == "number" && typeof s == "number" && isNaN(i) && isNaN(s)) return !0;
            a++
        }
        return !1
    }
}), String.prototype.includes || (String.prototype.includes = function(t, e) {
    return typeof e != "number" && (e = 0), !(e + t.length > this.length) && this.indexOf(t, e) !== -1
}), Array.prototype.find || Object.defineProperty(Array.prototype, "find", {
    value: function(t) {
        if (this == null) throw new TypeError('"this" is null or not defined');
        var e = Object(this),
            n = e.length >>> 0;
        if (typeof t != "function") throw new TypeError("predicate must be a function");
        for (var r = arguments[1], i = 0; i < n;) {
            var s = e[i];
            if (t.call(r, s, i, e)) return s;
            i++
        }
    }
});
var Uu = function(t) {
        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        return e.some(function(r) {
            return Object.prototype.toString.call(t).slice(8, -1).toLowerCase() === r
        })
    },
    Bl = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    },
    ww = function(t) {
        return [].filter.call(t, function(e) {
            return e !== `
`
        }).join("")
    },
    Is = function(t) {
        if (typeof t != "string" || (t = t.toLocaleLowerCase().trim()) === "transparent") return !1;
        var e;
        return !(/^rgba/.test(t) && ((e = /([^\s,]+)\)$/.exec(t)) === null ? 0 : typeof e == "object" ? NaN : typeof e == "number" ? e : typeof e == "string" ? e[e.length - 1] === "%" ? Number(e.slice(0, -1)) / 100 : Number(e) : NaN) === 0)
    },
    kL = function(t, e) {
        var n, r = ((n = t.padding) === null || n === void 0 ? void 0 : n.split(" ").map(function(u) {
                return e(u)
            })) || [0],
            i = 0,
            s = 0,
            o = 0,
            a = 0;
        switch (r.length) {
            case 1:
                i = s = o = a = r[0];
                break;
            case 2:
                i = s = r[0], o = a = r[1];
                break;
            case 3:
                i = r[0], o = a = r[1], s = r[2];
                break;
            default:
                i = r[0], s = r[1], o = r[2], a = r[3]
        }
        var l = {
            paddingTop: i,
            paddingBottom: s,
            paddingLeft: o,
            paddingRight: a
        };
        for (var c in l) l[c] = Bl(t, c) && Uu(t[c], "string", "number") ? e(t[c]) : l[c];
        return [i, s, o, a]
    },
    BL = function(t) {
        var e = [],
            n = t.map(function(i) {
                return Number(i)
            }).reduce(function(i, s) {
                if (s > 0) {
                    var o = i + s;
                    return e.push(o), o
                }
                return e.push(NaN), i
            }, 0),
            r = Math.random() * n;
        return e.findIndex(function(i) {
            return r <= i
        })
    },
    Ew = function(t, e, n, r) {
        r === void 0 && (r = 1 / 0), r <= 0 && (r = 1 / 0);
        for (var i = "", s = [], o = t.measureText("...").width, a = 0; a < e.length; a++) {
            i += e[a];
            var l = t.measureText(i).width,
                c = n(s);
            if (r === s.length + 1 && (l += o), c < 0) return s;
            if (l > c && (s.push(i.slice(0, -1)), i = e[a]), r === s.length) return s[s.length - 1] += "...", s
        }
        return i && s.push(i), s.length || s.push(e), s
    },
    Do = function() {
        function t() {
            this.subs = []
        }
        return t.prototype.addSub = function(e) {
            this.subs.includes(e) || this.subs.push(e)
        }, t.prototype.notify = function() {
            this.subs.forEach(function(e) {
                e.update()
            })
        }, t
    }(),
    Cye = "__proto__" in {};

function wP(t, e, n, r) {
    Object.defineProperty(t, e, {
        value: n,
        enumerable: !!r,
        writable: !0,
        configurable: !0
    })
}
var DL = Array.prototype,
    Zf = Object.create(DL);
["push", "pop", "shift", "unshift", "sort", "splice", "reverse"].forEach(function(t) {
    Zf[t] = function() {
        for (var e = [], n = 0; n < arguments.length; n++) e[n] = arguments[n];
        var r = DL[t].apply(this, e),
            i = this.__luckyOb__;
        return ["push", "unshift", "splice"].includes(t) && i.walk(this), i.dep.notify(), r
    }
});
var Pye = function() {
    function t(e) {
        this.dep = new Do, wP(e, "__luckyOb__", this), Array.isArray(e) && (Cye ? e.__proto__ = Zf : Object.getOwnPropertyNames(Zf).forEach(function(n) {
            wP(e, n, Zf[n])
        })), this.walk(e)
    }
    return t.prototype.walk = function(e) {
        Object.keys(e).forEach(function(n) {
            $L(e, n, e[n])
        })
    }, t
}();

function EP(t) {
    if (t && typeof t == "object") return "__luckyOb__" in t ? t.__luckyOb__ : new Pye(t)
}

function $L(t, e, n) {
    var r = new Do,
        i = Object.getOwnPropertyDescriptor(t, e);
    if (!i || i.configurable !== !1) {
        var s = i && i.get,
            o = i && i.set;
        s && !o || arguments.length !== 2 || (n = t[e]);
        var a = EP(n);
        Object.defineProperty(t, e, {
            get: function() {
                var l = s ? s.call(t) : n;
                return Do.target && (r.addSub(Do.target), a && a.dep.addSub(Do.target)), l
            },
            set: function(l) {
                l !== n && (n = l, s && !o || (o ? o.call(t, l) : n = l, a = EP(l), r.notify()))
            }
        })
    }
}
var Aye = 0,
    Oye = function() {
        function t(e, n, r, i) {
            i === void 0 && (i = {}), this.id = Aye++, this.$lucky = e, this.expr = n, this.deep = !!i.deep, this.getter = typeof n == "function" ? n : function(s) {
                s += ".";
                for (var o = [], a = "", l = 0; l < s.length; l++) {
                    var c = s[l];
                    if (/\[|\./.test(c)) o.push(a), a = "";
                    else {
                        if (/\W/.test(c)) continue;
                        a += c
                    }
                }
                return function(u) {
                    return o.reduce(function(d, f) {
                        return d[f]
                    }, u)
                }
            }(n), this.cb = r, this.value = this.get()
        }
        return t.prototype.get = function() {
            Do.target = this;
            var e = this.getter.call(this.$lucky, this.$lucky);
            return this.deep && function(n) {
                var r = function(i) {
                    Uu(i, "array", "object") && Object.keys(i).forEach(function(s) {
                        var o = i[s];
                        r(o)
                    })
                };
                r(n)
            }(e), Do.target = null, e
        }, t.prototype.update = function() {
            var e = this.get(),
                n = this.value;
            this.value = e, this.cb.call(this.$lucky, e, n)
        }, t
    }(),
    Sw = function() {
        function t(e, n) {
            var r = this;
            this.version = "1.7.21", this.htmlFontSize = 16, this.rAF = function() {}, this.boxWidth = 0, this.boxHeight = 0, typeof e == "string" ? e = {
                el: e
            } : e.nodeType === 1 && (e = {
                el: "",
                divElement: e
            }), e = e, this.config = e, this.data = n, e.flag || (e.flag = "WEB"), e.el && (e.divElement = document.querySelector(e.el)), e.divElement && (e.canvasElement = document.createElement("canvas"), e.divElement.appendChild(e.canvasElement)), e.canvasElement && (e.ctx = e.canvasElement.getContext("2d"), e.canvasElement.setAttribute("package", "lucky-canvas@1.7.21"), e.canvasElement.addEventListener("click", function(i) {
                return r.handleClick(i)
            })), this.ctx = e.ctx, this.initWindowFunction(), this.config.ctx || console.error(" CanvasContext2D"), window && typeof window.addEventListener == "function" && window.addEventListener("resize", function(i, s) {
                s === void 0 && (s = 300);
                var o = null;
                return function() {
                    for (var a = this, l = [], c = 0; c < arguments.length; c++) l[c] = arguments[c];
                    o || (o = setTimeout(function() {
                        i.apply(a, l), clearTimeout(o), o = null
                    }, s))
                }
            }(function() {
                return r.resize()
            }, 300)), window && typeof window.MutationObserver == "function" && new window.MutationObserver(function() {
                r.resize()
            }).observe(document.documentElement, {
                attributes: !0
            })
        }
        return t.prototype.resize = function() {
            var e, n;
            (n = (e = this.config).beforeResize) === null || n === void 0 || n.call(e), this.setHTMLFontSize(), this.setDpr(), this.resetWidthAndHeight(), this.zoomCanvas()
        }, t.prototype.initLucky = function() {
            if (this.resize(), !this.boxWidth || !this.boxHeight) return console.error("")
        }, t.prototype.handleClick = function(e) {}, t.prototype.setHTMLFontSize = function() {
            window && (this.htmlFontSize = +window.getComputedStyle(document.documentElement).fontSize.slice(0, -2))
        }, t.prototype.clearCanvas = function() {
            var e = [this.boxWidth, this.boxHeight],
                n = e[0],
                r = e[1];
            this.ctx.clearRect(-n, -r, 2 * n, 2 * r)
        }, t.prototype.setDpr = function() {
            var e = this.config;
            e.dpr || (window ? window.dpr = e.dpr = window.devicePixelRatio || 1 : e.dpr || console.error(e, " dpr "))
        }, t.prototype.resetWidthAndHeight = function() {
            var e = this.config,
                n = this.data,
                r = 0,
                i = 0;
            e.divElement && (r = e.divElement.offsetWidth, i = e.divElement.offsetHeight), this.boxWidth = this.getLength(n.width || e.width) || r, this.boxHeight = this.getLength(n.height || e.height) || i, e.divElement && (e.divElement.style.overflow = "hidden", e.divElement.style.width = this.boxWidth + "px", e.divElement.style.height = this.boxHeight + "px")
        }, t.prototype.zoomCanvas = function() {
            var e = this.config,
                n = this.ctx,
                r = e.canvasElement,
                i = e.dpr,
                s = [this.boxWidth * i, this.boxHeight * i],
                o = s[0],
                a = s[1];
            r && (r.width = o, r.height = a, r.style.width = o + "px", r.style.height = a + "px", r.style["transform-origin"] = "left top", r.style.transform = "scale(" + 1 / i + ")", n.scale(i, i))
        }, t.prototype.initWindowFunction = function() {
            var e = this.config;
            if (window) return this.rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function(r) {
                window.setTimeout(r, 1e3 / 60)
            }, e.setTimeout = window.setTimeout, e.setInterval = window.setInterval, e.clearTimeout = window.clearTimeout, void(e.clearInterval = window.clearInterval);
            if (e.rAF) this.rAF = e.rAF;
            else if (e.setTimeout) {
                var n = e.setTimeout;
                this.rAF = function(r) {
                    return n(r, 16.7)
                }
            } else this.rAF = function(r) {
                return setTimeout(r, 16.7)
            }
        }, t.prototype.loadImg = function(e, n, r) {
            var i = this;
            return r === void 0 && (r = "$resolve"), new Promise(function(s, o) {
                if (e || o("=> '" + n.src + "' "), i.config.flag !== "WEB") return n[r] = s, void(n.$reject = o);
                var a = new Image;
                a.onload = function() {
                    return s(a)
                }, a.onerror = function() {
                    return o("=> '" + n.src + "' ")
                }, a.src = e
            })
        }, t.prototype.drawImage = function(e, n) {
            for (var r, i = [], s = 2; s < arguments.length; s++) i[s - 2] = arguments[s];
            var o = this.config,
                a = o.flag,
                l = o.dpr;
            if (["WEB", "MP-WX"].includes(a)) r = n;
            else {
                if (!["UNI-H5", "UNI-MP", "TARO-H5", "TARO-MP"].includes(a)) return console.error(" flag, !");
                r = n.path
            }
            if (!r.canvas) return i.length === 8 && (i = i.map(function(d, f) {
                return f < 4 ? d * l : d
            })), e.drawImage.apply(e, Qa([r], i));
            var c = r.canvas.getContext("2d");
            i = i.map(function(d) {
                return d * l
            });
            var u = c.getImageData.apply(c, i.slice(0, 4));
            e.putImageData.apply(e, Qa([u], i.slice(4, 6)))
        }, t.prototype.computedWidthAndHeight = function(e, n, r, i) {
            if (!n.width && !n.height) return [e.width, e.height];
            if (n.width && !n.height) {
                var s = this.getLength(n.width, r);
                return [s, e.height * (s / e.width)]
            }
            if (!n.width && n.height) {
                var o = this.getLength(n.height, i);
                return [e.width * (o / e.height), o]
            }
            return [this.getLength(n.width, r), this.getLength(n.height, i)]
        }, t.prototype.changeUnits = function(e, n) {
            var r = this;
            n === void 0 && (n = 1);
            var i = this.config;
            return Number(e.replace(/^([-]*[0-9.]*)([a-z%]*)$/, function(s, o, a) {
                var l = {
                    "%": function(u) {
                        return u * (n / 100)
                    },
                    px: function(u) {
                        return 1 * u
                    },
                    rem: function(u) {
                        return u * r.htmlFontSize
                    },
                    vw: function(u) {
                        return u / 100 * window.innerWidth
                    }
                }[a];
                if (l) return l(o);
                var c = i.handleCssUnit || i.unitFunc;
                return c ? c(o, a) : o
            }))
        }, t.prototype.getLength = function(e, n) {
            return Uu(e, "number") ? e : Uu(e, "string") ? this.changeUnits(e, n) : 0
        }, t.prototype.getOffsetX = function(e, n) {
            return n === void 0 && (n = 0), (n - e) / 2
        }, t.prototype.getOffscreenCanvas = function(e, n) {
            if (!Bl(this, "_offscreenCanvas") && (window && window.document && this.config.flag === "WEB" ? this._offscreenCanvas = document.createElement("canvas") : this._offscreenCanvas = this.config.offscreenCanvas, !this._offscreenCanvas)) return console.error(" Canvas !");
            var r = this.config.dpr,
                i = this._offscreenCanvas;
            i.width = (e || 300) * r, i.height = (n || 150) * r;
            var s = i.getContext("2d");
            return s.clearRect(0, 0, e, n), s.scale(r, r), s.dpr = r, {
                _offscreenCanvas: i,
                _ctx: s
            }
        }, t.prototype.$set = function(e, n, r) {
            e && typeof e == "object" && $L(e, n, r)
        }, t.prototype.$computed = function(e, n, r) {
            var i = this;
            Object.defineProperty(e, n, {
                get: function() {
                    return r.call(i)
                }
            })
        }, t.prototype.$watch = function(e, n, r) {
            r === void 0 && (r = {}), typeof n == "object" && (n = (r = n).handler);
            var i = new Oye(this, e, n, r);
            return r.immediate && n.call(this, i.value),
                function() {}
        }, t.version = "1.7.21", t
    }(),
    go = function(t) {
        return Math.PI / 180 * t
    },
    Hh = function(t) {
        for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        var r = e[0],
            i = e[1],
            s = e[2],
            o = e[3],
            a = e[4],
            l = Math.min(s, o),
            c = Math.PI;
        a > l / 2 && (a = l / 2), t.beginPath(), t.moveTo(r + a, i), t.lineTo(r + a, i), t.lineTo(r + s - a, i), t.arc(r + s - a, i + a, a, -c / 2, 0), t.lineTo(r + s, i + o - a), t.arc(r + s - a, i + o - a, a, 0, c / 2), t.lineTo(r + a, i + o), t.arc(r + a, i + o - a, a, c / 2, c), t.lineTo(r, i + a), t.arc(r + a, i + a, a, c, -c / 2), t.closePath()
    },
    Tw = function(t, e, n, r) {
        return t >= r && (t = r), n * (t /= r) * t + e
    },
    Dl = function(t, e, n, r) {
        return t >= r && (t = r), -n * (t /= r) * (t - 2) + e
    },
    Iye = function(t) {
        function e(n, r) {
            var i, s = t.call(this, n, {
                width: r.width,
                height: r.height
            }) || this;
            return s.blocks = [], s.prizes = [], s.buttons = [], s.defaultConfig = {}, s.defaultStyle = {}, s._defaultConfig = {}, s._defaultStyle = {}, s.Radius = 0, s.prizeRadius = 0, s.prizeDeg = 0, s.prizeAng = 0, s.rotateDeg = 0, s.maxBtnRadius = 0, s.startTime = 0, s.endTime = 0, s.stopDeg = 0, s.endDeg = 0, s.FPS = 16.6, s.step = 0, s.ImageCache = new Map, s.initData(r), s.initWatch(), s.initComputed(), (i = n.beforeCreate) === null || i === void 0 || i.call(s), s.init(), s
        }
        return xw(e, t), e.prototype.resize = function() {
            var n, r;
            t.prototype.resize.call(this), this.Radius = Math.min(this.boxWidth, this.boxHeight) / 2, this.ctx.translate(this.Radius, this.Radius), this.draw(), (r = (n = this.config).afterResize) === null || r === void 0 || r.call(n)
        }, e.prototype.initLucky = function() {
            this.Radius = 0, this.prizeRadius = 0, this.prizeDeg = 0, this.prizeAng = 0, this.rotateDeg = 0, this.maxBtnRadius = 0, this.startTime = 0, this.endTime = 0, this.stopDeg = 0, this.endDeg = 0, this.FPS = 16.6, this.prizeFlag = -1, this.step = 0, t.prototype.initLucky.call(this)
        }, e.prototype.initData = function(n) {
            this.$set(this, "width", n.width || "300px"), this.$set(this, "height", n.height || "300px"), this.$set(this, "blocks", n.blocks || []), this.$set(this, "prizes", n.prizes || []), this.$set(this, "buttons", n.buttons || []), this.$set(this, "defaultConfig", n.defaultConfig || {}), this.$set(this, "defaultStyle", n.defaultStyle || {}), this.$set(this, "startCallback", n.start), this.$set(this, "endCallback", n.end)
        }, e.prototype.initComputed = function() {
            var n = this;
            this.$computed(this, "_defaultConfig", function() {
                return ji({
                    gutter: "0px",
                    offsetDegree: 0,
                    speed: 20,
                    speedFunction: "quad",
                    accelerationTime: 2500,
                    decelerationTime: 2500,
                    stopRange: 0
                }, n.defaultConfig)
            }), this.$computed(this, "_defaultStyle", function() {
                return ji({
                    fontSize: "18px",
                    fontColor: "#000",
                    fontStyle: "sans-serif",
                    fontWeight: "400",
                    background: "rgba(0,0,0,0)",
                    wordWrap: !0,
                    lengthLimit: "90%"
                }, n.defaultStyle)
            })
        }, e.prototype.initWatch = function() {
            var n = this;
            this.$watch("width", function(r) {
                n.data.width = r, n.resize()
            }), this.$watch("height", function(r) {
                n.data.height = r, n.resize()
            }), this.$watch("blocks", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("prizes", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("buttons", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("defaultConfig", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("defaultStyle", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("startCallback", function() {
                return n.init()
            }), this.$watch("endCallback", function() {
                return n.init()
            })
        }, e.prototype.init = function() {
            var n, r;
            return Vi(this, void 0, void 0, function() {
                var i;
                return Wi(this, function(s) {
                    switch (s.label) {
                        case 0:
                            return this.initLucky(), i = this.config, (n = i.beforeInit) === null || n === void 0 || n.call(this), this.draw(), this.draw(), [4, this.initImageCache()];
                        case 1:
                            return s.sent(), (r = i.afterInit) === null || r === void 0 || r.call(this), [2]
                    }
                })
            })
        }, e.prototype.initImageCache = function() {
            var n = this;
            return new Promise(function(r) {
                var i = {
                    blocks: n.blocks.map(function(s) {
                        return s.imgs
                    }),
                    prizes: n.prizes.map(function(s) {
                        return s.imgs
                    }),
                    buttons: n.buttons.map(function(s) {
                        return s.imgs
                    })
                };
                Object.keys(i).forEach(function(s) {
                    var o = i[s],
                        a = [];
                    o && o.forEach(function(l, c) {
                        l && l.forEach(function(u, d) {
                            a.push(n.loadAndCacheImg(s, c, d))
                        })
                    }), Promise.all(a).then(function() {
                        n.draw(), r()
                    })
                })
            })
        }, e.prototype.handleClick = function(n) {
            var r, i = this.ctx;
            i.beginPath(), i.arc(0, 0, this.maxBtnRadius, 0, 2 * Math.PI, !1), i.isPointInPath(n.offsetX, n.offsetY) && this.step === 0 && ((r = this.startCallback) === null || r === void 0 || r.call(this, n))
        }, e.prototype.loadAndCacheImg = function(n, r, i) {
            return Vi(this, void 0, void 0, function() {
                var s = this;
                return Wi(this, function(o) {
                    return [2, new Promise(function(a, l) {
                        var c = s[n][r];
                        if (c && c.imgs) {
                            var u = c.imgs[i];
                            u && s.loadImg(u.src, u).then(function(d) {
                                return Vi(s, void 0, void 0, function() {
                                    return Wi(this, function(f) {
                                        switch (f.label) {
                                            case 0:
                                                return typeof u.formatter != "function" ? [3, 2] : [4, Promise.resolve(u.formatter.call(this, d))];
                                            case 1:
                                                d = f.sent(), f.label = 2;
                                            case 2:
                                                return this.ImageCache.set(u.src, d), a(), [2]
                                        }
                                    })
                                })
                            }).catch(function(d) {
                                console.error(n + "[" + r + "].imgs[" + i + "] " + d), l()
                            })
                        }
                    })]
                })
            })
        }, e.prototype.drawBlock = function(n, r, i) {
            var s = this,
                o = this.ctx;
            Is(r.background) && (o.beginPath(), o.fillStyle = r.background, o.arc(0, 0, n, 0, 2 * Math.PI, !1), o.fill()), r.imgs && r.imgs.forEach(function(a, l) {
                var c = s.ImageCache.get(a.src);
                if (c) {
                    var u = s.computedWidthAndHeight(c, a, 2 * n, 2 * n),
                        d = u[0],
                        f = u[1],
                        h = [s.getOffsetX(d) + s.getLength(a.left, 2 * n), s.getLength(a.top, 2 * n) - n],
                        p = h[0],
                        b = h[1];
                    o.save(), a.rotate && o.rotate(go(s.rotateDeg)), s.drawImage(o, c, p, b, d, f), o.restore()
                }
            })
        }, e.prototype.draw = function() {
            var n, r, i = this,
                s = this,
                o = s.config,
                a = s.ctx,
                l = s._defaultConfig,
                c = s._defaultStyle;
            (n = o.beforeDraw) === null || n === void 0 || n.call(this, a), a.clearRect(-this.Radius, -this.Radius, 2 * this.Radius, 2 * this.Radius), this.prizeRadius = this.blocks.reduce(function(p, b, y) {
                return i.drawBlock(p, b, y), p - i.getLength(b.padding && b.padding.split(" ")[0])
            }, this.Radius), this.prizeDeg = 360 / this.prizes.length, this.prizeAng = go(this.prizeDeg);
            var u = this.prizeRadius * Math.sin(this.prizeAng / 2) * 2,
                d = go(this.rotateDeg - 90 + this.prizeDeg / 2 + l.offsetDegree),
                f = function(p, b) {
                    return i.getOffsetX(a.measureText(b).width) + i.getLength(p.left, u)
                },
                h = function(p, b, y) {
                    var m = p.lineHeight || c.lineHeight || p.fontSize || c.fontSize;
                    return i.getLength(p.top, b) + (y + 1) * i.getLength(m)
                };
            a.save(), this.prizes.forEach(function(p, b) {
                var y = d + b * i.prizeAng,
                    m = i.prizeRadius - i.maxBtnRadius,
                    g = p.background || c.background;
                Is(g) && (a.fillStyle = g, function(x, w, E, C, A, T) {
                    x.beginPath();
                    var S, P, R = go(90 / Math.PI / E * T),
                        D = C + R,
                        H = A - R;
                    x.arc(0, 0, E, D, H, !1), x.lineTo.apply(x, (S = (C + A) / 2, P = T / 2 / Math.abs(Math.sin((C - A) / 2)), [+(Math.cos(S) * P).toFixed(8), +(Math.sin(S) * P).toFixed(8)])), x.closePath()
                }(a, i.maxBtnRadius, i.prizeRadius, y - i.prizeAng / 2, y + i.prizeAng / 2, i.getLength(l.gutter)), a.fill());
                var v = Math.cos(y) * i.prizeRadius,
                    _ = Math.sin(y) * i.prizeRadius;
                a.translate(v, _), a.rotate(y + go(90)), p.imgs && p.imgs.forEach(function(x, w) {
                    var E = i.ImageCache.get(x.src);
                    if (E) {
                        var C = i.computedWidthAndHeight(E, x, i.prizeAng * i.prizeRadius, m),
                            A = C[0],
                            T = C[1],
                            S = [i.getOffsetX(A) + i.getLength(x.left, u), i.getLength(x.top, m)],
                            P = S[0],
                            R = S[1];
                        i.drawImage(a, E, P, R, A, T)
                    }
                }), p.fonts && p.fonts.forEach(function(x) {
                    var w = x.fontColor || c.fontColor,
                        E = x.fontWeight || c.fontWeight,
                        C = i.getLength(x.fontSize || c.fontSize),
                        A = x.fontStyle || c.fontStyle,
                        T = Bl(x, "wordWrap") ? x.wordWrap : c.wordWrap,
                        S = x.lengthLimit || c.lengthLimit,
                        P = x.lineClamp || c.lineClamp;
                    a.fillStyle = w, a.font = E + " " + (C >> 0) + "px " + A;
                    var R = String(x.text);
                    (T ? Ew(a, ww(R), function(D) {
                        var H = (i.prizeRadius - h(x, m, D.length)) * Math.tan(i.prizeAng / 2) * 2 - i.getLength(l.gutter);
                        return i.getLength(S, H)
                    }, P) : R.split(`
`)).filter(function(D) {
                        return !!D
                    }).forEach(function(D, H) {
                        a.fillText(D, f(x, D), h(x, m, H))
                    })
                }), a.rotate(go(360) - y - go(90)), a.translate(-v, -_)
            }), a.restore(), this.buttons.forEach(function(p, b) {
                var y = i.getLength(p.radius, i.prizeRadius);
                i.maxBtnRadius = Math.max(i.maxBtnRadius, y), Is(p.background) && (a.beginPath(), a.fillStyle = p.background, a.arc(0, 0, y, 0, 2 * Math.PI, !1), a.fill()), p.pointer && Is(p.background) && (a.beginPath(), a.fillStyle = p.background, a.moveTo(-y, 0), a.lineTo(y, 0), a.lineTo(0, 2 * -y), a.closePath(), a.fill()), p.imgs && p.imgs.forEach(function(m, g) {
                    var v = i.ImageCache.get(m.src);
                    if (v) {
                        var _ = i.computedWidthAndHeight(v, m, 2 * y, 2 * y),
                            x = _[0],
                            w = _[1],
                            E = [i.getOffsetX(x) + i.getLength(m.left, y), i.getLength(m.top, y)],
                            C = E[0],
                            A = E[1];
                        i.drawImage(a, v, C, A, x, w)
                    }
                }), p.fonts && p.fonts.forEach(function(m) {
                    var g = m.fontColor || c.fontColor,
                        v = m.fontWeight || c.fontWeight,
                        _ = i.getLength(m.fontSize || c.fontSize),
                        x = m.fontStyle || c.fontStyle;
                    a.fillStyle = g, a.font = v + " " + (_ >> 0) + "px " + x, String(m.text).split(`
`).forEach(function(w, E) {
                        a.fillText(w, f(m, w), h(m, y, E))
                    })
                })
            }), (r = o.afterDraw) === null || r === void 0 || r.call(this, a)
        }, e.prototype.carveOnGunwaleOfAMovingBoat = function() {
            var n = this,
                r = n._defaultConfig,
                i = n.prizeFlag,
                s = n.prizeDeg,
                o = n.rotateDeg;
            this.endTime = Date.now();
            for (var a = this.stopDeg = o, l = r.speed, c = (Math.random() * s - s / 2) * this.getLength(r.stopRange), u = 0, d = 0, f = 0; ++u;) {
                var h = 360 * u - i * s - o - r.offsetDegree + c - s / 2,
                    p = Dl(this.FPS, a, h, r.decelerationTime) - a;
                if (p > l) {
                    this.endDeg = l - d > p - l ? h : f;
                    break
                }
                f = h, d = p
            }
        }, e.prototype.play = function() {
            var n, r;
            this.step === 0 && (this.startTime = Date.now(), this.prizeFlag = void 0, this.step = 1, (r = (n = this.config).afterStart) === null || r === void 0 || r.call(n), this.run())
        }, e.prototype.stop = function(n) {
            if (this.step !== 0 && this.step !== 3) {
                if (!n && n !== 0) {
                    var r = this.prizes.map(function(i) {
                        return i.range
                    });
                    n = BL(r)
                }
                n < 0 ? (this.step = 0, this.prizeFlag = -1) : (this.step = 2, this.prizeFlag = n % this.prizes.length)
            }
        }, e.prototype.run = function(n) {
            var r;
            n === void 0 && (n = 0);
            var i = this,
                s = i.rAF,
                o = i.step,
                a = i.prizeFlag,
                l = i._defaultConfig,
                c = l.accelerationTime,
                u = l.decelerationTime,
                d = l.speed;
            if (o !== 0) {
                if (a !== -1) {
                    o !== 3 || this.endDeg || this.carveOnGunwaleOfAMovingBoat();
                    var f = Date.now() - this.startTime,
                        h = Date.now() - this.endTime,
                        p = this.rotateDeg;
                    if (o === 1 || f < c) {
                        this.FPS = f / n;
                        var b = Tw(f, 0, d, c);
                        b === d && (this.step = 2), p += b % 360
                    } else o === 2 ? (p += d % 360, a !== void 0 && a >= 0 && (this.step = 3, this.stopDeg = 0, this.endDeg = 0)) : o === 3 ? (p = Dl(h, this.stopDeg, this.endDeg, u), h >= u && (this.step = 0)) : this.stop(-1);
                    this.rotateDeg = p, this.draw(), s(this.run.bind(this, n + 1))
                }
            } else(r = this.endCallback) === null || r === void 0 || r.call(this, this.prizes.find(function(y, m) {
                return m === a
            }) || {})
        }, e.prototype.conversionAxis = function(n, r) {
            var i = this.config;
            return [n / i.dpr - this.Radius, r / i.dpr - this.Radius]
        }, e
    }(Sw),
    Mye = function(t) {
        function e(n, r) {
            var i, s = t.call(this, n, {
                width: r.width,
                height: r.height
            }) || this;
            return s.rows = 3, s.cols = 3, s.blocks = [], s.prizes = [], s.buttons = [], s.defaultConfig = {}, s.defaultStyle = {}, s.activeStyle = {}, s._defaultConfig = {}, s._defaultStyle = {}, s._activeStyle = {}, s.cellWidth = 0, s.cellHeight = 0, s.startTime = 0, s.endTime = 0, s.currIndex = 0, s.stopIndex = 0, s.endIndex = 0, s.demo = !1, s.timer = 0, s.FPS = 16.6, s.step = 0, s.prizeFlag = -1, s.cells = [], s.ImageCache = new Map, s.initData(r), s.initWatch(), s.initComputed(), (i = n.beforeCreate) === null || i === void 0 || i.call(s), s.init(), s
        }
        return xw(e, t), e.prototype.resize = function() {
            var n, r;
            t.prototype.resize.call(this), this.draw(), (r = (n = this.config).afterResize) === null || r === void 0 || r.call(n)
        }, e.prototype.initLucky = function() {
            this.cellWidth = 0, this.cellHeight = 0, this.startTime = 0, this.endTime = 0, this.currIndex = 0, this.stopIndex = 0, this.endIndex = 0, this.demo = !1, this.timer = 0, this.FPS = 16.6, this.prizeFlag = -1, this.step = 0, t.prototype.initLucky.call(this)
        }, e.prototype.initData = function(n) {
            this.$set(this, "width", n.width || "300px"), this.$set(this, "height", n.height || "300px"), this.$set(this, "rows", Number(n.rows) || 3), this.$set(this, "cols", Number(n.cols) || 3), this.$set(this, "blocks", n.blocks || []), this.$set(this, "prizes", n.prizes || []), this.$set(this, "buttons", n.buttons || []), this.$set(this, "button", n.button), this.$set(this, "defaultConfig", n.defaultConfig || {}), this.$set(this, "defaultStyle", n.defaultStyle || {}), this.$set(this, "activeStyle", n.activeStyle || {}), this.$set(this, "startCallback", n.start), this.$set(this, "endCallback", n.end)
        }, e.prototype.initComputed = function() {
            var n = this;
            this.$computed(this, "_defaultConfig", function() {
                var r = ji({
                    gutter: 5,
                    speed: 20,
                    accelerationTime: 2500,
                    decelerationTime: 2500
                }, n.defaultConfig);
                return r.gutter = n.getLength(r.gutter), r.speed = r.speed / 40, r
            }), this.$computed(this, "_defaultStyle", function() {
                return ji({
                    borderRadius: 20,
                    fontColor: "#000",
                    fontSize: "18px",
                    fontStyle: "sans-serif",
                    fontWeight: "400",
                    background: "rgba(0,0,0,0)",
                    shadow: "",
                    wordWrap: !0,
                    lengthLimit: "90%"
                }, n.defaultStyle)
            }), this.$computed(this, "_activeStyle", function() {
                return ji({
                    background: "#ffce98",
                    shadow: ""
                }, n.activeStyle)
            })
        }, e.prototype.initWatch = function() {
            var n = this;
            this.$watch("width", function(r) {
                n.data.width = r, n.resize()
            }), this.$watch("height", function(r) {
                n.data.height = r, n.resize()
            }), this.$watch("blocks", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("prizes", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("buttons", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("rows", function() {
                return n.init()
            }), this.$watch("cols", function() {
                return n.init()
            }), this.$watch("defaultConfig", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("defaultStyle", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("activeStyle", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("startCallback", function() {
                return n.init()
            }), this.$watch("endCallback", function() {
                return n.init()
            })
        }, e.prototype.init = function() {
            var n, r;
            return Vi(this, void 0, void 0, function() {
                var i;
                return Wi(this, function(s) {
                    switch (s.label) {
                        case 0:
                            return this.initLucky(), i = this.config, (n = i.beforeInit) === null || n === void 0 || n.call(this), this.draw(), [4, this.initImageCache()];
                        case 1:
                            return s.sent(), (r = i.afterInit) === null || r === void 0 || r.call(this), [2]
                    }
                })
            })
        }, e.prototype.initImageCache = function() {
            var n = this;
            return new Promise(function(r) {
                var i = n.buttons.map(function(o) {
                    return o.imgs
                });
                n.button && i.push(n.button.imgs);
                var s = {
                    blocks: n.blocks.map(function(o) {
                        return o.imgs
                    }),
                    prizes: n.prizes.map(function(o) {
                        return o.imgs
                    }),
                    buttons: i
                };
                Object.keys(s).forEach(function(o) {
                    var a = s[o],
                        l = [];
                    a && a.forEach(function(c, u) {
                        c && c.forEach(function(d, f) {
                            l.push(n.loadAndCacheImg(o, u, f))
                        })
                    }), Promise.all(l).then(function() {
                        n.draw(), r()
                    })
                })
            })
        }, e.prototype.handleClick = function(n) {
            var r = this,
                i = this.ctx;
            Qa(Qa([], this.buttons), [this.button]).forEach(function(s) {
                var o;
                if (s) {
                    var a = r.getGeometricProperty([s.x, s.y, s.col || 1, s.row || 1]),
                        l = a[0],
                        c = a[1],
                        u = a[2],
                        d = a[3];
                    i.beginPath(), i.rect(l, c, u, d), i.isPointInPath(n.offsetX, n.offsetY) && r.step === 0 && (typeof s.callback == "function" && s.callback.call(r, s), (o = r.startCallback) === null || o === void 0 || o.call(r, n, s))
                }
            })
        }, e.prototype.loadAndCacheImg = function(n, r, i) {
            return Vi(this, void 0, void 0, function() {
                var s = this;
                return Wi(this, function(o) {
                    return [2, new Promise(function(a, l) {
                        var c = s[n][r];
                        if (n === "buttons" && !s.buttons.length && s.button && (c = s.button), c && c.imgs) {
                            var u = c.imgs[i];
                            if (u) {
                                var d = [s.loadImg(u.src, u), u.activeSrc && s.loadImg(u.activeSrc, u, "$activeResolve")];
                                Promise.all(d).then(function(f) {
                                    var h = f[0],
                                        p = f[1];
                                    return Vi(s, void 0, void 0, function() {
                                        var b;
                                        return Wi(this, function(y) {
                                            switch (y.label) {
                                                case 0:
                                                    return typeof(b = u.formatter) != "function" ? [3, 3] : [4, Promise.resolve(b.call(this, h))];
                                                case 1:
                                                    return h = y.sent(), p ? [4, Promise.resolve(b.call(this, p))] : [3, 3];
                                                case 2:
                                                    p = y.sent(), y.label = 3;
                                                case 3:
                                                    return this.ImageCache.set(u.src, h), p && this.ImageCache.set(u.activeSrc, p), a(), [2]
                                            }
                                        })
                                    })
                                }).catch(function(f) {
                                    console.error(n + "[" + r + "].imgs[" + i + "] " + f), l()
                                })
                            }
                        }
                    })]
                })
            })
        }, e.prototype.draw = function() {
            var n, r, i = this,
                s = this,
                o = s.config,
                a = s.ctx,
                l = s._defaultConfig,
                c = s._defaultStyle,
                u = s._activeStyle;
            (n = o.beforeDraw) === null || n === void 0 || n.call(this, a), a.clearRect(0, 0, this.boxWidth, this.boxHeight), this.cells = Qa(Qa([], this.prizes), this.buttons), this.button && this.cells.push(this.button), this.cells.forEach(function(d) {
                d.col = d.col || 1, d.row = d.row || 1
            }), this.prizeArea = this.blocks.reduce(function(d, f, h) {
                var p = d.x,
                    b = d.y,
                    y = d.w,
                    m = d.h,
                    g = kL(f, i.getLength.bind(i)),
                    v = g[0],
                    _ = g[1],
                    x = g[2],
                    w = g[3],
                    E = f.borderRadius ? i.getLength(f.borderRadius) : 0,
                    C = f.background;
                return Is(C) && (a.fillStyle = i.handleBackground(p, b, y, m, C), Hh(a, p, b, y, m, E), a.fill()), f.imgs && f.imgs.forEach(function(A, T) {
                    var S = i.ImageCache.get(A.src);
                    if (S) {
                        var P = i.computedWidthAndHeight(S, A, y, m),
                            R = P[0],
                            D = P[1],
                            H = [i.getOffsetX(R, y) + i.getLength(A.left, y), i.getLength(A.top, m)],
                            B = H[0],
                            N = H[1];
                        i.drawImage(a, S, p + B, b + N, R, D)
                    }
                }), {
                    x: p + x,
                    y: b + v,
                    w: y - x - w,
                    h: m - v - _
                }
            }, {
                x: 0,
                y: 0,
                w: this.boxWidth,
                h: this.boxHeight
            }), this.cellWidth = (this.prizeArea.w - l.gutter * (this.cols - 1)) / this.cols, this.cellHeight = (this.prizeArea.h - l.gutter * (this.rows - 1)) / this.rows, this.cells.forEach(function(d, f) {
                var h = i.getGeometricProperty([d.x, d.y, d.col, d.row]),
                    p = h[0],
                    b = h[1],
                    y = h[2],
                    m = h[3],
                    g = !1;
                (i.prizeFlag === void 0 || i.prizeFlag > -1) && (g = f === i.currIndex % i.prizes.length >> 0);
                var v = g ? u.background : d.background || c.background;
                if (Is(v)) {
                    var _ = (g ? u.shadow : d.shadow || c.shadow).replace(/px/g, "").split(",")[0].split(" ").map(function(w, E) {
                        return E < 3 ? Number(w) : w
                    });
                    _.length === 4 && (a.shadowColor = _[3], a.shadowOffsetX = _[0] * o.dpr, a.shadowOffsetY = _[1] * o.dpr, a.shadowBlur = _[2], _[0] > 0 ? y -= _[0] : (y += _[0], p -= _[0]), _[1] > 0 ? m -= _[1] : (m += _[1], b -= _[1])), a.fillStyle = i.handleBackground(p, b, y, m, v);
                    var x = i.getLength(d.borderRadius ? d.borderRadius : c.borderRadius);
                    Hh(a, p, b, y, m, x), a.fill(), a.shadowColor = "rgba(0, 0, 0, 0)", a.shadowOffsetX = 0, a.shadowOffsetY = 0, a.shadowBlur = 0
                }
                f >= i.prizes.length && (f -= i.prizes.length), d.imgs && d.imgs.forEach(function(w, E) {
                    var C = i.ImageCache.get(w.src),
                        A = i.ImageCache.get(w.activeSrc);
                    if (C) {
                        var T = g && A || C;
                        if (T) {
                            var S = i.computedWidthAndHeight(T, w, y, m),
                                P = S[0],
                                R = S[1],
                                D = [p + i.getOffsetX(P, y) + i.getLength(w.left, y), b + i.getLength(w.top, m)],
                                H = D[0],
                                B = D[1];
                            i.drawImage(a, T, H, B, P, R)
                        }
                    }
                }), d.fonts && d.fonts.forEach(function(w) {
                    var E = g && u.fontStyle ? u.fontStyle : w.fontStyle || c.fontStyle,
                        C = g && u.fontWeight ? u.fontWeight : w.fontWeight || c.fontWeight,
                        A = g && u.fontSize ? i.getLength(u.fontSize) : i.getLength(w.fontSize || c.fontSize),
                        T = g && u.lineHeight ? u.lineHeight : w.lineHeight || c.lineHeight || w.fontSize || c.fontSize,
                        S = Bl(w, "wordWrap") ? w.wordWrap : c.wordWrap,
                        P = w.lengthLimit || c.lengthLimit,
                        R = w.lineClamp || c.lineClamp;
                    a.font = C + " " + (A >> 0) + "px " + E, a.fillStyle = g && u.fontColor ? u.fontColor : w.fontColor || c.fontColor;
                    var D = [],
                        H = String(w.text);
                    if (S) {
                        var B = i.getLength(P, y);
                        D = Ew(a, ww(H), function() {
                            return B
                        }, R)
                    } else D = H.split(`
`);
                    D.forEach(function(N, V) {
                        a.fillText(N, p + i.getOffsetX(a.measureText(N).width, y) + i.getLength(w.left, y), b + i.getLength(w.top, m) + (V + 1) * i.getLength(T))
                    })
                })
            }), (r = o.afterDraw) === null || r === void 0 || r.call(this, a)
        }, e.prototype.handleBackground = function(n, r, i, s, o) {
            var a = this.ctx;
            return o.includes("linear-gradient") && (o = function(l, c, u, d, f, h) {
                var p = /linear-gradient\((.+)\)/.exec(h)[1].split(",").map(function(v) {
                        return v.trim()
                    }),
                    b = p.shift(),
                    y = [0, 0, 0, 0];
                if (b.includes("deg")) {
                    var m = function(v) {
                        return Math.tan(v / 180 * Math.PI)
                    };
                    (b = b.slice(0, -3) % 360) >= 0 && b < 45 ? y = [c, u + f, c + d, u + f - d * m(b - 0)] : b >= 45 && b < 90 ? y = [c, u + f, c + d - f * m(b - 45), u] : b >= 90 && b < 135 ? y = [c + d, u + f, c + d - f * m(b - 90), u] : b >= 135 && b < 180 ? y = [c + d, u + f, c, u + d * m(b - 135)] : b >= 180 && b < 225 ? y = [c + d, u, c, u + d * m(b - 180)] : b >= 225 && b < 270 ? y = [c + d, u, c + f * m(b - 225), u + f] : b >= 270 && b < 315 ? y = [c, u, c + f * m(b - 270), u + f] : b >= 315 && b < 360 && (y = [c, u, c + d, u + f - d * m(b - 315)])
                } else b.includes("top") ? y = [c, u + f, c, u] : b.includes("bottom") ? y = [c, u, c, u + f] : b.includes("left") ? y = [c + d, u, c, u] : b.includes("right") && (y = [c, u, c + d, u]);
                var g = l.createLinearGradient.apply(l, y.map(function(v) {
                    return v >> 0
                }));
                return p.reduce(function(v, _, x) {
                    var w = _.split(" ");
                    return w.length === 1 ? v.addColorStop(x, w[0]) : w.length === 2 && v.addColorStop.apply(v, w), v
                }, g)
            }(a, n, r, i, s, o)), o
        }, e.prototype.carveOnGunwaleOfAMovingBoat = function() {
            var n = this,
                r = n._defaultConfig,
                i = n.prizeFlag,
                s = n.currIndex;
            this.endTime = Date.now();
            for (var o = this.stopIndex = s, a = r.speed, l = 0, c = 0, u = 0; ++l;) {
                var d = this.prizes.length * l + i - o,
                    f = Dl(this.FPS, o, d, r.decelerationTime) - o;
                if (f > a) {
                    this.endIndex = a - c > f - a ? d : u;
                    break
                }
                u = d, c = f
            }
        }, e.prototype.play = function() {
            var n, r;
            this.step === 0 && (this.startTime = Date.now(), this.prizeFlag = void 0, this.step = 1, (r = (n = this.config).afterStart) === null || r === void 0 || r.call(n), this.run())
        }, e.prototype.stop = function(n) {
            if (this.step !== 0 && this.step !== 3) {
                if (!n && n !== 0) {
                    var r = this.prizes.map(function(i) {
                        return i.range
                    });
                    n = BL(r)
                }
                n < 0 ? (this.step = 0, this.prizeFlag = -1) : (this.step = 2, this.prizeFlag = n % this.prizes.length)
            }
        }, e.prototype.run = function(n) {
            var r;
            n === void 0 && (n = 0);
            var i = this,
                s = i.rAF,
                o = i.step,
                a = i.prizes,
                l = i.prizeFlag,
                c = i._defaultConfig,
                u = c.accelerationTime,
                d = c.decelerationTime,
                f = c.speed;
            if (o !== 0) {
                if (l !== -1) {
                    o !== 3 || this.endIndex || this.carveOnGunwaleOfAMovingBoat();
                    var h = Date.now() - this.startTime,
                        p = Date.now() - this.endTime,
                        b = this.currIndex;
                    if (o === 1 || h < u) {
                        this.FPS = h / n;
                        var y = Tw(h, .1, f - .1, u);
                        y === f && (this.step = 2), b += y % a.length
                    } else o === 2 ? (b += f % a.length, l !== void 0 && l >= 0 && (this.step = 3, this.stopIndex = 0, this.endIndex = 0)) : o === 3 ? (b = Dl(p, this.stopIndex, this.endIndex, d), p >= d && (this.step = 0)) : this.stop(-1);
                    this.currIndex = b, this.draw(), s(this.run.bind(this, n + 1))
                }
            } else(r = this.endCallback) === null || r === void 0 || r.call(this, this.prizes.find(function(m, g) {
                return g === l
            }) || {})
        }, e.prototype.getGeometricProperty = function(n) {
            var r = n[0],
                i = n[1],
                s = n[2],
                o = s === void 0 ? 1 : s,
                a = n[3],
                l = a === void 0 ? 1 : a,
                c = this.cellWidth,
                u = this.cellHeight,
                d = this._defaultConfig.gutter,
                f = [this.prizeArea.x + (c + d) * r, this.prizeArea.y + (u + d) * i];
            return o && l && f.push(c * o + d * (o - 1), u * l + d * (l - 1)), f
        }, e.prototype.conversionAxis = function(n, r) {
            var i = this.config;
            return [n / i.dpr, r / i.dpr]
        }, e
    }(Sw),
    Rye = function(t) {
        function e(n, r) {
            var i, s = t.call(this, n, {
                width: r.width,
                height: r.height
            }) || this;
            return s.blocks = [], s.prizes = [], s.slots = [], s.defaultConfig = {}, s._defaultConfig = {}, s.defaultStyle = {}, s._defaultStyle = {}, s.endCallback = function() {}, s.cellWidth = 0, s.cellHeight = 0, s.cellAndSpacing = 0, s.widthAndSpacing = 0, s.heightAndSpacing = 0, s.FPS = 16.6, s.scroll = [], s.stopScroll = [], s.endScroll = [], s.startTime = 0, s.endTime = 0, s.step = 0, s.prizeFlag = void 0, s.ImageCache = new Map, s.initData(r), s.initWatch(), s.initComputed(), (i = n.beforeCreate) === null || i === void 0 || i.call(s), s.init(), s
        }
        return xw(e, t), e.prototype.resize = function() {
            var n, r;
            t.prototype.resize.call(this), this.draw(), (r = (n = this.config).afterResize) === null || r === void 0 || r.call(n)
        }, e.prototype.initLucky = function() {
            this.cellWidth = 0, this.cellHeight = 0, this.cellAndSpacing = 0, this.widthAndSpacing = 0, this.heightAndSpacing = 0, this.FPS = 16.6, this.scroll = [], this.stopScroll = [], this.endScroll = [], this.startTime = 0, this.endTime = 0, this.prizeFlag = void 0, this.step = 0, t.prototype.initLucky.call(this)
        }, e.prototype.initData = function(n) {
            this.$set(this, "width", n.width || "300px"), this.$set(this, "height", n.height || "300px"), this.$set(this, "blocks", n.blocks || []), this.$set(this, "prizes", n.prizes || []), this.$set(this, "slots", n.slots || []), this.$set(this, "defaultConfig", n.defaultConfig || {}), this.$set(this, "defaultStyle", n.defaultStyle || {}), this.$set(this, "endCallback", n.end)
        }, e.prototype.initComputed = function() {
            var n = this;
            this.$computed(this, "_defaultConfig", function() {
                var r = ji({
                    mode: "vertical",
                    rowSpacing: 0,
                    colSpacing: 5,
                    speed: 20,
                    direction: 1,
                    accelerationTime: 2500,
                    decelerationTime: 2500
                }, n.defaultConfig);
                return r.rowSpacing = n.getLength(r.rowSpacing), r.colSpacing = n.getLength(r.colSpacing), r
            }), this.$computed(this, "_defaultStyle", function() {
                return ji({
                    borderRadius: 0,
                    fontColor: "#000",
                    fontSize: "18px",
                    fontStyle: "sans-serif",
                    fontWeight: "400",
                    background: "rgba(0,0,0,0)",
                    wordWrap: !0,
                    lengthLimit: "90%"
                }, n.defaultStyle)
            })
        }, e.prototype.initWatch = function() {
            var n = this;
            this.$watch("width", function(r) {
                n.data.width = r, n.resize()
            }), this.$watch("height", function(r) {
                n.data.height = r, n.resize()
            }), this.$watch("blocks", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("prizes", function(r) {
                n.initImageCache()
            }, {
                deep: !0
            }), this.$watch("slots", function(r) {
                n.drawOffscreenCanvas(), n.draw()
            }, {
                deep: !0
            }), this.$watch("defaultConfig", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("defaultStyle", function() {
                return n.draw()
            }, {
                deep: !0
            }), this.$watch("endCallback", function() {
                return n.init()
            })
        }, e.prototype.init = function() {
            var n, r;
            return Vi(this, void 0, void 0, function() {
                var i;
                return Wi(this, function(s) {
                    switch (s.label) {
                        case 0:
                            return this.initLucky(), i = this.config, (n = i.beforeInit) === null || n === void 0 || n.call(this), this.drawOffscreenCanvas(), this.draw(), [4, this.initImageCache()];
                        case 1:
                            return s.sent(), (r = i.afterInit) === null || r === void 0 || r.call(this), [2]
                    }
                })
            })
        }, e.prototype.initImageCache = function() {
            var n = this;
            return new Promise(function(r) {
                var i = {
                    blocks: n.blocks.map(function(s) {
                        return s.imgs
                    }),
                    prizes: n.prizes.map(function(s) {
                        return s.imgs
                    })
                };
                Object.keys(i).forEach(function(s) {
                    var o = i[s],
                        a = [];
                    o && o.forEach(function(l, c) {
                        l && l.forEach(function(u, d) {
                            a.push(n.loadAndCacheImg(s, c, d))
                        })
                    }), Promise.all(a).then(function() {
                        n.drawOffscreenCanvas(), n.draw(), r()
                    })
                })
            })
        }, e.prototype.loadAndCacheImg = function(n, r, i) {
            return Vi(this, void 0, void 0, function() {
                var s = this;
                return Wi(this, function(o) {
                    return [2, new Promise(function(a, l) {
                        var c = s[n][r];
                        if (c && c.imgs) {
                            var u = c.imgs[i];
                            u && s.loadImg(u.src, u).then(function(d) {
                                return Vi(s, void 0, void 0, function() {
                                    return Wi(this, function(f) {
                                        switch (f.label) {
                                            case 0:
                                                return typeof u.formatter != "function" ? [3, 2] : [4, Promise.resolve(u.formatter.call(this, d))];
                                            case 1:
                                                d = f.sent(), f.label = 2;
                                            case 2:
                                                return this.ImageCache.set(u.src, d), a(), [2]
                                        }
                                    })
                                })
                            }).catch(function(d) {
                                console.error(n + "[" + r + "].imgs[" + i + "] " + d), l()
                            })
                        }
                    })]
                })
            })
        }, e.prototype.drawOffscreenCanvas = function() {
            var n = this,
                r = this._defaultConfig,
                i = this._defaultStyle,
                s = this.drawBlocks(),
                o = s.w,
                a = s.h,
                l = this.prizes.length,
                c = this.displacementWidthOrHeight(),
                u = c.cellWidth,
                d = c.cellHeight,
                f = c.widthAndSpacing,
                h = c.heightAndSpacing,
                p = new Array(l).fill(void 0).map(function(_, x) {
                    return x
                }),
                b = 0,
                y = 0;
            this.slots.forEach(function(_, x) {
                n.scroll[x] === void 0 && (n.scroll[x] = 0), _.order = _.order || p;
                var w = _.order.length;
                b = Math.max(b, o + f * w), y = Math.max(y, a + h * w)
            });
            var m = this.getOffscreenCanvas(b, y),
                g = m._offscreenCanvas,
                v = m._ctx;
            this._offscreenCanvas = g, this.slots.forEach(function(_, x) {
                var w = u * x,
                    E = d * x,
                    C = 0,
                    A = function(Y, le) {
                        for (var ae = {}, W = [], ne = 0; ne < Y.length; ne++) ae[ne] = Y[ne];
                        for (ne = 0; ne < le.length; ne++) {
                            var fe = ae[le[ne]];
                            fe && (W[ne] = fe)
                        }
                        return W
                    }(n.prizes, _.order);
                if (A.length) {
                    A.forEach(function(Y, le) {
                        if (Y) {
                            _.order[le];
                            var ae = f * le + r.colSpacing / 2,
                                W = h * le + r.rowSpacing / 2,
                                ne = n.displacement([w, W, h], [ae, E, f]),
                                fe = ne[0],
                                $ = ne[1],
                                X = ne[2];
                            C += X;
                            var F = Y.background || i.background;
                            if (Is(F)) {
                                var Z = n.getLength(Bl(Y, "borderRadius") ? Y.borderRadius : i.borderRadius);
                                Hh(v, fe, $, u, u, Z), v.fillStyle = F, v.fill()
                            }
                            Y.imgs && Y.imgs.forEach(function(K, ce) {
                                var de = n.ImageCache.get(K.src);
                                if (de) {
                                    var ge = n.computedWidthAndHeight(de, K, u, d),
                                        O = ge[0],
                                        L = ge[1],
                                        j = [fe + n.getOffsetX(O, u) + n.getLength(K.left, u), $ + n.getLength(K.top, d)],
                                        ie = j[0],
                                        oe = j[1];
                                    n.drawImage(v, de, ie, oe, O, L)
                                }
                            }), Y.fonts && Y.fonts.forEach(function(K) {
                                var ce = K.fontStyle || i.fontStyle,
                                    de = K.fontWeight || i.fontWeight,
                                    ge = n.getLength(K.fontSize || i.fontSize),
                                    O = K.lineHeight || i.lineHeight || K.fontSize || i.fontSize,
                                    L = Bl(K, "wordWrap") ? K.wordWrap : i.wordWrap,
                                    j = K.lengthLimit || i.lengthLimit,
                                    ie = K.lineClamp || i.lineClamp;
                                v.font = de + " " + (ge >> 0) + "px " + ce, v.fillStyle = K.fontColor || i.fontColor;
                                var oe = [],
                                    M = String(K.text);
                                if (L) {
                                    var k = n.getLength(j, u);
                                    oe = Ew(v, ww(M), function() {
                                        return k
                                    }, ie)
                                } else oe = M.split(`
`);
                                oe.forEach(function(U, J) {
                                    v.fillText(U, fe + n.getOffsetX(v.measureText(U).width, u) + n.getLength(K.left, u), $ + n.getLength(K.top, d) + (J + 1) * n.getLength(O))
                                })
                            })
                        }
                    });
                    for (var T = n.displacement([w, 0, u, C], [0, E, C, d]), S = T[0], P = T[1], R = T[2], D = T[3], H = C; H < y + C;) {
                        var B = n.displacement([S, H], [H, P]),
                            N = B[0],
                            V = B[1];
                        n.drawImage(v, g, S, P, R, D, N, V, R, D), H += C
                    }
                }
            })
        }, e.prototype.drawBlocks = function() {
            var n = this,
                r = this;
            r.config;
            var i = r.ctx;
            r._defaultConfig;
            var s = r._defaultStyle;
            return this.prizeArea = this.blocks.reduce(function(o, a, l) {
                var c = o.x,
                    u = o.y,
                    d = o.w,
                    f = o.h,
                    h = kL(a, n.getLength.bind(n)),
                    p = h[0],
                    b = h[1],
                    y = h[2],
                    m = h[3],
                    g = a.borderRadius ? n.getLength(a.borderRadius) : 0,
                    v = a.background || s.background;
                return Is(v) && (Hh(i, c, u, d, f, g), i.fillStyle = v, i.fill()), a.imgs && a.imgs.forEach(function(_, x) {
                    var w = n.ImageCache.get(_.src);
                    if (w) {
                        var E = n.computedWidthAndHeight(w, _, d, f),
                            C = E[0],
                            A = E[1],
                            T = [n.getOffsetX(C, d) + n.getLength(_.left, d), n.getLength(_.top, f)],
                            S = T[0],
                            P = T[1];
                        n.drawImage(i, w, c + S, u + P, C, A)
                    }
                }), {
                    x: c + y,
                    y: u + p,
                    w: d - y - m,
                    h: f - p - b
                }
            }, {
                x: 0,
                y: 0,
                w: this.boxWidth,
                h: this.boxHeight
            })
        }, e.prototype.draw = function() {
            var n, r = this,
                i = this,
                s = i.config,
                o = i.ctx;
            i._defaultConfig, i._defaultStyle, (n = s.beforeDraw) === null || n === void 0 || n.call(this, o), o.clearRect(0, 0, this.boxWidth, this.boxHeight);
            var a = this.drawBlocks(),
                l = a.x,
                c = a.y,
                u = a.w,
                d = a.h;
            if (this._offscreenCanvas) {
                var f = this,
                    h = f.cellWidth,
                    p = f.cellHeight,
                    b = f.cellAndSpacing,
                    y = f.widthAndSpacing,
                    m = f.heightAndSpacing;
                this.slots.forEach(function(g, v) {
                    var _ = b * g.order.length,
                        x = r.displacement(-(d - m) / 2, -(u - y) / 2),
                        w = r.scroll[v] + x;
                    w < 0 && (w = w % _ + _), w > _ && (w %= _);
                    var E = r.displacement([h * v, w, h, d], [w, p * v, u, p]),
                        C = E[0],
                        A = E[1],
                        T = E[2],
                        S = E[3],
                        P = r.displacement([l + y * v, c, h, d], [l, c + m * v, u, p]),
                        R = P[0],
                        D = P[1],
                        H = P[2],
                        B = P[3];
                    r.drawImage(o, r._offscreenCanvas, C, A, T, S, R, D, H, B)
                })
            }
        }, e.prototype.carveOnGunwaleOfAMovingBoat = function() {
            var n = this,
                r = this,
                i = r._defaultConfig,
                s = r.prizeFlag,
                o = r.cellAndSpacing;
            this.endTime = Date.now(), this.slots.forEach(function(a, l) {
                var c = a.order;
                if (c.length)
                    for (var u = a.speed || i.speed, d = a.direction || i.direction, f = c.findIndex(function(g) {
                            return g === s[l]
                        }), h = o * c.length, p = n.stopScroll[l] = n.scroll[l], b = 0; ++b;) {
                        var y = o * f + h * b * d - p,
                            m = Dl(n.FPS, p, y, i.decelerationTime) - p;
                        if (Math.abs(m) > u) {
                            n.endScroll[l] = y;
                            break
                        }
                    }
            })
        }, e.prototype.play = function() {
            var n, r;
            this.step === 0 && (this.startTime = Date.now(), this.prizeFlag = void 0, this.step = 1, (r = (n = this.config).afterStart) === null || r === void 0 || r.call(n), this.run())
        }, e.prototype.stop = function(n) {
            var r;
            if (this.step !== 0 && this.step !== 3) {
                if (typeof n == "number") this.prizeFlag = new Array(this.slots.length).fill(n);
                else {
                    if (!Uu(n, "array")) return this.stop(-1), console.error("stop()  " + typeof n);
                    if (n.length !== this.slots.length) return this.stop(-1), console.error("stop([" + n + "]) ");
                    this.prizeFlag = n
                }!((r = this.prizeFlag) === null || r === void 0) && r.includes(-1) ? (this.prizeFlag = [], this.step = 0) : this.step = 2
            }
        }, e.prototype.run = function(n) {
            var r, i, s = this;
            n === void 0 && (n = 0);
            var o = this,
                a = o.rAF,
                l = o.step,
                c = o.prizeFlag,
                u = o._defaultConfig,
                d = o.cellAndSpacing,
                f = o.slots,
                h = u.accelerationTime,
                p = u.decelerationTime;
            if (this.step !== 0 || (c == null ? void 0 : c.length) !== f.length) {
                if (c === void 0 || c.length) {
                    this.step !== 3 || this.endScroll.length || this.carveOnGunwaleOfAMovingBoat();
                    var b = Date.now() - this.startTime,
                        y = Date.now() - this.endTime;
                    f.forEach(function(x, w) {
                        var E = x.order;
                        if (E && E.length) {
                            var C = d * E.length,
                                A = Math.abs(x.speed || u.speed),
                                T = x.direction || u.direction,
                                S = 0,
                                P = s.scroll[w];
                            if (l === 1 || b < h) {
                                s.FPS = b / n;
                                var R = Tw(b, 0, A, h);
                                R === A && (s.step = 2), S = (P + R * T) % C
                            } else if (l === 2) S = (P + A * T) % C, (c == null ? void 0 : c.length) === f.length && (s.step = 3, s.stopScroll = [], s.endScroll = []);
                            else if (l === 3 && y) {
                                var D = s.stopScroll[w],
                                    H = s.endScroll[w];
                                S = Dl(y, D, H, p), y >= p && (s.step = 0)
                            }
                            s.scroll[w] = S
                        }
                    }), this.draw(), a(this.run.bind(this, n + 1))
                }
            } else {
                for (var m = c[0], g = 0; g < f.length; g++) {
                    var v = f[g],
                        _ = c[g];
                    if (!(!((r = v.order) === null || r === void 0) && r.includes(_)) || m !== _) {
                        m = -1;
                        break
                    }
                }(i = this.endCallback) === null || i === void 0 || i.call(this, this.prizes.find(function(x, w) {
                    return w === m
                }) || void 0)
            }
        }, e.prototype.displacement = function(n, r) {
            return this._defaultConfig.mode === "horizontal" ? r : n
        }, e.prototype.displacementWidthOrHeight = function() {
            var n = this._defaultConfig.mode,
                r = this.slots.length,
                i = this._defaultConfig,
                s = i.colSpacing,
                o = i.rowSpacing,
                a = this.prizeArea || this.drawBlocks();
            a.x, a.y;
            var l, c, u = a.w,
                d = a.h,
                f = 0,
                h = 0;
            return n === "horizontal" ? (h = this.cellHeight = (d - o * (r - 1)) / r, f = this.cellWidth = h) : (f = this.cellWidth = (u - s * (r - 1)) / r, h = this.cellHeight = f), l = this.widthAndSpacing = this.cellWidth + s, c = this.heightAndSpacing = this.cellHeight + o, this.cellAndSpacing = n === "horizontal" ? l : c, {
                cellWidth: f,
                cellHeight: h,
                widthAndSpacing: l,
                heightAndSpacing: c
            }
        }, e
    }(Sw),
    Cw = function(t, e, n) {
        e === void 0 && (e = {});
        var r = e.props,
            i = e.domProps,
            s = e.on,
            o = function(c, u) {
                var d = {};
                for (var f in c) Object.prototype.hasOwnProperty.call(c, f) && u.indexOf(f) < 0 && (d[f] = c[f]);
                if (c != null && typeof Object.getOwnPropertySymbols == "function") {
                    var h = 0;
                    for (f = Object.getOwnPropertySymbols(c); h < f.length; h++) u.indexOf(f[h]) < 0 && Object.prototype.propertyIsEnumerable.call(c, f[h]) && (d[f[h]] = c[f[h]])
                }
                return d
            }(e, ["props", "domProps", "on"]),
            a = function(c) {
                return c ? Object.entries(c).reduce(function(u, d) {
                    var f, h = d[0],
                        p = d[1];
                    return h = "on" + (h = h.charAt(0).toUpperCase() + h.slice(1)), Bn(Bn({}, u), ((f = {})[h] = p, f))
                }, {}) : null
            }(s),
            l = Bn(Bn(Bn(Bn({}, o), r), i), a);
        return Jt(t, l, n)
    },
    Pw = "@lucky-canvas/vue",
    kye = ve({
        name: "LuckyWheel",
        props: {
            width: {
                type: [String, Number]
            },
            height: {
                type: [String, Number]
            },
            blocks: {
                type: Array,
                default: function() {
                    return []
                }
            },
            prizes: {
                type: Array,
                default: function() {
                    return []
                }
            },
            buttons: {
                type: Array,
                default: function() {
                    return []
                }
            },
            defaultStyle: {
                type: Object,
                default: function() {
                    return {}
                }
            },
            defaultConfig: {
                type: Object,
                default: function() {
                    return {}
                }
            }
        },
        emits: ["start", "end", "success", "error", "finally"],
        watch: {
            blocks: function(t, e) {
                this.lucky && (this.lucky.blocks = t)
            },
            prizes: function(t, e) {
                this.lucky && (this.lucky.prizes = t)
            },
            buttons: function(t, e) {
                this.lucky && (this.lucky.buttons = t)
            }
        },
        data: function() {
            return {
                lucky: null
            }
        },
        mounted: function() {
            this.$refs.myLucky && this.$refs.myLucky.setAttribute("package", Pw + "@0.1.11");
            try {
                this.initLucky(), this.$emit("success")
            } catch (t) {
                this.$emit("error", t)
            } finally {
                this.$emit("finally")
            }
        },
        methods: {
            initLucky: function() {
                var t = this;
                this.lucky = new Iye({
                    flag: "WEB",
                    width: String(this.width),
                    height: String(this.height),
                    divElement: this.$refs.myLucky,
                    rAF: window.requestAnimationFrame,
                    setTimeout: window.setTimeout,
                    setInterval: window.setInterval,
                    clearTimeout: window.clearTimeout,
                    clearInterval: window.clearInterval
                }, Bn(Bn({}, this.$props), {
                    start: function(e) {
                        t.$emit("start", e)
                    },
                    end: function(e) {
                        t.$emit("end", e)
                    }
                }))
            },
            init: function() {
                this.lucky && this.lucky.init()
            },
            play: function() {
                var t;
                (t = this.lucky) === null || t === void 0 || t.play()
            },
            stop: function(t) {
                var e;
                (e = this.lucky) === null || e === void 0 || e.stop(t)
            }
        },
        render: function() {
            return Cw("div", {
                ref: "myLucky"
            })
        }
    }),
    Bye = ve({
        name: "LuckyGrid",
        props: {
            width: {
                type: [String, Number]
            },
            height: {
                type: [String, Number]
            },
            cols: {
                type: [String, Number],
                default: 3
            },
            rows: {
                type: [String, Number],
                default: 3
            },
            blocks: {
                type: Array,
                default: function() {
                    return []
                }
            },
            prizes: {
                type: Array,
                default: function() {
                    return []
                }
            },
            buttons: {
                type: Array,
                default: function() {
                    return []
                }
            },
            button: {
                type: Object
            },
            defaultStyle: {
                type: Object,
                default: function() {
                    return {}
                }
            },
            activeStyle: {
                type: Object,
                default: function() {
                    return {}
                }
            },
            defaultConfig: {
                type: Object,
                default: function() {
                    return {}
                }
            }
        },
        emits: ["start", "end", "success", "error", "finally"],
        watch: {
            cols: function(t, e) {
                this.lucky && (this.lucky.cols = t)
            },
            rows: function(t, e) {
                this.lucky && (this.lucky.rows = t)
            },
            blocks: function(t, e) {
                this.lucky && (this.lucky.blocks = t)
            },
            prizes: function(t, e) {
                this.lucky && (this.lucky.prizes = t)
            },
            buttons: function(t, e) {
                this.lucky && (this.lucky.buttons = t)
            },
            button: function(t, e) {
                this.lucky && (this.lucky.button = t)
            }
        },
        data: function() {
            return {
                lucky: null
            }
        },
        mounted: function() {
            this.$refs.myLucky && this.$refs.myLucky.setAttribute("package", Pw + "@0.1.11");
            try {
                this.initLucky(), this.$emit("success")
            } catch (t) {
                this.$emit("error", t)
            } finally {
                this.$emit("finally")
            }
        },
        methods: {
            initLucky: function() {
                var t = this;
                this.lucky = new Mye({
                    flag: "WEB",
                    width: String(this.width),
                    height: String(this.height),
                    divElement: this.$refs.myLucky,
                    rAF: window.requestAnimationFrame,
                    setTimeout: window.setTimeout,
                    setInterval: window.setInterval,
                    clearTimeout: window.clearTimeout,
                    clearInterval: window.clearInterval
                }, Bn(Bn({}, this.$props), {
                    start: function(e, n) {
                        t.$emit("start", e, n)
                    },
                    end: function(e) {
                        t.$emit("end", e)
                    }
                }))
            },
            init: function() {
                this.lucky && this.lucky.init()
            },
            play: function() {
                var t;
                (t = this.lucky) === null || t === void 0 || t.play()
            },
            stop: function(t) {
                var e;
                (e = this.lucky) === null || e === void 0 || e.stop(t)
            }
        },
        render: function() {
            return Cw("div", {
                ref: "myLucky"
            })
        }
    }),
    Dye = ve({
        name: "SlotMachine",
        props: {
            width: {
                type: [String, Number]
            },
            height: {
                type: [String, Number]
            },
            blocks: {
                type: Array,
                default: function() {
                    return []
                }
            },
            prizes: {
                type: Array,
                default: function() {
                    return []
                }
            },
            slots: {
                type: Array,
                default: function() {
                    return []
                }
            },
            defaultStyle: {
                type: Object,
                default: function() {
                    return {}
                }
            },
            defaultConfig: {
                type: Object,
                default: function() {
                    return {}
                }
            }
        },
        watch: {
            blocks: function(t, e) {
                this.lucky && (this.lucky.blocks = t)
            },
            slots: function(t, e) {
                this.lucky && (this.lucky.slots = t)
            },
            prizes: function(t, e) {
                this.lucky && (this.lucky.prizes = t)
            }
        },
        data: function() {
            return {
                lucky: null
            }
        },
        mounted: function() {
            this.$refs.myLucky && this.$refs.myLucky.setAttribute("package", Pw + "@0.1.11");
            try {
                this.initLucky(), this.$emit("success")
            } catch (t) {
                this.$emit("error", t)
            } finally {
                this.$emit("finally")
            }
        },
        methods: {
            initLucky: function() {
                var t = this;
                this.lucky = new Rye({
                    flag: "WEB",
                    width: String(this.width),
                    height: String(this.height),
                    divElement: this.$refs.myLucky,
                    rAF: window.requestAnimationFrame,
                    setTimeout: window.setTimeout,
                    setInterval: window.setInterval,
                    clearTimeout: window.clearTimeout,
                    clearInterval: window.clearInterval
                }, Bn(Bn({}, this.$props), {
                    start: function(e) {
                        t.$emit("start", e)
                    },
                    end: function(e) {
                        t.$emit("end", e)
                    }
                }))
            },
            init: function() {
                this.lucky && this.lucky.init()
            },
            play: function() {
                var t;
                (t = this.lucky) === null || t === void 0 || t.play()
            },
            stop: function(t) {
                var e;
                (e = this.lucky) === null || e === void 0 || e.stop(t)
            }
        },
        render: function() {
            return Cw("div", {
                ref: "myLucky"
            })
        }
    }),
    $ye = function(t) {
        t.component("LuckyWheel", kye), t.component("LuckyGrid", Bye), t.component("SlotMachine", Dye)
    };
typeof window < "u" && window.Vue && RL && $ye(window.Vue);
const FL = new Set,
    Zn = new WeakMap,
    cl = new WeakMap,
    ua = new WeakMap,
    e_ = new WeakMap,
    Fye = new WeakMap,
    $l = new WeakMap,
    zh = new WeakMap;
let Js;
const $o = "__aa_tgt",
    t_ = "__aa_del",
    Lye = t => {
        const e = zye(t);
        e && e.forEach(n => jye(n))
    },
    Nye = t => {
        t.forEach(e => {
            e.target === Js && Gye(), Zn.has(e.target) && Ea(e.target)
        })
    };

function Uye(t) {
    const e = e_.get(t);
    e == null || e.disconnect();
    let n = Zn.get(t),
        r = 0;
    const i = 5;
    n || (n = Fl(t), Zn.set(t, n));
    const {
        offsetWidth: s,
        offsetHeight: o
    } = Js, l = [n.top - i, s - (n.left + i + n.width), o - (n.top + i + n.height), n.left - i].map(u => `${-1*Math.floor(u)}px`).join(" "), c = new IntersectionObserver(() => {
        ++r > 1 && Ea(t)
    }, {
        root: Js,
        threshold: 1,
        rootMargin: l
    });
    c.observe(t), e_.set(t, c)
}

function Ea(t) {
    clearTimeout(zh.get(t));
    const e = gm(t),
        n = typeof e == "function" ? 500 : e.duration;
    zh.set(t, setTimeout(() => {
        const r = ua.get(t);
        (!r || r.finished) && (Zn.set(t, Fl(t)), Uye(t))
    }, n))
}

function Gye() {
    clearTimeout(zh.get(Js)), zh.set(Js, setTimeout(() => {
        FL.forEach(t => UL(t, e => LL(() => Ea(e))))
    }, 100))
}

function Hye(t) {
    setTimeout(() => {
        Fye.set(t, setInterval(() => LL(Ea.bind(null, t)), 2e3))
    }, Math.round(2e3 * Math.random()))
}

function LL(t) {
    typeof requestIdleCallback == "function" ? requestIdleCallback(() => t()) : requestAnimationFrame(() => t())
}
let n_, el;
typeof window < "u" && (Js = document.documentElement, n_ = new MutationObserver(Lye), el = new ResizeObserver(Nye), el.observe(Js));

function zye(t) {
    return t.reduce((e, n) => {
        if (e === !1) return !1;
        if (n.target instanceof Element) {
            if (yy(n.target), !e.has(n.target)) {
                e.add(n.target);
                for (let r = 0; r < n.target.children.length; r++) {
                    const i = n.target.children.item(r);
                    if (i) {
                        if (t_ in i) return !1;
                        yy(n.target, i), e.add(i)
                    }
                }
            }
            if (n.removedNodes.length)
                for (let r = 0; r < n.removedNodes.length; r++) {
                    const i = n.removedNodes[r];
                    if (t_ in i) return !1;
                    i instanceof Element && (e.add(i), yy(n.target, i), cl.set(i, [n.previousSibling, n.nextSibling]))
                }
        }
        return e
    }, new Set)
}

function yy(t, e) {
    !e && !($o in t) ? Object.defineProperty(t, $o, {
        value: t
    }) : e && !($o in e) && Object.defineProperty(e, $o, {
        value: t
    })
}

function jye(t) {
    var e;
    const n = Js.contains(t),
        r = Zn.has(t);
    n && cl.has(t) && cl.delete(t), ua.has(t) && ((e = ua.get(t)) === null || e === void 0 || e.cancel()), r && n ? Vye(t) : r && !n ? Yye(t) : Wye(t)
}

function qr(t) {
    return Number(t.replace(/[^0-9.\-]/g, ""))
}

function Fl(t) {
    const e = t.getBoundingClientRect();
    return {
        top: e.top + window.scrollY,
        left: e.left + window.scrollX,
        width: e.width,
        height: e.height
    }
}

function NL(t, e, n) {
    let r = e.width,
        i = e.height,
        s = n.width,
        o = n.height;
    const a = getComputedStyle(t);
    if (a.getPropertyValue("box-sizing") === "content-box") {
        const c = qr(a.paddingTop) + qr(a.paddingBottom) + qr(a.borderTopWidth) + qr(a.borderBottomWidth),
            u = qr(a.paddingLeft) + qr(a.paddingRight) + qr(a.borderRightWidth) + qr(a.borderLeftWidth);
        r -= u, s -= u, i -= c, o -= c
    }
    return [r, s, i, o].map(Math.round)
}

function gm(t) {
    return $o in t && $l.has(t[$o]) ? $l.get(t[$o]) : {
        duration: 250,
        easing: "ease-in-out"
    }
}

function UL(t, ...e) {
    e.forEach(n => n(t, $l.has(t)));
    for (let n = 0; n < t.children.length; n++) {
        const r = t.children.item(n);
        r && e.forEach(i => i(r, $l.has(r)))
    }
}

function Vye(t) {
    const e = Zn.get(t),
        n = Fl(t);
    let r;
    if (!e) return;
    const i = gm(t);
    if (typeof i != "function") {
        const s = e.left - n.left,
            o = e.top - n.top,
            [a, l, c, u] = NL(t, e, n),
            d = {
                transform: `translate(${s}px, ${o}px)`
            },
            f = {
                transform: "translate(0, 0)"
            };
        a !== l && (d.width = `${a}px`, f.width = `${l}px`), c !== u && (d.height = `${c}px`, f.height = `${u}px`), r = t.animate([d, f], i)
    } else r = new Animation(i(t, "remain", e, n)), r.play();
    ua.set(t, r), Zn.set(t, n), r.addEventListener("finish", Ea.bind(null, t))
}

function Wye(t) {
    const e = Fl(t);
    Zn.set(t, e);
    const n = gm(t);
    let r;
    typeof n != "function" ? r = t.animate([{
        transform: "scale(.98)",
        opacity: 0
    }, {
        transform: "scale(0.98)",
        opacity: 0,
        offset: .5
    }, {
        transform: "scale(1)",
        opacity: 1
    }], {
        duration: n.duration * 1.5,
        easing: "ease-in"
    }) : (r = new Animation(n(t, "add", e)), r.play()), ua.set(t, r), r.addEventListener("finish", Ea.bind(null, t))
}

function Yye(t) {
    if (!cl.has(t) || !Zn.has(t)) return;
    const [e, n] = cl.get(t);
    Object.defineProperty(t, t_, {
        value: !0
    }), n && n.parentNode && n.parentNode instanceof Element ? n.parentNode.insertBefore(t, n) : e && e.parentNode && e.parentNode.appendChild(t);
    const [r, i, s, o] = Xye(t), a = gm(t), l = Zn.get(t);
    let c;
    Object.assign(t.style, {
        position: "absolute",
        top: `${r}px`,
        left: `${i}px`,
        width: `${s}px`,
        height: `${o}px`,
        margin: 0,
        pointerEvents: "none",
        transformOrigin: "center",
        zIndex: 100
    }), typeof a != "function" ? c = t.animate([{
        transform: "scale(1)",
        opacity: 1
    }, {
        transform: "scale(.98)",
        opacity: 0
    }], {
        duration: a.duration,
        easing: "ease-out"
    }) : (c = new Animation(a(t, "remove", l)), c.play()), ua.set(t, c), c.addEventListener("finish", () => {
        var u;
        t.remove(), Zn.delete(t), cl.delete(t), ua.delete(t), (u = e_.get(t)) === null || u === void 0 || u.disconnect()
    })
}

function Xye(t) {
    const e = Zn.get(t),
        [n, , r] = NL(t, e, Fl(t));
    let i = t.parentElement;
    for (; i && (getComputedStyle(i).position === "static" || i instanceof HTMLBodyElement);) i = i.parentElement;
    i || (i = document.body);
    const s = getComputedStyle(i),
        o = Zn.get(i) || Fl(i),
        a = Math.round(e.top - o.top) - qr(s.borderTopWidth),
        l = Math.round(e.left - o.left) - qr(s.borderLeftWidth);
    return [a, l, n, r]
}

function Rwe(t, e = {}) {
    n_ && el && (getComputedStyle(t).position === "static" && Object.assign(t.style, {
        position: "relative"
    }), UL(t, Ea, Hye, n => el == null ? void 0 : el.observe(n)), typeof e == "function" ? $l.set(t, e) : $l.set(t, {
        duration: 250,
        easing: "ease-in-out",
        ...e
    }), n_.observe(t, {
        childList: !0
    }), FL.add(t))
}
var Ql = TypeError;
const qye = new Proxy({}, {
        get(t, e) {
            throw new Error(`Module "" has been externalized for browser compatibility. Cannot access ".${e}" in client code.  See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)
        }
    }),
    Kye = Object.freeze(Object.defineProperty({
        __proto__: null,
        default: qye
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    Jye = q_(Kye);
var Aw = typeof Map == "function" && Map.prototype,
    vy = Object.getOwnPropertyDescriptor && Aw ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
    jh = Aw && vy && typeof vy.get == "function" ? vy.get : null,
    SP = Aw && Map.prototype.forEach,
    Ow = typeof Set == "function" && Set.prototype,
    _y = Object.getOwnPropertyDescriptor && Ow ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
    Vh = Ow && _y && typeof _y.get == "function" ? _y.get : null,
    TP = Ow && Set.prototype.forEach,
    Zye = typeof WeakMap == "function" && WeakMap.prototype,
    tu = Zye ? WeakMap.prototype.has : null,
    Qye = typeof WeakSet == "function" && WeakSet.prototype,
    nu = Qye ? WeakSet.prototype.has : null,
    eve = typeof WeakRef == "function" && WeakRef.prototype,
    CP = eve ? WeakRef.prototype.deref : null,
    tve = Boolean.prototype.valueOf,
    nve = Object.prototype.toString,
    rve = Function.prototype.toString,
    ive = String.prototype.match,
    Iw = String.prototype.slice,
    Ms = String.prototype.replace,
    sve = String.prototype.toUpperCase,
    PP = String.prototype.toLowerCase,
    GL = RegExp.prototype.test,
    AP = Array.prototype.concat,
    Zr = Array.prototype.join,
    ove = Array.prototype.slice,
    OP = Math.floor,
    r_ = typeof BigInt == "function" ? BigInt.prototype.valueOf : null,
    by = Object.getOwnPropertySymbols,
    i_ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null,
    Ll = typeof Symbol == "function" && typeof Symbol.iterator == "object",
    ru = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === Ll || "symbol") ? Symbol.toStringTag : null,
    HL = Object.prototype.propertyIsEnumerable,
    IP = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
        return t.__proto__
    } : null);

function MP(t, e) {
    if (t === 1 / 0 || t === -1 / 0 || t !== t || t && t > -1e3 && t < 1e3 || GL.call(/e/, e)) return e;
    var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof t == "number") {
        var r = t < 0 ? -OP(-t) : OP(t);
        if (r !== t) {
            var i = String(r),
                s = Iw.call(e, i.length + 1);
            return Ms.call(i, n, "$&_") + "." + Ms.call(Ms.call(s, /([0-9]{3})/g, "$&_"), /_$/, "")
        }
    }
    return Ms.call(e, n, "$&_")
}
var s_ = Jye,
    RP = s_.custom,
    kP = VL(RP) ? RP : null,
    zL = {
        __proto__: null,
        double: '"',
        single: "'"
    },
    ave = {
        __proto__: null,
        double: /(["\\])/g,
        single: /(['\\])/g
    },
    ym = function t(e, n, r, i) {
        var s = n || {};
        if (Oi(s, "quoteStyle") && !Oi(zL, s.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
        if (Oi(s, "maxStringLength") && (typeof s.maxStringLength == "number" ? s.maxStringLength < 0 && s.maxStringLength !== 1 / 0 : s.maxStringLength !== null)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
        var o = Oi(s, "customInspect") ? s.customInspect : !0;
        if (typeof o != "boolean" && o !== "symbol") throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
        if (Oi(s, "indent") && s.indent !== null && s.indent !== "	" && !(parseInt(s.indent, 10) === s.indent && s.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
        if (Oi(s, "numericSeparator") && typeof s.numericSeparator != "boolean") throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
        var a = s.numericSeparator;
        if (typeof e > "u") return "undefined";
        if (e === null) return "null";
        if (typeof e == "boolean") return e ? "true" : "false";
        if (typeof e == "string") return YL(e, s);
        if (typeof e == "number") {
            if (e === 0) return 1 / 0 / e > 0 ? "0" : "-0";
            var l = String(e);
            return a ? MP(e, l) : l
        }
        if (typeof e == "bigint") {
            var c = String(e) + "n";
            return a ? MP(e, c) : c
        }
        var u = typeof s.depth > "u" ? 5 : s.depth;
        if (typeof r > "u" && (r = 0), r >= u && u > 0 && typeof e == "object") return o_(e) ? "[Array]" : "[Object]";
        var d = Tve(s, r);
        if (typeof i > "u") i = [];
        else if (WL(i, e) >= 0) return "[Circular]";

        function f(R, D, H) {
            if (D && (i = ove.call(i), i.push(D)), H) {
                var B = {
                    depth: s.depth
                };
                return Oi(s, "quoteStyle") && (B.quoteStyle = s.quoteStyle), t(R, B, r + 1, i)
            }
            return t(R, s, r + 1, i)
        }
        if (typeof e == "function" && !BP(e)) {
            var h = gve(e),
                p = Of(e, f);
            return "[Function" + (h ? ": " + h : " (anonymous)") + "]" + (p.length > 0 ? " { " + Zr.call(p, ", ") + " }" : "")
        }
        if (VL(e)) {
            var b = Ll ? Ms.call(String(e), /^(Symbol\(.*\))_[^)]*$/, "$1") : i_.call(e);
            return typeof e == "object" && !Ll ? wc(b) : b
        }
        if (wve(e)) {
            for (var y = "<" + PP.call(String(e.nodeName)), m = e.attributes || [], g = 0; g < m.length; g++) y += " " + m[g].name + "=" + jL(lve(m[g].value), "double", s);
            return y += ">", e.childNodes && e.childNodes.length && (y += "..."), y += "</" + PP.call(String(e.nodeName)) + ">", y
        }
        if (o_(e)) {
            if (e.length === 0) return "[]";
            var v = Of(e, f);
            return d && !Sve(v) ? "[" + a_(v, d) + "]" : "[ " + Zr.call(v, ", ") + " ]"
        }
        if (uve(e)) {
            var _ = Of(e, f);
            return !("cause" in Error.prototype) && "cause" in e && !HL.call(e, "cause") ? "{ [" + String(e) + "] " + Zr.call(AP.call("[cause]: " + f(e.cause), _), ", ") + " }" : _.length === 0 ? "[" + String(e) + "]" : "{ [" + String(e) + "] " + Zr.call(_, ", ") + " }"
        }
        if (typeof e == "object" && o) {
            if (kP && typeof e[kP] == "function" && s_) return s_(e, {
                depth: u - r
            });
            if (o !== "symbol" && typeof e.inspect == "function") return e.inspect()
        }
        if (yve(e)) {
            var x = [];
            return SP && SP.call(e, function(R, D) {
                x.push(f(D, e, !0) + " => " + f(R, e))
            }), DP("Map", jh.call(e), x, d)
        }
        if (bve(e)) {
            var w = [];
            return TP && TP.call(e, function(R) {
                w.push(f(R, e))
            }), DP("Set", Vh.call(e), w, d)
        }
        if (vve(e)) return xy("WeakMap");
        if (xve(e)) return xy("WeakSet");
        if (_ve(e)) return xy("WeakRef");
        if (fve(e)) return wc(f(Number(e)));
        if (pve(e)) return wc(f(r_.call(e)));
        if (hve(e)) return wc(tve.call(e));
        if (dve(e)) return wc(f(String(e)));
        if (typeof window < "u" && e === window) return "{ [object Window] }";
        if (typeof globalThis < "u" && e === globalThis || typeof Jo < "u" && e === Jo) return "{ [object globalThis] }";
        if (!cve(e) && !BP(e)) {
            var E = Of(e, f),
                C = IP ? IP(e) === Object.prototype : e instanceof Object || e.constructor === Object,
                A = e instanceof Object ? "" : "null prototype",
                T = !C && ru && Object(e) === e && ru in e ? Iw.call(ao(e), 8, -1) : A ? "Object" : "",
                S = C || typeof e.constructor != "function" ? "" : e.constructor.name ? e.constructor.name + " " : "",
                P = S + (T || A ? "[" + Zr.call(AP.call([], T || [], A || []), ": ") + "] " : "");
            return E.length === 0 ? P + "{}" : d ? P + "{" + a_(E, d) + "}" : P + "{ " + Zr.call(E, ", ") + " }"
        }
        return String(e)
    };

function jL(t, e, n) {
    var r = n.quoteStyle || e,
        i = zL[r];
    return i + t + i
}

function lve(t) {
    return Ms.call(String(t), /"/g, "&quot;")
}

function Sa(t) {
    return !ru || !(typeof t == "object" && (ru in t || typeof t[ru] < "u"))
}

function o_(t) {
    return ao(t) === "[object Array]" && Sa(t)
}

function cve(t) {
    return ao(t) === "[object Date]" && Sa(t)
}

function BP(t) {
    return ao(t) === "[object RegExp]" && Sa(t)
}

function uve(t) {
    return ao(t) === "[object Error]" && Sa(t)
}

function dve(t) {
    return ao(t) === "[object String]" && Sa(t)
}

function fve(t) {
    return ao(t) === "[object Number]" && Sa(t)
}

function hve(t) {
    return ao(t) === "[object Boolean]" && Sa(t)
}

function VL(t) {
    if (Ll) return t && typeof t == "object" && t instanceof Symbol;
    if (typeof t == "symbol") return !0;
    if (!t || typeof t != "object" || !i_) return !1;
    try {
        return i_.call(t), !0
    } catch {}
    return !1
}

function pve(t) {
    if (!t || typeof t != "object" || !r_) return !1;
    try {
        return r_.call(t), !0
    } catch {}
    return !1
}
var mve = Object.prototype.hasOwnProperty || function(t) {
    return t in this
};

function Oi(t, e) {
    return mve.call(t, e)
}

function ao(t) {
    return nve.call(t)
}

function gve(t) {
    if (t.name) return t.name;
    var e = ive.call(rve.call(t), /^function\s*([\w$]+)/);
    return e ? e[1] : null
}

function WL(t, e) {
    if (t.indexOf) return t.indexOf(e);
    for (var n = 0, r = t.length; n < r; n++)
        if (t[n] === e) return n;
    return -1
}

function yve(t) {
    if (!jh || !t || typeof t != "object") return !1;
    try {
        jh.call(t);
        try {
            Vh.call(t)
        } catch {
            return !0
        }
        return t instanceof Map
    } catch {}
    return !1
}

function vve(t) {
    if (!tu || !t || typeof t != "object") return !1;
    try {
        tu.call(t, tu);
        try {
            nu.call(t, nu)
        } catch {
            return !0
        }
        return t instanceof WeakMap
    } catch {}
    return !1
}

function _ve(t) {
    if (!CP || !t || typeof t != "object") return !1;
    try {
        return CP.call(t), !0
    } catch {}
    return !1
}

function bve(t) {
    if (!Vh || !t || typeof t != "object") return !1;
    try {
        Vh.call(t);
        try {
            jh.call(t)
        } catch {
            return !0
        }
        return t instanceof Set
    } catch {}
    return !1
}

function xve(t) {
    if (!nu || !t || typeof t != "object") return !1;
    try {
        nu.call(t, nu);
        try {
            tu.call(t, tu)
        } catch {
            return !0
        }
        return t instanceof WeakSet
    } catch {}
    return !1
}

function wve(t) {
    return !t || typeof t != "object" ? !1 : typeof HTMLElement < "u" && t instanceof HTMLElement ? !0 : typeof t.nodeName == "string" && typeof t.getAttribute == "function"
}

function YL(t, e) {
    if (t.length > e.maxStringLength) {
        var n = t.length - e.maxStringLength,
            r = "... " + n + " more character" + (n > 1 ? "s" : "");
        return YL(Iw.call(t, 0, e.maxStringLength), e) + r
    }
    var i = ave[e.quoteStyle || "single"];
    i.lastIndex = 0;
    var s = Ms.call(Ms.call(t, i, "\\$1"), /[\x00-\x1f]/g, Eve);
    return jL(s, "single", e)
}

function Eve(t) {
    var e = t.charCodeAt(0),
        n = {
            8: "b",
            9: "t",
            10: "n",
            12: "f",
            13: "r"
        }[e];
    return n ? "\\" + n : "\\x" + (e < 16 ? "0" : "") + sve.call(e.toString(16))
}

function wc(t) {
    return "Object(" + t + ")"
}

function xy(t) {
    return t + " { ? }"
}

function DP(t, e, n, r) {
    var i = r ? a_(n, r) : Zr.call(n, ", ");
    return t + " (" + e + ") {" + i + "}"
}

function Sve(t) {
    for (var e = 0; e < t.length; e++)
        if (WL(t[e], `
`) >= 0) return !1;
    return !0
}

function Tve(t, e) {
    var n;
    if (t.indent === "	") n = "	";
    else if (typeof t.indent == "number" && t.indent > 0) n = Zr.call(Array(t.indent + 1), " ");
    else return null;
    return {
        base: n,
        prev: Zr.call(Array(e + 1), n)
    }
}

function a_(t, e) {
    if (t.length === 0) return "";
    var n = `
` + e.prev + e.base;
    return n + Zr.call(t, "," + n) + `
` + e.prev
}

function Of(t, e) {
    var n = o_(t),
        r = [];
    if (n) {
        r.length = t.length;
        for (var i = 0; i < t.length; i++) r[i] = Oi(t, i) ? e(t[i], t) : ""
    }
    var s = typeof by == "function" ? by(t) : [],
        o;
    if (Ll) {
        o = {};
        for (var a = 0; a < s.length; a++) o["$" + s[a]] = s[a]
    }
    for (var l in t) Oi(t, l) && (n && String(Number(l)) === l && l < t.length || Ll && o["$" + l] instanceof Symbol || (GL.call(/[^\w$]/, l) ? r.push(e(l, t) + ": " + e(t[l], t)) : r.push(l + ": " + e(t[l], t))));
    if (typeof by == "function")
        for (var c = 0; c < s.length; c++) HL.call(t, s[c]) && r.push("[" + e(s[c]) + "]: " + e(t[s[c]], t));
    return r
}
var Cve = ym,
    Pve = Ql,
    vm = function(t, e, n) {
        for (var r = t, i;
            (i = r.next) != null; r = i)
            if (i.key === e) return r.next = i.next, n || (i.next = t.next, t.next = i), i
    },
    Ave = function(t, e) {
        if (t) {
            var n = vm(t, e);
            return n && n.value
        }
    },
    Ove = function(t, e, n) {
        var r = vm(t, e);
        r ? r.value = n : t.next = {
            key: e,
            next: t.next,
            value: n
        }
    },
    Ive = function(t, e) {
        return t ? !!vm(t, e) : !1
    },
    Mve = function(t, e) {
        if (t) return vm(t, e, !0)
    },
    Rve = function() {
        var e, n = {
            assert: function(r) {
                if (!n.has(r)) throw new Pve("Side channel does not contain " + Cve(r))
            },
            delete: function(r) {
                var i = e && e.next,
                    s = Mve(e, r);
                return s && i && i === s && (e = void 0), !!s
            },
            get: function(r) {
                return Ave(e, r)
            },
            has: function(r) {
                return Ive(e, r)
            },
            set: function(r, i) {
                e || (e = {
                    next: void 0
                }), Ove(e, r, i)
            }
        };
        return n
    },
    XL = Object,
    kve = Error,
    Bve = EvalError,
    Dve = RangeError,
    $ve = ReferenceError,
    Fve = SyntaxError,
    Lve = URIError,
    Nve = Math.abs,
    Uve = Math.floor,
    Gve = Math.max,
    Hve = Math.min,
    zve = Math.pow,
    jve = Math.round,
    Vve = Number.isNaN || function(e) {
        return e !== e
    },
    Wve = Vve,
    Yve = function(e) {
        return Wve(e) || e === 0 ? e : e < 0 ? -1 : 1
    },
    Xve = Object.getOwnPropertyDescriptor,
    Qf = Xve;
if (Qf) try {
    Qf([], "length")
} catch {
    Qf = null
}
var qL = Qf,
    eh = Object.defineProperty || !1;
if (eh) try {
    eh({}, "a", {
        value: 1
    })
} catch {
    eh = !1
}
var qve = eh,
    wy, $P;

function Kve() {
    return $P || ($P = 1, wy = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function") return !1;
        if (typeof Symbol.iterator == "symbol") return !0;
        var e = {},
            n = Symbol("test"),
            r = Object(n);
        if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]") return !1;
        var i = 42;
        e[n] = i;
        for (var s in e) return !1;
        if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0) return !1;
        var o = Object.getOwnPropertySymbols(e);
        if (o.length !== 1 || o[0] !== n || !Object.prototype.propertyIsEnumerable.call(e, n)) return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var a = Object.getOwnPropertyDescriptor(e, n);
            if (a.value !== i || a.enumerable !== !0) return !1
        }
        return !0
    }), wy
}
var Ey, FP;

function Jve() {
    if (FP) return Ey;
    FP = 1;
    var t = typeof Symbol < "u" && Symbol,
        e = Kve();
    return Ey = function() {
        return typeof t != "function" || typeof Symbol != "function" || typeof t("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : e()
    }, Ey
}
var Sy, LP;

function KL() {
    return LP || (LP = 1, Sy = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Sy
}
var Ty, NP;

function JL() {
    if (NP) return Ty;
    NP = 1;
    var t = XL;
    return Ty = t.getPrototypeOf || null, Ty
}
var Cy, UP;

function Zve() {
    if (UP) return Cy;
    UP = 1;
    var t = "Function.prototype.bind called on incompatible ",
        e = Object.prototype.toString,
        n = Math.max,
        r = "[object Function]",
        i = function(l, c) {
            for (var u = [], d = 0; d < l.length; d += 1) u[d] = l[d];
            for (var f = 0; f < c.length; f += 1) u[f + l.length] = c[f];
            return u
        },
        s = function(l, c) {
            for (var u = [], d = c || 0, f = 0; d < l.length; d += 1, f += 1) u[f] = l[d];
            return u
        },
        o = function(a, l) {
            for (var c = "", u = 0; u < a.length; u += 1) c += a[u], u + 1 < a.length && (c += l);
            return c
        };
    return Cy = function(l) {
        var c = this;
        if (typeof c != "function" || e.apply(c) !== r) throw new TypeError(t + c);
        for (var u = s(arguments, 1), d, f = function() {
                if (this instanceof d) {
                    var m = c.apply(this, i(u, arguments));
                    return Object(m) === m ? m : this
                }
                return c.apply(l, i(u, arguments))
            }, h = n(0, c.length - u.length), p = [], b = 0; b < h; b++) p[b] = "$" + b;
        if (d = Function("binder", "return function (" + o(p, ",") + "){ return binder.apply(this,arguments); }")(f), c.prototype) {
            var y = function() {};
            y.prototype = c.prototype, d.prototype = new y, y.prototype = null
        }
        return d
    }, Cy
}
var Py, GP;

function _m() {
    if (GP) return Py;
    GP = 1;
    var t = Zve();
    return Py = Function.prototype.bind || t, Py
}
var Ay, HP;

function Mw() {
    return HP || (HP = 1, Ay = Function.prototype.call), Ay
}
var Oy, zP;

function ZL() {
    return zP || (zP = 1, Oy = Function.prototype.apply), Oy
}
var Qve = typeof Reflect < "u" && Reflect && Reflect.apply,
    e0e = _m(),
    t0e = ZL(),
    n0e = Mw(),
    r0e = Qve,
    i0e = r0e || e0e.call(n0e, t0e),
    s0e = _m(),
    o0e = Ql,
    a0e = Mw(),
    l0e = i0e,
    QL = function(e) {
        if (e.length < 1 || typeof e[0] != "function") throw new o0e("a function is required");
        return l0e(s0e, a0e, e)
    },
    Iy, jP;

function c0e() {
    if (jP) return Iy;
    jP = 1;
    var t = QL,
        e = qL,
        n;
    try {
        n = [].__proto__ === Array.prototype
    } catch (o) {
        if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS") throw o
    }
    var r = !!n && e && e(Object.prototype, "__proto__"),
        i = Object,
        s = i.getPrototypeOf;
    return Iy = r && typeof r.get == "function" ? t([r.get]) : typeof s == "function" ? function(a) {
        return s(a == null ? a : i(a))
    } : !1, Iy
}
var My, VP;

function u0e() {
    if (VP) return My;
    VP = 1;
    var t = KL(),
        e = JL(),
        n = c0e();
    return My = t ? function(i) {
        return t(i)
    } : e ? function(i) {
        if (!i || typeof i != "object" && typeof i != "function") throw new TypeError("getProto: not an object");
        return e(i)
    } : n ? function(i) {
        return n(i)
    } : null, My
}
var Ry, WP;

function d0e() {
    if (WP) return Ry;
    WP = 1;
    var t = Function.prototype.call,
        e = Object.prototype.hasOwnProperty,
        n = _m();
    return Ry = n.call(t, e), Ry
}
var ze, f0e = XL,
    h0e = kve,
    p0e = Bve,
    m0e = Dve,
    g0e = $ve,
    Nl = Fve,
    ul = Ql,
    y0e = Lve,
    v0e = Nve,
    _0e = Uve,
    b0e = Gve,
    x0e = Hve,
    w0e = zve,
    E0e = jve,
    S0e = Yve,
    e3 = Function,
    ky = function(t) {
        try {
            return e3('"use strict"; return (' + t + ").constructor;")()
        } catch {}
    },
    Gu = qL,
    T0e = qve,
    By = function() {
        throw new ul
    },
    C0e = Gu ? function() {
        try {
            return arguments.callee, By
        } catch {
            try {
                return Gu(arguments, "callee").get
            } catch {
                return By
            }
        }
    }() : By,
    Ha = Jve()(),
    Xt = u0e(),
    P0e = JL(),
    A0e = KL(),
    t3 = ZL(),
    wd = Mw(),
    qa = {},
    O0e = typeof Uint8Array > "u" || !Xt ? ze : Xt(Uint8Array),
    Wo = {
        __proto__: null,
        "%AggregateError%": typeof AggregateError > "u" ? ze : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer > "u" ? ze : ArrayBuffer,
        "%ArrayIteratorPrototype%": Ha && Xt ? Xt([][Symbol.iterator]()) : ze,
        "%AsyncFromSyncIteratorPrototype%": ze,
        "%AsyncFunction%": qa,
        "%AsyncGenerator%": qa,
        "%AsyncGeneratorFunction%": qa,
        "%AsyncIteratorPrototype%": qa,
        "%Atomics%": typeof Atomics > "u" ? ze : Atomics,
        "%BigInt%": typeof BigInt > "u" ? ze : BigInt,
        "%BigInt64Array%": typeof BigInt64Array > "u" ? ze : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array > "u" ? ze : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView > "u" ? ze : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": h0e,
        "%eval%": eval,
        "%EvalError%": p0e,
        "%Float16Array%": typeof Float16Array > "u" ? ze : Float16Array,
        "%Float32Array%": typeof Float32Array > "u" ? ze : Float32Array,
        "%Float64Array%": typeof Float64Array > "u" ? ze : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? ze : FinalizationRegistry,
        "%Function%": e3,
        "%GeneratorFunction%": qa,
        "%Int8Array%": typeof Int8Array > "u" ? ze : Int8Array,
        "%Int16Array%": typeof Int16Array > "u" ? ze : Int16Array,
        "%Int32Array%": typeof Int32Array > "u" ? ze : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": Ha && Xt ? Xt(Xt([][Symbol.iterator]())) : ze,
        "%JSON%": typeof JSON == "object" ? JSON : ze,
        "%Map%": typeof Map > "u" ? ze : Map,
        "%MapIteratorPrototype%": typeof Map > "u" || !Ha || !Xt ? ze : Xt(new Map()[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": f0e,
        "%Object.getOwnPropertyDescriptor%": Gu,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise > "u" ? ze : Promise,
        "%Proxy%": typeof Proxy > "u" ? ze : Proxy,
        "%RangeError%": m0e,
        "%ReferenceError%": g0e,
        "%Reflect%": typeof Reflect > "u" ? ze : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set > "u" ? ze : Set,
        "%SetIteratorPrototype%": typeof Set > "u" || !Ha || !Xt ? ze : Xt(new Set()[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? ze : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": Ha && Xt ? Xt("" [Symbol.iterator]()) : ze,
        "%Symbol%": Ha ? Symbol : ze,
        "%SyntaxError%": Nl,
        "%ThrowTypeError%": C0e,
        "%TypedArray%": O0e,
        "%TypeError%": ul,
        "%Uint8Array%": typeof Uint8Array > "u" ? ze : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? ze : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array > "u" ? ze : Uint16Array,
        "%Uint32Array%": typeof Uint32Array > "u" ? ze : Uint32Array,
        "%URIError%": y0e,
        "%WeakMap%": typeof WeakMap > "u" ? ze : WeakMap,
        "%WeakRef%": typeof WeakRef > "u" ? ze : WeakRef,
        "%WeakSet%": typeof WeakSet > "u" ? ze : WeakSet,
        "%Function.prototype.call%": wd,
        "%Function.prototype.apply%": t3,
        "%Object.defineProperty%": T0e,
        "%Object.getPrototypeOf%": P0e,
        "%Math.abs%": v0e,
        "%Math.floor%": _0e,
        "%Math.max%": b0e,
        "%Math.min%": x0e,
        "%Math.pow%": w0e,
        "%Math.round%": E0e,
        "%Math.sign%": S0e,
        "%Reflect.getPrototypeOf%": A0e
    };
if (Xt) try {
    null.error
} catch (t) {
    var I0e = Xt(Xt(t));
    Wo["%Error.prototype%"] = I0e
}
var M0e = function t(e) {
        var n;
        if (e === "%AsyncFunction%") n = ky("async function () {}");
        else if (e === "%GeneratorFunction%") n = ky("function* () {}");
        else if (e === "%AsyncGeneratorFunction%") n = ky("async function* () {}");
        else if (e === "%AsyncGenerator%") {
            var r = t("%AsyncGeneratorFunction%");
            r && (n = r.prototype)
        } else if (e === "%AsyncIteratorPrototype%") {
            var i = t("%AsyncGenerator%");
            i && Xt && (n = Xt(i.prototype))
        }
        return Wo[e] = n, n
    },
    YP = {
        __proto__: null,
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
    },
    Ed = _m(),
    Wh = d0e(),
    R0e = Ed.call(wd, Array.prototype.concat),
    k0e = Ed.call(t3, Array.prototype.splice),
    XP = Ed.call(wd, String.prototype.replace),
    Yh = Ed.call(wd, String.prototype.slice),
    B0e = Ed.call(wd, RegExp.prototype.exec),
    D0e = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
    $0e = /\\(\\)?/g,
    F0e = function(e) {
        var n = Yh(e, 0, 1),
            r = Yh(e, -1);
        if (n === "%" && r !== "%") throw new Nl("invalid intrinsic syntax, expected closing `%`");
        if (r === "%" && n !== "%") throw new Nl("invalid intrinsic syntax, expected opening `%`");
        var i = [];
        return XP(e, D0e, function(s, o, a, l) {
            i[i.length] = a ? XP(l, $0e, "$1") : o || s
        }), i
    },
    L0e = function(e, n) {
        var r = e,
            i;
        if (Wh(YP, r) && (i = YP[r], r = "%" + i[0] + "%"), Wh(Wo, r)) {
            var s = Wo[r];
            if (s === qa && (s = M0e(r)), typeof s > "u" && !n) throw new ul("intrinsic " + e + " exists, but is not available. Please file an issue!");
            return {
                alias: i,
                name: r,
                value: s
            }
        }
        throw new Nl("intrinsic " + e + " does not exist!")
    },
    Rw = function(e, n) {
        if (typeof e != "string" || e.length === 0) throw new ul("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof n != "boolean") throw new ul('"allowMissing" argument must be a boolean');
        if (B0e(/^%?[^%]*%?$/, e) === null) throw new Nl("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        var r = F0e(e),
            i = r.length > 0 ? r[0] : "",
            s = L0e("%" + i + "%", n),
            o = s.name,
            a = s.value,
            l = !1,
            c = s.alias;
        c && (i = c[0], k0e(r, R0e([0, 1], c)));
        for (var u = 1, d = !0; u < r.length; u += 1) {
            var f = r[u],
                h = Yh(f, 0, 1),
                p = Yh(f, -1);
            if ((h === '"' || h === "'" || h === "`" || p === '"' || p === "'" || p === "`") && h !== p) throw new Nl("property names with quotes must have matching quotes");
            if ((f === "constructor" || !d) && (l = !0), i += "." + f, o = "%" + i + "%", Wh(Wo, o)) a = Wo[o];
            else if (a != null) {
                if (!(f in a)) {
                    if (!n) throw new ul("base intrinsic for " + e + " exists, but the property is not available.");
                    return
                }
                if (Gu && u + 1 >= r.length) {
                    var b = Gu(a, f);
                    d = !!b, d && "get" in b && !("originalValue" in b.get) ? a = b.get : a = a[f]
                } else d = Wh(a, f), a = a[f];
                d && !l && (Wo[o] = a)
            }
        }
        return a
    },
    n3 = Rw,
    r3 = QL,
    N0e = r3([n3("%String.prototype.indexOf%")]),
    i3 = function(e, n) {
        var r = n3(e, !!n);
        return typeof r == "function" && N0e(e, ".prototype.") > -1 ? r3([r]) : r
    },
    U0e = Rw,
    Sd = i3,
    G0e = ym,
    H0e = Ql,
    qP = U0e("%Map%", !0),
    z0e = Sd("Map.prototype.get", !0),
    j0e = Sd("Map.prototype.set", !0),
    V0e = Sd("Map.prototype.has", !0),
    W0e = Sd("Map.prototype.delete", !0),
    Y0e = Sd("Map.prototype.size", !0),
    s3 = !!qP && function() {
        var e, n = {
            assert: function(r) {
                if (!n.has(r)) throw new H0e("Side channel does not contain " + G0e(r))
            },
            delete: function(r) {
                if (e) {
                    var i = W0e(e, r);
                    return Y0e(e) === 0 && (e = void 0), i
                }
                return !1
            },
            get: function(r) {
                if (e) return z0e(e, r)
            },
            has: function(r) {
                return e ? V0e(e, r) : !1
            },
            set: function(r, i) {
                e || (e = new qP), j0e(e, r, i)
            }
        };
        return n
    },
    X0e = Rw,
    bm = i3,
    q0e = ym,
    If = s3,
    K0e = Ql,
    za = X0e("%WeakMap%", !0),
    J0e = bm("WeakMap.prototype.get", !0),
    Z0e = bm("WeakMap.prototype.set", !0),
    Q0e = bm("WeakMap.prototype.has", !0),
    e_e = bm("WeakMap.prototype.delete", !0),
    t_e = za ? function() {
        var e, n, r = {
            assert: function(i) {
                if (!r.has(i)) throw new K0e("Side channel does not contain " + q0e(i))
            },
            delete: function(i) {
                if (za && i && (typeof i == "object" || typeof i == "function")) {
                    if (e) return e_e(e, i)
                } else if (If && n) return n.delete(i);
                return !1
            },
            get: function(i) {
                return za && i && (typeof i == "object" || typeof i == "function") && e ? J0e(e, i) : n && n.get(i)
            },
            has: function(i) {
                return za && i && (typeof i == "object" || typeof i == "function") && e ? Q0e(e, i) : !!n && n.has(i)
            },
            set: function(i, s) {
                za && i && (typeof i == "object" || typeof i == "function") ? (e || (e = new za), Z0e(e, i, s)) : If && (n || (n = If()), n.set(i, s))
            }
        };
        return r
    } : If,
    n_e = Ql,
    r_e = ym,
    i_e = Rve,
    s_e = s3,
    o_e = t_e,
    a_e = o_e || s_e || i_e,
    l_e = function() {
        var e, n = {
            assert: function(r) {
                if (!n.has(r)) throw new n_e("Side channel does not contain " + r_e(r))
            },
            delete: function(r) {
                return !!e && e.delete(r)
            },
            get: function(r) {
                return e && e.get(r)
            },
            has: function(r) {
                return !!e && e.has(r)
            },
            set: function(r, i) {
                e || (e = a_e()), e.set(r, i)
            }
        };
        return n
    },
    c_e = String.prototype.replace,
    u_e = /%20/g,
    Dy = {
        RFC1738: "RFC1738",
        RFC3986: "RFC3986"
    },
    kw = {
        default: Dy.RFC3986,
        formatters: {
            RFC1738: function(t) {
                return c_e.call(t, u_e, "+")
            },
            RFC3986: function(t) {
                return String(t)
            }
        },
        RFC1738: Dy.RFC1738,
        RFC3986: Dy.RFC3986
    },
    d_e = kw,
    $y = Object.prototype.hasOwnProperty,
    Co = Array.isArray,
    Vr = function() {
        for (var t = [], e = 0; e < 256; ++e) t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
        return t
    }(),
    f_e = function(e) {
        for (; e.length > 1;) {
            var n = e.pop(),
                r = n.obj[n.prop];
            if (Co(r)) {
                for (var i = [], s = 0; s < r.length; ++s) typeof r[s] < "u" && i.push(r[s]);
                n.obj[n.prop] = i
            }
        }
    },
    o3 = function(e, n) {
        for (var r = n && n.plainObjects ? {
                __proto__: null
            } : {}, i = 0; i < e.length; ++i) typeof e[i] < "u" && (r[i] = e[i]);
        return r
    },
    h_e = function t(e, n, r) {
        if (!n) return e;
        if (typeof n != "object" && typeof n != "function") {
            if (Co(e)) e.push(n);
            else if (e && typeof e == "object")(r && (r.plainObjects || r.allowPrototypes) || !$y.call(Object.prototype, n)) && (e[n] = !0);
            else return [e, n];
            return e
        }
        if (!e || typeof e != "object") return [e].concat(n);
        var i = e;
        return Co(e) && !Co(n) && (i = o3(e, r)), Co(e) && Co(n) ? (n.forEach(function(s, o) {
            if ($y.call(e, o)) {
                var a = e[o];
                a && typeof a == "object" && s && typeof s == "object" ? e[o] = t(a, s, r) : e.push(s)
            } else e[o] = s
        }), e) : Object.keys(n).reduce(function(s, o) {
            var a = n[o];
            return $y.call(s, o) ? s[o] = t(s[o], a, r) : s[o] = a, s
        }, i)
    },
    p_e = function(e, n) {
        return Object.keys(n).reduce(function(r, i) {
            return r[i] = n[i], r
        }, e)
    },
    m_e = function(t, e, n) {
        var r = t.replace(/\+/g, " ");
        if (n === "iso-8859-1") return r.replace(/%[0-9a-f]{2}/gi, unescape);
        try {
            return decodeURIComponent(r)
        } catch {
            return r
        }
    },
    Fy = 1024,
    g_e = function(e, n, r, i, s) {
        if (e.length === 0) return e;
        var o = e;
        if (typeof e == "symbol" ? o = Symbol.prototype.toString.call(e) : typeof e != "string" && (o = String(e)), r === "iso-8859-1") return escape(o).replace(/%u[0-9a-f]{4}/gi, function(h) {
            return "%26%23" + parseInt(h.slice(2), 16) + "%3B"
        });
        for (var a = "", l = 0; l < o.length; l += Fy) {
            for (var c = o.length >= Fy ? o.slice(l, l + Fy) : o, u = [], d = 0; d < c.length; ++d) {
                var f = c.charCodeAt(d);
                if (f === 45 || f === 46 || f === 95 || f === 126 || f >= 48 && f <= 57 || f >= 65 && f <= 90 || f >= 97 && f <= 122 || s === d_e.RFC1738 && (f === 40 || f === 41)) {
                    u[u.length] = c.charAt(d);
                    continue
                }
                if (f < 128) {
                    u[u.length] = Vr[f];
                    continue
                }
                if (f < 2048) {
                    u[u.length] = Vr[192 | f >> 6] + Vr[128 | f & 63];
                    continue
                }
                if (f < 55296 || f >= 57344) {
                    u[u.length] = Vr[224 | f >> 12] + Vr[128 | f >> 6 & 63] + Vr[128 | f & 63];
                    continue
                }
                d += 1, f = 65536 + ((f & 1023) << 10 | c.charCodeAt(d) & 1023), u[u.length] = Vr[240 | f >> 18] + Vr[128 | f >> 12 & 63] + Vr[128 | f >> 6 & 63] + Vr[128 | f & 63]
            }
            a += u.join("")
        }
        return a
    },
    y_e = function(e) {
        for (var n = [{
                obj: {
                    o: e
                },
                prop: "o"
            }], r = [], i = 0; i < n.length; ++i)
            for (var s = n[i], o = s.obj[s.prop], a = Object.keys(o), l = 0; l < a.length; ++l) {
                var c = a[l],
                    u = o[c];
                typeof u == "object" && u !== null && r.indexOf(u) === -1 && (n.push({
                    obj: o,
                    prop: c
                }), r.push(u))
            }
        return f_e(n), e
    },
    v_e = function(e) {
        return Object.prototype.toString.call(e) === "[object RegExp]"
    },
    __e = function(e) {
        return !e || typeof e != "object" ? !1 : !!(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e))
    },
    b_e = function(e, n) {
        return [].concat(e, n)
    },
    x_e = function(e, n) {
        if (Co(e)) {
            for (var r = [], i = 0; i < e.length; i += 1) r.push(n(e[i]));
            return r
        }
        return n(e)
    },
    a3 = {
        arrayToObject: o3,
        assign: p_e,
        combine: b_e,
        compact: y_e,
        decode: m_e,
        encode: g_e,
        isBuffer: __e,
        isRegExp: v_e,
        maybeMap: x_e,
        merge: h_e
    },
    l3 = l_e,
    th = a3,
    iu = kw,
    w_e = Object.prototype.hasOwnProperty,
    c3 = {
        brackets: function(e) {
            return e + "[]"
        },
        comma: "comma",
        indices: function(e, n) {
            return e + "[" + n + "]"
        },
        repeat: function(e) {
            return e
        }
    },
    Jr = Array.isArray,
    E_e = Array.prototype.push,
    u3 = function(t, e) {
        E_e.apply(t, Jr(e) ? e : [e])
    },
    S_e = Date.prototype.toISOString,
    KP = iu.default,
    Ht = {
        addQueryPrefix: !1,
        allowDots: !1,
        allowEmptyArrays: !1,
        arrayFormat: "indices",
        charset: "utf-8",
        charsetSentinel: !1,
        commaRoundTrip: !1,
        delimiter: "&",
        encode: !0,
        encodeDotInKeys: !1,
        encoder: th.encode,
        encodeValuesOnly: !1,
        filter: void 0,
        format: KP,
        formatter: iu.formatters[KP],
        indices: !1,
        serializeDate: function(e) {
            return S_e.call(e)
        },
        skipNulls: !1,
        strictNullHandling: !1
    },
    T_e = function(e) {
        return typeof e == "string" || typeof e == "number" || typeof e == "boolean" || typeof e == "symbol" || typeof e == "bigint"
    },
    Ly = {},
    C_e = function t(e, n, r, i, s, o, a, l, c, u, d, f, h, p, b, y, m, g) {
        for (var v = e, _ = g, x = 0, w = !1;
            (_ = _.get(Ly)) !== void 0 && !w;) {
            var E = _.get(e);
            if (x += 1, typeof E < "u") {
                if (E === x) throw new RangeError("Cyclic object value");
                w = !0
            }
            typeof _.get(Ly) > "u" && (x = 0)
        }
        if (typeof u == "function" ? v = u(n, v) : v instanceof Date ? v = h(v) : r === "comma" && Jr(v) && (v = th.maybeMap(v, function(le) {
                return le instanceof Date ? h(le) : le
            })), v === null) {
            if (o) return c && !y ? c(n, Ht.encoder, m, "key", p) : n;
            v = ""
        }
        if (T_e(v) || th.isBuffer(v)) {
            if (c) {
                var C = y ? n : c(n, Ht.encoder, m, "key", p);
                return [b(C) + "=" + b(c(v, Ht.encoder, m, "value", p))]
            }
            return [b(n) + "=" + b(String(v))]
        }
        var A = [];
        if (typeof v > "u") return A;
        var T;
        if (r === "comma" && Jr(v)) y && c && (v = th.maybeMap(v, c)), T = [{
            value: v.length > 0 ? v.join(",") || null : void 0
        }];
        else if (Jr(u)) T = u;
        else {
            var S = Object.keys(v);
            T = d ? S.sort(d) : S
        }
        var P = l ? String(n).replace(/\./g, "%2E") : String(n),
            R = i && Jr(v) && v.length === 1 ? P + "[]" : P;
        if (s && Jr(v) && v.length === 0) return R + "[]";
        for (var D = 0; D < T.length; ++D) {
            var H = T[D],
                B = typeof H == "object" && H && typeof H.value < "u" ? H.value : v[H];
            if (!(a && B === null)) {
                var N = f && l ? String(H).replace(/\./g, "%2E") : String(H),
                    V = Jr(v) ? typeof r == "function" ? r(R, N) : R : R + (f ? "." + N : "[" + N + "]");
                g.set(e, x);
                var Y = l3();
                Y.set(Ly, g), u3(A, t(B, V, r, i, s, o, a, l, r === "comma" && y && Jr(v) ? null : c, u, d, f, h, p, b, y, m, Y))
            }
        }
        return A
    },
    P_e = function(e) {
        if (!e) return Ht;
        if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.encodeDotInKeys < "u" && typeof e.encodeDotInKeys != "boolean") throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.encoder !== null && typeof e.encoder < "u" && typeof e.encoder != "function") throw new TypeError("Encoder has to be a function.");
        var n = e.charset || Ht.charset;
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        var r = iu.default;
        if (typeof e.format < "u") {
            if (!w_e.call(iu.formatters, e.format)) throw new TypeError("Unknown format option provided.");
            r = e.format
        }
        var i = iu.formatters[r],
            s = Ht.filter;
        (typeof e.filter == "function" || Jr(e.filter)) && (s = e.filter);
        var o;
        if (e.arrayFormat in c3 ? o = e.arrayFormat : "indices" in e ? o = e.indices ? "indices" : "repeat" : o = Ht.arrayFormat, "commaRoundTrip" in e && typeof e.commaRoundTrip != "boolean") throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
        var a = typeof e.allowDots > "u" ? e.encodeDotInKeys === !0 ? !0 : Ht.allowDots : !!e.allowDots;
        return {
            addQueryPrefix: typeof e.addQueryPrefix == "boolean" ? e.addQueryPrefix : Ht.addQueryPrefix,
            allowDots: a,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : Ht.allowEmptyArrays,
            arrayFormat: o,
            charset: n,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Ht.charsetSentinel,
            commaRoundTrip: !!e.commaRoundTrip,
            delimiter: typeof e.delimiter > "u" ? Ht.delimiter : e.delimiter,
            encode: typeof e.encode == "boolean" ? e.encode : Ht.encode,
            encodeDotInKeys: typeof e.encodeDotInKeys == "boolean" ? e.encodeDotInKeys : Ht.encodeDotInKeys,
            encoder: typeof e.encoder == "function" ? e.encoder : Ht.encoder,
            encodeValuesOnly: typeof e.encodeValuesOnly == "boolean" ? e.encodeValuesOnly : Ht.encodeValuesOnly,
            filter: s,
            format: r,
            formatter: i,
            serializeDate: typeof e.serializeDate == "function" ? e.serializeDate : Ht.serializeDate,
            skipNulls: typeof e.skipNulls == "boolean" ? e.skipNulls : Ht.skipNulls,
            sort: typeof e.sort == "function" ? e.sort : null,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Ht.strictNullHandling
        }
    },
    A_e = function(t, e) {
        var n = t,
            r = P_e(e),
            i, s;
        typeof r.filter == "function" ? (s = r.filter, n = s("", n)) : Jr(r.filter) && (s = r.filter, i = s);
        var o = [];
        if (typeof n != "object" || n === null) return "";
        var a = c3[r.arrayFormat],
            l = a === "comma" && r.commaRoundTrip;
        i || (i = Object.keys(n)), r.sort && i.sort(r.sort);
        for (var c = l3(), u = 0; u < i.length; ++u) {
            var d = i[u],
                f = n[d];
            r.skipNulls && f === null || u3(o, C_e(f, d, a, l, r.allowEmptyArrays, r.strictNullHandling, r.skipNulls, r.encodeDotInKeys, r.encode ? r.encoder : null, r.filter, r.sort, r.allowDots, r.serializeDate, r.format, r.formatter, r.encodeValuesOnly, r.charset, c))
        }
        var h = o.join(r.delimiter),
            p = r.addQueryPrefix === !0 ? "?" : "";
        return r.charsetSentinel && (r.charset === "iso-8859-1" ? p += "utf8=%26%2310003%3B&" : p += "utf8=%E2%9C%93&"), h.length > 0 ? p + h : ""
    },
    da = a3,
    l_ = Object.prototype.hasOwnProperty,
    JP = Array.isArray,
    Ct = {
        allowDots: !1,
        allowEmptyArrays: !1,
        allowPrototypes: !1,
        allowSparse: !1,
        arrayLimit: 20,
        charset: "utf-8",
        charsetSentinel: !1,
        comma: !1,
        decodeDotInKeys: !1,
        decoder: da.decode,
        delimiter: "&",
        depth: 5,
        duplicates: "combine",
        ignoreQueryPrefix: !1,
        interpretNumericEntities: !1,
        parameterLimit: 1e3,
        parseArrays: !0,
        plainObjects: !1,
        strictDepth: !1,
        strictNullHandling: !1,
        throwOnLimitExceeded: !1
    },
    O_e = function(t) {
        return t.replace(/&#(\d+);/g, function(e, n) {
            return String.fromCharCode(parseInt(n, 10))
        })
    },
    d3 = function(t, e, n) {
        if (t && typeof t == "string" && e.comma && t.indexOf(",") > -1) return t.split(",");
        if (e.throwOnLimitExceeded && n >= e.arrayLimit) throw new RangeError("Array limit exceeded. Only " + e.arrayLimit + " element" + (e.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
        return t
    },
    I_e = "utf8=%26%2310003%3B",
    M_e = "utf8=%E2%9C%93",
    R_e = function(e, n) {
        var r = {
                __proto__: null
            },
            i = n.ignoreQueryPrefix ? e.replace(/^\?/, "") : e;
        i = i.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
        var s = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit,
            o = i.split(n.delimiter, n.throwOnLimitExceeded ? s + 1 : s);
        if (n.throwOnLimitExceeded && o.length > s) throw new RangeError("Parameter limit exceeded. Only " + s + " parameter" + (s === 1 ? "" : "s") + " allowed.");
        var a = -1,
            l, c = n.charset;
        if (n.charsetSentinel)
            for (l = 0; l < o.length; ++l) o[l].indexOf("utf8=") === 0 && (o[l] === M_e ? c = "utf-8" : o[l] === I_e && (c = "iso-8859-1"), a = l, l = o.length);
        for (l = 0; l < o.length; ++l)
            if (l !== a) {
                var u = o[l],
                    d = u.indexOf("]="),
                    f = d === -1 ? u.indexOf("=") : d + 1,
                    h, p;
                f === -1 ? (h = n.decoder(u, Ct.decoder, c, "key"), p = n.strictNullHandling ? null : "") : (h = n.decoder(u.slice(0, f), Ct.decoder, c, "key"), p = da.maybeMap(d3(u.slice(f + 1), n, JP(r[h]) ? r[h].length : 0), function(y) {
                    return n.decoder(y, Ct.decoder, c, "value")
                })), p && n.interpretNumericEntities && c === "iso-8859-1" && (p = O_e(String(p))), u.indexOf("[]=") > -1 && (p = JP(p) ? [p] : p);
                var b = l_.call(r, h);
                b && n.duplicates === "combine" ? r[h] = da.combine(r[h], p) : (!b || n.duplicates === "last") && (r[h] = p)
            }
        return r
    },
    k_e = function(t, e, n, r) {
        var i = 0;
        if (t.length > 0 && t[t.length - 1] === "[]") {
            var s = t.slice(0, -1).join("");
            i = Array.isArray(e) && e[s] ? e[s].length : 0
        }
        for (var o = r ? e : d3(e, n, i), a = t.length - 1; a >= 0; --a) {
            var l, c = t[a];
            if (c === "[]" && n.parseArrays) l = n.allowEmptyArrays && (o === "" || n.strictNullHandling && o === null) ? [] : da.combine([], o);
            else {
                l = n.plainObjects ? {
                    __proto__: null
                } : {};
                var u = c.charAt(0) === "[" && c.charAt(c.length - 1) === "]" ? c.slice(1, -1) : c,
                    d = n.decodeDotInKeys ? u.replace(/%2E/g, ".") : u,
                    f = parseInt(d, 10);
                !n.parseArrays && d === "" ? l = {
                    0: o
                } : !isNaN(f) && c !== d && String(f) === d && f >= 0 && n.parseArrays && f <= n.arrayLimit ? (l = [], l[f] = o) : d !== "__proto__" && (l[d] = o)
            }
            o = l
        }
        return o
    },
    B_e = function(e, n, r, i) {
        if (e) {
            var s = r.allowDots ? e.replace(/\.([^.[]+)/g, "[$1]") : e,
                o = /(\[[^[\]]*])/,
                a = /(\[[^[\]]*])/g,
                l = r.depth > 0 && o.exec(s),
                c = l ? s.slice(0, l.index) : s,
                u = [];
            if (c) {
                if (!r.plainObjects && l_.call(Object.prototype, c) && !r.allowPrototypes) return;
                u.push(c)
            }
            for (var d = 0; r.depth > 0 && (l = a.exec(s)) !== null && d < r.depth;) {
                if (d += 1, !r.plainObjects && l_.call(Object.prototype, l[1].slice(1, -1)) && !r.allowPrototypes) return;
                u.push(l[1])
            }
            if (l) {
                if (r.strictDepth === !0) throw new RangeError("Input depth exceeded depth option of " + r.depth + " and strictDepth is true");
                u.push("[" + s.slice(l.index) + "]")
            }
            return k_e(u, n, r, i)
        }
    },
    D_e = function(e) {
        if (!e) return Ct;
        if (typeof e.allowEmptyArrays < "u" && typeof e.allowEmptyArrays != "boolean") throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
        if (typeof e.decodeDotInKeys < "u" && typeof e.decodeDotInKeys != "boolean") throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
        if (e.decoder !== null && typeof e.decoder < "u" && typeof e.decoder != "function") throw new TypeError("Decoder has to be a function.");
        if (typeof e.charset < "u" && e.charset !== "utf-8" && e.charset !== "iso-8859-1") throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
        if (typeof e.throwOnLimitExceeded < "u" && typeof e.throwOnLimitExceeded != "boolean") throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
        var n = typeof e.charset > "u" ? Ct.charset : e.charset,
            r = typeof e.duplicates > "u" ? Ct.duplicates : e.duplicates;
        if (r !== "combine" && r !== "first" && r !== "last") throw new TypeError("The duplicates option must be either combine, first, or last");
        var i = typeof e.allowDots > "u" ? e.decodeDotInKeys === !0 ? !0 : Ct.allowDots : !!e.allowDots;
        return {
            allowDots: i,
            allowEmptyArrays: typeof e.allowEmptyArrays == "boolean" ? !!e.allowEmptyArrays : Ct.allowEmptyArrays,
            allowPrototypes: typeof e.allowPrototypes == "boolean" ? e.allowPrototypes : Ct.allowPrototypes,
            allowSparse: typeof e.allowSparse == "boolean" ? e.allowSparse : Ct.allowSparse,
            arrayLimit: typeof e.arrayLimit == "number" ? e.arrayLimit : Ct.arrayLimit,
            charset: n,
            charsetSentinel: typeof e.charsetSentinel == "boolean" ? e.charsetSentinel : Ct.charsetSentinel,
            comma: typeof e.comma == "boolean" ? e.comma : Ct.comma,
            decodeDotInKeys: typeof e.decodeDotInKeys == "boolean" ? e.decodeDotInKeys : Ct.decodeDotInKeys,
            decoder: typeof e.decoder == "function" ? e.decoder : Ct.decoder,
            delimiter: typeof e.delimiter == "string" || da.isRegExp(e.delimiter) ? e.delimiter : Ct.delimiter,
            depth: typeof e.depth == "number" || e.depth === !1 ? +e.depth : Ct.depth,
            duplicates: r,
            ignoreQueryPrefix: e.ignoreQueryPrefix === !0,
            interpretNumericEntities: typeof e.interpretNumericEntities == "boolean" ? e.interpretNumericEntities : Ct.interpretNumericEntities,
            parameterLimit: typeof e.parameterLimit == "number" ? e.parameterLimit : Ct.parameterLimit,
            parseArrays: e.parseArrays !== !1,
            plainObjects: typeof e.plainObjects == "boolean" ? e.plainObjects : Ct.plainObjects,
            strictDepth: typeof e.strictDepth == "boolean" ? !!e.strictDepth : Ct.strictDepth,
            strictNullHandling: typeof e.strictNullHandling == "boolean" ? e.strictNullHandling : Ct.strictNullHandling,
            throwOnLimitExceeded: typeof e.throwOnLimitExceeded == "boolean" ? e.throwOnLimitExceeded : !1
        }
    },
    $_e = function(t, e) {
        var n = D_e(e);
        if (t === "" || t === null || typeof t > "u") return n.plainObjects ? {
            __proto__: null
        } : {};
        for (var r = typeof t == "string" ? R_e(t, n) : t, i = n.plainObjects ? {
                __proto__: null
            } : {}, s = Object.keys(r), o = 0; o < s.length; ++o) {
            var a = s[o],
                l = B_e(a, r[a], n, typeof t == "string");
            i = da.merge(i, l, n)
        }
        return n.allowSparse === !0 ? i : da.compact(i)
    },
    F_e = A_e,
    L_e = $_e,
    N_e = kw,
    U_e = {
        formats: N_e,
        parse: L_e,
        stringify: F_e
    };
const kwe = Hl(U_e);
Re.add(kie);
Re.mixin(er, Bie);
Re.add(GB);
Re.add(HB);
Re.add(vD);
Re.mixin(er, dle);
Re.add(yD);
Re.add(Z$);
Re.add($x);
Re.add(tF);
Re.add(rF);
Re.add(iF);
Re.add(gF);
Re.add(mF);
Re.add(dF);
Re.add(pF);
Re.add(fF);
Re.add(uF);
Re.add(cF);
Re.add(ED);
Re.add(wD);
const G_e = Object.freeze(Object.defineProperty({
        __proto__: null
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    H_e = Object.freeze(Object.defineProperty({
        __proto__: null
    }, Symbol.toStringTag, {
        value: "Module"
    }));
var ZP = function() {
    return ZP = Object.assign || function(e) {
        for (var n, r = 1, i = arguments.length; r < i; r++) {
            n = arguments[r];
            for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (e[s] = n[s])
        }
        return e
    }, ZP.apply(this, arguments)
};

function Bwe(t, e, n, r) {
    function i(s) {
        return s instanceof n ? s : new n(function(o) {
            o(s)
        })
    }
    return new(n || (n = Promise))(function(s, o) {
        function a(u) {
            try {
                c(r.next(u))
            } catch (d) {
                o(d)
            }
        }

        function l(u) {
            try {
                c(r.throw(u))
            } catch (d) {
                o(d)
            }
        }

        function c(u) {
            u.done ? s(u.value) : i(u.value).then(a, l)
        }
        c((r = r.apply(t, e || [])).next())
    })
}

function Dwe(t, e) {
    var n = {
            label: 0,
            sent: function() {
                if (s[0] & 1) throw s[1];
                return s[1]
            },
            trys: [],
            ops: []
        },
        r, i, s, o = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
    return o.next = a(0), o.throw = a(1), o.return = a(2), typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }), o;

    function a(c) {
        return function(u) {
            return l([c, u])
        }
    }

    function l(c) {
        if (r) throw new TypeError("Generator is already executing.");
        for (; o && (o = 0, c[0] && (n = 0)), n;) try {
            if (r = 1, i && (s = c[0] & 2 ? i.return : c[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, c[1])).done) return s;
            switch (i = 0, s && (c = [c[0] & 2, s.value]), c[0]) {
                case 0:
                case 1:
                    s = c;
                    break;
                case 4:
                    return n.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    n.label++, i = c[1], c = [0];
                    continue;
                case 7:
                    c = n.ops.pop(), n.trys.pop();
                    continue;
                default:
                    if (s = n.trys, !(s = s.length > 0 && s[s.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        n = 0;
                        continue
                    }
                    if (c[0] === 3 && (!s || c[1] > s[0] && c[1] < s[3])) {
                        n.label = c[1];
                        break
                    }
                    if (c[0] === 6 && n.label < s[1]) {
                        n.label = s[1], s = c;
                        break
                    }
                    if (s && n.label < s[2]) {
                        n.label = s[2], n.ops.push(c);
                        break
                    }
                    s[2] && n.ops.pop(), n.trys.pop();
                    continue
            }
            c = e.call(t, n)
        } catch (u) {
            c = [6, u], i = 0
        } finally {
            r = s = 0
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
}

function $we(t, e, n) {
    if (n || arguments.length === 2)
        for (var r = 0, i = e.length, s; r < i; r++)(s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
    return t.concat(s || Array.prototype.slice.call(e))
}

function z_e(t, e) {
    if (t.match(/^[a-z]+:\/\//i)) return t;
    if (t.match(/^\/\//)) return window.location.protocol + t;
    if (t.match(/^[a-z]+:/i)) return t;
    const n = document.implementation.createHTMLDocument(),
        r = n.createElement("base"),
        i = n.createElement("a");
    return n.head.appendChild(r), n.body.appendChild(i), e && (r.href = e), i.href = t, i.href
}
const j_e = (() => {
    let t = 0;
    const e = () => `0000${(Math.random()*36**4<<0).toString(36)}`.slice(-4);
    return () => (t += 1, `u${e()}${t}`)
})();

function Us(t) {
    const e = [];
    for (let n = 0, r = t.length; n < r; n++) e.push(t[n]);
    return e
}
let ja = null;

function f3(t = {}) {
    return ja || (t.includeStyleProperties ? (ja = t.includeStyleProperties, ja) : (ja = Us(window.getComputedStyle(document.documentElement)), ja))
}

function Xh(t, e) {
    const r = (t.ownerDocument.defaultView || window).getComputedStyle(t).getPropertyValue(e);
    return r ? parseFloat(r.replace("px", "")) : 0
}

function V_e(t) {
    const e = Xh(t, "border-left-width"),
        n = Xh(t, "border-right-width");
    return t.clientWidth + e + n
}

function W_e(t) {
    const e = Xh(t, "border-top-width"),
        n = Xh(t, "border-bottom-width");
    return t.clientHeight + e + n
}

function Bw(t, e = {}) {
    const n = e.width || V_e(t),
        r = e.height || W_e(t);
    return {
        width: n,
        height: r
    }
}

function Y_e() {
    let t, e;
    try {
        e = process
    } catch {}
    const n = e && e.env ? e.env.devicePixelRatio : null;
    return n && (t = parseInt(n, 10), Number.isNaN(t) && (t = 1)), t || window.devicePixelRatio || 1
}
const Hn = 16384;

function X_e(t) {
    (t.width > Hn || t.height > Hn) && (t.width > Hn && t.height > Hn ? t.width > t.height ? (t.height *= Hn / t.width, t.width = Hn) : (t.width *= Hn / t.height, t.height = Hn) : t.width > Hn ? (t.height *= Hn / t.width, t.width = Hn) : (t.width *= Hn / t.height, t.height = Hn))
}

function q_e(t, e = {}) {
    return t.toBlob ? new Promise(n => {
        t.toBlob(n, e.type ? e.type : "image/png", e.quality ? e.quality : 1)
    }) : new Promise(n => {
        const r = window.atob(t.toDataURL(e.type ? e.type : void 0, e.quality ? e.quality : void 0).split(",")[1]),
            i = r.length,
            s = new Uint8Array(i);
        for (let o = 0; o < i; o += 1) s[o] = r.charCodeAt(o);
        n(new Blob([s], {
            type: e.type ? e.type : "image/png"
        }))
    })
}

function qh(t) {
    return new Promise((e, n) => {
        const r = new Image;
        r.onload = () => {
            r.decode().then(() => {
                requestAnimationFrame(() => e(r))
            })
        }, r.onerror = n, r.crossOrigin = "anonymous", r.decoding = "async", r.src = t
    })
}
async function K_e(t) {
    return Promise.resolve().then(() => new XMLSerializer().serializeToString(t)).then(encodeURIComponent).then(e => `data:image/svg+xml;charset=utf-8,${e}`)
}
async function J_e(t, e, n) {
    const r = "http://www.w3.org/2000/svg",
        i = document.createElementNS(r, "svg"),
        s = document.createElementNS(r, "foreignObject");
    return i.setAttribute("width", `${e}`), i.setAttribute("height", `${n}`), i.setAttribute("viewBox", `0 0 ${e} ${n}`), s.setAttribute("width", "100%"), s.setAttribute("height", "100%"), s.setAttribute("x", "0"), s.setAttribute("y", "0"), s.setAttribute("externalResourcesRequired", "true"), i.appendChild(s), s.appendChild(t), K_e(i)
}
const Nn = (t, e) => {
    if (t instanceof e) return !0;
    const n = Object.getPrototypeOf(t);
    return n === null ? !1 : n.constructor.name === e.name || Nn(n, e)
};

function Z_e(t) {
    const e = t.getPropertyValue("content");
    return `${t.cssText} content: '${e.replace(/'|"/g,"")}';`
}

function Q_e(t, e) {
    return f3(e).map(n => {
        const r = t.getPropertyValue(n),
            i = t.getPropertyPriority(n);
        return `${n}: ${r}${i?" !important":""};`
    }).join(" ")
}

function ebe(t, e, n, r) {
    const i = `.${t}:${e}`,
        s = n.cssText ? Z_e(n) : Q_e(n, r);
    return document.createTextNode(`${i}{${s}}`)
}

function QP(t, e, n, r) {
    const i = window.getComputedStyle(t, n),
        s = i.getPropertyValue("content");
    if (s === "" || s === "none") return;
    const o = j_e();
    try {
        e.className = `${e.className} ${o}`
    } catch {
        return
    }
    const a = document.createElement("style");
    a.appendChild(ebe(o, n, i, r)), e.appendChild(a)
}

function tbe(t, e, n) {
    QP(t, e, ":before", n), QP(t, e, ":after", n)
}
const eA = "application/font-woff",
    tA = "image/jpeg",
    nbe = {
        woff: eA,
        woff2: eA,
        ttf: "application/font-truetype",
        eot: "application/vnd.ms-fontobject",
        png: "image/png",
        jpg: tA,
        jpeg: tA,
        gif: "image/gif",
        tiff: "image/tiff",
        svg: "image/svg+xml",
        webp: "image/webp"
    };

function rbe(t) {
    const e = /\.([^./]*?)$/g.exec(t);
    return e ? e[1] : ""
}

function Dw(t) {
    const e = rbe(t).toLowerCase();
    return nbe[e] || ""
}

function ibe(t) {
    return t.split(/,/)[1]
}

function c_(t) {
    return t.search(/^(data:)/) !== -1
}

function h3(t, e) {
    return `data:${e};base64,${t}`
}
async function p3(t, e, n) {
    const r = await fetch(t, e);
    if (r.status === 404) throw new Error(`Resource "${r.url}" not found`);
    const i = await r.blob();
    return new Promise((s, o) => {
        const a = new FileReader;
        a.onerror = o, a.onloadend = () => {
            try {
                s(n({
                    res: r,
                    result: a.result
                }))
            } catch (l) {
                o(l)
            }
        }, a.readAsDataURL(i)
    })
}
const Ny = {};

function sbe(t, e, n) {
    let r = t.replace(/\?.*/, "");
    return n && (r = t), /ttf|otf|eot|woff2?/i.test(r) && (r = r.replace(/.*\//, "")), e ? `[${e}]${r}` : r
}
async function $w(t, e, n) {
    const r = sbe(t, e, n.includeQueryParams);
    if (Ny[r] != null) return Ny[r];
    n.cacheBust && (t += (/\?/.test(t) ? "&" : "?") + new Date().getTime());
    let i;
    try {
        const s = await p3(t, n.fetchRequestInit, ({
            res: o,
            result: a
        }) => (e || (e = o.headers.get("Content-Type") || ""), ibe(a)));
        i = h3(s, e)
    } catch (s) {
        i = n.imagePlaceholder || "";
        let o = `Failed to fetch resource: ${t}`;
        s && (o = typeof s == "string" ? s : s.message), o && console.warn(o)
    }
    return Ny[r] = i, i
}
async function obe(t) {
    const e = t.toDataURL();
    return e === "data:," ? t.cloneNode(!1) : qh(e)
}
async function abe(t, e) {
    if (t.currentSrc) {
        const s = document.createElement("canvas"),
            o = s.getContext("2d");
        s.width = t.clientWidth, s.height = t.clientHeight, o == null || o.drawImage(t, 0, 0, s.width, s.height);
        const a = s.toDataURL();
        return qh(a)
    }
    const n = t.poster,
        r = Dw(n),
        i = await $w(n, r, e);
    return qh(i)
}
async function lbe(t, e) {
    var n;
    try {
        if (!((n = t == null ? void 0 : t.contentDocument) === null || n === void 0) && n.body) return await xm(t.contentDocument.body, e, !0)
    } catch {}
    return t.cloneNode(!1)
}
async function cbe(t, e) {
    return Nn(t, HTMLCanvasElement) ? obe(t) : Nn(t, HTMLVideoElement) ? abe(t, e) : Nn(t, HTMLIFrameElement) ? lbe(t, e) : t.cloneNode(m3(t))
}
const ube = t => t.tagName != null && t.tagName.toUpperCase() === "SLOT",
    m3 = t => t.tagName != null && t.tagName.toUpperCase() === "SVG";
async function dbe(t, e, n) {
    var r, i;
    if (m3(e)) return e;
    let s = [];
    return ube(t) && t.assignedNodes ? s = Us(t.assignedNodes()) : Nn(t, HTMLIFrameElement) && (!((r = t.contentDocument) === null || r === void 0) && r.body) ? s = Us(t.contentDocument.body.childNodes) : s = Us(((i = t.shadowRoot) !== null && i !== void 0 ? i : t).childNodes), s.length === 0 || Nn(t, HTMLVideoElement) || await s.reduce((o, a) => o.then(() => xm(a, n)).then(l => {
        l && e.appendChild(l)
    }), Promise.resolve()), e
}

function fbe(t, e, n) {
    const r = e.style;
    if (!r) return;
    const i = window.getComputedStyle(t);
    i.cssText ? (r.cssText = i.cssText, r.transformOrigin = i.transformOrigin) : f3(n).forEach(s => {
        let o = i.getPropertyValue(s);
        s === "font-size" && o.endsWith("px") && (o = `${Math.floor(parseFloat(o.substring(0,o.length-2)))-.1}px`), Nn(t, HTMLIFrameElement) && s === "display" && o === "inline" && (o = "block"), s === "d" && e.getAttribute("d") && (o = `path(${e.getAttribute("d")})`), r.setProperty(s, o, i.getPropertyPriority(s))
    })
}

function hbe(t, e) {
    Nn(t, HTMLTextAreaElement) && (e.innerHTML = t.value), Nn(t, HTMLInputElement) && e.setAttribute("value", t.value)
}

function pbe(t, e) {
    if (Nn(t, HTMLSelectElement)) {
        const n = e,
            r = Array.from(n.children).find(i => t.value === i.getAttribute("value"));
        r && r.setAttribute("selected", "")
    }
}

function mbe(t, e, n) {
    return Nn(e, Element) && (fbe(t, e, n), tbe(t, e, n), hbe(t, e), pbe(t, e)), e
}
async function gbe(t, e) {
    const n = t.querySelectorAll ? t.querySelectorAll("use") : [];
    if (n.length === 0) return t;
    const r = {};
    for (let s = 0; s < n.length; s++) {
        const a = n[s].getAttribute("xlink:href");
        if (a) {
            const l = t.querySelector(a),
                c = document.querySelector(a);
            !l && c && !r[a] && (r[a] = await xm(c, e, !0))
        }
    }
    const i = Object.values(r);
    if (i.length) {
        const s = "http://www.w3.org/1999/xhtml",
            o = document.createElementNS(s, "svg");
        o.setAttribute("xmlns", s), o.style.position = "absolute", o.style.width = "0", o.style.height = "0", o.style.overflow = "hidden", o.style.display = "none";
        const a = document.createElementNS(s, "defs");
        o.appendChild(a);
        for (let l = 0; l < i.length; l++) a.appendChild(i[l]);
        t.appendChild(o)
    }
    return t
}
async function xm(t, e, n) {
    return !n && e.filter && !e.filter(t) ? null : Promise.resolve(t).then(r => cbe(r, e)).then(r => dbe(t, r, e)).then(r => mbe(t, r, e)).then(r => gbe(r, e))
}
const g3 = /url\((['"]?)([^'"]+?)\1\)/g,
    ybe = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g,
    vbe = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;

function _be(t) {
    const e = t.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
    return new RegExp(`(url\\(['"]?)(${e})(['"]?\\))`, "g")
}

function bbe(t) {
    const e = [];
    return t.replace(g3, (n, r, i) => (e.push(i), n)), e.filter(n => !c_(n))
}
async function xbe(t, e, n, r, i) {
    try {
        const s = n ? z_e(e, n) : e,
            o = Dw(e);
        let a;
        if (i) {
            const l = await i(s);
            a = h3(l, o)
        } else a = await $w(s, o, r);
        return t.replace(_be(e), `$1${a}$3`)
    } catch {}
    return t
}

function wbe(t, {
    preferredFontFormat: e
}) {
    return e ? t.replace(vbe, n => {
        for (;;) {
            const [r, , i] = ybe.exec(n) || [];
            if (!i) return "";
            if (i === e) return `src: ${r};`
        }
    }) : t
}

function y3(t) {
    return t.search(g3) !== -1
}
async function v3(t, e, n) {
    if (!y3(t)) return t;
    const r = wbe(t, n);
    return bbe(r).reduce((s, o) => s.then(a => xbe(a, o, e, n)), Promise.resolve(r))
}
async function Va(t, e, n) {
    var r;
    const i = (r = e.style) === null || r === void 0 ? void 0 : r.getPropertyValue(t);
    if (i) {
        const s = await v3(i, null, n);
        return e.style.setProperty(t, s, e.style.getPropertyPriority(t)), !0
    }
    return !1
}
async function Ebe(t, e) {
    await Va("background", t, e) || await Va("background-image", t, e), await Va("mask", t, e) || await Va("-webkit-mask", t, e) || await Va("mask-image", t, e) || await Va("-webkit-mask-image", t, e)
}
async function Sbe(t, e) {
    const n = Nn(t, HTMLImageElement);
    if (!(n && !c_(t.src)) && !(Nn(t, SVGImageElement) && !c_(t.href.baseVal))) return;
    const r = n ? t.src : t.href.baseVal,
        i = await $w(r, Dw(r), e);
    await new Promise((s, o) => {
        t.onload = s, t.onerror = e.onImageErrorHandler ? (...l) => {
            try {
                s(e.onImageErrorHandler(...l))
            } catch (c) {
                o(c)
            }
        } : o;
        const a = t;
        a.decode && (a.decode = s), a.loading === "lazy" && (a.loading = "eager"), n ? (t.srcset = "", t.src = i) : t.href.baseVal = i
    })
}
async function Tbe(t, e) {
    const r = Us(t.childNodes).map(i => _3(i, e));
    await Promise.all(r).then(() => t)
}
async function _3(t, e) {
    Nn(t, Element) && (await Ebe(t, e), await Sbe(t, e), await Tbe(t, e))
}

function Cbe(t, e) {
    const {
        style: n
    } = t;
    e.backgroundColor && (n.backgroundColor = e.backgroundColor), e.width && (n.width = `${e.width}px`), e.height && (n.height = `${e.height}px`);
    const r = e.style;
    return r != null && Object.keys(r).forEach(i => {
        n[i] = r[i]
    }), t
}
const nA = {};
async function rA(t) {
    let e = nA[t];
    if (e != null) return e;
    const r = await (await fetch(t)).text();
    return e = {
        url: t,
        cssText: r
    }, nA[t] = e, e
}
async function iA(t, e) {
    let n = t.cssText;
    const r = /url\(["']?([^"')]+)["']?\)/g,
        s = (n.match(/url\([^)]+\)/g) || []).map(async o => {
            let a = o.replace(r, "$1");
            return a.startsWith("https://") || (a = new URL(a, t.url).href), p3(a, e.fetchRequestInit, ({
                result: l
            }) => (n = n.replace(o, `url(${l})`), [o, l]))
        });
    return Promise.all(s).then(() => n)
}

function sA(t) {
    if (t == null) return [];
    const e = [],
        n = /(\/\*[\s\S]*?\*\/)/gi;
    let r = t.replace(n, "");
    const i = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
    for (;;) {
        const l = i.exec(r);
        if (l === null) break;
        e.push(l[0])
    }
    r = r.replace(i, "");
    const s = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi,
        o = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})",
        a = new RegExp(o, "gi");
    for (;;) {
        let l = s.exec(r);
        if (l === null) {
            if (l = a.exec(r), l === null) break;
            s.lastIndex = a.lastIndex
        } else a.lastIndex = s.lastIndex;
        e.push(l[0])
    }
    return e
}
async function Pbe(t, e) {
    const n = [],
        r = [];
    return t.forEach(i => {
        if ("cssRules" in i) try {
            Us(i.cssRules || []).forEach((s, o) => {
                if (s.type === CSSRule.IMPORT_RULE) {
                    let a = o + 1;
                    const l = s.href,
                        c = rA(l).then(u => iA(u, e)).then(u => sA(u).forEach(d => {
                            try {
                                i.insertRule(d, d.startsWith("@import") ? a += 1 : i.cssRules.length)
                            } catch (f) {
                                console.error("Error inserting rule from remote css", {
                                    rule: d,
                                    error: f
                                })
                            }
                        })).catch(u => {
                            console.error("Error loading remote css", u.toString())
                        });
                    r.push(c)
                }
            })
        } catch (s) {
            const o = t.find(a => a.href == null) || document.styleSheets[0];
            i.href != null && r.push(rA(i.href).then(a => iA(a, e)).then(a => sA(a).forEach(l => {
                o.insertRule(l, o.cssRules.length)
            })).catch(a => {
                console.error("Error loading remote stylesheet", a)
            })), console.error("Error inlining remote css file", s)
        }
    }), Promise.all(r).then(() => (t.forEach(i => {
        if ("cssRules" in i) try {
            Us(i.cssRules || []).forEach(s => {
                n.push(s)
            })
        } catch (s) {
            console.error(`Error while reading CSS rules from ${i.href}`, s)
        }
    }), n))
}

function Abe(t) {
    return t.filter(e => e.type === CSSRule.FONT_FACE_RULE).filter(e => y3(e.style.getPropertyValue("src")))
}
async function Obe(t, e) {
    if (t.ownerDocument == null) throw new Error("Provided element is not within a Document");
    const n = Us(t.ownerDocument.styleSheets),
        r = await Pbe(n, e);
    return Abe(r)
}

function b3(t) {
    return t.trim().replace(/["']/g, "")
}

function Ibe(t) {
    const e = new Set;

    function n(r) {
        (r.style.fontFamily || getComputedStyle(r).fontFamily).split(",").forEach(s => {
            e.add(b3(s))
        }), Array.from(r.children).forEach(s => {
            s instanceof HTMLElement && n(s)
        })
    }
    return n(t), e
}
async function x3(t, e) {
    const n = await Obe(t, e),
        r = Ibe(t);
    return (await Promise.all(n.filter(s => r.has(b3(s.style.fontFamily))).map(s => {
        const o = s.parentStyleSheet ? s.parentStyleSheet.href : null;
        return v3(s.cssText, o, e)
    }))).join(`
`)
}
async function Mbe(t, e) {
    const n = e.fontEmbedCSS != null ? e.fontEmbedCSS : e.skipFonts ? null : await x3(t, e);
    if (n) {
        const r = document.createElement("style"),
            i = document.createTextNode(n);
        r.appendChild(i), t.firstChild ? t.insertBefore(r, t.firstChild) : t.appendChild(r)
    }
}
async function w3(t, e = {}) {
    const {
        width: n,
        height: r
    } = Bw(t, e), i = await xm(t, e, !0);
    return await Mbe(i, e), await _3(i, e), Cbe(i, e), await J_e(i, n, r)
}
async function Td(t, e = {}) {
    const {
        width: n,
        height: r
    } = Bw(t, e), i = await w3(t, e), s = await qh(i), o = document.createElement("canvas"), a = o.getContext("2d"), l = e.pixelRatio || Y_e(), c = e.canvasWidth || n, u = e.canvasHeight || r;
    return o.width = c * l, o.height = u * l, e.skipAutoScale || X_e(o), o.style.width = `${c}`, o.style.height = `${u}`, e.backgroundColor && (a.fillStyle = e.backgroundColor, a.fillRect(0, 0, o.width, o.height)), a.drawImage(s, 0, 0, o.width, o.height), o
}
async function Rbe(t, e = {}) {
    const {
        width: n,
        height: r
    } = Bw(t, e);
    return (await Td(t, e)).getContext("2d").getImageData(0, 0, n, r).data
}
async function kbe(t, e = {}) {
    return (await Td(t, e)).toDataURL()
}
async function Bbe(t, e = {}) {
    return (await Td(t, e)).toDataURL("image/jpeg", e.quality || 1)
}
async function Dbe(t, e = {}) {
    const n = await Td(t, e);
    return await q_e(n)
}
async function $be(t, e = {}) {
    return x3(t, e)
}
const Fwe = Object.freeze(Object.defineProperty({
    __proto__: null,
    getFontEmbedCSS: $be,
    toBlob: Dbe,
    toCanvas: Td,
    toJpeg: Bbe,
    toPixelData: Rbe,
    toPng: kbe,
    toSvg: w3
}, Symbol.toStringTag, {
    value: "Module"
}));
export {
    mwe as $, _t as A, Ue as B, ns as C, is as D, hi as E, et as F, he as G, En as H, ft as I, te as J, ix as K, yW as L, bI as M, nr as N, Jbe as O, ve as P, E4 as Q, vU as R, Gbe as S, N_ as T, mt as U, T4 as V, fp as W, kN as X, I as Y, pwe as Z, Bwe as _, Dwe as a, Ws as a$, Hl as a0, XX as a1, pxe as a2, Zxe as a3, Wxe as a4, nwe as a5, Qbe as a6, swe as a7, Bv as a8, gr as a9, B2 as aA, O2 as aB, _G as aC, wU as aD, kye as aE, fwe as aF, Pwe as aG, qxe as aH, See as aI, Nt as aJ, Rc as aK, Kxe as aL, Xxe as aM, Rwe as aN, S4 as aO, owe as aP, dn as aQ, kG as aR, Iwe as aS, Owe as aT, Awe as aU, Jxe as aV, _d as aW, WO as aX, QR as aY, XR as aZ, uN as a_, Yxe as aa, np as ab, _se as ac, bf as ad, er as ae, ra as af, bwe as ag, Ewe as ah, rwe as ai, EU as aj, cwe as ak, mr as al, yr as am, Ku as an, P4 as ao, Ju as ap, eO as aq, Mwe as ar, twe as as, L_ as at, A_ as au, pp as av, t4 as aw, n4 as ax, v4 as ay, hh as az, ZP as b, Cxe as b$, Vs as b0, Vxe as b1, U_e as b2, jxe as b3, exe as b4, Jo as b5, cN as b6, rd as b7, s7 as b8, Mt as b9, C4 as bA, Dte as bB, Lfe as bC, Swe as bD, Twe as bE, Cwe as bF, xxe as bG, jbe as bH, sxe as bI, rxe as bJ, Pxe as bK, Axe as bL, vxe as bM, _xe as bN, oxe as bO, U7 as bP, Vbe as bQ, Wbe as bR, Sxe as bS, mxe as bT, gxe as bU, uxe as bV, dxe as bW, ss as bX, lxe as bY, hxe as bZ, cxe as b_, nxe as ba, _h as bb, wxe as bc, Xbe as bd, qbe as be, b4 as bf, c4 as bg, bn as bh, _we as bi, $h as bj, dt as bk, _le as bl, wwe as bm, we as bn, xwe as bo, Rxe as bp, Ul as bq, Jt as br, mv as bs, rt as bt, iwe as bu, dp as bv, Ke as bw, kwe as bx, XA as by, gq as bz, $we as c, Ixe as c0, bxe as c1, txe as c2, xa as c3, aY as c4, fxe as c5, Oxe as c6, kxe as c7, axe as c8, Txe as c9, Mp as ca, Exe as cb, V2 as cc, Mxe as cd, yxe as ce, JO as cf, Fbe as cg, Nbe as ch, awe as ci, pa as cj, ewe as ck, lwe as cl, Fwe as cm, Dxe as d, $xe as e, Fxe as f, Lxe as g, Nxe as h, Uxe as i, Gxe as j, Hxe as k, zxe as l, Bxe as m, nh as n, Zbe as o, Ube as p, Hbe as q, q as r, gW as s, uwe as t, Qxe as u, Lbe as v, hwe as w, dwe as x, gwe as y, Kbe as z
};
//# sourceMappingURL=common.modules-0a990f43.js.map